<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Python-httpx</title>
    <link href="/post/dcae2e3f/"/>
    <url>/post/dcae2e3f/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>HTTPX 是功能齐全的 Python 的 HTTP客户端，它提供同步和异步API，支持 HTTP/1.1 和 HTTP/2  </p><p>官方文档：<a href="https://www.python-httpx.org/">https://www.python-httpx.org/</a><br>github: <a href="https://github.com/encode/httpx/">https://github.com/encode/httpx/</a>  </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p>版本需求：Python 3.6+  </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install httpx<br></code></pre></td></tr></table></figure><p>如果希望支持 HTTP/2，可以使用：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install httpx[http2]<br></code></pre></td></tr></table></figure><p>如果希望支持 brotli 压缩算法，可以使用：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ pip install httpx[brotli]<br></code></pre></td></tr></table></figure><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><h3 id="基础请求方法"><a href="#基础请求方法" class="headerlink" title="基础请求方法"></a>基础请求方法</h3><p>基础的请求方法都类似  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">r = httpx.get(<span class="hljs-string">&#x27;https://httpbin.org/get&#x27;</span>)<br>r = httpx.post(<span class="hljs-string">&#x27;https://httpbin.org/post&#x27;</span>, data=&#123;<span class="hljs-string">&#x27;key&#x27;</span>: <span class="hljs-string">&#x27;value&#x27;</span>&#125;)<br>r = httpx.put(<span class="hljs-string">&#x27;https://httpbin.org/put&#x27;</span>, data=&#123;<span class="hljs-string">&#x27;key&#x27;</span>: <span class="hljs-string">&#x27;value&#x27;</span>&#125;)<br>r = httpx.delete(<span class="hljs-string">&#x27;https://httpbin.org/delete&#x27;</span>)<br>r = httpx.head(<span class="hljs-string">&#x27;https://httpbin.org/get&#x27;</span>)<br>r = httpx.options(<span class="hljs-string">&#x27;https://httpbin.org/get&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="自定义header"><a href="#自定义header" class="headerlink" title="自定义header"></a>自定义header</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://httpbin.org/headers&#x27;</span><br>headers = &#123;<span class="hljs-string">&#x27;user-agent&#x27;</span>: <span class="hljs-string">&#x27;my-app/0.0.1&#x27;</span>&#125;<br>r = httpx.get(url, headers=headers)<br>print(r.json())<br></code></pre></td></tr></table></figure><h3 id="get请求参数"><a href="#get请求参数" class="headerlink" title="get请求参数"></a>get请求参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">params = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>, <span class="hljs-string">&#x27;key3&#x27;</span>: [<span class="hljs-string">&#x27;value3&#x27;</span>, <span class="hljs-string">&#x27;value4&#x27;</span>]&#125;<br>r = httpx.get(<span class="hljs-string">&#x27;https://httpbin.org/get&#x27;</span>, params=params)<br>print(r.url)<br></code></pre></td></tr></table></figure><h3 id="post请求数据"><a href="#post请求数据" class="headerlink" title="post请求数据"></a>post请求数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">data = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>, <span class="hljs-string">&#x27;key3&#x27;</span>: [<span class="hljs-string">&#x27;value3&#x27;</span>, <span class="hljs-string">&#x27;value4&#x27;</span>]&#125;<br>r = httpx.post(<span class="hljs-string">&quot;https://httpbin.org/post&quot;</span>, data=data)<br>print(r.json()[<span class="hljs-string">&#x27;form&#x27;</span>])<br></code></pre></td></tr></table></figure><h3 id="post请求上传文件"><a href="#post请求上传文件" class="headerlink" title="post请求上传文件"></a>post请求上传文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 文件可以传入文件名和文件类型</span><br>files = &#123;<span class="hljs-string">&#x27;upload-file&#x27;</span>: (<span class="hljs-string">&#x27;README.md&#x27;</span>, <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;README.md&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>), <span class="hljs-string">&#x27;text/plain&#x27;</span>)&#125;<br>r = httpx.post(<span class="hljs-string">&quot;https://httpbin.org/post&quot;</span>, files=files)<br>print(r.text)<br></code></pre></td></tr></table></figure><p>可以一次性传输多个文件  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">files = [(<span class="hljs-string">&#x27;images&#x27;</span>, (<span class="hljs-string">&#x27;foo.png&#x27;</span>, <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;foo.png&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>), <span class="hljs-string">&#x27;image/png&#x27;</span>)),<br>                      (<span class="hljs-string">&#x27;images&#x27;</span>, (<span class="hljs-string">&#x27;bar.png&#x27;</span>, <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;bar.png&#x27;</span>, <span class="hljs-string">&#x27;rb&#x27;</span>), <span class="hljs-string">&#x27;image/png&#x27;</span>))]<br>r = httpx.post(<span class="hljs-string">&quot;https://httpbin.org/post&quot;</span>, files=files)<br></code></pre></td></tr></table></figure><h3 id="post请求发送json"><a href="#post请求发送json" class="headerlink" title="post请求发送json"></a>post请求发送json</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">data = &#123;<span class="hljs-string">&#x27;integer&#x27;</span>: <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;boolean&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-string">&#x27;list&#x27;</span>: [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]&#125;<br>r = httpx.post(<span class="hljs-string">&quot;https://httpbin.org/post&quot;</span>, json=data)<br>print(r.json())<br></code></pre></td></tr></table></figure><h3 id="流式响应"><a href="#流式响应" class="headerlink" title="流式响应"></a>流式响应</h3><ul><li><p>二进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> httpx.stream(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://www.example.com&quot;</span>) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> r.iter_bytes():<br>        print(data)<br></code></pre></td></tr></table></figure></li><li><p>文本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> httpx.stream(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://www.example.com&quot;</span>) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> r.iter_text():<br>        print(text)<br></code></pre></td></tr></table></figure></li><li><p>多行文本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> httpx.stream(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://www.example.com&quot;</span>) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> r.iter_lines():<br>        print(line)<br></code></pre></td></tr></table></figure></li><li><p>响应源码<br>未被经过 gzip, deflate, brotli 解压缩的源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> httpx.stream(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://www.example.com&quot;</span>) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> r.iter_raw():<br>        print(chunk)<br></code></pre></td></tr></table></figure></li><li><p>*注意**<br>如果您以任何上述方式使用流式响应，则response.content和response.text属性将不可用，并且在访问时会引发错误。<br>但是，你可以使用响应流功能来有条件地加载响应主体：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> httpx.stream(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://www.example.com&quot;</span>) <span class="hljs-keyword">as</span> r:<br>    <span class="hljs-keyword">if</span> r.headers[<span class="hljs-string">&#x27;Content-Length&#x27;</span>] &lt; <span class="hljs-number">99</span>:<br>        r.read()<br>        print(r.text)<br></code></pre></td></tr></table></figure><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>实际上，如果不进行特别的设置，这个超时的时间时5秒</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">httpx.get(<span class="hljs-string">&#x27;https://github.com/&#x27;</span>, timeout=<span class="hljs-number">0.001</span>)<br></code></pre></td></tr></table></figure><p>你可以通过将它设置为None来禁用它，虽然这可能导致永远挂起  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">httpx.get(<span class="hljs-string">&#x27;https://github.com/&#x27;</span>, timeout=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure><h3 id="授权验证"><a href="#授权验证" class="headerlink" title="授权验证"></a>授权验证</h3></li><li><p>明文身份验证  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">httpx.get(<span class="hljs-string">&quot;https://example.com&quot;</span>, auth=(<span class="hljs-string">&quot;my_user&quot;</span>, <span class="hljs-string">&quot;password123&quot;</span>))<br></code></pre></td></tr></table></figure></li><li><p>Digest 身份验证  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">auth = httpx.DigestAuth(<span class="hljs-string">&quot;my_user&quot;</span>, <span class="hljs-string">&quot;password123&quot;</span>)<br>httpx.get(<span class="hljs-string">&quot;https://example.com&quot;</span>, auth=auth)<br></code></pre></td></tr></table></figure><h2 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h2><h3 id="内容获取"><a href="#内容获取" class="headerlink" title="内容获取"></a>内容获取</h3></li><li><p>二进制数据<br>程序会自动处理 gzip 和 deflate 压缩的响应<br>如果安装了 brotlipy，那么 brotli 压缩的响应也能够处理  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">r = httpx.get(<span class="hljs-string">&#x27;https://www.example.org/&#x27;</span>)<br><br>print(r.content)<br></code></pre></td></tr></table></figure></li><li><p>文本  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">r = httpx.get(<span class="hljs-string">&#x27;https://www.example.org/&#x27;</span>)<br>print(r.encoding)<br>print(r.text)<br></code></pre></td></tr></table></figure><p>  通常情况下都是utf-8，遇到不是的话，需要手动指定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">r.encoding = <span class="hljs-string">&#x27;ISO-8859-1&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>json  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">r = httpx.get(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>)<br>print(r.json())<br></code></pre></td></tr></table></figure><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">r = httpx.get(<span class="hljs-string">&#x27;https://httpbin.org/get&#x27;</span>)<br>print(r.status_code)<br></code></pre></td></tr></table></figure><p>对于正常的响应，httpx有非常简单的判断方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">is_ok = r.status_code == httpx.codes.OK<br>print(is_ok)<br></code></pre></td></tr></table></figure><p>对于异常的响应，也有简易的抛出错误的方法<br>这个方法若是响应正常，会返回None.若是出现问题，则会抛出对应错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">r.raise_for_status()<br></code></pre></td></tr></table></figure><h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">r = httpx.get(<span class="hljs-string">&#x27;https://httpbin.org/get&#x27;</span>)<br>print(r.headers)<br></code></pre></td></tr></table></figure><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 由http跳转到https</span><br>r = httpx.get(<span class="hljs-string">&#x27;http://github.com/&#x27;</span>)<br>print(r.url)<br>print(r.status_code)<br>print(r.history)<br></code></pre></td></tr></table></figure><p>如果不想要跳转，那么可以设置  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">r = httpx.get(<span class="hljs-string">&#x27;http://github.com/&#x27;</span>, allow_redirects=<span class="hljs-literal">False</span>)<br>print(r.status_code)<br>print(r.history)<br></code></pre></td></tr></table></figure><p>在使用head方式发送请求时，也能用这个参数来启用跳转  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">r = httpx.head(<span class="hljs-string">&#x27;http://github.com/&#x27;</span>, allow_redirects=<span class="hljs-literal">True</span>)<br>print(r.url)<br>print(r.history)<br></code></pre></td></tr></table></figure><h2 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h2></li><li><p>从响应中获取  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">r = httpx.get(<span class="hljs-string">&#x27;http://httpbin.org/cookies/set?chocolate=chip&#x27;</span>, allow_redirects=<span class="hljs-literal">False</span>)<br>print(r.cookies[<span class="hljs-string">&#x27;chocolate&#x27;</span>])<br></code></pre></td></tr></table></figure></li><li><p>请求时设置(简易)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">cookies = &#123;<span class="hljs-string">&quot;peanut&quot;</span>: <span class="hljs-string">&quot;butter&quot;</span>&#125;<br>r = httpx.get(<span class="hljs-string">&#x27;http://httpbin.org/cookies&#x27;</span>, cookies=cookies)<br>print(r.json())<br></code></pre></td></tr></table></figure></li><li><p>请求时设置(标准)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">cookies = httpx.Cookies()<br>cookies.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;cookie_on_domain&#x27;</span>, <span class="hljs-string">&#x27;hello, there!&#x27;</span>, domain=<span class="hljs-string">&#x27;httpbin.org&#x27;</span>)<br>cookies.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;cookie_off_domain&#x27;</span>, <span class="hljs-string">&#x27;nope.&#x27;</span>, domain=<span class="hljs-string">&#x27;example.org&#x27;</span>)<br>r = httpx.get(<span class="hljs-string">&#x27;http://httpbin.org/cookies&#x27;</span>, cookies=cookies)<br>print(r.json())<br></code></pre></td></tr></table></figure></li></ul><h1 id="更多用法"><a href="#更多用法" class="headerlink" title="更多用法"></a>更多用法</h1><h2 id="Client-实例"><a href="#Client-实例" class="headerlink" title="Client 实例"></a>Client 实例</h2><blockquote><p>如果你曾经用过Requests，那么你可以将<code>httpx.Client()</code>看作是<code>requests.Session()</code>来快速理解  </p></blockquote><p>如果你并不是想要写“一次性访问代码”，那么应该用客户端实例<br>每次在使用 “快速入门” 里面的顶层API来访问网络时都会 建立TCP连接。频繁的建立TCP连接会使得程序的效率会大幅度下降  </p><p><code>Client</code> 实例拥有 HTTP连接池。当你访问同一个网络，<code>Client</code> 重用已经创建了的TCP连接。这样做能显著地提高订正API的性能  </p><ul><li>减少了请求之间的延迟（重用连接无需握手）  </li><li>减少CPU使用率和往返次数  </li><li>减少网络拥塞  </li></ul><p><code>Client</code>也有其它的功能  </p><ul><li>Cookie保持  </li><li>在所有传出请求中应用配置  </li><li>通过HTTP代理发送请求  </li><li>使用HTTP/2  </li></ul><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>推荐使用 <code>with</code>语句来使用  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> httpx.Client() <span class="hljs-keyword">as</span> client:<br>    ...<br></code></pre></td></tr></table></figure><p>也可以显式的在不需要使用用用<code>close</code>函数关闭  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">client = httpx.Client()<br><span class="hljs-keyword">try</span>:<br>    ...<br><span class="hljs-keyword">finally</span>:<br>    client.close()<br></code></pre></td></tr></table></figure><h3 id="请求-1"><a href="#请求-1" class="headerlink" title="请求"></a>请求</h3><p><code>Clent</code>拥有和高层级API一样的函数，比如说 <code>get()</code>, <code>post()</code>，在 “快速开始” 中的方法大多都有实现    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> httpx.Client() <span class="hljs-keyword">as</span> client:<br>    r = client.get(<span class="hljs-string">&#x27;https://example.com&#x27;</span>)<br></code></pre></td></tr></table></figure><h3 id="共享请求配置"><a href="#共享请求配置" class="headerlink" title="共享请求配置"></a>共享请求配置</h3><p>可以为<code>Client</code>配置内容，其配置的内容在发送请求时也会应用  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://httpbin.org/headers&#x27;</span><br>headers = &#123;<span class="hljs-string">&#x27;user-agent&#x27;</span>: <span class="hljs-string">&#x27;my-app/0.0.1&#x27;</span>&#125;<br><span class="hljs-keyword">with</span> httpx.Client(headers=headers) <span class="hljs-keyword">as</span> client:<br>    r = client.get(url)<br>r.json()[<span class="hljs-string">&#x27;headers&#x27;</span>][<span class="hljs-string">&#x27;User-Agent&#x27;</span>]<br></code></pre></td></tr></table></figure><p>此处<code>get()</code>并没有传入headers，但由于<code>Client</code>存在headers配置，最终的GET请求也存在headers配置  </p><h3 id="配置合并"><a href="#配置合并" class="headerlink" title="配置合并"></a>配置合并</h3><p>当你同时在<code>Client</code>中配置内容，在请求函数中也配置内容，可能会发生两种情况：  </p><ul><li>对于 Headers, Cookies, Query参数<br>它们的值会合并并一起应用到最后的请求中  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">headers = &#123;<span class="hljs-string">&#x27;X-Auth&#x27;</span>: <span class="hljs-string">&#x27;from-client&#x27;</span>&#125;<br>params = &#123;<span class="hljs-string">&#x27;client_id&#x27;</span>: <span class="hljs-string">&#x27;client1&#x27;</span>&#125;<br><span class="hljs-keyword">with</span> httpx.Client(headers=headers, params=params) <span class="hljs-keyword">as</span> client:<br>    headers = &#123;<span class="hljs-string">&#x27;X-Custom&#x27;</span>: <span class="hljs-string">&#x27;from-request&#x27;</span>&#125;<br>    params = &#123;<span class="hljs-string">&#x27;request_id&#x27;</span>: <span class="hljs-string">&#x27;request1&#x27;</span>&#125;<br>    r = client.get(<span class="hljs-string">&#x27;https://example.com&#x27;</span>, headers=headers, params=params)<br><br>print(r.request.url)<br>print(r.request.headers[<span class="hljs-string">&#x27;X-Auth&#x27;</span>])<br>print(r.request.headers[<span class="hljs-string">&#x27;X-Custom&#x27;</span>])<br></code></pre></td></tr></table></figure></li><li>对于其它参数，请求函数中设置的参数会覆盖<code>Client</code>中设置的参数  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> httpx.Client(auth=(<span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-string">&#x27;mot123&#x27;</span>)) <span class="hljs-keyword">as</span> client:<br>    r = client.get(<span class="hljs-string">&#x27;https://example.com&#x27;</span>, auth=(<span class="hljs-string">&#x27;alice&#x27;</span>, <span class="hljs-string">&#x27;ecila123&#x27;</span>))<br><br>_, _, auth = r.request.headers[<span class="hljs-string">&#x27;Authorization&#x27;</span>].partition(<span class="hljs-string">&#x27; &#x27;</span>)<br><span class="hljs-keyword">import</span> base64<br>base64.b64decode(auth)<br><span class="hljs-string">b&#x27;alice:ecila123&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="基础url"><a href="#基础url" class="headerlink" title="基础url"></a>基础url</h3>基础url可以让请求输入参数时少输入一些url  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> httpx.Client(base_url=<span class="hljs-string">&#x27;http://httpbin.org&#x27;</span>) <span class="hljs-keyword">as</span> client:<br>    r = client.get(<span class="hljs-string">&#x27;/headers&#x27;</span>)<br><br>print(r.request.url)<br></code></pre></td></tr></table></figure>更多的<code>Client</code>内容可以查看<a href="https://www.python-httpx.org/api/#client">API</a>  </li></ul><h2 id="Request-实例"><a href="#Request-实例" class="headerlink" title="Request 实例"></a>Request 实例</h2><p>httpx 是支持显式创建 <code>Request</code>实例的  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">request = httpx.Request(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://example.com&quot;</span>)<br></code></pre></td></tr></table></figure><p>创建的 <code>Request</code>实例可以使用<code>Client</code>实例的 <code>send()</code>方法来发送  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> httpx.Client() <span class="hljs-keyword">as</span> client:<br>    response = client.send(request)<br></code></pre></td></tr></table></figure><p>如果想要使用不同层级的配置，可以使用<code>Client</code>实例的<code>build_request()</code>方法  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">headers = &#123;<span class="hljs-string">&quot;X-Api-Key&quot;</span>: <span class="hljs-string">&quot;...&quot;</span>, <span class="hljs-string">&quot;X-Client-ID&quot;</span>: <span class="hljs-string">&quot;ABC123&quot;</span>&#125;<br><br><span class="hljs-keyword">with</span> httpx.Client(headers=headers) <span class="hljs-keyword">as</span> client:<br>    request = client.build_request(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://example.com&quot;</span>)<br>    print(request.headers[<span class="hljs-string">&quot;X-Client-ID&quot;</span>])  <span class="hljs-comment"># &quot;ABC123&quot;</span><br>    <span class="hljs-comment"># 删除header中的一个项</span><br>    request.headers.pop(<span class="hljs-string">&quot;X-Api-Key&quot;</span>)<br>    response = client.send(request)<br>    ...<br></code></pre></td></tr></table></figure><h2 id="事件钩子-Event-Hooks"><a href="#事件钩子-Event-Hooks" class="headerlink" title="事件钩子 Event Hooks"></a>事件钩子 Event Hooks</h2><p>httpx 可以让你注册 “事件钩子”，每当指定的事件发生，钩子内容会被调用<br>现在能够使用的钩子有两个  </p><ul><li>request - 请求即将发送时调用。传递请求实例  </li><li>response - 响应返回后调用。传递响应实例  </li></ul><p>例：利用事件钩子进行记录  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log_request</span>(<span class="hljs-params">request</span>):</span><br>    print(<span class="hljs-string">f&quot;Request event hook: <span class="hljs-subst">&#123;request.method&#125;</span> <span class="hljs-subst">&#123;request.url&#125;</span> - Waiting for response&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log_response</span>(<span class="hljs-params">response</span>):</span><br>    request = response.request<br>    print(<span class="hljs-string">f&quot;Response event hook: <span class="hljs-subst">&#123;request.method&#125;</span> <span class="hljs-subst">&#123;request.url&#125;</span> - Status <span class="hljs-subst">&#123;response.status_code&#125;</span>&quot;</span>)<br><br>client = httpx.Client(event_hooks=&#123;<span class="hljs-string">&#x27;request&#x27;</span>: [log_request], <span class="hljs-string">&#x27;response&#x27;</span>: [log_response]&#125;)<br></code></pre></td></tr></table></figure><p>例：在状态码为4xx或5xx时，抛出错误    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">raise_on_4xx_5xx</span>(<span class="hljs-params">response</span>):</span><br>    response.raise_for_status()<br><br>client = httpx.Client(event_hooks=&#123;<span class="hljs-string">&#x27;response&#x27;</span>: [raise_on_4xx_5xx]&#125;)<br></code></pre></td></tr></table></figure><p>钩子能够传入多个函数，只要一并放入参数中即可    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">client = httpx.Client()<br>client.event_hooks[<span class="hljs-string">&#x27;request&#x27;</span>] = [log_request]<br>client.event_hooks[<span class="hljs-string">&#x27;response&#x27;</span>] = [log_response, raise_on_4xx_5xx]<br></code></pre></td></tr></table></figure><p>在设置完毕后，可以使用<code>Client</code>对象的<code>event_hooks</code>属性查看设置  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">client = httpx.Client()<br>client.event_hooks[<span class="hljs-string">&#x27;request&#x27;</span>] = [log_request]<br>client.event_hooks[<span class="hljs-string">&#x27;response&#x27;</span>] = [log_response, raise_on_4xx_5xx]<br></code></pre></td></tr></table></figure><blockquote><p>如果未来使用异步请求，那么钩子函数也需要是异步函数  </p></blockquote><h2 id="监视响应进度"><a href="#监视响应进度" class="headerlink" title="监视响应进度"></a>监视响应进度</h2><p>如果需要监视响应进度（例如下载文件时的下载进度），可以使用 stream请求和<code>response.num_bytes_downloaded</code></p><p>例：使用 <code>tqdm</code>库 配合显示下载进度  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tempfile<br><br><span class="hljs-keyword">import</span> httpx<br><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><br><span class="hljs-keyword">with</span> tempfile.NamedTemporaryFile() <span class="hljs-keyword">as</span> download_file:<br>    url = <span class="hljs-string">&quot;https://speed.hetzner.de/100MB.bin&quot;</span><br>    <span class="hljs-keyword">with</span> httpx.stream(<span class="hljs-string">&quot;GET&quot;</span>, url) <span class="hljs-keyword">as</span> response:<br>        total = <span class="hljs-built_in">int</span>(response.headers[<span class="hljs-string">&quot;Content-Length&quot;</span>])<br><br>        <span class="hljs-keyword">with</span> tqdm(total=total, unit_scale=<span class="hljs-literal">True</span>, unit_divisor=<span class="hljs-number">1024</span>, unit=<span class="hljs-string">&quot;B&quot;</span>) <span class="hljs-keyword">as</span> progress:<br>            num_bytes_downloaded = response.num_bytes_downloaded<br>            <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> response.iter_bytes():<br>                download_file.write(chunk)<br>                progress.update(response.num_bytes_downloaded - num_bytes_downloaded)<br>                num_bytes_downloaded = response.num_bytes_downloaded<br></code></pre></td></tr></table></figure><h2 id="netrc支持"><a href="#netrc支持" class="headerlink" title=".netrc支持"></a>.netrc支持</h2><p>HTTPX支持 <code>.netrc</code>文件。 在<code>trust_env = True</code>情况下，如果未定义<code>auth</code>参数，则HTTPX尝试将<code>auth</code>从<code>.netrc</code>文件添加到请求的标头中<br>默认情况下 <code>trust_env</code>参数值为<code>True</code>  </p><p>如果<code>NETRC</code>环境没设置，那么 httpx 会尝试去读取系统默认环境下的文件  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 更改环境</span><br><span class="hljs-keyword">import</span> os<br>os.environ[<span class="hljs-string">&quot;NETRC&quot;</span>] = <span class="hljs-string">&quot;my_default_folder/.my_netrc&quot;</span><br></code></pre></td></tr></table></figure><p>注意，如果使用<code>Client</code>，那么<code>trust_env</code>参数应该在<code>Client</code>中进行设置，而不是在请求方法中传入  </p><h2 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h2><p>httpx支持使用代理，传入<code>proxies</code>传入内容即可使用<br>例: 传入HTTP代理 与 HTTPS代理  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">proxies = &#123;<br>    <span class="hljs-string">&quot;http://&quot;</span>: <span class="hljs-string">&quot;http://localhost:8030&quot;</span>,<br>    <span class="hljs-string">&quot;https://&quot;</span>: <span class="hljs-string">&quot;http://localhost:8031&quot;</span>,<br>&#125;<br><br><span class="hljs-keyword">with</span> httpx.Client(proxies=proxies) <span class="hljs-keyword">as</span> client:<br>    ...<br></code></pre></td></tr></table></figure><h3 id="代理路由"><a href="#代理路由" class="headerlink" title="代理路由"></a>代理路由</h3><p>httpx提供多种不同的选择代理的方法  </p><ul><li>通配<br>让所有请求都走这个代理  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">proxies = &#123;<br>    <span class="hljs-string">&quot;all://&quot;</span>: <span class="hljs-string">&quot;http://localhost:8030&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li>协议匹配<br>根据请求类型走不同的代理  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">proxies = &#123;<br>    <span class="hljs-string">&quot;http://&quot;</span>: <span class="hljs-string">&quot;http://localhost:8030&quot;</span>,<br>    <span class="hljs-string">&quot;https://&quot;</span>: <span class="hljs-string">&quot;http://localhost:8031&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li>域名匹配<br>域名为<code>example.com</code>的请求走这个代理  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">proxies = &#123;<br>    <span class="hljs-string">&quot;all://example.com&quot;</span>: <span class="hljs-string">&quot;http://localhost:8030&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>  域名为<code>example.com</code>的HTTP请求走这个代理  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">proxies = &#123;<br>    <span class="hljs-string">&quot;http://example.com&quot;</span>: <span class="hljs-string">&quot;http://localhost:8030&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>  域名及子域名匹配<code>example.com</code>的请求走这个代理  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">proxies = &#123;<br>    <span class="hljs-string">&quot;all://*example.com&quot;</span>: <span class="hljs-string">&quot;http://localhost:8030&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>  <code>example.com</code>子域名的请求都走这个代理  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">proxies = &#123;<br>    <span class="hljs-string">&quot;all://*.example.com&quot;</span>: <span class="hljs-string">&quot;http://localhost:8030&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li>端口匹配<br>访问”example.com”的1234端口的HTTPS请求走这个代理  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">proxies = &#123;<br>    <span class="hljs-string">&quot;https://example.com:1234&quot;</span>: <span class="hljs-string">&quot;http://localhost:8030&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure>所有1234端口的请求走这个代理<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">proxies = &#123;<br>    <span class="hljs-string">&quot;all://*:1234&quot;</span>: <span class="hljs-string">&quot;http://localhost:8030&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li>不走代理<br>只要设定键值为<code>None</code>即可  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">proxies = &#123;<br>    <span class="hljs-comment"># Route requests through a proxy by default...</span><br>    <span class="hljs-string">&quot;all://&quot;</span>: <span class="hljs-string">&quot;http://localhost:8031&quot;</span>,<br>    <span class="hljs-comment"># Except those for &quot;example.com&quot;.</span><br>    <span class="hljs-string">&quot;all://example.com&quot;</span>: <span class="hljs-literal">None</span>,<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代理类型"><a href="#代理类型" class="headerlink" title="代理类型"></a>代理类型</h3>代理根据它的流程有两种类型：转发 与 隧道  </li><li>转发：就只是单纯的转发  </li><li>隧道：中间人，即将客户端的数据包解析出来，再将数据重新发送。这样子包的记录信息（IP、Mac等）都时代理的信息  </li></ul><p>默认情况下 httpx 传输 HTTP时会使用 转发类型的代理，而传输HTTPS则使用隧道类型的代理  </p><p>httpx提供了代理检查功能，通过使用<code>httpx.Proxy</code>实例，设置 <code>FORWARD_ONLY</code> 或 <code>TUNNEL_ONLY</code>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 所有HTTPS请求都走这个代理, 这个代理必须是隧道类型</span><br>proxies = httpx.Proxy(<br>    url=<span class="hljs-string">&quot;https://localhost:8030&quot;</span>,<br>    mode=<span class="hljs-string">&quot;TUNNEL_ONLY&quot;</span>,<br>)<br><br><span class="hljs-keyword">with</span> httpx.Client(proxies=proxies) <span class="hljs-keyword">as</span> client:<br>    <span class="hljs-comment"># This HTTP request will be tunneled instead of forwarded.</span><br>    r = client.get(<span class="hljs-string">&quot;http://example.com&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h2><p>实际上，除了直接设置总体超时时间，httpx还可以对超时进行更细致的设定<br>超时有四种类型：  </p><ul><li><p>连接超时 connect<br>指定等待与请求的主机建立连接之前的最长时间。 如果HTTPX在此时间段内无法连接，则会引发ConnectTimeout异常  </p></li><li><p>读取超时 read<br>指定了等待接收数据（例如，响应主体的块）的最长时间。 如果HTTPX在此时间段内无法接收数据，则会引发ReadTimeout异常  </p></li><li><p>写超时 write<br>指定等待发送数据块（例如，请求正文的块）的最大持续时间。 如果HTTPX在此时间段内无法发送数据，则会引发WriteTimeout异常  </p></li><li><p>从连接池获取连接超时 pool<br>指定等待从连接池获取连接的最大持续时间。 如果HTTPX在此时间段内无法获取连接，则会引发PoolTimeout异常  </p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># A client with a 60s timeout for connecting, and a 10s timeout elsewhere.</span><br>timeout = httpx.Timeout(<span class="hljs-number">10.0</span>, connect=<span class="hljs-number">60.0</span>)<br>client = httpx.Client(timeout=timeout)<br><br>response = client.get(<span class="hljs-string">&#x27;http://example.com/&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="连接池限制"><a href="#连接池限制" class="headerlink" title="连接池限制"></a>连接池限制</h2><p>你可以设置httpx连接池连接数量限制  </p><ul><li><code>max_keepalive</code> 允许的保持活动连接数。为<code>None</code>则表示无限制（默认值：10）  </li><li><code>max_connections</code> 最大链接数。为<code>None</code>则表示无限制（默认值：100）  </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">limits = httpx.Limits(max_keepalive_connections=<span class="hljs-number">5</span>, max_connections=<span class="hljs-number">10</span>)<br>client = httpx.Client(limits=limits)<br></code></pre></td></tr></table></figure><h2 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h2><p>通过HTTPS发出请求时，HTTPX需要验证所请求主机的身份。 为此，它使用由受信任的证书颁发机构（CA）交付的SSL证书捆绑包（也称为CA bundle）  </p><p>默认情况下，httpx 使用 <a href="https://pypi.org/project/certifi/">Certifi</a> 的 CA bundle<br>在大多数情况下，这个设置已经足够了。但在一些情况可能需要使用不同的CA bundle<br>如果想要使用自己的CA bundle，可以通过 <code>verify</code> 参数传入  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> httpx<br><br>r = httpx.get(<span class="hljs-string">&quot;https://example.org&quot;</span>, verify=<span class="hljs-string">&quot;path/to/client.pem&quot;</span>)<br></code></pre></td></tr></table></figure><p>或者使用标准库<code>ssl.SSLContext</code>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> ssl<br><span class="hljs-keyword">import</span> httpx<br>context = ssl.create_default_context()<br>context.load_verify_locations(cafile=<span class="hljs-string">&quot;/tmp/client.pem&quot;</span>)<br>httpx.get(<span class="hljs-string">&#x27;https://example.org&#x27;</span>, verify=context)<br></code></pre></td></tr></table></figure><p>httpx 也拥有方便创建 <code>SSLContext</code> 的函数<br><code>create_ssl_context</code>函数接受与 <code>httpx.Client</code> 或<code>httpx.AsyncClient</code> 相同的SSL配置参数集（trust_env，verify，cert和http2参数）  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> httpx<br>context = httpx.create_ssl_context(verify=<span class="hljs-string">&quot;/tmp/client.pem&quot;</span>)<br>httpx.get(<span class="hljs-string">&#x27;https://example.org&#x27;</span>, verify=context)<br></code></pre></td></tr></table></figure><p>如果你完全不需要SSL，可以通过对 <code>verify</code> 参数传入<code>False</code>来进行设置  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> httpx<br><br>r = httpx.get(<span class="hljs-string">&quot;https://example.org&quot;</span>, verify=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h3 id="SSL配置与Client实例"><a href="#SSL配置与Client实例" class="headerlink" title="SSL配置与Client实例"></a>SSL配置与Client实例</h3><p>如果你使用<code>Client</code>实例，并且希望使用SSL配置，那么应该在创建它的时候传入<br>请求函数（get,post等）并不支持对SSL配置进行修改。如果在不同情况下需要不同的SSL设置，则应该使用多个客户端实例，对每个实例进行不同的设置。每个客户端将在该池中的所有连接上使用具有特定的固定SSL配置的隔离连接池  </p><h3 id="HTTPS请求与本地服务器"><a href="#HTTPS请求与本地服务器" class="headerlink" title="HTTPS请求与本地服务器"></a>HTTPS请求与本地服务器</h3><p>向本地服务器（例如在本地主机上运行的开发服务器）发出请求时，通常将使用未加密的HTTP连接  </p><p>如果需要建立与本地服务器的HTTPS连接（例如，测试仅HTTPS服务），则需要创建并使用自己的证书（自签证书）<br>在服务器生成密钥对以后，拿到其对应的<code>.pem</code>密钥文件，传入<code>verify</code>参数之中即可    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> httpx<br>r = httpx.get(<span class="hljs-string">&quot;https://localhost:8000&quot;</span>, verify=<span class="hljs-string">&quot;/tmp/client.pem&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="自定义传输"><a href="#自定义传输" class="headerlink" title="自定义传输"></a>自定义传输</h2><p><code>Client</code>能接受传输参数，该参数允许您提供一个自定义的传输对象，该对象将用于执行请求的实际发送  </p><p>对于某些高级配置，需要直接实例化传输类，并将其传递给客户端实例。 <code>httpcore</code> 软件包提供了只能通过此低级API使用的<code>local_address</code>配置  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> httpx, httpcore<br>ssl_context = httpx.create_ssl_context()<br>transport = httpcore.SyncConnectionPool(<br>    ssl_context=ssl_context,<br>    max_connections=<span class="hljs-number">100</span>,<br>    max_keepalive_connections=<span class="hljs-number">20</span>,<br>    keepalive_expiry=<span class="hljs-number">5.0</span>,<br>    local_address=<span class="hljs-string">&quot;0.0.0.0&quot;</span><br>)  <span class="hljs-comment"># 使用httpx默认标准设置, 然后添加了只允许 IPv4  的&#x27;local_address&#x27;设置</span><br>client = httpx.Client(transport=transport)<br></code></pre></td></tr></table></figure><p>类似地，httpcore提供了一个uds选项，用于通过Unix域套接字进行连接，该选项仅可通过以下底层API使用：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> httpx, httpcore<br>ssl_context = httpx.create_ssl_context()<br>transport = httpcore.SyncConnectionPool(<br>    ssl_context=ssl_context,<br>    max_connections=<span class="hljs-number">100</span>,<br>    max_keepalive_connections=<span class="hljs-number">20</span>,<br>    keepalive_expiry=<span class="hljs-number">5.0</span>,<br>    uds=<span class="hljs-string">&quot;/var/run/docker.sock&quot;</span>,<br>)  <span class="hljs-comment"># 通过 Unix Socket 连接 Docker API</span><br>client = httpx.Client(transport=transport)<br>response = client.get(<span class="hljs-string">&quot;http://docker/info&quot;</span>)<br>response.json()<br></code></pre></td></tr></table></figure><p>与 <code>Client</code>不同，较低级别的httpcore传输实例不包含用于配置方面（例如连接池详细信息）的任何默认值，因此在使用此API时需要提供更明确的配置  </p><h2 id="自定义传输类"><a href="#自定义传输类" class="headerlink" title="自定义传输类"></a>自定义传输类</h2><p>传输实例必须实现 <code>httpcore</code> 定义的传输API<br>自定义传输类应该继承<code>httpcore.AsyncHTTPTransport</code>来实现与<code>AsyncClient</code>一起使用的传输<br>或者继承<code>httpcore.SyncHTTPTransport</code>来实现与<code>Client</code>一起使用的传输  </p><p>定制传输实现的完整示例为：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> httpcore<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorldTransport</span>(<span class="hljs-params">httpcore.SyncHTTPTransport</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    A mock transport that always returns a JSON &quot;Hello, world!&quot; response.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">self, method, url, headers=<span class="hljs-literal">None</span>, stream=<span class="hljs-literal">None</span>, timeout=<span class="hljs-literal">None</span></span>):</span><br>        message = &#123;<span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;Hello, world!&quot;</span>&#125;<br>        content = json.dumps(message).encode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>        stream = httpcore.PlainByteStream(content)<br>        headers = [(<span class="hljs-string">b&quot;content-type&quot;</span>, <span class="hljs-string">b&quot;application/json&quot;</span>)]<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">b&quot;HTTP/1.1&quot;</span>, <span class="hljs-number">200</span>, <span class="hljs-string">b&quot;OK&quot;</span>, headers, stream<br></code></pre></td></tr></table></figure><p>上面代码的作用与下面的代码相同  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> httpx<br>client = httpx.Client(transport=HelloWorldTransport())<br>response = client.get(<span class="hljs-string">&quot;https://example.org/&quot;</span>)<br></code></pre></td></tr></table></figure><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><p>异步是一种并发模型，其效率远远高于多线程，并且可以提供显着的性能优势并允许使用长期存在的网络连接（例如WebSockets）    </p><p>想要用 httpx 发出异步请求，则需要使用<code>AsyncClient</code>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> httpx.AsyncClient() <span class="hljs-keyword">as</span> client:<br>    r = <span class="hljs-keyword">await</span> client.get(<span class="hljs-string">&#x27;https://www.example.com/&#x27;</span>)<br></code></pre></td></tr></table></figure><p>有<code>AsyncClient</code>有很多与<code>Client</code>相似的请求方法  </p><ul><li>AsyncClient.get(url, …)  </li><li>AsyncClient.options(url, …)  </li><li>AsyncClient.head(url, …)  </li><li>AsyncClient.post(url, …)  </li><li>AsyncClient.put(url, …)  </li><li>AsyncClient.patch(url, …)  </li><li>AsyncClient.delete(url, …)  </li><li>AsyncClient.request(method, url, …)  </li><li>AsyncClient.send(request, …)  </li></ul><h2 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h2><p><code>AsyncClient</code>的关闭的方法时<code>aclose()</code>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">client = httpx.AsyncClient()<br><span class="hljs-keyword">await</span> client.aclose()<br></code></pre></td></tr></table></figure><p>但是，实际上依旧推荐使用<code>with</code>来使用，并不推荐显式关闭  </p><h2 id="流式响应-1"><a href="#流式响应-1" class="headerlink" title="流式响应"></a>流式响应</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">client = httpx.AsyncClient()<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> client.stream(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://www.example.com/&#x27;</span>) <span class="hljs-keyword">as</span> response:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> response.aiter_bytes():<br>        ...<br></code></pre></td></tr></table></figure><ul><li><code>Response.aread()</code><br>用于有条件地读取流块内的响应  </li><li><code>Response.aiter_bytes()</code><br>用于以字节形式流式传输响应内容  </li><li><code>Response.aiter_text()</code><br>用于以文本形式流式传输响应内容  </li><li><code>Response.aiter_lines()</code><br>用于将响应内容作为文本流传输  </li><li><code>Response.aiter_raw()</code><br>用于流式传输原始响应字节，而无需应用内容解码  </li><li><code>Response.aclose()</code><br>用于关闭响应。 通常不需要这样做，因为.stream块会在退出时自动关闭响应  </li></ul><p>对于无法使用上下文块的情况，可以通过使用<code>client.send(...，stream = True)</code>发送一个 Request实例 来进入“手动模式”  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> httpx<br><span class="hljs-keyword">from</span> starlette.background <span class="hljs-keyword">import</span> BackgroundTask<br><span class="hljs-keyword">from</span> starlette.responses <span class="hljs-keyword">import</span> StreamingResponse<br><br>client = httpx.AsyncClient()<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">home</span>(<span class="hljs-params">request</span>):</span><br>    req = client.build_request(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;https://www.example.com/&quot;</span>)<br>    r = <span class="hljs-keyword">await</span> client.send(req, stream=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> StreamingResponse(r.aiter_text(), background=BackgroundTask(r.aclose))<br></code></pre></td></tr></table></figure><h2 id="AsyncIO"><a href="#AsyncIO" class="headerlink" title="AsyncIO"></a>AsyncIO</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> httpx<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> httpx.AsyncClient() <span class="hljs-keyword">as</span> client:<br>        response = <span class="hljs-keyword">await</span> client.get(<span class="hljs-string">&#x27;https://www.example.com/&#x27;</span>)<br>        print(response)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h1 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h1><p>HTTP/2 提供了更有效的传输，并具有潜在的性能优势。HTTP2不会更改请求或响应的核心语义，但会更改数据与服务器之间的发送方式  </p><p>详细可以参考：<a href="https://evilrecluse.top/post/f317f6d8/">我的HTTP2记录</a>  、<a href="https://http2-explained.haxx.se/zh/part1">HTTP2解析</a>  </p><p>httpx 默认并不支持 HTTP/2，如果想要使用，则需要启用HTTP/2支持<br>首先，需要安装 httpx 的 HTTP/2依赖  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install httpx[http2]<br></code></pre></td></tr></table></figure><p>再带那么重初始化支持 HTTP/2 的 <code>Client</code>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> httpx.AsyncClient(http2=<span class="hljs-literal">True</span>) <span class="hljs-keyword">as</span> client:<br>    ...<br></code></pre></td></tr></table></figure><p><code>Client</code> 和 <code>AsyncClient</code> 都可以使用 HTTP/2 支持    </p><h2 id="检查HTTP版本"><a href="#检查HTTP版本" class="headerlink" title="检查HTTP版本"></a>检查HTTP版本</h2><p>在<code>Client</code>上启用 HTTP/2 支持不一定意味着请求和响应将通过 HTTP/2 传输，因为只有客户端和服务器都支持 HTTP/2，HTTP2才会运行。如果连接到仅支持HTTP / 1.1的服务器，那么<code>Client</code>会自动改用 HTTP/1.1 进行连接  </p><p>通过检查<code>Response.http_version</code>属性来确定使用了哪个版本的HTTP协议  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">client = httpx.AsyncClient(http2=<span class="hljs-literal">True</span>)<br>response = <span class="hljs-keyword">await</span> client.get(...)<br>print(response.http_version)  <span class="hljs-comment"># &quot;HTTP/1.0&quot;, &quot;HTTP/1.1&quot;, or &quot;HTTP/2&quot;.</span><br></code></pre></td></tr></table></figure><hr><p>后续可继续查阅官方文档内容  </p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>httpx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP2</title>
    <link href="/post/f317f6d8/"/>
    <url>/post/f317f6d8/</url>
    
    <content type="html"><![CDATA[<p>HTTP/2 将很多以前在应用中针对 HTTP/1.1 想出来的“歪招儿”一笔勾销，把解决那些问题的方案内置在了传输层中  </p><p>HTTP/2 的主要目标是通过 支持完整的请求 与 响应复用 来减少延迟，通过有效压缩 HTTP 标头字段将协议开销降至最低，同时增加对请求优先级和服务器推送的支持<br>为达成这些目标，HTTP/2 给我们带来了大量其他协议层面的辅助实现，例如新的流控制、错误处理和升级机制  </p><p>HTTP/2 没有改动 HTTP 的应用语义。 HTTP 方法、状态代码、URI 和标头字段等核心概念一如往常<br>不过，HTTP/2 修改了数据格式化（分帧）以及在客户端与服务器间传输的方式。这两点统帅全局，通过新的分帧层向我们的应用隐藏了所有复杂性。 因此，现有的应用都可以不经修改的在新协议下运行  </p><blockquote><p>为什么不是 HTTP/1.2？<br>为了实现 HTTP 工作组设定的性能目标，HTTP/2 引入了一个新的二进制分帧层，该层无法与之前的 HTTP/1.x 服务器和客户端向后兼容，因此协议的主版本提升到 HTTP/2  </p></blockquote><p>除非你自己实现网络服务器（或自定义客户端），需要使用原始的 TCP 套接字，否则由 http1.1 转到 http2，你可能注意不到任何区别：所有新的分帧操作由客户端和服务器为你执行。唯一可以观察到的区别是性能的提升和请求优先级、流控制与服务器推送等新功能的出现  </p><h1 id="SPDY-与-HTTP-2-简史"><a href="#SPDY-与-HTTP-2-简史" class="headerlink" title="SPDY 与 HTTP/2 简史"></a>SPDY 与 HTTP/2 简史</h1><p>SPDY 是 Google 开发的一个实验性协议，于 2009 年年中发布，其主要目标是通过解决 HTTP/1.1 中广为人知的一些性能限制来减少网页的加载延迟<br>具体来说，这个项目设定的目标如下：  </p><ul><li>页面加载时间 (PLT) 减少 50%  </li><li>无需网站作者修改任何内容  </li><li>将部署复杂性降至最低，无需变更网络基础设施  </li><li>与开源社区合作开发此新协议  </li><li>收集真实性能数据，验证实验性协议是否有效  </li></ul><p>注：为了达到减少 50% 页面加载时间的目标，SPDY 引入一个新的二进制分帧层，以实现请求和响应复用、优先级和标头压缩，目的是更有效地利用底层 TCP 连接  </p><blockquote><p><strong>延迟性能瓶颈</strong><br><img src="/HTTP2/20210222085448883.png"><br>带宽增加到一定程度，再增加就对速度影响较小<br>而延迟越小，页面读取速度越快  </p></blockquote><p>首次发布后不久，Google 的两位软件工程师 Mike Belshe 和 Roberto Peon 就分享了他们对这个新实验性 SPDY 协议的实现结果、文档和源代码  </p><p>到了 2012 年，这个新的实验性协议得到 Chrome、Firefox 和 Opera 的支持，而且越来越多的大型网站（如 Google、Twitter、Facebook）和小型网站开始在其基础设施内部署 SPDY。 事实上，在被行业越来越多的采用之后，SPDY 已经具备了成为一个标准的条件  </p><p>观察到这一趋势后，HTTP 工作组 (HTTP-WG) 将这一工作提上议事日程，吸取 SPDY 的经验教训，并在此基础上制定了官方“HTTP/2”标准。 在拟定宣言草案、向社会征集 HTTP/2 建议并经过内部讨论之后，HTTP-WG 决定将 SPDY 规范作为新 HTTP/2 协议的基础  </p><p>在接下来几年中，SPDY 和 HTTP/2 继续共同演化，其中 SPDY 作为实验性分支，用于为 HTTP/2 标准测试新功能和建议。 理论不一定适合实践（反之亦然），SPDY 提供一个测试和评估路线，可以对要纳入 HTTP/2 标准中的每条建议进行测试和评估。 最终，这个过程持续了三年，期间产生了十余个中间草案  </p><p>SPDY 与 HTTP/2 的共同演化让服务器、浏览器和网站开发者可以在新协议制定过程中获得真实体验。 因此，HTTP/2 标准自诞生之日起就成为最好并经过大量测试的标准之一。 到 HTTP/2 被 IESG 批准时，已经有很多经过完全测试并且可以立即投入生产的客户端与服务器。 事实上，在最终协议被批准的几周后，由于多款热门浏览器（和许多网站）都部署了完整的 HTTP/2 支持，大量用户都体会到了新协议的好处  </p><h1 id="技术目标"><a href="#技术目标" class="headerlink" title="技术目标"></a>技术目标</h1><p>早期版本的 HTTP 协议的设计初衷主要是实现要简单： HTTP/0.9 只用一行协议就启动了万维网；HTTP/1.0 则是对流行的 HTTP/0.9 扩展的一个正式说明；HTTP 1.1 则是 IETF 的一份官方标准；因此，HTTP/0.9-1.x 实现了其目的：HTTP 是应用最广泛、采用最多的一个互联网应用协议  </p><p>然而，实现简单是以牺牲应用性能为代价的：  </p><ul><li>HTTP/1.x 客户端需要使用多个连接才能实现并发和缩短延迟；  <ul><li>浏览器阻塞（HOL blocking）<br><img src="/HTTP2/20210223115019379.png"><br>浏览器会因为一些原因阻塞请求。浏览器对于同一个域名一般同时只能有4-6 个连接，超过浏览器最大连接数限制，后续请求就会被阻塞，这个被称作线头阻塞head of line block  </li><li>建立连接（Initial connection）<br>HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大  </li></ul></li><li>HTTP/1.x 不会压缩请求和响应标头，从而导致不必要的网络流量；  </li><li>HTTP/1.x 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下；  </li></ul><p>这些代价并不致命，但随着网络应用的范围、复杂性不断增大。它们对网络开发者和用户都造成了巨大负担，这正是 HTTP/2 要致力于解决的：  </p><ul><li>HTTP/2 通过支持标头字段压缩和在同一连接上 进行多个并发交换，让应用更有效地利用网络资源，减少 感知的延迟时间<br>可以对同一连接上的请求和响应消息进行交错 发送并为 HTTP 标头字段使用 有效编码。 HTTP/2 允许为请求设置优先级，让更重要的请求更快速地完成，从而进一步提升性能  </li><li>与 HTTP/1.x 相比，可以使用更少的 TCP 连接<br>与其他流的竞争减小，并且连接的持续时间变长，这些特性反过来提高 了可用网络容量的利用率。 HTTP/2 还可以通过使用二进制消息分帧对消息进行更高效的处理  </li></ul><blockquote><p><strong>HTTP/2 仍是对之前 HTTP 标准的扩展，而非替代</strong><br>HTTP 的应用语义、提供的功能、HTTP 方法、状态代码、URI 和标头字段等这些核心概念不变<br>虽然高级 API 保持不变，仍有必要了解低级变更如何解决了之前协议的性能限制。 我们来简单了解一下二进制分帧层及其功能  </p></blockquote><h1 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h1><p>HTTP/2 所有性能增强的核心在于新的二进制分帧层，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输  </p><p><img src="/HTTP2/20210222094255088.png"><br>这里所谓的“层”，指的是位于套接字接口与应用可见的高级 HTTP API 之间一个经过优化的新编码机制：HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的编码方式变了  </p><p>HTTP/1.x 协议以换行符作为纯文本的分隔符，而 HTTP/2 将所有传输的信息分割为更小的消息和帧，并采用二进制格式对它们编码<br>这样一来，客户端和服务器为了相互理解，都必须使用新的二进制编码机制：HTTP/1.x 客户端无法理解只支持 HTTP/2 的服务器，反之亦然<br>不过不要紧，现有的应用不必担心这些变化，因为客户端和服务器会替我们完成必要的分帧工作  </p><h1 id="数据流、消息和帧"><a href="#数据流、消息和帧" class="headerlink" title="数据流、消息和帧"></a>数据流、消息和帧</h1><p>新的二进制分帧机制改变了客户端与服务器之间交换数据的方式<br>为了说明这个过程，首先需要了解 HTTP/2 的三个概念：  </p><ul><li>数据流(stream)<br>已建立的连接内的双向字节流，可以承载一条或多条消息  </li><li>消息(message)<br>与逻辑请求或响应消息对应的完整的一系列帧  </li><li>帧(frame)<br>HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流  </li></ul><p>这些概念的关系总结如下：  </p><ul><li>所有通信都在一个 TCP 连接上完成，此连接可以承载任意数量的双向数据流  </li><li>每个数据流都有一个唯一的标识符和可选的优先级信息，用于承载双向消息  </li><li>每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧  </li><li>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装  </li></ul><p><img src="/HTTP2/20210223093330027.png">  </p><p>简而言之，HTTP/2 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个 TCP 连接内复用。 这是 HTTP/2 协议所有其他功能和性能优化的基础  </p><h1 id="请求与响应复用"><a href="#请求与响应复用" class="headerlink" title="请求与响应复用"></a>请求与响应复用</h1><p>在 HTTP/1.x 中，如果客户端要想发起多个并行请求以提升性能，则必须使用多个 TCP 连接。 这是 HTTP/1.x 交付模型的直接结果，该模型可以保证每个连接每次只交付一个响应（响应排队）。 糟糕的是，这种模型也会导致队首阻塞，从而造成底层 TCP 连接的效率低下  </p><p><img src="/HTTP2/999.jpg">  </p><p>HTTP/2 中新的二进制分帧层突破了这些限制，实现了完整的请求和响应复用：客户端和服务器可以将 HTTP 消息分解为互不依赖的帧，然后交错发送，最后再在另一端把它们重新组装起来  </p><p><img src="/HTTP2/20210223094509651.png">  </p><p>快照捕捉了同一个连接内并行的多个数据流。 客户端正在向服务器传输一个 DATA 帧（数据流 5），与此同时，服务器正向客户端交错发送数据流 1 和数据流 3 的一系列帧。因此，一个连接上同时有三个并行数据流  </p><p>将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP 2 最重要的一项增强。事实上，这个机制会在整个网络技术栈中引发一系列连锁反应，从而带来巨大的性能提升：  </p><ul><li>并行交错地发送多个请求，请求之间互不影响。</li><li>并行交错地发送多个响应，响应之间互不干扰。</li><li>使用一个连接并行发送多个请求和响应。</li><li>不必再为绕过 HTTP/1.x 限制而做很多工作（例如:级联文件、image sprites 和域名分片。</li><li>消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间。</li><li>……</li></ul><p>HTTP/2 中的新二进制分帧层解决了 HTTP/1.x 中存在的队首阻塞问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。 所以应用速度更快、开发更简单、部署成本更低  </p><h1 id="数据流优先级"><a href="#数据流优先级" class="headerlink" title="数据流优先级"></a>数据流优先级</h1><p>将 HTTP 消息分解为很多独立的帧之后，我们就可以复用多个数据流中的帧，客户端和服务器交错发送和传输这些帧的顺序就成为关键的性能决定因素   </p><p>HTTP/2 标准允许每个数据流都有一个关联的权重和依赖关系：  </p><ul><li>可以向每个数据流分配一个介于 1 至 256 之间的整数  </li><li>每个数据流与其他数据流之间可以存在显式依赖关系  </li></ul><p>数据流依赖关系和权重的组合让客户端可以构建和传递“优先级树”，表明它倾向于如何接收响应。 反过来，服务器可以使用此信息通过控制 CPU、内存和其他资源的分配设定数据流处理的优先级，在资源数据可用之后，带宽分配可以确保将高优先级响应以最优方式传输至客户端  </p><p>HTTP/2 内的数据流依赖关系通过将另一个数据流的唯一标识符作为父项引用进行声明；如果忽略标识符，相应数据流将依赖于“根数据流”。 声明数据流依赖关系指出，应尽可能先向父数据流分配资源，然后再向其依赖项分配资源。共享相同父项的数据流（即，同级数据流）应按其权重比例分配资源<br>简而言之：  </p><ul><li>没有标识依赖于谁，则认为依赖于根  </li><li>优先考虑依赖关系，父级优先，子级靠边  </li><li>父级相同时，才考虑权重。权重越大，优先级越高  </li></ul><p><img src="/HTTP2/20210223095121176.png">  </p><p>上图中的其他几个操作示例。 从左到右依次为：  </p><ol><li>数据流 A 和数据流 B 都没有指定父依赖项，依赖于显式“根数据流”<br>A 的权重为 12，B 的权重为 4<br>因此，根据比例权重：数据流 B 获得的资源是 A 所获资源的三分之一  </li><li>数据流 D 依赖于根数据流；C 依赖于 D<br>因此，D 应先于 C 获得完整资源分配。权重不重要，因为 C 的依赖关系拥有更高的优先级  </li><li>数据流 D 应先于 C 获得完整资源分配；C 应先于 A 和 B 获得完整资源分配；数据流 B 获得的资源是 A 所获资源的三分之一  </li><li>数据流 D 应先于 E 和 C 获得完整资源分配；E 和 C 应先于 A 和 B 获得相同的资源分配；A 和 B 应基于其权重获得比例分配  </li></ol><p>数据流依赖关系和权重的组合明确表达了资源优先级，这是一种用于提升浏览性能的关键功能，网络中拥有多种资源类型，它们的依赖关系和权重各不相同<br>不仅如此，HTTP/2 协议还允许客户端随时更新这些优先级，进一步优化了浏览器性能。 换句话说，我们可以根据用户互动和其他信号更改依赖关系和重新分配权重  </p><blockquote><p><strong>优先级并不决定顺序</strong><br>数据流依赖关系和权重表示传输优先级，而不是要求，因此不能保证特定的处理或传输顺序   客户端无法强制服务器通过数据流优先级以特定顺序处理数据流。 尽管这看起来违反直觉，但却是一种必要行为。 我们不希望在优先级较高的资源受到阻止时，还阻止服务器处理优先级较低的资源  </p></blockquote><h1 id="每个来源一个连接"><a href="#每个来源一个连接" class="headerlink" title="每个来源一个连接"></a>每个来源一个连接</h1><p>有了新的分帧机制后，HTTP/2 不再依赖多个 TCP 连接去并行复用数据流；每个数据流都拆分成很多帧，而这些帧可以交错，还可以分别设定优先级。 因此，所有 HTTP/2 连接都是永久的，而且仅需要每个来源一个连接，随之带来诸多性能优势  </p><p>SPDY 和 HTTP/2 的杀手级功能是，可以在一个拥塞受到良好控制的通道上任意进行复用。 这一功能的重要性和良好运行状况让我吃惊。 我喜欢的一个非常不错的指标是连接拆分，这些拆分仅承载一个 HTTP 事务（并因此让该事务承担所有开销）。 对于 HTTP/1，我们 74% 的活动连接仅承载一个事务 - 永久连接并不如我们所有人希望的那般有用。 但是在 HTTP/2 中，这一比例锐减至 25%。 这是在减少开销方面获得的巨大成效  </p><p>大多数 HTTP 传输都是短暂且急促的，而 TCP 则针对长时间的批量数据传输进行了优化。 通过重用相同的连接，HTTP/2 既可以更有效地利用每个 TCP 连接，也可以显著降低整体协议开销。 不仅如此，使用更少的连接还可以减少占用的内存和处理空间，也可以缩短完整连接路径（即，客户端、可信中介和源服务器之间的路径） 这降低了整体运行成本并提高了网络利用率和容量。 因此，迁移到 HTTP/2 不仅可以减少网络延迟，还有助于提高通量和降低运行成本  </p><p>注：连接数量减少对提升 HTTPS 部署的性能来说是一项特别重要的功能：可以减少开销较大的 TLS 连接数、提升会话重用率，以及从整体上减少所需的客户端和服务器资源  </p><h1 id="流控制"><a href="#流控制" class="headerlink" title="流控制"></a>流控制</h1><p>流控制是一种阻止发送方向接收方发送大量数据的机制，以免超出后者的需求或处理能力：发送方可能非常繁忙、处于较高的负载之下，也可能仅仅希望为特定数据流分配固定量的资源   例如，客户端可能请求了一个具有较高优先级的大型视频流，但是用户已经暂停视频，客户端现在希望暂停或限制从服务器的传输，以免提取和缓冲不必要的数据。 再比如，一个代理服务器可能具有较快的下游连接和较慢的上游连接，并且也希望调节下游连接传输数据的速度以匹配上游连接的速度来控制其资源利用率；等等。</p><p>上述要求会让您想到 TCP 流控制吗？你应当想到这一点；因为问题基本相同（请参阅流控制）。 不过，由于 HTTP/2 数据流在一个 TCP 连接内复用，TCP 流控制既不够精细，也无法提供必要的应用级 API 来调节各个数据流的传输。 为了解决这一问题，HTTP/2 提供了一组简单的构建块，这些构建块允许客户端和服务器实现其自己的数据流和连接级流控制：  </p><ul><li>流控制具有方向性<br>每个接收方都可以根据自身需要选择为每个数据流和整个连接设置任意的窗口大小  </li><li>流控制基于信用<br>每个接收方都可以公布其初始连接和数据流流控制窗口（以字节为单位），每当发送方发出 DATA 帧时都会减小，在接收方发出 WINDOW_UPDATE 帧时增大  </li><li>流控制无法停用<br>建立 HTTP/2 连接后，客户端将与服务器交换 SETTINGS 帧，这会在两个方向上设置流控制窗口。 流控制窗口的默认值设为 65,535 字节，但是接收方可以设置一个较大的最大窗口大小（2^31-1 字节），并在接收到任意数据时通过发送 WINDOW_UPDATE 帧来维持这一大小  </li><li>流控制为逐跃点控制，而非端到端控制<br>可信中介可以使用它来控制资源使用，以及基于自身条件和启发式算法实现资源分配机制  </li></ul><p>HTTP/2 未指定任何特定算法来实现流控制。 不过，它提供了简单的构建块并推迟了客户端和服务器实现，可以实现自定义策略来调节资源使用和分配，以及实现新传输能力，同时提升网页应用的实际性能和感知性能（请参阅<a href="https://hpbn.co/primer-on-web-performance/#speed-performance-and-human-perception">速度、性能和人类感知</a>）  </p><p>例如，应用层流控制允许浏览器仅提取一部分特定资源，通过将数据流流控制窗口减小为零来暂停提取，稍后再行恢复。 换句话说，它允许浏览器提取图像预览或首次扫描结果，进行显示并允许其他高优先级提取继续，然后在更关键的资源完成加载后恢复提取  </p><h1 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h1><p>HTTP/2 新增的另一个强大的新功能是，服务器可以对一个客户端请求发送多个响应。 换句话说，除了对最初请求的响应外，服务器还可以向客户端推送额外资源，而无需客户端明确地请求  </p><p><img src="/HTTP2/20210223111904424.png">  </p><p>服务器为推送资源发起新数据流 (promise)  </p><blockquote><p><strong>打破了严格的请求-响应语义</strong><br>HTTP/2 打破了严格的请求-响应语义，支持一对多和服务器发起的推送工作流，在浏览器内外开启了全新的互动可能性。 这是一项使能功能，对我们思考协议、协议用途和使用方式具有重要的长期影响  </p></blockquote><p><span></span></p><blockquote><p><strong>为什么在浏览器中需要一种此类机制呢？</strong><br>一个典型的网络应用包含多种资源，客户端需要检查服务器提供的文档才能逐个找到它们。 那为什么不让服务器提前推送这些资源，从而减少额外的延迟时间呢？ 服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场  </p></blockquote><p>事实上，如果你在网页中内联过 CSS、JavaScript，或者通过数据 URI 内联过其他资产，那么你就已经亲身体验过服务器推送了<br>对于将资源手动内联到文档中的过程，我们实际上是在将资源推送给客户端，而不是等待客户端请求。 使用 HTTP/2，我们不仅可以实现相同结果，还会获得其他性能优势。 推送资源可以进行以下处理：</p><ul><li>由客户端缓存  </li><li>在不同页面之间重用  </li><li>与其他资源一起复用  </li><li>由服务器设定优先级  </li><li>被客户端拒绝  </li></ul><h2 id="PUSH-PROMISE-101"><a href="#PUSH-PROMISE-101" class="headerlink" title="PUSH_PROMISE 101"></a>PUSH_PROMISE 101</h2><p>所有服务器推送数据流都由 PUSH_PROMISE 帧发起，表明了服务器向客户端推送所述资源的意图，并且需要先于请求推送资源的响应数据传输。这种传输顺序非常重要：客户端需要了解服务器打算推送哪些资源，以免为这些资源创建重复请求<br>满足此要求的最简单策略是先于父响应（即，DATA 帧）发送所有 PUSH_PROMISE 帧，其中包含所承诺资源的 HTTP 标头  </p><p>在客户端接收到 PUSH_PROMISE 帧后，它可以根据自身情况选择拒绝数据流（通过 RST_STREAM 帧）。 （例如，如果资源已经位于缓存中，便可能会发生这种情况。） 这是一个相对于 HTTP/1.x 的重要提升。 相比之下，使用资源内联（一种受欢迎的 HTTP/1.x“优化”）等同于“强制推送”：客户端无法选择拒绝、取消或单独处理内联的资源  </p><p>使用 HTTP/2，客户端仍然完全掌控服务器推送的使用方式。 客户端可以限制并行推送的数据流数量；调整初始的流控制窗口以控制在数据流首次打开时推送的数据量；或完全停用服务器推送。 这些优先级在 HTTP/2 连接开始时通过 SETTINGS 帧传输，可能随时更新  </p><p>推送的每个资源都是一个数据流，与内嵌资源不同，客户端可以对推送的资源逐一复用、设定优先级和处理。 浏览器强制执行的唯一安全限制是，推送的资源必须符合原点相同这一政策：服务器对所提供内容必须具有权威性  </p><h1 id="标头压缩"><a href="#标头压缩" class="headerlink" title="标头压缩"></a>标头压缩</h1><p>每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性<br>在 HTTP/1.x 中，此元数据始终以纯文本形式，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节  </p><p>为了减少此开销和提升性能，HTTP/2 使用 HPACK 压缩格式压缩请求和响应标头元数据<br><img src="/HTTP2/20210224095705074.png">  </p><ul><li><strong>静态表（Static Table）</strong><br>静态表在规范中定义，并提供了一个包含所有连接都可能使用的常用 HTTP 标头字段的列表,为常见内容提供压缩参照<br>（例如：”GET” =&gt; “2”）  </li><li><strong>动态表（Dynamic Table）</strong><br>动态表最初为空，将根据在特定连接内交换的值进行更新<br>为之前未见过的值采用静态 Huffman 编码，并替换动态表中已存在值的索引，可以减小每个请求的大小  </li></ul><p><img src="/HTTP2/20210223113949650.png"><br>Huffman编码可以在传输时对各个值进行压缩，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码，索引值可用于有效查询和重构完整的标头键值对  </p><blockquote><p>注：在 HTTP/2 中，请求和响应标头字段的定义保持不变，仅有一些微小的差异：所有标头字段名称均为小写，请求行现在拆分成各个 :method、:scheme、:authority 和 :path 伪标头字段  </p></blockquote><h1 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h1><p>HTTP/2 相比于 HTTP1.1，大幅提升了多连接访问时性能<br>对于简单的、单一的页面请求提升并不大  </p><p><a href="https://http2.akamai.com/demo">Akamai HTTP2 Demo</a> 这个链接是一个演示Demo，用来比较 HTTP/2 与 HTTP/1.1 在性能上的差异  </p><hr><ul><li><a href="https://hpbn.co/">《高性能浏览器网络》</a> - Ilya Grigorik  </li><li><a href="https://hpbn.co/http2/">HTTP/2</a> – Ilya Grigorik 所著的完整文章  </li><li><a href="https://surma.link/things/h2setup/">设置 HTTP/2</a> – 如何在不同的后端中设置 HTTP/2，作者：Surma  </li><li><a href="https://docs.google.com/presentation/d/1r7QXGYOLCh4fcUq0jDdDwKJWNqWK1o4xMtYpKZCJYjM/edit?hl=zh-cn#slide=id.p19">HTTP/2”已经粉墨登场，我们一起优化性能吧！</a> – Ilya Grigorik 在 Velocity 2015 上所作的演示  </li><li><a href="https://docs.google.com/document/d/1K0NykTXBbbbTlv60t5MyJvXjqKGsCVNYHyLEXIxYMv0/edit?hl=zh-cn">HTTP/2 推送的经验法则</a> – Tom Bergan、Simon Pelchat 和 Michael Buettner 对何时以及如何使用推送的分析  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>http2</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP2-wireshark-抓包</title>
    <link href="/post/bc48295f/"/>
    <url>/post/bc48295f/</url>
    
    <content type="html"><![CDATA[<p>主流浏览器都大多都支持 HTTP/2 Over TLS<br>HTTP2 网站都使用了 HTTPS，数据传输都经过了 SSL 加密<br>默认情况下，Wireshark抓到的包没有密钥，只能解析到SSL层，在其之上的协议细节完全看不到（即：在这种情况下，如果尝试取抓的话，抓到的是TLS的包）  </p><p>Wireshark 的抓包原理是直接读取并分析网卡数据，要想让它解密 HTTPS 流量，有两个办法：<br>1）如果你拥有 HTTPS 网站的加密私钥，可以用来解密这个网站的加密流量<br>2）某些浏览器支持将 TLS 会话中使用的对称密钥保存在外部文件中，可供 Wireshark 加密使用  </p><p>Firefox 和 Chrome 都支持生成上述第二种方式的文件，具体格式见这里：<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format">NSS Key Log Format</a>  </p><ul><li><p>添加浏览器密钥记录日志环境变量<br>Firefox 和 Chrome 只会在系统环境变量中存在 SSLKEYLOGFILE 路径时才会生成它<br><img src="/HTTP2-wireshark-%E6%8A%93%E5%8C%85/20210222033910509.png"><br>如果系统环境变量中没有这个值，那么就手动创建一个  </p></li><li><p>wireshark 配置<br>在 wireshark 首选项中配置读取浏览器密钥记录<br>菜单栏-编辑-首选项-协议-TLS<br><img src="/HTTP2-wireshark-%E6%8A%93%E5%8C%85/20210222034949302.png"><br>将浏览器密钥日志填入  </p></li><li><p>测试<br>过滤器中直接填入http2协议，浏览器访问一个http2的网站即可<br>例如：<a href="https://http2.akamai.com/demo">https://http2.akamai.com/demo</a><br><img src="/HTTP2-wireshark-%E6%8A%93%E5%8C%85/20210222035435016.png">  </p></li></ul><blockquote><p>注意，访问网站不能使用代理，否则不会走http2  </p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>http2</tag>
      
      <tag>wireshark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列-MessageQueue</title>
    <link href="/post/9cdada3e/"/>
    <url>/post/9cdada3e/</url>
    
    <content type="html"><![CDATA[<h1 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h1><p>消息队列好比是一个存放消息的容器，发送者发送消息存到里面，当接收者需要消息的时候可以取出消息供自己使用<br>消息队列是分布式系统中重要的组件，使用消息队列主要是为了通过异步处理提高系统性能和削峰、降低系统耦合性  </p><p>目前使用较多的消息队列有：ActiveMQ，RabbitMQ，Kafka，RocketMQ  </p><p>队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的<br>比如生产者发送消息1,2,3…对于消费者就会按照1,2,3…的顺序来消费<br>但是偶尔也会出现消息被消费的顺序不对的情况，比如某个消息消费失败又或者一个 queue 多个consumer 也会导致消息被消费的顺序不对，我们一定要保证消息被消费的顺序正确  </p><p>除了上面说的消息消费顺序的问题，使用消息队列，我们还要考虑：如何保证消息不被重复消费？如何保证消息的可靠性传输（如何处理消息丢失的问题）？……等等问题<br>所以说使用消息队列也不是十全十美的，使用它也会让系统可用性降低、复杂度提高，另外需要我们保障一致性等问题  </p><h1 id="为什么要用消息队列"><a href="#为什么要用消息队列" class="headerlink" title="为什么要用消息队列"></a>为什么要用消息队列</h1><p>使用消息队列主要好处：  </p><ul><li>降低系统耦合  </li><li>异步处理，提高系统性能  </li><li>削峰，避免崩溃  </li></ul><h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>假设现在有一个 可以产生userId的系统A 和 两个需要userId的系统，B和C<br><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-MessageQueue/20210208024615505.png"><br>这样的结构下，代码会类似于  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>():</span><br>    userID = <span class="hljs-number">666</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.b, self.c = B(), C()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        self.b.using(self.userID)<br>        self.c.using(self.userID)<br></code></pre></td></tr></table></figure><p>此时，B与C系统都依赖于A<br>如果有一天，需要添加一个类似于B或C的系统D，那么A的代码需要修改<br>如果有一天，需要删除系统B或C，那么A的代码也需要更改<br><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-MessageQueue/20210208025917936.png"><br>此时引入消息队列。系统A只专注于将 userId 写到消息队列中，系统C和D从消息队列中拿数据。此时，无论取userId 的系统发生什么更变，都不会影响到系统A。如此一来系统A与BC都解耦了  </p><h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>类似的，假设现在有一个 可以产生userId的系统A 和 三个需要userId的系统，B、C和D<br><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-MessageQueue/20210208031027565.png"><br>这样的结构下，代码会类似于  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>():</span><br>    userID = <span class="hljs-number">666</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.b, self.c, self.d = B(), C(), D()<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        threads = [<br>            Thread(self.b.using, arg=userID),<br>            Thread(self.c.using, arg=userID),<br>            Thread(self.d.using, arg=userID),<br>        ]<br>        <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads:<br>            thread.start()<br>        <span class="hljs-keyword">for</span> thread <span class="hljs-keyword">in</span> threads:<br>            thread.join()<br></code></pre></td></tr></table></figure><p>这样的情况下会有一个问题，在 B，C、D 执行完毕之前，A就只能等待<br>这已经是 B、C、D 并行的情况，若是 B、C、D是串行的，那么等待的情况会更加糟糕<br>为了提高用户体验和吞吐量，其实可以用 消息队列 异步地调用系统 B、C、D 的接口<br><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-MessageQueue/20210208033040673.png"><br>系统A执行完了以后，将 userId 写到消息队列中，然后就直接返回了(至于其他的操作，则异步处理)  </p><h2 id="消峰"><a href="#消峰" class="headerlink" title="消峰"></a>消峰</h2><p>这个其实非常好理解<br><img src="/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-MessageQueue/20210208033610934.png"><br>如果有一个A接口，1秒可以响应1000请求<br>此时外部调用A接口频率超过 1000次/s，那么不仅仅会导致接口响应缓慢，而且还有可能导致接口服务崩溃<br>此时在请求与接口间添加消息队列，将请求记录下来，等接口有空再去取，那么系统就会变得更加稳定  </p><h1 id="消息队列要点"><a href="#消息队列要点" class="headerlink" title="消息队列要点"></a>消息队列要点</h1><h2 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h2><p>无论是我们使用消息队列来做解耦、异步还是削峰，消息队列肯定不能是单机的<br>如果是单机的消息队列，万一这台机器挂了，那我们整个系统几乎就是不可用了<br>所以项目中使用消息队列，都是得集群/分布式的。要做集群/分布式就必然希望该消息队列能够提供现成的支持，而不是自己写代码手动去实现  </p><h2 id="数据丢失问题"><a href="#数据丢失问题" class="headerlink" title="数据丢失问题"></a>数据丢失问题</h2><p>我们将数据写到消息队列上，系统还没来得及取消息队列的数据，就挂掉了。此时如果没有做任何的措施，那么保存在队列中的数据就丢了<br>但如果做数据备份，那么备份到哪里？用什么方式？就是一个问题  </p><h1 id="常见MQ对比"><a href="#常见MQ对比" class="headerlink" title="常见MQ对比"></a>常见MQ对比</h1><ul><li><p>ActiveMQ<br>社区算是比较成熟，但是较目前来说，ActiveMQ 的性能比较差，而且版本迭代很慢，不推荐使用  </p></li><li><p>RabbitMQ<br>在吞吐量方面虽然稍逊于 Kafka 和 RocketMQ ，但是由于它基于 erlang 开发，所以并发能力很强，性能极其好，延时很低，达到微秒级。但是也因为 RabbitMQ 基于 erlang 开发，所以国内很少有公司有实力做erlang源码级别的研究和定制。如果业务场景对并发量要求不是太高（十万级、百万级），那这四种消息队列中，RabbitMQ 一定是你的首选。如果是大数据领域的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范  </p></li><li><p>RocketMQ<br>阿里出品，Java 系开源项目，源代码我们可以直接阅读，然后可以定制自己公司的MQ，并且 RocketMQ 有阿里巴巴的实际业务场景的实战考验。RocketMQ 社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准 JMS 规范走的有些系统要迁移需要修改大量代码。还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ 挺好的  </p></li><li><p>kafka<br>的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms 级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时 kafka 最好是支撑较少的 topic 数量即可，保证其超高吞吐量。kafka 唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集  </p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript-浏览器环境模拟</title>
    <link href="/post/361f44ce/"/>
    <url>/post/361f44ce/</url>
    
    <content type="html"><![CDATA[<h1 id="jsdom"><a href="#jsdom" class="headerlink" title="jsdom"></a>jsdom</h1><p>jsdom 是一个纯粹由 javascript 实现的一系列 web标准，特别是 WHATWG 组织制定的DOM和 HTML 标准，用于在 nodejs 中使用。大体上来说，该项目的目标是模拟足够的Web浏览器子集，以便用于测试和挖掘真实世界的Web应用程序  </p><p><strong>链接</strong><br>github地址：<a href="https://github.com/jsdom/jsdom">https://github.com/jsdom/jsdom</a>  </p><p><strong>安装</strong>  </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> jsdom<br></code></pre></td></tr></table></figure><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> jsdom = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;jsdom&quot;</span>);<br><span class="hljs-keyword">const</span> &#123; JSDOM &#125; = jsdom;<br></code></pre></td></tr></table></figure><p>为了使用 jsdom，主要用到jsdom主模块的一个命名导出的 jsdom 构造函数<br>往构造器传递一个字符串，将会得到一个 jsdom 构造实例对象，这个对象有很多实用的属性，特别是 window 对象:  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dom = <span class="hljs-keyword">new</span> JSDOM(<span class="hljs-string">`&lt;!DOCTYPE html&gt;&lt;p&gt;Hello world&lt;/p&gt;`</span>);<br><span class="hljs-built_in">console</span>.log(dom.window.document.querySelector(<span class="hljs-string">&quot;p&quot;</span>).textContent); <span class="hljs-comment">// &quot;Hello world&quot;</span><br></code></pre></td></tr></table></figure><p>(注意: jsdom会像浏览器一样解析您传递的HTML，包括隐含的<html>，<head>和<body>标记)  </p><p>生成的对象是 JSDOM类 的一个实例，其中包括 window 对象在内的许多有用的属性和方法<br>一般来说，它可以用来从“外部”对jsdom进行操作，而这些操作对于普通DOM API来说是不可能的<br>对于不需要任何功能的简单场景，推荐使用类似的编码模式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; <span class="hljs-built_in">window</span> &#125; = <span class="hljs-keyword">new</span> JSDOM(<span class="hljs-string">`...`</span>);<br><span class="hljs-comment">// or even</span><br><span class="hljs-keyword">const</span> &#123; <span class="hljs-built_in">document</span> &#125; = (<span class="hljs-keyword">new</span> JSDOM(<span class="hljs-string">`...`</span>)).window;<br></code></pre></td></tr></table></figure><h2 id="简单选项"><a href="#简单选项" class="headerlink" title="简单选项"></a>简单选项</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dom = <span class="hljs-keyword">new</span> JSDOM(<span class="hljs-string">``</span>, &#123;<br>  url: <span class="hljs-string">&quot;https://example.org/&quot;</span>,<br>  referrer: <span class="hljs-string">&quot;https://example.com/&quot;</span>,<br>  contentType: <span class="hljs-string">&quot;text/html&quot;</span>,<br>  userAgent: <span class="hljs-string">&quot;Mellblomenator/9000&quot;</span>,<br>  includeNodeLocations: <span class="hljs-literal">true</span><br>&#125;);<br></code></pre></td></tr></table></figure><ul><li> url<br>设置的值可以通过<code>window.location</code>，<code>document.URL</code>和<code>document.documentURI</code>来返回，并会影响文档中相关URL的解析以及获取子资源时使用的同源限制和referrer。默认值为<code>about:blank</code>  </li><li> referrer<br>仅仅影响<code>document.referrer</code>的值。默认没有引用（即为空字符串）  </li><li> contentType<br>影响<code>document.contentType</code>的值，是按照HTML解析文档还是 XML来解析。它的值如果不是<code>text/html</code>或<code>XML mime type</code> 值的话将会抛出异常。默认值为<code>text/html</code>  </li><li> userAgent<br>影响<code>navigator.userAgent</code>的值以及请求子资源时发送的<code>User-Agent</code>头。默认值为<code>Mozilla / 5.0（$ &#123;process.platform&#125;）AppleWebKit / 537.36（KHTML，如Gecko）jsdom / $ &#123;jsdomVersion&#125;</code>  </li><li> includeNodeLocations<br>保留由HTML解析器生成的位置信息，允许您使用<code>nodeLocation()</code>方法（如下所述）检索它  </li></ul><p>它还能确保在<code>&lt;script&gt;</code>元素内运行的代码的异常堆栈跟踪中报告的行号是正确的<br>默认值为<code>false</code>以提供最佳性能，并且不能与XML内容类型一起使用，因为我们的XML解析器不支持位置信息  </p><p>请注意，url 和referrer在使用之前已经被规范化了，例如<br>如果你传入<code>https:example.com</code>，jsdom会自动规范化解释为<code>https://example.com/</code><br>如果你传递了一个不可解析的URL，该调用将抛出错误。<br>（URL根据URL标准进行分析和序列化）  </p><h2 id="执行脚本"><a href="#执行脚本" class="headerlink" title="执行脚本"></a>执行脚本</h2><p>jsdom 最强大的功能是它可以在 jsdom 中执行脚本。这些脚本可以修改页面的内容并访问 jsdom 实现的所有Web平台API  </p><p>但是，这在处理不可信内容时也非常危险<br>jsdom沙箱并不是万无一失的，在DOM的<code>&lt;script&gt;</code>内部运行的代码如果足够深入，就可以访问 <code>Node.js</code> 环境，从而访问您的计算机<br>因此，默认情况下，执行嵌入在HTML中的脚本的功能是禁用的：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dom = <span class="hljs-keyword">new</span> JSDOM(<span class="hljs-string">`&lt;body&gt;</span><br><span class="hljs-string">  &lt;script&gt;document.body.appendChild(document.createElement(&quot;hr&quot;));&lt;/script&gt;</span><br><span class="hljs-string">&lt;/body&gt;`</span>);<br><br><span class="hljs-comment">// 脚本默认将不能执行:</span><br>dom.window.document.body.children.length === <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>要在页面内启用脚本，可以使用 <code>runScripts:&quot;dangerously&quot;</code>选项：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> dom = <span class="hljs-keyword">new</span> JSDOM(<span class="hljs-string">`&lt;body&gt;</span><br><span class="hljs-string">  &lt;script&gt;document.body.appendChild(document.createElement(&quot;hr&quot;));&lt;/script&gt;</span><br><span class="hljs-string">&lt;/body&gt;`</span>, &#123; <span class="hljs-attr">runScripts</span>: <span class="hljs-string">&quot;dangerously&quot;</span> &#125;);<br><br><span class="hljs-comment">// 脚本将执行并修改 DOM:</span><br>dom.window.document.body.children.length === <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>我们再次强调只有在提供给 jsdom 的代码是你已知道是安全的代码时方可使用它。如果您运行了任意用户提供的或 Internet 上的不可信的 Node.js 代码，可能会危及您的计算机  </p><p>假如你想通过<code>&lt;script src=&quot;&quot;&gt;</code>来执行外部脚本，你需要确保已经加载了它们。为此，请添加选项 <code>resources:&quot;usable&quot;</code> 如下所述  </p><p>请注意，除非<code>runScripts</code>设置为<code>dangerously</code>，否则事件处理程序属性（如<code>&lt;div onclick =“”&gt;</code>）也将不起作用。（但是，事件处理函数属性，比如<code>div.onclick = ...</code>，将无视<code>runScripts</code>参数 并且会起作用）  </p><p>如果您只是试图从“外部”执行脚本，而不是通过<code>&lt;script&gt;</code>元素（和内联事件处理程序）从内部运行“，则可以使用<code>runScripts: &quot;outside-only&quot;</code>选项，该选项会启用<code>window.eval</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-built_in">window</span> = (<span class="hljs-keyword">new</span> JSDOM(<span class="hljs-string">``</span>, &#123; <span class="hljs-attr">runScripts</span>: <span class="hljs-string">&quot;outside-only&quot;</span> &#125;)).window;<br><br><span class="hljs-built_in">window</span>.eval(<span class="hljs-string">`document.body.innerHTML = &quot;&lt;p&gt;Hello, world!&lt;/p&gt;&quot;;`</span>);<br><span class="hljs-built_in">window</span>.document.body.children.length === <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>由于性能原因，默认情况下会关闭此功能，但可以安全启用  </p><p>请注意，我们强烈建议不要试图通过将 jsdom 和 Node 全局环境混合在一起（例如，通过执行<code>global.window = dom.window</code>）来“执行脚本”，然后在 Node 全局环境中执行脚本或测试代码<br>相反，您应该像对待浏览器一样对待 jsdom，并使用 <code>window.eval</code>或<code>runScripts: &quot;dangerously&quot;</code>来运行需要访问 jsdom 环境内的 DOM 的所有脚本和测试<br>例如，这可能需要创建一个browserify包作为<code>&lt;script&gt;</code>元素执行 - 就像在浏览器中一样  </p><h2 id="Cookie-jars-存储Cookie的容器"><a href="#Cookie-jars-存储Cookie的容器" class="headerlink" title="Cookie jars(存储Cookie的容器)"></a>Cookie jars(存储Cookie的容器)</h2><p>像网页浏览器一样，jsdom 也具有cookie jar的概念，存储 HTTP cookie  在文档的同一个域上一个 URL，并且没有标记为 HTTP only 的 cookies,可以通过 document.cookie API 来访问。此外，Cookie jar 中的所有 cookie 都会影响子资源的 http 加载  </p><p>默认情况下，JSDOM构造函数将返回一个带有空cookie的实例。要创建自己的cookie jar并将其传递给jsdom，可以通过以下代码来覆盖默认值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> cookieJar = <span class="hljs-keyword">new</span> jsdom.CookieJar(store, options);<br><span class="hljs-keyword">const</span> dom = <span class="hljs-keyword">new</span> JSDOM(<span class="hljs-string">``</span>, &#123; cookieJar &#125;);<br></code></pre></td></tr></table></figure><p>如果您想要在多个 jsdoms 中共享同一个 cookie jar，或者提前使用特定的值来填充 cookie jar，这将非常有用  </p><p>Cookie jar 包由 tough-cookie 包提供的。jsdom.CookieJar 构造函数是 tough-cookie cookie jar 的子类，并且默认设置了looseMode：true选项，因为它更符合浏览器的行为方式<br>如果您想自己使用 tough-cookie 的方法和类，则可以使用 jsdom.toughCookie 模块导出来访问使用 jsdom 打包的 tough-cookie 模块实例  </p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>见github文档： <a href="https://github.com/jsdom/jsdom#jsdom-object-api">https://github.com/jsdom/jsdom#jsdom-object-api</a>  </p><h1 id="abab"><a href="#abab" class="headerlink" title="abab"></a>abab</h1><p>jsdom 提供的 window对象 并没有 <code>atob</code>与<code>btoa</code> 这两个处理 base64 字符的方法。使用这个库可以获取到一样的方法，既标准 base64 编码解码方法    </p><p><strong>链接</strong><br>github地址：<a href="https://github.com/jsdom/abab">https://github.com/jsdom/abab</a>  </p><p><strong>安装</strong>  </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> abab<br></code></pre></td></tr></table></figure><h2 id="btoa-base64-encode"><a href="#btoa-base64-encode" class="headerlink" title="btoa (base64 encode)"></a>btoa (base64 encode)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> &#123; btoa &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;abab&#x27;</span>);<br>btoa(<span class="hljs-string">&#x27;Hello, world!&#x27;</span>); <span class="hljs-comment">// &#x27;SGVsbG8sIHdvcmxkIQ==&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="atob-base64-decode"><a href="#atob-base64-decode" class="headerlink" title="atob (base64 decode)"></a>atob (base64 decode)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascri">const &#123; atob &#125; &#x3D; require(&#39;abab&#39;);<br>atob(&#39;SGVsbG8sIHdvcmxkIQ&#x3D;&#x3D;&#39;); &#x2F;&#x2F; &#39;Hello, world!&#39;<br></code></pre></td></tr></table></figure><h2 id="有效字符"><a href="#有效字符" class="headerlink" title="有效字符"></a>有效字符</h2><p>根据规范，btoa 将接受字符串“仅包含 <code>U + 0000</code> 到 <code>U + 00FF</code>范围内的字符”<br>如果传递的字符串的字符大于 <code>U + 00FF</code>，则 <code>btoa</code>将返回 <code>null</code><br>如果传递的<code>atob</code>字符串不是<code>base64</code>合法的，则它还将返回null<br>在这两种情况下，当返回<code>null</code>时，规范都要求抛出<code>InvalidCharacterError</code>类型的<code>DOMException</code>  </p><h2 id="在浏览器中使用"><a href="#在浏览器中使用" class="headerlink" title="在浏览器中使用"></a>在浏览器中使用</h2><p>如果希望在浏览器使用  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> atob = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;abab/lib/atob&#x27;</span>);<br><span class="hljs-keyword">const</span> btoa = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;abab/lib/btoa&#x27;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>jsdom</tag>
      
      <tag>abab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim-文本编辑器-摆脱鼠标提高开发效率</title>
    <link href="/post/f9eaa896/"/>
    <url>/post/f9eaa896/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Vim</code>是从<code>vi</code>发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，是在开放源代码方式下发行的自由软件  </p><p>对于大多数用户来说，<code>Vim</code>有着一个比较陡峭的学习曲线<br>这意味着开始学习的时候可能会进展缓慢，但是一旦掌握一些基本操作之后，能大幅度提高编辑效率  </p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p><code>vim</code>的使用平台有很多，几乎每个<code>Linux</code>系统都会自带一个<code>vim</code>  </p><p>此处以 <code>VSCode</code> + <code>vim</code>插件 进行学习<br><code>VSCode</code>搜索插件<code>vim</code>安装<br>在插件页可以找到其 <code>setting.json</code> 默认配置<br><img src="/Vim-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8-%E6%91%86%E8%84%B1%E9%BC%A0%E6%A0%87%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/20210202114212912.png"><br>将其添加到 <code>setting.json</code> 即可弯沉给配置<br>在完成配置后，编辑 <code>VSCode</code> 内的文档会变成<code>vim</code>编辑的形式<br>可以在状态栏中查看到现在的模式<br><img src="/Vim-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8-%E6%91%86%E8%84%B1%E9%BC%A0%E6%A0%87%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/20210202033715325.png">  </p><h1 id="一、Vim-语法"><a href="#一、Vim-语法" class="headerlink" title="一、Vim 语法"></a>一、Vim 语法</h1><p>这章将是最重要的一章，一旦你理解了Vim命令的语法结构，你将能够和 Vim “说话”<br>注意，在这一章中当我讨论 Vim 语言时，我讨论并不是 Vimscript (Vim自带的插件编写和自定义设置的语言)，这里讨论的是 Vim 中 normal 模式的下的命令的通用规则  </p><h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><p>你只需要知道一个Vim语言的语法规则：  </p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">verb</span> + noun <span class="hljs-comment"># 动词 + 名词</span><br></code></pre></td></tr></table></figure><p>这就类似与在英语中的祈使句：</p><ul><li>Eat(verb) a donut(noun)</li><li>Kick(verb) a ball(noun)</li><li>Learn(verb) the Vim Editor(noun)</li></ul><p>现在你需要的就是用Vim中基本的动词和名字来建立你的词汇表</p><h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><h3 id="名词-动作-Motion"><a href="#名词-动作-Motion" class="headerlink" title="名词(动作 Motion)"></a>名词(动作 Motion)</h3><p>我们这里将动作作为名词，动作用来在Vim中到处移动，他们也是Vim中的名词<br>下面列出了一些常见的动作的例子：</p><table><thead><tr><th>名词/动作</th><th>意义</th></tr></thead><tbody><tr><td>h</td><td>左</td></tr><tr><td>j</td><td>下</td></tr><tr><td>k</td><td>上</td></tr><tr><td>l</td><td>右</td></tr><tr><td>w</td><td>向前移动到下一个单词的开头</td></tr><tr><td>}</td><td>跳转到下一个段落</td></tr><tr><td>$</td><td>跳转到当前行的末尾</td></tr></tbody></table><p>在之后的章节你将学习更多的关于<strong>动作</strong>的内容，所以如果你不理解上面这些动作也不必担心  </p><h3 id="动词-操作符-Operator"><a href="#动词-操作符-Operator" class="headerlink" title="动词(操作符 Operator)"></a>动词(操作符 Operator)</h3><p>根据<code>:h operator</code>，Vim 共有 16个<strong>操作符</strong>，学习常用的这3个操作符在80%的情况下就已经够用了  </p><table><thead><tr><th>操作符</th><th>作用</th></tr></thead><tbody><tr><td>y</td><td>yank(复制)</td></tr><tr><td>d</td><td>delete(删除)</td></tr><tr><td>c</td><td>change 删除文本，将删除的文本存到寄存器中，进入插入模式</td></tr></tbody></table><p>现在你已经知道了基本的动词和名词，我们来用一下我们的语法规则。假设你有下面这段文本：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> learn = <span class="hljs-string">&quot;Vim&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>复制当前位置到行尾的所有内容：<code>y$</code>  </li><li>删除当前位置到下一个单词的开头：<code>dw</code>  </li><li>修改当前位置到这个段落的结尾：<code>c&#125;</code>  </li></ul><p><strong>动作</strong>也接受数字作为参数，如果你需要向上移动3行，你可以用3k代替按3次k  </p><ul><li>向左拷贝2个字符：<code>y2h</code>  </li><li>删除后两个单词：<code>d2w</code>  </li><li>修改后面两行：<code>c2j</code><br>目前，也许需要想很久才能完成一个简单的命令，不过刚开始时都是这样，经历过类似的挣扎的阶段后速度就会快起来   </li></ul><p>作为补充，行级的<strong>操作符</strong>在文本编辑中和其他的<strong>操作符</strong>一样，Vim 允许你通过按两次命令执行行级的操作<br>例如dd，yy，cc来执行删除，复制或修改整个行  </p><p>目前为止还没有结束，Vim 有另一种类型的名词：文本对象(text object)  </p><h3 id="更多名词-文本对象"><a href="#更多名词-文本对象" class="headerlink" title="更多名词(文本对象)"></a>更多名词(文本对象)</h3><p>想象一下你现在正在某个被括号包围的文本中例如 <code>(hello Vim)</code>，你现在想要删掉括号中的所有内容，你会怎样快速的完成它？是否有一种方法能够把括号中内容作为整体删除呢？  </p><p>答案是有的。文本通常是结构化的，特别是代码经常被放置在小括号、中括号、大括号、引号等当中。Vim提供了一种处理这种结构的文本对象的方法  </p><p>文本对象可以被<strong>操作符</strong>使用，这里有两类文本对象：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">i</span> + <span class="hljs-selector-tag">object</span>  内部文本对象<br><span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">object</span>  外部文本对象<br></code></pre></td></tr></table></figure><p><strong>内部文本对象</strong>选中的部分不包含包围文本对象的空白或括号等，<strong>外部文本对象</strong>则包括了包围内容的空白或括号等对象<br>外部对象总是比内部对象选中的内容更多，因此如果你的光标位于一对括号内部  </p><p>例：(<code>hello Vim</code>)    </p><ul><li>删除括号内部的内容但保留括号：<code>di(</code>  </li><li>删除括号以及内部的内容：<code>da(</code>  </li></ul><p>例：假设你有这样一段<code>Javascript</code>的函数，你的光标停留在”Hello”上：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hello = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello Vim&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>删除整个”Hello Vim”：<code>di(</code>  </li><li>删除整个函数(被{}包含)：<code>di&#123;</code>  </li><li>删除”Hello”这个词：<code>diw</code>  </li></ul><p>文本对象很强大因为你可以在一个位置指向不同的对象，能够删除一对括号、函数体或整个单词的文本对象中的内容<br>此外，当你看到 <code>di(</code>，<code>di&#123;</code>和<code>diw</code>时，你也可以很好的意识到他们表示的是什么  </p><p>例：假设你有这样一些<code>html</code>的标签的文本  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Header1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果你的光标位于”Header1”文本上：  </p><ul><li>删除<code>Header1</code>：dit  </li><li>删除<code>&lt;h1&gt;Header1&lt;/h1&gt;</code>：dat  </li></ul><p>如果你的光标在”div”文本上：  </p><ul><li>删除h1和所有p标签的行：dit  </li><li>删除所有文本：dat  </li><li>删除”div”：di&lt;<br>下面列举的一些通常见到的文本对象：  </li></ul><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>w</td><td>一个单词</td></tr><tr><td>p</td><td>一个段落</td></tr><tr><td>s</td><td>一个句子</td></tr><tr><td>(或)</td><td>一对()</td></tr><tr><td>{或}</td><td>一对{}</td></tr><tr><td>[或]</td><td>一对[]</td></tr><tr><td>&lt;或&gt;</td><td>一对&lt;&gt;</td></tr><tr><td>t</td><td>XML标签</td></tr><tr><td>“</td><td>一对””</td></tr><tr><td>‘</td><td>一对’’</td></tr><tr><td>`</td><td>一对``</td></tr><tr><td>你可以通过<code>:h text-objects</code>了解更多</td><td></td></tr></tbody></table><h2 id="结合性和语法"><a href="#结合性和语法" class="headerlink" title="结合性和语法"></a>结合性和语法</h2><p>在学习 Vim 的语法之后，让我们来讨论一下 Vim 中的结合性以及为什么在文本编辑器中这是一个强大的功能  </p><p>结合性意味着你有很多可以组合起来完成更复杂命令的普通命令，就像你在编程中可以通过一些简单的抽象建立更复杂的抽象，在 Vim 中你可以通过简单的命令的组合执行更复杂的命令<br>Vim 语法正是 Vim 中命令的可结合性的体现  </p><p>Vim 的结合性最强大之处体现在它和外部程序结合时，Vim 有一个<strong>过滤操作符</strong><code>!</code>可以用外部程序过滤我们的文本  </p><p>例：你有下面这段混乱的文本，用tab格式化的更好看的一些  </p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coq">Id|<span class="hljs-type">Name</span>|<span class="hljs-type">Cuteness</span><br><span class="hljs-number">01</span>|<span class="hljs-type">Puppy</span>|<span class="hljs-type">Very</span><br><span class="hljs-number">02</span>|<span class="hljs-type">Kitten</span>|<span class="hljs-type">Ok</span><br><span class="hljs-number">03</span>|<span class="hljs-type">Bunny</span>|<span class="hljs-type">Ok</span><br></code></pre></td></tr></table></figure><p>这件事情通过 Vim命令不太容易完成，但是你可以通过终端提供的命令 column 很快的完成它<br>当你的光标位于<code>Id</code>上时，运行<code>!&#125;column -t -s &quot;|&quot;</code>，你的文本就变得整齐了许多  </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust">Id  Name    Cuteness<br><span class="hljs-number">01</span>  Puppy   Very<br><span class="hljs-number">02</span>  Kitten  <span class="hljs-literal">Ok</span><br><span class="hljs-number">03</span>  Bunny   <span class="hljs-literal">Ok</span><br></code></pre></td></tr></table></figure><p>让我们分解一下上面那条命令，动词是!(过滤操作符)，名词是}(到下一个段落)。过滤操作符<code>!</code>接受终端命令作为另一个参数，因此我把<code>column -t -s &quot;|&quot;</code>传给它。我不想详细描述<code>column</code>是如何工作的，但是总之它格式化了文本  </p><p>假设你不止想格式化你的文本，还想只展示Ok结尾的行，你知道awk命令可以做这件事情，那么你可以这样做  </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dart">!&#125;column -t -s <span class="hljs-string">&quot;|&quot;</span> | awk <span class="hljs-string">&#x27;NR &gt; 1 &amp;&amp; /Ok/&#123;print <span class="hljs-subst">$0</span>&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>结果如下：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">02 </span> Kitten  Ok<br><span class="hljs-symbol">03 </span> Bunny   Ok<br></code></pre></td></tr></table></figure><p>这就是 Vim的结合性的强大之处。你知道的<strong>操作符</strong>，<strong>动作</strong>，终端命令越多，你组建复杂操作的能力成倍增长  </p><p>假设你只知道:  </p><ul><li>四个动作：<code>w</code>, <code>$</code>, <code>&#125;</code>,<code>G</code>  </li><li>删除操作符(<code>d</code>)  </li></ul><p>你可以做8件事：按四种方式移动(<code>w</code>, <code>$</code>, <code>&#125;</code>, <code>G</code>)和删除4种文本对象(<code>dw</code>, <code>d$</code>, <code>d&#125;</code>, <code>dG</code>)  </p><p>如果有一天你学习了小写变大写的<strong>操作符</strong>(<code>gU</code>)，你的 Vim 工具箱中多的不是1种工具，而是4种：<code>gUw</code>, <code>gU$</code>, <code>gU&#125;</code>, <code>gUG</code>。现在你的 Vim工具箱中就有12种工具了  </p><p>使用 Vim这种能够组合的工具，所有你知道的东西都可以被串起来完成更复杂的操作。你知道的越多，你就越强大  </p><p>这种具有结合性的行为也正符合Unix的哲学：一个命令做好一件事<br><strong>动作</strong>只需要做一件事：前往X<br><strong>操作符</strong>只需要做一件事：完成Y<br>通过结合一个操作符和一个动作，你就获得了YX：在X上完成Y  </p><p>甚至，<strong>动作</strong>和<strong>操作符</strong>都是可拓展的，你可以自己创造动作和操作符去丰富你的 Vim工具箱，<code>Vim-textobj-user</code>有一系列自定义的文本对象  </p><p>另外，如果你不知道刚才使用的<code>column</code>和<code>awk</code>命令也没有关系，重要的是 Vim可以和终端命令很好的结合起来  </p><h1 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h1><p>学习光标移动以及如何高效的使用<br>记住，这一章所讲的并不是 Vim 的全部移动命令，目标是介绍有用的移动来快速提高效率<br>如果你需要学习更多的移动命令，查看<code>:h motion.txt</code>  </p><h2 id="上下左右步进移动"><a href="#上下左右步进移动" class="headerlink" title="上下左右步进移动"></a>上下左右步进移动</h2><p>最基本的移动单元是上下左右移动一个字符  </p><table><thead><tr><th>方向</th><th>左</th><th>下</th><th>右</th><th>上</th></tr></thead><tbody><tr><td>键位</td><td>h</td><td>j</td><td>k</td><td>l</td></tr></tbody></table><blockquote><p>为什么Vim使用hjkl进行移动?<br>实际上是历史原因。因为 <code>Bill Joy</code>写 <code>VI</code>(VIM前身)用的 <code>Lear-Siegler ADM-3A</code>终端没有方向键，而是把<code>hjkl</code>当做方向键  </p></blockquote><p>常用情景：  </p><ul><li>从一个单词的一个部分移动到另一个部分，使用<code>h</code>或<code>l</code>  </li><li>在可见的范围内上下移动几行，我会使用j和k  </li></ul><p>对于其它的场景，实际上会有更好的方法  </p><h2 id="对步进移动-计数"><a href="#对步进移动-计数" class="headerlink" title="对步进移动 计数"></a>对步进移动 计数</h2><p>实际上，可以指定步进数量来达到指定目的<br>语法：  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[计数] [步进移动]<br></code></pre></td></tr></table></figure><p>如果你想向右移动9个字符，你可以使用9l来代替按9次<code>l</code><br>当你学到了更多的动作时，你都可以试试给定计数参数  </p><h2 id="单词导航"><a href="#单词导航" class="headerlink" title="单词导航"></a>单词导航</h2><table><thead><tr><th>导航</th><th>作用</th></tr></thead><tbody><tr><td>w</td><td>移动到下一个单词的开头</td></tr><tr><td>W</td><td>移动到下一个词组的开头</td></tr><tr><td>e</td><td>移动到下一个单词的结尾</td></tr><tr><td>E</td><td>移动到下一个词组的结尾</td></tr><tr><td>b</td><td>移动到前一个单词的开头</td></tr><tr><td>B</td><td>移动到前一个词组的开头</td></tr><tr><td>ge</td><td>移动到前一个单词的结尾</td></tr><tr><td>gE</td><td>移动到前一个词组的结尾</td></tr></tbody></table><p>词组和单词到底有什么相同和不同呢？<br>单词和词组都按照非空字符被分割，一个单词指的是一个只包含<code>a-z</code>、<code>A-Z</code>、<code>0-9</code>字符串，一个词组指的是一个包含除了空字符(包括空格，tab，EOL)以外的字符的字符串  </p><p>可以通过<code>:h word</code>和<code>:h WORD</code>了解更多  </p><p>例如，假如你有下面这段内容：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hello = <span class="hljs-string">&quot;world&quot;</span>;<br></code></pre></td></tr></table></figure><p>当你光标位于这行的开头时，你可以通过l走到行尾，但是你需要按21下，使用w，你需要6下，使用W只需要4下。 单词和词组都是短距离移动的很好的选择  </p><h2 id="当前行导航"><a href="#当前行导航" class="headerlink" title="当前行导航"></a>当前行导航</h2><table><thead><tr><th>导航</th><th>信息</th></tr></thead><tbody><tr><td><code>0</code></td><td>跳到本行第一个字符</td></tr><tr><td><code>^</code></td><td>跳到本行第一个非空字符</td></tr><tr><td><code>g_</code></td><td>跳到本行最后一个非空字符</td></tr><tr><td><code>$</code></td><td>跳到本行最后一个字符</td></tr><tr><td>`n</td><td>`</td></tr><tr><td><code>f&#123;chars&#125;</code></td><td>在同一行向后搜索第一个<code>&#123;chars&#125;</code>匹配</td></tr><tr><td><code>F&#123;chars&#125;</code></td><td>在同一行向前搜索第一个<code>&#123;chars&#125;</code>匹配</td></tr><tr><td><code>t&#123;chars&#125;</code></td><td>在同一行向后搜索第一个<code>&#123;chars&#125;</code>匹配，并停在匹配前</td></tr><tr><td><code>T&#123;chars&#125;</code></td><td>在同一行向前搜索第一个<code>&#123;chars&#125;</code>匹配，并停在匹配前</td></tr><tr><td><code>;</code></td><td>在同一行重复最近一次搜索</td></tr><tr><td><code>,</code></td><td>在同一行向相反方向重复最近一次搜索</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hello = <span class="hljs-string">&quot;world&quot;</span>;<br></code></pre></td></tr></table></figure><p>当你的光标位于行的开头时，你可以通过按一次键<code>$</code>去往行尾的最后一个字符<code>;</code>。 如果想去往<code>world</code>中的<code>w</code>，你可以使用<code>fw</code><br>一个建议是，在行内目标附近通过寻找重复出现最少的字母例如<code>j</code>，<code>x</code>，<code>z</code>来前往行中的该位置更快  </p><h2 id="句子和段落导航"><a href="#句子和段落导航" class="headerlink" title="句子和段落导航"></a>句子和段落导航</h2><p>首先我们来聊聊句子。 一个句子的定义是以.!?和跟着的一个换行符或空格，tab结尾的<br>你可以通过)和(跳到下一个和上一个句子  </p><table><thead><tr><th>导航</th><th>信息</th></tr></thead><tbody><tr><td>(</td><td>跳到前一个句子</td></tr><tr><td>)</td><td>跳到下一个句子</td></tr></tbody></table><p>让我们来看一些例子，你觉得哪些字段是句子哪些不是? 可以尝试在 Vim 中用<code>(</code>和<code>)</code>感受一下  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs applescript">I am a sentence. I am another sentence because I <span class="hljs-keyword">end</span> <span class="hljs-keyword">with</span> a period. I am still a sentence when ending <span class="hljs-keyword">with</span> an exclamation point! What <span class="hljs-keyword">about</span> question mark? I am <span class="hljs-keyword">not</span> quite a sentence because <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> hyphen - <span class="hljs-keyword">and</span> neither semicolon ; nor colon :<br><br>There <span class="hljs-keyword">is</span> an empty line <span class="hljs-keyword">above</span> <span class="hljs-keyword">me</span>.<br></code></pre></td></tr></table></figure><p>另外，如果你的 Vim 中遇到了无法将一个以<code>.</code>结尾的字段并且后面跟着一个空行的这种情况判断为一个句子的问题，你可能处于 compatible的模式。运行<code>:set nocompatible</code> 可以修复  </p><p>在<code>Vi</code>中，一个句子是以两个空格结尾的，你应该总是保持的<code>nocompatible</code>的设置  </p><p>一个段落可以从一个空行之后开始，也可以从段落选项中字符对所指定的段落宏的每个集合开始  </p><table><thead><tr><th>导航</th><th>信息</th></tr></thead><tbody><tr><td>{</td><td>跳转到上一个段落</td></tr><tr><td>}</td><td>跳转到下一个段落</td></tr></tbody></table><p>如果你不知道什么是段落宏，不用担心，重要的是一个段落总是以一个空行开始和结尾， 在大多数时候总是对的  </p><p>例: 你可以尝试着使用<code>&#125;</code>和<code>&#123;</code>进行导航，也可以试一试<code>(``)</code>这样的句子导航  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript">Hello. How are you? I am great, thanks!<br>Vim <span class="hljs-keyword">is</span> awesome.<br>It may <span class="hljs-keyword">not</span> easy <span class="hljs-keyword">to</span> learn <span class="hljs-keyword">it</span> <span class="hljs-keyword">at</span> <span class="hljs-keyword">first</span>...- <span class="hljs-keyword">but</span> we are <span class="hljs-keyword">in</span> this together. Good luck!<br><br>Hello again.<br><br>Try <span class="hljs-keyword">to</span> move <span class="hljs-keyword">around</span> <span class="hljs-keyword">with</span> ), (, &#125;, <span class="hljs-keyword">and</span> &#123;. Feel how they work.<br>You got this.<br></code></pre></td></tr></table></figure><p>你可以通过<code>:h setence</code>和<code>:h paragraph</code>了解更多  </p><h2 id="匹配导航"><a href="#匹配导航" class="headerlink" title="匹配导航"></a>匹配导航</h2><p>程序员经常编辑含有代码的文件，这种文件内容会包含大量的小括号，中括号和大括号，并且可能会把你搞迷糊你当前到底在哪对括号里<br>许多编程语言都用到了小括号，中括号和大括号，你可能会迷失于其中。 如果你在它们中的某一对括号中，你可以通过%跳到q其中一个括号或另一个上(如果存在)。 你也可以通过这种方法弄清你是否各个括号都成对匹配了  </p><table><thead><tr><th>导航</th><th>信息</th></tr></thead><tbody><tr><td>%</td><td>导航到匹配的 <code>()</code>, <code>[]</code>, <code>&#123;&#125;</code></td></tr></tbody></table><p>可以使用类似 <code>vim-rainbow</code> 这样的可视化指示插件来作为<code>%</code>的补充。 通过<code>:h %</code>了解更多  </p><h2 id="行号导航"><a href="#行号导航" class="headerlink" title="行号导航"></a>行号导航</h2><p>有时你不知道你想去的位置的具体行号，但是知道它大概在整个文件的 70% 左右的位置，你可以使用70%跳过去，可以使用50%跳到文件的中间  </p><table><thead><tr><th>导航</th><th>信息</th></tr></thead><tbody><tr><td>gg</td><td>跳转到第一行</td></tr><tr><td>G</td><td>跳转到最后一行</td></tr><tr><td>nG</td><td>跳转到第n行</td></tr><tr><td>n%</td><td>跳到文件的n%</td></tr><tr><td>另外，如果你想看文件总行数，可以用<code>CTRL-g</code>查看</td><td></td></tr></tbody></table><h2 id="窗格导航"><a href="#窗格导航" class="headerlink" title="窗格导航"></a>窗格导航</h2><p>为了移动到当前窗格的顶部，中间，底部，你可以使用<code>H</code>，<code>M</code>和<code>L</code>  </p><p>你也可以给<code>H</code>和<code>L</code>传一个数字前缀<br>如果你输入<code>10H</code>你会跳转到窗格顶部往下数 10行的位置，如果你输入<code>3L</code>，你会跳转到距离当前窗格的底部一行向上数3行的位置  </p><table><thead><tr><th>导航</th><th>信息</th></tr></thead><tbody><tr><td>H</td><td>跳转到屏幕的顶部</td></tr><tr><td>M</td><td>跳转到屏幕的中间</td></tr><tr><td>L</td><td>跳转到屏幕的底部</td></tr><tr><td>nH</td><td>跳转到距离顶部n行的位置</td></tr><tr><td>nL</td><td>跳转到距离底部n行的位置</td></tr></tbody></table><h2 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h2><table><thead><tr><th>导航</th><th>信息</th></tr></thead><tbody><tr><td>Ctrl-e</td><td>向下滚动一行</td></tr><tr><td>Ctrl-d</td><td>向下滚动半屏</td></tr><tr><td>Ctrl-f</td><td>向下滚动一屏</td></tr><tr><td>Ctrl-y</td><td>向上滚动一行</td></tr><tr><td>Ctrl-u</td><td>向上滚动半屏</td></tr><tr><td>Ctrl-b</td><td>向上滚动一屏</td></tr></tbody></table><p>你也可以相对当前行进行滚动</p><table><thead><tr><th>导航</th><th>信息</th></tr></thead><tbody><tr><td>zt</td><td>将当前行置于屏幕顶部附近</td></tr><tr><td>zz</td><td>将当前行置于屏幕中央</td></tr><tr><td>zt</td><td>将当前行置于屏幕底部</td></tr></tbody></table><h2 id="搜索导航"><a href="#搜索导航" class="headerlink" title="搜索导航"></a>搜索导航</h2><p>通常，你已经知道这个文件中有一个字段，你可以通过搜索导航非常快速的定位你的目标  </p><table><thead><tr><th>导航</th><th>信息</th></tr></thead><tbody><tr><td>/</td><td>向后搜索一个匹配</td></tr><tr><td>?</td><td>向前搜素一个匹配</td></tr><tr><td>n</td><td>重复上一次搜索(和上一次方向相同)</td></tr><tr><td>N</td><td>重复上一次搜索(和上一次方向相反)</td></tr></tbody></table><p>假设你有一下文本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> one = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> two = <span class="hljs-number">2</span>;<br>one = <span class="hljs-string">&quot;01&quot;</span>;<br>one = <span class="hljs-string">&quot;one&quot;</span>;<br><span class="hljs-keyword">let</span> onetwo = <span class="hljs-number">12</span>;<br></code></pre></td></tr></table></figure><p>可以通过<code>/let</code>搜索<code>let</code>，然后通过n快速的重复搜索下一个<code>let</code>，如果需要向相反方向搜索，可以使用<code>N</code><br>如果你用<code>?let</code>搜索，会得到一个向前的搜索，这时你使用<code>n</code>，它会继续向前搜索，就和<code>?</code>的方向一致。(<code>N</code>将会向后搜索<code>let</code>)  </p><p>你可以通过<code>:set hlsearch</code>设置搜索高亮。 这样，当你搜索<code>/let</code>，它将高亮文件中所有匹配的字段<br>另外，如果你通过<code>:set incsearch</code>设置了增量搜索，它将在你输入时不断匹配的输入的内容<br>默认情况下，匹配的字段会一直高亮到你搜索另一个字段，这有时候很烦人，如果你希望取消高亮，可以使用<code>:nohlsearch</code>  </p><p>如果经常使用这个功能，可以设置一个映射：  </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">nnoremap &lt;esc&gt;&lt;esc&gt; <span class="hljs-symbol">:noh&lt;return&gt;&lt;esc&gt;</span><br></code></pre></td></tr></table></figure><p>你可以通过<code>*</code>快速的向下搜索光标下的文本，通过<code>#</code>快速向前搜索光标下的文本<br>如果你的光标位于一个字符串<code>one</code>上，按下<code>*</code>相当于<code>/\&lt;one\&gt;</code>。 <code>/\&lt;one\&gt;</code>中的<code>\&lt;</code>和<code>\&gt;</code>表示整词匹配，使得一个更长的包含<code>one</code>的单词不会被匹配上，也就是说它会匹配<code>one</code>，但不会匹配<code>onetwo</code><br>如果你的光标在<code>one</code>上并且你想向后搜索完全或部分匹配的单词，例如<code>one</code>和<code>onetwo</code>，你可以用<code>g*</code>替代<code>*</code>  </p><table><thead><tr><th>导航</th><th>信息</th></tr></thead><tbody><tr><td>*</td><td>向后查找光标所在的完整单词</td></tr><tr><td>#</td><td>向前查找光标所在的完整单词</td></tr><tr><td>g*</td><td>向后搜索光标所在的单词</td></tr><tr><td>g#</td><td>向前搜索光标所在的单词</td></tr></tbody></table><h2 id="位置标记"><a href="#位置标记" class="headerlink" title="位置标记"></a>位置标记</h2><p>可以通过标记保存当前位置并在之后回到这个位置，就像文本编辑中的书签  </p><table><thead><tr><th>导航</th><th>信息</th></tr></thead><tbody><tr><td>ma</td><td>用a标签标记一个位置</td></tr><tr><td>`a</td><td>精确回到a标签的位置(行和列)</td></tr><tr><td>‘a</td><td>跳转到a标签的行</td></tr></tbody></table><p><code>a-z</code>的标签和<code>A-Z</code>的标签存在一个区别，小写字母是局部标签，大写字母是全局标签(也称文件标记)  </p><p>我们首先说说局部标记。 每个<code>buffer</code>可以有自己的一套局部标记，如果打开了两个文件，我可以在第一个文件中设置标记<code>a</code>(ma)，然后在另一个文件中设置另一个标记<code>a</code>(ma)  </p><p>不像你可以在每个buffer中设置一套局部标签，你只能设置一套全局标签。 如果你在 myFile.txt 中设置了标签<code>mA</code>，下一次你在另一个文件中设置<code>mA</code>时，<code>A</code>标签的位置会被覆盖。 全局标签有一个好处就是，即使你在不同的项目红，你也可以跳转到任何一个全局标签上，全局标签可以帮助你在文件间切换  </p><p>使用<code>:marks</code>查看所有标签，你也许会注意到除了<code>a-z</code>,<code>A-Z</code>以外还有别的标签，其中有一些例如：</p><table><thead><tr><th>导航</th><th>信息</th></tr></thead><tbody><tr><td>“</td><td>在当前buffer中跳转回到上一次跳转前的最后一行</td></tr><tr><td>``</td><td>在当前buffer中跳转回到上一次跳转前的最后一个位置</td></tr><tr><td>`[</td><td>跳转到上一次修改或拷贝的文本的开头</td></tr><tr><td>`]</td><td>跳转到上一次修改或拷贝的文本的结尾</td></tr><tr><td>`&lt;</td><td>跳转到最近一次可视模式下选择的部分的开头</td></tr><tr><td>`&gt;</td><td>跳转到最近一次可视模式下选择的部分的结尾</td></tr><tr><td>`0</td><td>跳转到退出Vim前编辑的最后一个文件</td></tr></tbody></table><p>除了上面列举的，还有更多标记，我不会在这一一列举因为我觉得它们很少用到，不过如果你很好奇，你可以通过<code>: marks</code>查看  </p><h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>最后，我们聊聊Vim中的跳转你通过任意的移动可以在不同文件中或者同一个的文件的不同部分间跳转。 然而并不是所有的移动都被认为是一个跳转。 使用j向下移动一行就不被看做一个跳转，即使你使用10j向下移动10行，也不是一个跳转。 但是你通过10G去往第10行被算作一个跳转。</p><table><thead><tr><th>导航</th><th>信息</th></tr></thead><tbody><tr><td>‘</td><td>跳转到标记的行</td></tr><tr><td>`</td><td>跳转到标记的位置(行和列)</td></tr><tr><td>G</td><td>跳转到行</td></tr><tr><td>/</td><td>向后搜索</td></tr><tr><td>?</td><td>向前搜索</td></tr><tr><td>n</td><td>重复上一次搜索，相同方向</td></tr><tr><td>N</td><td>重复上一次搜索，相反方向</td></tr><tr><td>%</td><td>查找匹配</td></tr><tr><td>(</td><td>跳转上一个句子</td></tr><tr><td>)</td><td>跳转下一个句子</td></tr><tr><td>{</td><td>跳转上一个段落</td></tr><tr><td>}</td><td>跳转下一个段落</td></tr><tr><td>L</td><td>跳转到当前屏幕的最后一行</td></tr><tr><td>M</td><td>跳转到当前屏幕的中间</td></tr><tr><td>H</td><td>跳转到当前屏幕的第一行</td></tr><tr><td>[[</td><td>跳转到上一个小节</td></tr><tr><td>]]</td><td>跳转到下一个小节</td></tr><tr><td>:s</td><td>替换</td></tr><tr><td>:tag</td><td>跳转到tag定义</td></tr></tbody></table><p>不建议把上面这个列表记下来，一个大致的规则是，任何大于一个单词或超过当前行导航的移动都可能是一个跳转。 Vim 保留了你移动前位置的记录，你可以通过<code>:jumps</code>查看这个列表，如果想了解更多，可以查看<code>:h jump-motions</code>  </p><p>为什么跳转有呢? 因为你可以在跳转列表中通过 Ctrl-o 和 Ctrl-i 在记录之间向上或向下跳转到对应位置<br>实际上是可以在不同文件中进行跳转的  </p><h1 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h1><p>输入模式是大部分文本编辑器的默认模式，在这个模式下，所敲即所得  </p><h2 id="进入输入模式"><a href="#进入输入模式" class="headerlink" title="进入输入模式"></a>进入输入模式</h2><p>我们有很多方式从普通模式进入输入模式，下面列举出了其中的一些方法  </p><table><thead><tr><th>命令</th><th>信息</th></tr></thead><tbody><tr><td>i</td><td>从光标之前的位置开始输入文本</td></tr><tr><td>I</td><td>从当前行第一个非空字符之前的位置之前开始输入文本</td></tr><tr><td>a</td><td>在光标之后的位置追加文本</td></tr><tr><td>A</td><td>在当前行的末尾追加文本</td></tr><tr><td>o</td><td>在光标位置下方新起一行并开始输入文本</td></tr><tr><td>O</td><td>在光标位置的上方新起一行并开始输入文本</td></tr><tr><td>s</td><td>删除当前光标位置的字符并开始输入文本</td></tr><tr><td>S</td><td>删除当前行并开始输入文本</td></tr><tr><td>gi</td><td>从当前缓冲区上次结束输入模式的地方开始输入文本</td></tr><tr><td>gI</td><td>在当前行的第一列的位置开始输入文本</td></tr></tbody></table><p>值得注意的是这些命令的小写/大写模式，每一个小写命令都有一个与之对应的大写命令<br>如果你是初学者，不用担心记不住以上整个命令列表，可以从 <code>i</code> 和 <code>a</code>两条命令开始，这两条命令足够在入门阶段使用了，之后再逐渐地掌握更多其他的命令  </p><h2 id="退出输入模式的方法"><a href="#退出输入模式的方法" class="headerlink" title="退出输入模式的方法"></a>退出输入模式的方法</h2><p>下面列出了一些从输入模式退出到普通模式的方法：</p><table><thead><tr><th>命令</th><th>信息</th></tr></thead><tbody><tr><td><esc></td><td>退出输入模式进入普通模式</td></tr><tr><td>Ctrl-[</td><td>退出输入模式进入普通模式</td></tr><tr><td>Ctrl-c</td><td>与 Ctrl-[ 和 <esc>功能相同, 但是不检查缩写</td></tr></tbody></table><p>Vim用户中常见的习惯是用以下的配置方法在输入模式中把<code>esc</code>映射到<code>jj</code>或者<code>jk</code>  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">inoremap</span> jj <span class="hljs-symbol">&lt;esc&gt;</span><br><span class="hljs-keyword">inoremap</span> jk <span class="hljs-symbol">&lt;esc&gt;</span><br></code></pre></td></tr></table></figure><h2 id="重复输入模式"><a href="#重复输入模式" class="headerlink" title="重复输入模式"></a>重复输入模式</h2><p>你可以在进入输入模式之前传递一个计数参数. 比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">10i</span><br></code></pre></td></tr></table></figure><p>如果你输入 <code>hello world!</code> 然后退出输入模式， Vim 将重复这段文本10次。这个方法对任意一种进入输入模式的方式都有效（如：<code>10I</code>, <code>11a</code>, <code>12o</code>）</p><h2 id="在输入模式中删除大块文本"><a href="#在输入模式中删除大块文本" class="headerlink" title="在输入模式中删除大块文本"></a>在输入模式中删除大块文本</h2><p>当你输入过程中出现一些输入错误时，一直重复地用<code>backspace</code>来删除的话会非常地繁琐<br>更为合理的做法是切换到普通模式并使用d来删除错误<br>或者，你能用以下命令在输入模式下就删除一个或者多个字符：  </p><table><thead><tr><th>快捷键</th><th>信息</th></tr></thead><tbody><tr><td>Ctrl-h</td><td>删除一个字符</td></tr><tr><td>Ctrl-w</td><td>删除一个单词</td></tr><tr><td>Ctrl-u</td><td>删除一整行</td></tr></tbody></table><p>此外，这些快捷键也支持在 命令行模式 和 Ex模式 中使用  </p><h2 id="用寄存器进行输入"><a href="#用寄存器进行输入" class="headerlink" title="用寄存器进行输入"></a>用寄存器进行输入</h2><p>寄存器就像是内存里的暂存器一样，可供存储和取出文本<br>在输入模式下，可以使用快捷键 Ctrl-r 加上寄存器的标识来从任何有标识的寄存器输入文本<br>有很多标识可供使用，但是在这一章节中你只需要知道以（a-z)命名的寄存器是可以使用的就足够了  </p><p>让我们在一个具体的例子中展示寄存器的用法，首先你需要复制一个单词到寄存器a中，这一步可以用以下这条命令来完成：  </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;ayiw</span><br></code></pre></td></tr></table></figure><ul><li><code>&quot;a</code> 告诉Vim你下一个动作的目标地址是寄存器a  </li><li><code>yiw</code> 复制一个内词（inner word），可以回顾Vim语法章节查看具体语法<br>现在 寄存器a 存放着你刚复制的单词。在输入模式中，使用以下的快捷键来粘贴存放在寄存器a中文本  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">Ctrl-r a</span><br></code></pre></td></tr></table></figure>Vim 中存在很多种类型的寄存器，后面的章节会介绍更多他们的细节  </li></ul><h2 id="页面滚动"><a href="#页面滚动" class="headerlink" title="页面滚动"></a>页面滚动</h2><p>在输入模式下，如果你使用快捷键 Ctrl-x 进入 <strong>Ctrl-x子模式</strong>，你可以进行一些额外操作，页面滚动正是其中之一  </p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gml">Ctrl-<span class="hljs-symbol">x</span> Ctrl-<span class="hljs-symbol">y</span>    向上滚动页面<br>Ctrl-<span class="hljs-symbol">x</span> Ctrl-e    向下滚动页面<br></code></pre></td></tr></table></figure><h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>Vim 在进入 Ctrl-x子模式 后，有一个自带的自动补全功能。<br>尽管它不如 intellisense 或 者其他的语言服务器协议（LSP）一样好用，但是也算是一个锦上添花的内置功能了  </p><p>下面列出了一些适合入门时学习的自动补全命令：</p><table><thead><tr><th>命令</th><th>信息</th></tr></thead><tbody><tr><td>Ctrl-x Ctrl-l</td><td>补全一整行</td></tr><tr><td>Ctrl-x Ctrl-n</td><td>从当前文件中补全文本</td></tr><tr><td>Ctrl-x Ctrl-i</td><td>从引用（include）的文件中补全文本</td></tr><tr><td>Ctrl-x Ctrl-f</td><td>补全一个文件名</td></tr></tbody></table><p>当你出发自动补全时，Vim 会显示一个选项弹窗，可以使用  Ctrl-n 和 Ctrl-p 来分别向上和向下浏览选项  </p><p>Vim也提供了两条不需要进入Ctrl-x模式就能使用的命令：  </p><table><thead><tr><th>快捷键</th><th>信息</th></tr></thead><tbody><tr><td>Ctrl-n</td><td>使用下一个匹配的单词进行补全</td></tr><tr><td>Ctrl-p</td><td>使用上一个匹配的单词进行补全</td></tr></tbody></table><p>通常 Vim会关注所有缓冲区（buffer）中的文本作为自动补全的文本来源<br>如果你打开了一个缓冲区，其中一行是<code>Chocolate donuts are the best</code></p><ul><li>当你输入”Choco”然后使用快捷键Ctrl-x Ctrl-l， Vim会进行匹配并输出这一整行的文本  </li><li>当你输入”Choco”然后使用快捷键Ctrl-p，Vim会进行匹配并输出”Chocolate”这个单词  </li></ul><p>Vim 的自动补全是一个相当大的话题，以上只是冰山一角，想要进一步学习的话可以使用<code>:h ins-completion</code>命令进行查看  </p><h2 id="执行普通模式下的命令"><a href="#执行普通模式下的命令" class="headerlink" title="执行普通模式下的命令"></a>执行普通模式下的命令</h2><p>在输入模式下， 如果你按下 Ctrl-o，你就会进入到 <strong>insert-normal</strong>（输入-普通）子模式<br>如果你关注一下左下角的模式指示器，通常你将看到<code>-- INSERT --</code> ，但是按下 Ctrl-o 后就会变为<code>-- (insert) --</code><br>在这一模式下，你可以执行一条普通模式的命令，比如你可以做以下这些事  </p><p><strong>设置居中以及跳转</strong>  </p><table><thead><tr><th>命令</th><th>信息</th></tr></thead><tbody><tr><td>Ctrl-o zz</td><td>居中窗口</td></tr><tr><td>Ctrl-o H/M/L</td><td>跳转到窗口的顶部/中部/底部</td></tr><tr><td>Ctrl-o ‘a</td><td>跳转到标志’a处</td></tr></tbody></table><p><strong>重复文本</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Ctrl</span>-o <span class="hljs-number">100</span>ihello    输入 <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-number">100</span> 次<br></code></pre></td></tr></table></figure><p><strong>执行终端命令</strong>  </p><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">Ctrl-o !! curl https://google.com    运行curl命令<br>Ctrl-o !! pwd                        运行pwd命令<br></code></pre></td></tr></table></figure><p><strong>快速删除</strong></p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">Ctrl</span><span class="hljs-operator">-</span><span class="hljs-variable">o</span> <span class="hljs-variable">dtz</span>    从当前位置开始删除文本，直到遇到字母<span class="hljs-string">&quot;z&quot;</span><br><span class="hljs-variable">Ctrl</span><span class="hljs-operator">-</span><span class="hljs-variable">o</span> <span class="hljs-built_in">D</span>      从当前位置开始删除文本，直到行末<br></code></pre></td></tr></table></figure><blockquote><p>寄语：<br>如果你和我一样是从其他文本编辑器转到Vim的，你或许也会觉得一直待在输入模式下很有诱惑力，但是我强烈反对你在没有输入文本时，却仍然待在输入模式下。应该养成当你的双手没有在输入时，就退出到普通模式的好习惯。<br>当你需要进行输入时，先问问自己将要输入的文本是否已经存在。如果存在的话，试着复制或者移动这段文本而不是手动输入它。再问问自己是不是非得进入输入模式，试试能不能尽可能地使用自动补全来进行输入。尽量避免重复输入同一个单词  </p></blockquote><h1 id="点命令"><a href="#点命令" class="headerlink" title="点命令"></a>点命令</h1><p>在编辑文本时，我们应该尽可能地避免重复的动作<br>本章学习如何使用点命令来重放上一个修改操作。点命令是最简单的命令，然而又是减少重复操作最为有用的命令  </p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>正如这个命令的名字一样，你可以通过按下<code>.</code>键来使用点命令  </p><p>比如，如果你想将下面文本中的所有<code>let</code>替换为<code>const</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> one = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-keyword">let</span> two = <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-keyword">let</span> three = <span class="hljs-string">&quot;3&quot;</span>;<br></code></pre></td></tr></table></figure><ol><li>使用<code>/let</code>来进行匹配  </li><li>使用<code>cwconst&lt;esc&gt;</code>来将<code>let</code>替换成<code>const</code>  </li><li>使用n来找到下一个匹配的位置。</li><li>最后，使用点命令(.)来重复之前的操作。持续地使用<code>n .</code> <code>n .</code>直到每一个匹配的词都被替换  </li></ol><p>在这个例子里面，点命令重复的是<code>cwconst&lt;esc&gt;</code>这一串命令，它能够帮你将需要8次输入的命令简化到只需要敲击一次键盘  </p><h2 id="什么才算是修改操作？"><a href="#什么才算是修改操作？" class="headerlink" title="什么才算是修改操作？"></a>什么才算是修改操作？</h2><p>如果你查看点命令的定义的话(<code>:h .</code>),文档中说点命令会重复上一个修改操作，那么什么才算是一个修改操作呢？  </p><p>当你使用普通模式下的命令来更新（添加，修改或者删除）当前缓冲区中的内容时，你就是在执行一个修改操作了<br>其中的例外是使用命令行命令进行的修改（以<code>：</code>开头的命令），这些命令不算作修改操作  </p><p>在第一个例子中，你看到的<code>cwconst&lt;esc&gt;</code>就是一个修改操作<br>现在假设你有以下这么一个句子：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">pancake,</span> potatoes, fruit-juice,<br></code></pre></td></tr></table></figure><p>我们来删除从这行开始的位置到第一个逗号出现的位置。你可以使用<code>df</code>,来完成这个操作,使用<code>.</code>来重复两次直到你将整个句子删除  </p><p>让我们再来试试另一个例子：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">pancake,</span> potatoes, fruit-juice,<br></code></pre></td></tr></table></figure><p>这一次你只需要删除所有的逗号，不包括逗号前面的词。我们可以使用<code>f</code>,来找到第一个逗号，再使用<code>x</code>来删除光标下的字符。然后使用用.来重复两次，很简单对不对？等等！这样做行不通(只会重复删除光标下的一个字符，而不是删除逗号)！为什么会这样呢？  </p><p>在Vim里，修改操作是不包括移动操作（motions）的，因为动作不会更新缓冲区的内容。当你运行<code>f,x</code>，你实际上是在执行两个独立的操作：<code>f,</code>命令只移动光标，而<code>x</code>更新缓冲区的内容，只有后者算作修改动作。和之前例子中的<code>df</code>,进行一下对比的话，你会发现<code>df</code>,中的<code>f</code>,告诉删除操作d哪里需要删除，是整个删除命令<code>df</code>,的一部分  </p><p>让我们想想办法完成这个任务。在你运行<code>f</code>,并执行<code>x</code>来删除第一个逗号后，使用<code>;</code>来继续匹配<code>f</code>的下一个目标（下一个逗号）。之后再使用<code>.</code>来重复修改操作，删除光标下的字符。重复<code>; .</code> <code>; .</code>直到所有的逗号都被删除。完整的命令即为<code>f,x;.;.。</code>  </p><p>再来试试下一个例子：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">pancake</span><br><span class="hljs-attribute">potatoes</span><br><span class="hljs-attribute">fruit-juice</span><br></code></pre></td></tr></table></figure><p>我们的目标是给每一行的结尾加上逗号。从第一行开始，我们执行命令<code>A,&lt;esc&gt;j</code>来给结尾加上逗号并移动到下一行。现在我们知道了<code>j</code>是不算作修改操作的，只有<code>A,</code>算作修改操作。你可以使用<code>j .</code> <code>j .</code> 来移动并重复修改操作。完整的命令是<code>A,&lt;esc&gt;j</code>  </p><p>从你按下输入命令（<code>A</code>）开始到你退出输入模式（）之间的所有输入都算作是一整个修改操作<br>Vim 不仅允许你控制需要添加的文本的内容，还允许你控制在什么位置添加文本<br>你可以在选择在这些位置进行输入：光标位置前（<code>i</code>）,光标位置之后（<code>a</code>）,在下方插入一行（<code>o</code>），在上方插入一行（<code>O</code>），在当前行的末尾(<code>A</code>),或者在当前行的开始位置(<code>I</code>)<br>如果你想复习一下相关内容的话，可以看看输入模式（Insert Mode）这一章节</p><h2 id="重复多行修改操作"><a href="#重复多行修改操作" class="headerlink" title="重复多行修改操作"></a>重复多行修改操作</h2><p>假设你有如下的文本：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> one = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-keyword">let</span> two = <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-keyword">let</span> three = <span class="hljs-string">&quot;3&quot;</span>;<br><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&quot;bar&quot;</span>;<br><span class="hljs-keyword">let</span> four = <span class="hljs-string">&quot;4&quot;</span>;<br><span class="hljs-keyword">let</span> five = <span class="hljs-string">&quot;5&quot;</span>;<br><span class="hljs-keyword">let</span> six = <span class="hljs-string">&quot;6&quot;</span>;<br><span class="hljs-keyword">let</span> seven = <span class="hljs-string">&quot;7&quot;</span>;<br><span class="hljs-keyword">let</span> eight = <span class="hljs-string">&quot;8&quot;</span>;<br><span class="hljs-keyword">let</span> nine = <span class="hljs-string">&quot;9&quot;</span>;<br></code></pre></td></tr></table></figure><p>目标是删除除了含有<code>foo</code>那一行的其他所有行  </p><ol><li>首先，使用<code>d2j</code>删除前三行  </li><li>之后跳过<code>foo</code>这一行<code>j</code>，在其下一行使用点命令<code>.</code>两次来删除剩下的六行。完整的命令是<code>d2jj..</code>  </li></ol><p>这里的修改操作是<code>d2j</code>，<code>2j</code>不是一个移动操作，而是整个删除命令的一部分  </p><p>我们再来看看下一个例子：  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">zlet zzone</span> = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-attribute">zlet zztwo</span> = <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-attribute">zlet zzthree</span> = <span class="hljs-string">&quot;3&quot;</span>;<br><span class="hljs-attribute">let four</span> = <span class="hljs-string">&quot;4&quot;</span>;<br></code></pre></td></tr></table></figure><p>目标是删除所有的<code>z</code><br>首先，在块可视化模式下使用<code>Ctrl-vjj</code>来选中前三行的第一个<code>z</code>字母。如果你对块可视化模式不熟悉的话也不用担心，我会在下一章节中进行介绍<br>在选中前三行的第一个<code>z</code>后，使用<code>d</code>来删除它们。接着用<code>w</code>移动到下一个<code>z</code>字母上，使用<code>..</code>重复两次之前选中加删除的动作。完整的命令为<code>Ctrl-vjjdw..</code>  </p><p>你删除一列上的三个<code>z</code>的操作(<code>Ctrl-vjjd</code>)被看做一整个修改操作  可视化模式中的选择操作可以用来选中多行，作为修改动作的一部分  </p><h2 id="在修改中包含移动操作"><a href="#在修改中包含移动操作" class="headerlink" title="在修改中包含移动操作"></a>在修改中包含移动操作</h2><p>让我们来重新回顾一下本章中的第一个例子。这个例子中我们使用了<code>/letcwconst&lt;esc&gt;</code>紧接着<code>n .</code> <code>n .</code>将下面的文本中的’let’都替换成了’const’  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> one = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-keyword">let</span> two = <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-keyword">let</span> three = <span class="hljs-string">&quot;3&quot;</span>;<br></code></pre></td></tr></table></figure><p>其实还有更快的方法来完成整个操作。在删除的时候，并不使用<code>w</code>,而是使用<code>gn</code>  </p><p><code>gn</code>是向前搜索和上一个搜索的模式（本例中为<code>/let</code>）匹配的位置，并且自动对匹配的文本进行可视化模式下的选取的移动操作。想要对下一个匹配的位置进行替换的话，你不再需要先移动在重复修改操作（<code>n .</code> <code>n .</code>），而是简单地使用<code>. .</code>就能完成。你不需要再进行移动操作了，因为找到下一个匹配的位置并进行选中成为了修改操作的一部分了。完整的命令为<code>/letdgn..</code></p><p>当你在编辑文本时，应该时刻关注像<code>gn</code>命令这种能一下子做好几件事的移动操作  </p><blockquote><p>寄语:<br>点命令的强大之处在于使用仅仅1次键盘敲击代替好几次敲击<br>对于<code>x</code>这种只需一次敲击键盘就能完成的修改操作来说，点命令或许不会带来什么收益。但是如果你的上一个修改操作是像<code>cgnconst&lt;esc&gt;</code>这种复杂命令的话，使用点命令来替代就有非常可观的收益了<br>在进行编辑时，思考一下你正将进行的操作是否是可以重复的<br>举个例子，如果我需要删除接下来的三个单词，是使用<code>d3w</code>更划算，还是<code>dw</code>再使用<code>.</code>两次更划算？之后还会不会再进行删除操作？如果是这样的话，使用<code>dw</code>好几次确实比<code>d3w</code>更加合理，因为<code>dw</code>更加有复用性。在编辑时应该养成“修改操作驱动”的观念  </p></blockquote><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><hr><p>参考：  </p><ul><li><a href="https://github.com/RecluseXU/Learn-Vim_zh_cn">https://github.com/RecluseXU/Learn-Vim_zh_cn</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-基础-2</title>
    <link href="/post/e8b7be43/"/>
    <url>/post/e8b7be43/</url>
    
    <content type="html"><![CDATA[<h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>Javascript</code> 原生提供<code>Object</code>对象（注意起首的<code>O</code>是大写），本章介绍该对象原生的各种方法  </p><p><code>Javacript</code> 的所有其他对象都继承自<code>Object</code>对象，即那些对象都是<code>Object</code>的实例  </p><p><code>Object</code>对象的原生方法分成两类：<code>Object</code>本身的方法与<code>Object</code>的实例方法  </p><p><strong>（1）<code>Object</code>对象本身的方法</strong>  </p><p>所谓“本身的方法”就是直接定义在<code>Object</code>对象的方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.print = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>&#123; <span class="hljs-built_in">console</span>.log(o) &#125;;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>print</code>方法就是直接定义在<code>Object</code>对象上  </p><p><strong>（2）<code>Object</code>的实例方法</strong>  </p><p>所谓实例方法就是定义在<code>Object</code>原型对象<code>Object.prototype</code>上的方法。它可以被<code>Object</code>实例直接使用  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.print = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>obj.print() <span class="hljs-comment">// Object</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Object.prototype</code>定义了一个<code>print</code>方法，然后生成一个<code>Object</code>的实例<code>obj</code>。<code>obj</code>直接继承了<code>Object.prototype</code>的属性和方法，可以直接使用<code>obj.print</code>调用<code>print</code>方法。也就是说，<code>obj</code>对象的<code>print</code>方法实质上就是调用<code>Object.prototype.print</code>方法  </p><p>凡是定义在<code>Object.prototype</code>对象上面的属性和方法，将被所有实例对象共享  </p><p>以下先介绍<code>Object</code>作为函数的用法，然后再介绍<code>Object</code>对象的原生方法，分成对象自身的方法（又称为“静态方法”）和实例方法两部分  </p><h3 id="Object"><a href="#Object" class="headerlink" title="Object()"></a>Object()</h3><p><code>Object</code>本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象  </p><p>如果参数为空（或者为<code>undefined</code>和<code>null</code>），<code>Object()</code>返回一个空对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>();<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(<span class="hljs-literal">undefined</span>);<br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(<span class="hljs-literal">null</span>);<br><br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码的含义，是将<code>undefined</code>和<code>null</code>转为对象，结果得到了一个空对象<code>obj</code>  </p><p><code>instanceof</code>运算符用来验证，一个对象是否为指定的构造函数的实例。<code>obj instanceof Object</code>返回<code>true</code>，就表示<code>obj</code>对象是<code>Object</code>的实例  </p><p>如果参数是原始类型的值，<code>Object</code>方法将其转为对应的包装对象的实例  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(<span class="hljs-number">1</span>);<br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(<span class="hljs-literal">true</span>);<br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Boolean</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Object</code>函数的参数是各种原始类型的值，转换成对象就是原始类型值对应的包装对象  </p><p>如果<code>Object</code>方法的参数是一个对象，它总是返回该对象，即不用转换  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(arr); <span class="hljs-comment">// 返回原数组</span><br>obj === arr <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">var</span> value = &#123;&#125;;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(value) <span class="hljs-comment">// 返回原对象</span><br>obj === value <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(fn); <span class="hljs-comment">// 返回原函数</span><br>obj === fn <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>利用这一点，可以写一个判断变量是否为对象的函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> value === <span class="hljs-built_in">Object</span>(value);<br>&#125;<br><br>isObject([]) <span class="hljs-comment">// true</span><br>isObject(<span class="hljs-literal">true</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="Object-构造函数"><a href="#Object-构造函数" class="headerlink" title="Object 构造函数"></a>Object 构造函数</h3><p><code>Object</code>不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用<code>new</code>命令  </p><p><code>Object</code>构造函数的首要用途，是直接通过它来生成新对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br></code></pre></td></tr></table></figure><blockquote><p>注意，通过<code>var obj = new Object()</code>的写法生成新对象，与字面量的写法<code>var obj = &#123;&#125;</code>是等价的。或者说，后者只是前者的一种简便写法  </p></blockquote><p><code>Object</code>构造函数的用法与工具方法很相似，几乎一模一样  </p><p>使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(o1);<br>o1 === o2 <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(<span class="hljs-number">123</span>);<br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>虽然用法相似，但是<code>Object(value)</code>与<code>new Object(value)</code>两者的语义是不同的，<code>Object(value)</code>表示将<code>value</code>转成一个对象，<code>new Object(value)</code>则表示新生成一个对象，它的值是<code>value</code>。</p><h3 id="Object-的静态方法"><a href="#Object-的静态方法" class="headerlink" title="Object 的静态方法"></a>Object 的静态方法</h3><p>所谓“静态方法”，是指部署在<code>Object</code>对象自身的方法  </p><h4 id="Object-keys-，Object-getOwnPropertyNames"><a href="#Object-keys-，Object-getOwnPropertyNames" class="headerlink" title="Object.keys()，Object.getOwnPropertyNames()"></a>Object.keys()，Object.getOwnPropertyNames()</h4><p><code>Object.keys</code>方法和<code>Object.getOwnPropertyNames</code>方法都用来遍历对象的属性  </p><p><code>Object.keys</code>方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p1: <span class="hljs-number">123</span>,<br>  p2: <span class="hljs-number">456</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.keys(obj) <span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;]</span><br></code></pre></td></tr></table></figure><p><code>Object.getOwnPropertyNames</code>方法与<code>Object.keys</code>类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p1: <span class="hljs-number">123</span>,<br>  p2: <span class="hljs-number">456</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj) <span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;]</span><br></code></pre></td></tr></table></figure><p>对于一般的对象来说，<code>Object.keys()</code>和<code>Object.getOwnPropertyNames()</code>返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。<code>Object.keys</code>方法只返回可枚举的属性，<code>Object.getOwnPropertyNames</code>方法还返回不可枚举的属性名  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;World&#x27;</span>];<br><br><span class="hljs-built_in">Object</span>.keys(a) <span class="hljs-comment">// [&quot;0&quot;, &quot;1&quot;]</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(a) <span class="hljs-comment">// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，数组的<code>length</code>属性是不可枚举的属性，所以只出现在<code>Object.getOwnPropertyNames</code>方法的返回结果中  </p><p>由于<code> Javascript</code> 没有提供计算对象属性个数的方法，所以可以用这两个方法代替  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p1: <span class="hljs-number">123</span>,<br>  p2: <span class="hljs-number">456</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.keys(obj).length <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj).length <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>一般情况下，几乎总是使用<code>Object.keys</code>方法，遍历对象的属性  </p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>除了上面提到的两个方法，<code>Object</code>还有不少其他静态方法，将在后文逐一详细介绍  </p><p><strong>（1）对象属性模型的相关方法</strong></p><ul><li><code>Object.getOwnPropertyDescriptor()</code>：获取某个属性的描述对象  </li><li><code>Object.defineProperty()</code>：通过描述对象，定义某个属性  </li><li><code>Object.defineProperties()</code>：通过描述对象，定义多个属性  </li></ul><p><strong>（2）控制对象状态的方法</strong></p><ul><li><code>Object.preventExtensions()</code>：防止对象扩展  </li><li><code>Object.isExtensible()</code>：判断对象是否可扩展  </li><li><code>Object.seal()</code>：禁止对象配置  </li><li><code>Object.isSealed()</code>：判断一个对象是否可配置  </li><li><code>Object.freeze()</code>：冻结一个对象  </li><li><code>Object.isFrozen()</code>：判断一个对象是否被冻结  </li></ul><p><strong>（3）原型链相关方法</strong></p><ul><li><code>Object.create()</code>：该方法可以指定原型对象和属性，返回一个新的对象  </li><li><code>Object.getPrototypeOf()</code>：获取对象的<code>Prototype</code>对象  </li></ul><h3 id="Object-的实例方法"><a href="#Object-的实例方法" class="headerlink" title="Object 的实例方法"></a>Object 的实例方法</h3><p>除了静态方法，还有不少方法定义在<code>Object.prototype</code>对象。它们称为实例方法，所有<code>Object</code>的实例对象都继承了这些方法  </p><p><code>Object</code>实例对象的方法，主要有以下六个  </p><ul><li><code>Object.prototype.valueOf()</code>：返回当前对象对应的值  </li><li><code>Object.prototype.toString()</code>：返回当前对象对应的字符串形式  </li><li><code>Object.prototype.toLocaleString()</code>：返回当前对象对应的本地字符串形式  </li><li><code>Object.prototype.hasOwnProperty()</code>：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性  </li><li><code>Object.prototype.isPrototypeOf()</code>：判断当前对象是否为另一个对象的原型  </li><li><code>Object.prototype.propertyIsEnumerable()</code>：判断某个属性是否可枚举   </li></ul><h4 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h4><p><code>valueOf</code>方法的作用是返回一个对象的“值”，默认情况下返回对象本身  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>obj.valueOf() === obj <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码比较<code>obj.valueOf()</code>与<code>obj</code>本身，两者是一样的  </p><p><code>valueOf</code>方法的主要用途是，<code>Javascript</code> 自动类型转换时会默认调用这个方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-number">1</span> + obj <span class="hljs-comment">// &quot;1[object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码将对象<code>obj</code>与数字<code>1</code>相加，这时 <code>Javascript</code> 就会默认调用<code>valueOf()</code>方法，求出<code>obj</code>的值再与<code>1</code>相加。所以，如果自定义<code>valueOf</code>方法，就可以得到想要的结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>obj.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;;<br><br><span class="hljs-number">1</span> + obj <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面代码自定义了<code>obj</code>对象的<code>valueOf</code>方法，于是<code>1 + obj</code>就得到了<code>3</code>  </p><p>这种方法就相当于用自定义的<code>obj.valueOf</code>，覆盖<code>Object.prototype.valueOf</code>  </p><h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h4><p><code>toString</code>方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>o1.toString() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br><span class="hljs-keyword">var</span> o2 = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;;<br>o2.toString() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码表示，对于一个对象调用<code>toString</code>方法，会返回字符串<code>[object Object]</code>，该字符串说明对象的类型  </p><p>字符串<code>[object Object]</code>本身没有太大的用处，但是通过自定义<code>toString</code>方法，可以让对象在自动类型转换时，得到想要的字符串形式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br>obj.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span>;<br>&#125;;<br><br>obj + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-string">&#x27;world&#x27;</span> <span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码表示，当对象用于字符串加法时，会自动调用<code>toString</code>方法。由于自定义了<code>toString</code>方法，所以返回字符串<code>hello world</code>  </p><p>数组、字符串、函数、Date 对象都分别部署了自定义的<code>toString</code>方法，覆盖了<code>Object.prototype.toString</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].toString() <span class="hljs-comment">// &quot;1,2,3&quot;</span><br><br><span class="hljs-string">&#x27;123&#x27;</span>.toString() <span class="hljs-comment">// &quot;123&quot;</span><br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;<br>&#125;).toString()<br><span class="hljs-comment">// &quot;function () &#123;</span><br><span class="hljs-comment">//   return 123;</span><br><span class="hljs-comment">// &#125;&quot;</span><br><br>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).toString()<br><span class="hljs-comment">// &quot;Tue May 10 2016 09:11:31 GMT+0800 (CST)&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，数组、字符串、函数、Date 对象调用<code>toString</code>方法，并不会返回<code>[object Object]</code>，因为它们都自定义了<code>toString</code>方法，覆盖原始方法  </p><h4 id="toString-的应用：判断数据类型"><a href="#toString-的应用：判断数据类型" class="headerlink" title="toString() 的应用：判断数据类型"></a>toString() 的应用：判断数据类型</h4><p><code>Object.prototype.toString</code>方法返回对象的类型字符串，因此可以用来判断一个值的类型  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.toString() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码调用空对象的<code>toString</code>方法，结果返回一个字符串<code>object Object</code>，其中第二个<code>Object</code>表示该值的构造函数。这是一个十分有用的判断数据类型的方法  </p><p>由于实例对象可能会自定义<code>toString</code>方法，覆盖掉<code>Object.prototype.toString</code>方法，所以为了得到类型字符串，最好直接使用<code>Object.prototype.toString</code>方法。通过函数的<code>call</code>方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.toString.call(value)<br></code></pre></td></tr></table></figure><p>上面代码表示对<code>value</code>这个值调用<code>Object.prototype.toString</code>方法  </p><p>不同数据类型的<code>Object.prototype.toString</code>方法返回值如下  </p><ul><li>数值：返回<code>[object Number]</code>  </li><li>字符串：返回<code>[object String]</code>  </li><li>布尔值：返回<code>[object Boolean]</code>  </li><li>undefined：返回<code>[object Undefined]</code>  </li><li>null：返回<code>[object Null]</code>  </li><li>数组：返回<code>[object Array]</code> </li><li>arguments 对象：返回<code>[object Arguments]</code>  </li><li>函数：返回<code>[object Function]</code>  </li><li>Error 对象：返回<code>[object Error]</code>  </li><li>Date 对象：返回<code>[object Date]</code>  </li><li>RegExp 对象：返回<code>[object RegExp]</code>  </li><li>其他对象：返回<code>[object Object]</code>  </li></ul><p>这就是说，<code>Object.prototype.toString</code>可以看出一个值到底是什么类型  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;[object Number]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// &quot;[object String]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>) <span class="hljs-comment">// &quot;[object Boolean]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// &quot;[object Undefined]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>) <span class="hljs-comment">// &quot;[object Null]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">Math</span>) <span class="hljs-comment">// &quot;[object Math]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(&#123;&#125;) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call([]) <span class="hljs-comment">// &quot;[object Array]&quot;</span><br></code></pre></td></tr></table></figure><p>利用这个特性，可以写出一个比<code>typeof</code>运算符更准确的类型判断函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> type = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> s = <span class="hljs-built_in">Object</span>.prototype.toString.call(o);<br>  <span class="hljs-keyword">return</span> s.match(<span class="hljs-regexp">/\[object (.*?)\]/</span>)[<span class="hljs-number">1</span>].toLowerCase();<br>&#125;;<br><br>type(&#123;&#125;); <span class="hljs-comment">// &quot;object&quot;</span><br>type([]); <span class="hljs-comment">// &quot;array&quot;</span><br>type(<span class="hljs-number">5</span>); <span class="hljs-comment">// &quot;number&quot;</span><br>type(<span class="hljs-literal">null</span>); <span class="hljs-comment">// &quot;null&quot;</span><br>type(); <span class="hljs-comment">// &quot;undefined&quot;</span><br>type(<span class="hljs-regexp">/abcd/</span>); <span class="hljs-comment">// &quot;regex&quot;</span><br>type(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()); <span class="hljs-comment">// &quot;date&quot;</span><br></code></pre></td></tr></table></figure><p>在上面这个<code>type</code>函数的基础上，还可以加上专门判断某种类型数据的方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> type = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> s = <span class="hljs-built_in">Object</span>.prototype.toString.call(o);<br>  <span class="hljs-keyword">return</span> s.match(<span class="hljs-regexp">/\[object (.*?)\]/</span>)[<span class="hljs-number">1</span>].toLowerCase();<br>&#125;;<br><br>[<span class="hljs-string">&#x27;Null&#x27;</span>,<br> <span class="hljs-string">&#x27;Undefined&#x27;</span>,<br> <span class="hljs-string">&#x27;Object&#x27;</span>,<br> <span class="hljs-string">&#x27;Array&#x27;</span>,<br> <span class="hljs-string">&#x27;String&#x27;</span>,<br> <span class="hljs-string">&#x27;Number&#x27;</span>,<br> <span class="hljs-string">&#x27;Boolean&#x27;</span>,<br> <span class="hljs-string">&#x27;Function&#x27;</span>,<br> <span class="hljs-string">&#x27;RegExp&#x27;</span><br>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) </span>&#123;<br>  type[<span class="hljs-string">&#x27;is&#x27;</span> + t] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> type(o) === t.toLowerCase();<br>  &#125;;<br>&#125;);<br><br>type.isObject(&#123;&#125;) <span class="hljs-comment">// true</span><br>type.isNumber(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// true</span><br>type.isRegExp(<span class="hljs-regexp">/abc/</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="Object-prototype-toLocaleString"><a href="#Object-prototype-toLocaleString" class="headerlink" title="Object.prototype.toLocaleString()"></a>Object.prototype.toLocaleString()</h4><p><code>Object.prototype.toLocaleString</code>方法与<code>toString</code>的返回结果相同，也是返回一个值的字符串形式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.toString(obj) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br>obj.toLocaleString(obj) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的<code>toLocaleString</code>，用来返回针对某些地域的特定的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Henry Norman Bethune&#x27;</span>;<br>  &#125;,<br>  toLocaleString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;白求恩&#x27;</span>;<br>  &#125;<br>&#125;;<br><br>person.toString() <span class="hljs-comment">// Henry Norman Bethune</span><br>person.toLocaleString() <span class="hljs-comment">// 白求恩</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>toString()</code>方法返回对象的一般字符串形式，<code>toLocaleString()</code>方法返回本地的字符串形式  </p><p>目前，主要有三个对象自定义了<code>toLocaleString</code>方法  </p><ul><li>Array.prototype.toLocaleString()</li><li>Number.prototype.toLocaleString()</li><li>Date.prototype.toLocaleString()</li></ul><p>举例来说，日期的实例对象的<code>toString</code>和<code>toLocaleString</code>返回值就不一样，而且<code>toLocaleString</code>的返回值跟用户设定的所在地域相关  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>date.toString() <span class="hljs-comment">// &quot;Tue Jan 01 2018 12:01:33 GMT+0800 (CST)&quot;</span><br>date.toLocaleString() <span class="hljs-comment">// &quot;1/01/2018, 12:01:33 PM&quot;</span><br></code></pre></td></tr></table></figure><h4 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h4><p><code>Object.prototype.hasOwnProperty</code>方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-number">123</span><br>&#125;;<br><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;p&#x27;</span>) <span class="hljs-comment">// true</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;toString&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>自身具有<code>p</code>属性，所以返回<code>true</code>。<code>toString</code>属性是继承的，所以返回<code>false</code>  </p><h2 id="属性描述对象"><a href="#属性描述对象" class="headerlink" title="属性描述对象"></a>属性描述对象</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>Javascript</code> 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等  </p><p>这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息  </p><p>下面是属性描述对象的一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  value: <span class="hljs-number">123</span>,<br>  writable: <span class="hljs-literal">false</span>,<br>  enumerable: <span class="hljs-literal">true</span>,<br>  configurable: <span class="hljs-literal">false</span>,<br>  get: <span class="hljs-literal">undefined</span>,<br>  set: <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></td></tr></table></figure><p>属性描述对象提供6个元属性。</p><ol><li><p><code>value</code><br><code>value</code>是该属性的属性值，默认为<code>undefined</code>  </p></li><li><p><code>writable</code><br><code>writable</code>是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为<code>true</code>  </p></li><li><p><code>enumerable</code><br><code>enumerable</code>是一个布尔值，表示该属性是否可遍历，默认为<code>true</code>。如果设为<code>false</code>，会使得某些操作（比如<code>for...in</code>循环、<code>Object.keys()</code>）跳过该属性  </p></li><li><p><code>configurable</code><br> <code>configurable</code>是一个布尔值，表示可配置性，默认为<code>true</code>。如果设为<code>false</code>，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（<code>value</code>属性除外）  </p><p>也就是说，<code>configurable</code>属性控制了属性描述对象的可写性  </p></li><li><p><code>get</code><br> <code>get</code>是一个函数，表示该属性的取值函数（getter），默认为<code>undefined</code>  </p></li><li><p><code>set</code><br> <code>set</code>是一个函数，表示该属性的存值函数（setter），默认为<code>undefined</code>  </p></li></ol><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h4><p><code>Object.getOwnPropertyDescriptor()</code>方法可以获取属性描述对象  </p><p>它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;p&#x27;</span>)<br><span class="hljs-comment">// Object &#123; value: &quot;a&quot;,</span><br><span class="hljs-comment">//   writable: true,</span><br><span class="hljs-comment">//   enumerable: true,</span><br><span class="hljs-comment">//   configurable: true</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Object.getOwnPropertyDescriptor()</code>方法获取<code>obj.p</code>的属性描述对象  </p><p>注意，<code>Object.getOwnPropertyDescriptor()</code>方法只能用于对象自身的属性，不能用于继承的属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;toString&#x27;</span>)<br><span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>toString</code>是<code>obj</code>对象继承的属性，<code>Object.getOwnPropertyDescriptor()</code>无法获取  </p><h4 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h4><p><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperties(&#123;&#125;, &#123;<br>  p1: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> &#125;,<br>  p2: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span> &#125;<br>&#125;);<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj)<br><span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.p1</code>是可遍历的，<code>obj.p2</code>是不可遍历的。<code>Object.getOwnPropertyNames</code>会将它们都返回。</p><p>这跟<code>Object.keys</code>的行为不同，<code>Object.keys</code>只返回对象自身的可遍历属性的全部属性名  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.keys([]) <span class="hljs-comment">// []</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames([]) <span class="hljs-comment">// [ &#x27;length&#x27; ]</span><br><br><span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">// []</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(<span class="hljs-built_in">Object</span>.prototype)<br><span class="hljs-comment">// [&#x27;hasOwnProperty&#x27;,</span><br><span class="hljs-comment">//  &#x27;valueOf&#x27;,</span><br><span class="hljs-comment">//  &#x27;constructor&#x27;,</span><br><span class="hljs-comment">//  &#x27;toLocaleString&#x27;,</span><br><span class="hljs-comment">//  &#x27;isPrototypeOf&#x27;,</span><br><span class="hljs-comment">//  &#x27;propertyIsEnumerable&#x27;,</span><br><span class="hljs-comment">//  &#x27;toString&#x27;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，数组自身的<code>length</code>属性是不可遍历的，<code>Object.keys</code>不会返回该属性。第二个例子的<code>Object.prototype</code>也是一个对象，所有实例对象都会继承它，它自身的属性都是不可遍历的  </p><h4 id="Object-defineProperty-，Object-defineProperties"><a href="#Object-defineProperty-，Object-defineProperties" class="headerlink" title="Object.defineProperty()，Object.defineProperties()"></a>Object.defineProperty()，Object.defineProperties()</h4><p><code>Object.defineProperty()</code>方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(object, propertyName, attributesObject)<br></code></pre></td></tr></table></figure><p><code>Object.defineProperty</code>方法接受三个参数，依次如下  </p><ul><li>object：属性所在的对象  </li><li>propertyName：字符串，表示属性名  </li><li>attributesObject：属性描述对象  </li></ul><p>举例来说，定义<code>obj.p</code>可以写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">123</span>,<br>  writable: <span class="hljs-literal">false</span>,<br>  enumerable: <span class="hljs-literal">true</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><br>obj.p <span class="hljs-comment">// 123</span><br><br>obj.p = <span class="hljs-number">246</span>;<br>obj.p <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Object.defineProperty()</code>方法定义了<code>obj.p</code>属性。由于属性描述对象的<code>writable</code>属性为<code>false</code>，所以<code>obj.p</code>属性不可写。注意，这里的<code>Object.defineProperty</code>方法的第一个参数是<code>&#123;&#125;</code>（一个新建的空对象），<code>p</code>属性直接定义在这个空对象上面，然后返回这个对象，这是<code>Object.defineProperty()</code>的常见用法  </p><p>如果属性已经存在，<code>Object.defineProperty()</code>方法相当于更新该属性的属性描述对象  </p><p>如果一次性定义或修改多个属性，可以使用<code>Object.defineProperties()</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperties(&#123;&#125;, &#123;<br>  p1: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">123</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> &#125;,<br>  p2: &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> &#125;,<br>  p3: &#123; <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.p1 + <span class="hljs-built_in">this</span>.p2 &#125;,<br>    enumerable:<span class="hljs-literal">true</span>,<br>    configurable:<span class="hljs-literal">true</span><br>  &#125;<br>&#125;);<br><br>obj.p1 <span class="hljs-comment">// 123</span><br>obj.p2 <span class="hljs-comment">// &quot;abc&quot;</span><br>obj.p3 <span class="hljs-comment">// &quot;123abc&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Object.defineProperties()</code>同时定义了<code>obj</code>对象的三个属性。其中，<code>p3</code>属性定义了取值函数<code>get</code>，即每次读取该属性，都会调用这个取值函数。</p><p>注意，一旦定义了取值函数<code>get</code>（或存值函数<code>set</code>），就不能将<code>writable</code>属性设为<code>true</code>，或者同时定义<code>value</code>属性，否则会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">123</span>,<br>  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">456</span>; &#125;<br>&#125;);<br><span class="hljs-comment">// TypeError: Invalid property.</span><br><span class="hljs-comment">// A property cannot both have accessors and be writable or have a value</span><br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  writable: <span class="hljs-literal">true</span>,<br>  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">456</span>; &#125;<br>&#125;);<br><span class="hljs-comment">// TypeError: Invalid property descriptor.</span><br><span class="hljs-comment">// Cannot both specify accessors and a value or writable attribute</span><br></code></pre></td></tr></table></figure><p>上面代码中，同时定义了<code>get</code>属性和<code>value</code>属性，以及将<code>writable</code>属性设为<code>true</code>，就会报错  </p><p><code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>参数里面的属性描述对象，<code>writable</code>、<code>configurable</code>、<code>enumerable</code>这三个属性的默认值都为<code>false</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;&#125;);<br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//   value: undefined,</span><br><span class="hljs-comment">//   writable: false,</span><br><span class="hljs-comment">//   enumerable: false,</span><br><span class="hljs-comment">//   configurable: false</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，定义<code>obj.foo</code>时用了一个空的属性描述对象，就可以看到各个元属性的默认值  </p><h4 id="Object-prototype-propertyIsEnumerable"><a href="#Object-prototype-propertyIsEnumerable" class="headerlink" title="Object.prototype.propertyIsEnumerable()"></a>Object.prototype.propertyIsEnumerable()</h4><p>实例对象的<code>propertyIsEnumerable()</code>方法返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回<code>false</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.p = <span class="hljs-number">123</span>;<br><br>obj.propertyIsEnumerable(<span class="hljs-string">&#x27;p&#x27;</span>) <span class="hljs-comment">// true</span><br>obj.propertyIsEnumerable(<span class="hljs-string">&#x27;toString&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.p</code>是可遍历的，而<code>obj.toString</code>是继承的属性  </p><h3 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h3><p>属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性  </p><h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p><code>value</code>属性是目标属性的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.p = <span class="hljs-number">123</span>;<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;p&#x27;</span>).value<br><span class="hljs-comment">// 123</span><br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">246</span> &#125;);<br>obj.p <span class="hljs-comment">// 246</span><br></code></pre></td></tr></table></figure><p>上面代码是通过<code>value</code>属性，读取或改写<code>obj.p</code>的例子  </p><h4 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h4><p><code>writable</code>属性是一个布尔值，决定了目标属性的值（value）是否可以被改变  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<br>  value: <span class="hljs-number">37</span>,<br>  writable: <span class="hljs-literal">false</span><br>&#125;);<br><br>obj.a <span class="hljs-comment">// 37</span><br>obj.a = <span class="hljs-number">25</span>;<br>obj.a <span class="hljs-comment">// 37</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.a</code>的<code>writable</code>属性是<code>false</code>。然后，改变<code>obj.a</code>的值，不会有任何效果  </p><p>注意，正常模式下，对<code>writable</code>为<code>false</code>的属性赋值不会报错，只会默默失败  </p><p>但是，严格模式下会报错，即使对<code>a</code>属性重新赋予一个同样的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<br>  value: <span class="hljs-number">37</span>,<br>  writable: <span class="hljs-literal">false</span><br>&#125;);<br><br>obj.a = <span class="hljs-number">37</span>;<br><span class="hljs-comment">// Uncaught TypeError: Cannot assign to read only property &#x27;a&#x27; of object</span><br></code></pre></td></tr></table></figure><p>上面代码是严格模式，对<code>obj.a</code>任何赋值行为都会报错。</p><p>如果原型对象的某个属性的<code>writable</code>为<code>false</code>，那么子对象将无法自定义这个属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> proto = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;<br>  value: <span class="hljs-string">&#x27;a&#x27;</span>,<br>  writable: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(proto);<br><br>obj.foo = <span class="hljs-string">&#x27;b&#x27;</span>;<br>obj.foo <span class="hljs-comment">// &#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>proto</code>是原型对象，它的<code>foo</code>属性不可写。<code>obj</code>对象继承<code>proto</code>，也不可以再自定义这个属性了  </p><p>如果是严格模式，这样做还会抛出一个错误  </p><p>但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> proto = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;<br>  value: <span class="hljs-string">&#x27;a&#x27;</span>,<br>  writable: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(proto);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;<br>  value: <span class="hljs-string">&#x27;b&#x27;</span><br>&#125;);<br><br>obj.foo <span class="hljs-comment">// &quot;b&quot;</span><br></code></pre></td></tr></table></figure><h4 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h4><p><code>enumerable</code>（可遍历性）返回一个布尔值，表示目标属性是否可遍历  </p><p>JavaScript 的早期版本，<code>for...in</code>循环是基于<code>in</code>运算符的。我们知道，<code>in</code>运算符不管某个属性是对象自身的还是继承的，都会返回<code>true</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> obj <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>toString</code>不是<code>obj</code>对象自身的属性，但是<code>in</code>运算符也返回<code>true</code>，这导致了<code>toString</code>属性也会被<code>for...in</code>循环遍历  </p><p>这显然不太合理，后来就引入了“可遍历性”这个概念。只有可遍历的属性，才会被<code>for...in</code>循环遍历，同时还规定<code>toString</code>这一类实例对象继承的原生属性，都是不可遍历的，这样就保证了<code>for...in</code>循环的可用性  </p><p>具体来说，如果一个属性的<code>enumerable</code>为<code>false</code>，下面三个操作不会取到该属性  </p><ul><li><code>for..in</code>循环  </li><li><code>Object.keys</code>方法  </li><li><code>JSON.stringify</code>方法  </li></ul><p>因此，<code>enumerable</code>可以用来设置“秘密”属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;x&#x27;</span>, &#123;<br>  value: <span class="hljs-number">123</span>,<br>  enumerable: <span class="hljs-literal">false</span><br>&#125;);<br><br>obj.x <span class="hljs-comment">// 123</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-built_in">console</span>.log(key);<br>&#125;<br><span class="hljs-comment">// undefined</span><br><br><span class="hljs-built_in">Object</span>.keys(obj)  <span class="hljs-comment">// []</span><br><span class="hljs-built_in">JSON</span>.stringify(obj) <span class="hljs-comment">// &quot;&#123;&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.x</code>属性的<code>enumerable</code>为<code>false</code>，所以一般的遍历操作都无法获取该属性，使得它有点像“秘密”属性，但不是真正的私有属性，还是可以直接获取它的值  </p><p>注意，<code>for...in</code>循环包括继承的属性，<code>Object.keys</code>方法不包括继承的属性。如果需要获取对象自身的所有属性，不管是否可遍历，可以使用<code>Object.getOwnPropertyNames</code>方法  </p><p>另外，<code>JSON.stringify</code>方法会排除<code>enumerable</code>为<code>false</code>的属性，有时可以利用这一点。如果对象的 JSON 格式输出要排除某些属性，就可以把这些属性的<code>enumerable</code>设为<code>false</code>  </p><h4 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h4><p><code>configurable</code>(可配置性）返回一个布尔值，决定了是否可以修改属性描述对象  </p><p><code>configurable</code>为<code>false</code>时，<code>value</code>、<code>writable</code>、<code>enumerable</code>和<code>configurable</code>都不能被修改了  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">1</span>,<br>  writable: <span class="hljs-literal">false</span>,<br>  enumerable: <span class="hljs-literal">false</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">2</span>&#125;)<br><span class="hljs-comment">// TypeError: Cannot redefine property: p</span><br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;)<br><span class="hljs-comment">// TypeError: Cannot redefine property: p</span><br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>&#125;)<br><span class="hljs-comment">// TypeError: Cannot redefine property: p</span><br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>&#125;)<br><span class="hljs-comment">// TypeError: Cannot redefine property: p</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.p</code>的<code>configurable</code>为<code>false</code>。然后，改动<code>value</code>、<code>writable</code>、<code>enumerable</code>、<code>configurable</code>，结果都报错  </p><p>注意，<code>writable</code>只有在<code>false</code>改为<code>true</code>会报错，<code>true</code>改为<code>false</code>是允许的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  writable: <span class="hljs-literal">true</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;)<br><span class="hljs-comment">// 修改成功</span><br></code></pre></td></tr></table></figure><p>至于<code>value</code>，只要<code>writable</code>和<code>configurable</code>有一个为<code>true</code>，就允许改动  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">1</span>,<br>  writable: <span class="hljs-literal">true</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-built_in">Object</span>.defineProperty(o1, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">2</span>&#125;)<br><span class="hljs-comment">// 修改成功</span><br><br><span class="hljs-keyword">var</span> o2 = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">1</span>,<br>  writable: <span class="hljs-literal">false</span>,<br>  configurable: <span class="hljs-literal">true</span><br>&#125;);<br><br><span class="hljs-built_in">Object</span>.defineProperty(o2, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">2</span>&#125;)<br><span class="hljs-comment">// 修改成功</span><br></code></pre></td></tr></table></figure><p>另外，<code>writable</code>为<code>false</code>时，直接目标属性赋值，不报错，但不会成功  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">1</span>,<br>  writable: <span class="hljs-literal">false</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><br>obj.p = <span class="hljs-number">2</span>;<br>obj.p <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.p</code>的<code>writable</code>为<code>false</code>，对<code>obj.p</code>直接赋值不会生效。如果是严格模式，还会报错  </p><p>可配置性决定了目标属性是否可以被删除（delete）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperties(&#123;&#125;, &#123;<br>  p1: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span> &#125;,<br>  p2: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span> &#125;<br>&#125;);<br><br><span class="hljs-keyword">delete</span> obj.p1 <span class="hljs-comment">// true</span><br><span class="hljs-keyword">delete</span> obj.p2 <span class="hljs-comment">// false</span><br><br>obj.p1 <span class="hljs-comment">// undefined</span><br>obj.p2 <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.p1</code>的<code>configurable</code>是<code>true</code>，所以可以被删除，<code>obj.p2</code>就无法删除  </p><h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>除了直接定义以外，属性还可以用存取器（accessor）定义  </p><p>其中，存值函数称为<code>setter</code>，使用属性描述对象的<code>set</code>属性；取值函数称为<code>getter</code>，使用属性描述对象的<code>get</code>属性。</p><p>一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如定制属性的读取和赋值行为  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;getter&#x27;</span>;<br>  &#125;,<br>  set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setter: &#x27;</span> + value);<br>  &#125;<br>&#125;);<br><br>obj.p <span class="hljs-comment">// &quot;getter&quot;</span><br>obj.p = <span class="hljs-number">123</span> <span class="hljs-comment">// &quot;setter: 123&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.p</code>定义了<code>get</code>和<code>set</code>属性。<code>obj.p</code>取值时，就会调用<code>get</code>；赋值时，就会调用<code>set</code>  </p><p><code>Javascript</code> 还提供了存取器的另一种写法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法二</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">p</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;getter&#x27;</span>;<br>  &#125;,<br>  <span class="hljs-keyword">set</span> <span class="hljs-title">p</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setter: &#x27;</span> + value);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面两种写法，虽然属性<code>p</code>的读取和赋值行为是一样的，但是有一些细微的区别  </p><ul><li><p>第一种写法，属性<code>p</code>的<code>configurable</code>和<code>enumerable</code>都为<code>false</code>，从而导致属性<code>p</code>是不可遍历的  </p></li><li><p>第二种写法，属性<code>p</code>的<code>configurable</code>和<code>enumerable</code>都为<code>true</code>，因此属性<code>p</code>是可遍历的  </p></li></ul><p>实际开发中，写法二更常用  </p><p>注意，取值函数<code>get</code>不能接受参数，存值函数<code>set</code>只能接受一个参数（即属性的值）  </p><p>存取器往往用于，属性的值依赖对象内部数据的场合  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj =&#123;<br>  $n : <span class="hljs-number">5</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">next</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$n++ &#125;,<br>  <span class="hljs-keyword">set</span> <span class="hljs-title">next</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-built_in">this</span>.$n) <span class="hljs-built_in">this</span>.$n = n;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;新的值必须大于当前值&#x27;</span>);<br>  &#125;<br>&#125;;<br><br>obj.next <span class="hljs-comment">// 5</span><br><br>obj.next = <span class="hljs-number">10</span>;<br>obj.next <span class="hljs-comment">// 10</span><br><br>obj.next = <span class="hljs-number">5</span>;<br><span class="hljs-comment">// Uncaught Error: 新的值必须大于当前值</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>next</code>属性的存值函数和取值函数，都依赖于内部属性<code>$n</code>  </p><h3 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h3><p>有时，我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> extend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> <span class="hljs-keyword">from</span>) &#123;<br>    to[property] = <span class="hljs-keyword">from</span>[property];<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> to;<br>&#125;<br><br>extend(&#123;&#125;, &#123;<br>  a: <span class="hljs-number">1</span><br>&#125;)<br><span class="hljs-comment">// &#123;a: 1&#125;</span><br></code></pre></td></tr></table></figure><p>上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">extend(&#123;&#125;, &#123;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">a</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &#125;<br>&#125;)<br><span class="hljs-comment">// &#123;a: 1&#125;</span><br></code></pre></td></tr></table></figure><p>为了解决这个问题，我们可以通过<code>Object.defineProperty</code>方法来拷贝属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> extend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> <span class="hljs-keyword">from</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">from</span>.hasOwnProperty(property)) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">Object</span>.defineProperty(<br>      to,<br>      property,<br>      <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-keyword">from</span>, property)<br>    );<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> to;<br>&#125;<br><br>extend(&#123;&#125;, &#123; <span class="hljs-keyword">get</span> <span class="hljs-title">a</span>()&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &#125; &#125;)<br><span class="hljs-comment">// &#123; get a()&#123; return 1 &#125; &#125;)</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>hasOwnProperty</code>那一行用来过滤掉继承的属性，否则可能会报错，因为<code>Object.getOwnPropertyDescriptor</code>读不到继承属性的属性描述对象  </p><h3 id="控制对象状态"><a href="#控制对象状态" class="headerlink" title="控制对象状态"></a>控制对象状态</h3><p>有时需要冻结对象的读写状态，防止对象被改变  </p><p><code>Javascript</code> 提供了三种冻结方法，最弱的一种是<code>Object.preventExtensions</code>，其次是<code>Object.seal</code>，最强的是<code>Object.freeze</code>  </p><h4 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions()"></a>Object.preventExtensions()</h4><p><code>Object.preventExtensions</code>方法可以使得一个对象无法再添加新的属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.preventExtensions(obj);<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;);<br><span class="hljs-comment">// TypeError: Cannot define property:p, object is not extensible.</span><br><br>obj.p = <span class="hljs-number">1</span>;<br>obj.p <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象经过<code>Object.preventExtensions</code>以后，就无法添加新属性了  </p><h4 id="Object-isExtensible"><a href="#Object-isExtensible" class="headerlink" title="Object.isExtensible()"></a>Object.isExtensible()</h4><p><code>Object.isExtensible</code>方法用于检查一个对象是否使用了<code>Object.preventExtensions</code>方法。也就是说，检查是否可以为一个对象添加属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br><span class="hljs-built_in">Object</span>.isExtensible(obj) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.preventExtensions(obj);<br><span class="hljs-built_in">Object</span>.isExtensible(obj) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，对<code>obj</code>对象使用<code>Object.preventExtensions</code>方法以后，再使用<code>Object.isExtensible</code>方法，返回<code>false</code>，表示已经不能添加新属性了  </p><h4 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal()"></a>Object.seal()</h4><p><code>Object.seal</code>方法使得一个对象既无法添加新属性，也无法删除旧属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;;<br><span class="hljs-built_in">Object</span>.seal(obj);<br><br><span class="hljs-keyword">delete</span> obj.p;<br>obj.p <span class="hljs-comment">// &quot;hello&quot;</span><br><br>obj.x = <span class="hljs-string">&#x27;world&#x27;</span>;<br>obj.x <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象执行<code>Object.seal</code>方法以后，就无法添加新属性和删除旧属性了  </p><p><code>Object.seal</code>实质是把属性描述对象的<code>configurable</code>属性设为<code>false</code>，因此属性描述对象不再能改变了  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-string">&#x27;a&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// seal方法之前</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;p&#x27;</span>)<br><span class="hljs-comment">// Object &#123;</span><br><span class="hljs-comment">//   value: &quot;a&quot;,</span><br><span class="hljs-comment">//   writable: true,</span><br><span class="hljs-comment">//   enumerable: true,</span><br><span class="hljs-comment">//   configurable: true</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-built_in">Object</span>.seal(obj);<br><br><span class="hljs-comment">// seal方法之后</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;p&#x27;</span>)<br><span class="hljs-comment">// Object &#123;</span><br><span class="hljs-comment">//   value: &quot;a&quot;,</span><br><span class="hljs-comment">//   writable: true,</span><br><span class="hljs-comment">//   enumerable: true,</span><br><span class="hljs-comment">//   configurable: false</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  enumerable: <span class="hljs-literal">false</span><br>&#125;)<br><span class="hljs-comment">// TypeError: Cannot redefine property: p</span><br></code></pre></td></tr></table></figure><p>上面代码中，使用<code>Object.seal</code>方法之后，属性描述对象的<code>configurable</code>属性就变成了<code>false</code>，然后改变<code>enumerable</code>属性就会报错  </p><p><code>Object.seal</code>只是禁止新增或删除属性，并不影响修改某个属性的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><span class="hljs-built_in">Object</span>.seal(obj);<br>obj.p = <span class="hljs-string">&#x27;b&#x27;</span>;<br>obj.p <span class="hljs-comment">// &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Object.seal</code>方法对<code>p</code>属性的<code>value</code>无效，是因为此时<code>p</code>属性的可写性由<code>writable</code>决定  </p><h4 id="Object-isSealed"><a href="#Object-isSealed" class="headerlink" title="Object.isSealed()"></a>Object.isSealed()</h4><p><code>Object.isSealed</code>方法用于检查一个对象是否使用了<code>Object.seal</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><br><span class="hljs-built_in">Object</span>.seal(obj);<br><span class="hljs-built_in">Object</span>.isSealed(obj) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>这时，<code>Object.isExtensible</code>方法也返回<code>false</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><br><span class="hljs-built_in">Object</span>.seal(obj);<br><span class="hljs-built_in">Object</span>.isExtensible(obj) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h4><p><code>Object.freeze</code>方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.freeze(obj);<br><br>obj.p = <span class="hljs-string">&#x27;world&#x27;</span>;<br>obj.p <span class="hljs-comment">// &quot;hello&quot;</span><br><br>obj.t = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>obj.t <span class="hljs-comment">// undefined</span><br><br><span class="hljs-keyword">delete</span> obj.p <span class="hljs-comment">// false</span><br>obj.p <span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，对<code>obj</code>对象进行<code>Object.freeze()</code>以后，修改属性、新增属性、删除属性都无效了。这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错  </p><h4 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen()"></a>Object.isFrozen()</h4><p><code>Object.isFrozen</code>方法用于检查一个对象是否使用了<code>Object.freeze</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.freeze(obj);<br><span class="hljs-built_in">Object</span>.isFrozen(obj) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>使用<code>Object.freeze</code>方法以后，<code>Object.isSealed</code>将会返回<code>true</code>，<code>Object.isExtensible</code>返回<code>false</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.freeze(obj);<br><br><span class="hljs-built_in">Object</span>.isSealed(obj) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.isExtensible(obj) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><code>Object.isFrozen</code>的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.freeze(obj);<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.isFrozen(obj)) &#123;<br>  obj.p = <span class="hljs-string">&#x27;world&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，确认<code>obj</code>没有被冻结后，再对它的属性赋值，就不会报错了  </p><h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.preventExtensions(obj);<br><br><span class="hljs-keyword">var</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(obj);<br>proto.t = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>obj.t<br><span class="hljs-comment">// hello</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>本身不能新增属性，但是可以在它的原型对象上新增属性，就依然能够在<code>obj</code>上读到  </p><p>一种解决方案是，把<code>obj</code>的原型也冻结住  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.preventExtensions(obj);<br><br><span class="hljs-keyword">var</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(obj);<br><span class="hljs-built_in">Object</span>.preventExtensions(proto);<br><br>proto.t = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>obj.t <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  foo: <span class="hljs-number">1</span>,<br>  bar: [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br>&#125;;<br><span class="hljs-built_in">Object</span>.freeze(obj);<br><br>obj.bar.push(<span class="hljs-string">&#x27;c&#x27;</span>);<br>obj.bar <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.bar</code>属性指向一个数组，<code>obj</code>对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的  </p><h1 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>Array</code>是<code>Javascript</code>的原生对象，同时也是一个构造函数，可以用它生成新的数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>);<br>arr.length <span class="hljs-comment">// 2</span><br>arr <span class="hljs-comment">// [ empty x 2 ]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Array()</code>构造函数的参数<code>2</code>，表示生成一个两个成员的数组，每个位置都是空值  </p><p>如果没有使用<code>new</code>关键字，运行结果也是一样的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><p>考虑到语义性，以及与其他构造函数用户保持一致，建议总是加上<code>new</code>  </p><p><code>Array()</code>构造函数有一个很大的缺陷，不同的参数会导致行为不一致  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 无参数时，返回一个空数组</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>() <span class="hljs-comment">// []</span><br><br><span class="hljs-comment">// 单个正整数参数，表示返回的新数组的长度</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// [ empty ]</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// [ empty x 2 ]</span><br><br><span class="hljs-comment">// 非正整数的数值作为参数，会报错</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3.2</span>) <span class="hljs-comment">// RangeError: Invalid array length</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(-<span class="hljs-number">3</span>) <span class="hljs-comment">// RangeError: Invalid array length</span><br><br><span class="hljs-comment">// 单个非数值（比如字符串、布尔值、对象等）作为参数，</span><br><span class="hljs-comment">// 则该参数是返回的新数组的成员</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) <span class="hljs-comment">// [&#x27;abc&#x27;]</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>([<span class="hljs-number">1</span>]) <span class="hljs-comment">// [Array[1]]</span><br><br><span class="hljs-comment">// 多参数时，所有参数都是返回的新数组的成员</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [1, 2]</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure><p>可以看到，<code>Array()</code>作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br></code></pre></td></tr></table></figure><p>注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回<code>undefined</code>，但实际上该位置没有任何值。虽然这时可以读取到<code>length</code>属性，但是取不到键名  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> b = [<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>];<br><br>a.length <span class="hljs-comment">// 3</span><br>b.length <span class="hljs-comment">// 3</span><br><br>a[<span class="hljs-number">0</span>] <span class="hljs-comment">// undefined</span><br>b[<span class="hljs-number">0</span>] <span class="hljs-comment">// undefined</span><br><br><span class="hljs-number">0</span> <span class="hljs-keyword">in</span> a <span class="hljs-comment">// false</span><br><span class="hljs-number">0</span> <span class="hljs-keyword">in</span> b <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>a</code>是<code>Array()</code>生成的一个长度为3的空数组，<code>b</code>是一个三个成员都是<code>undefined</code>的数组，这两个数组是不一样的。读取键值的时候，<code>a</code>和<code>b</code>都返回<code>undefined</code>，但是<code>a</code>的键名（成员的序号）都是空的，<code>b</code>的键名是有值的  </p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p><code>Array.isArray</code>方法返回一个布尔值，表示参数是否为数组。它可以弥补<code>typeof</code>运算符的不足  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">typeof</span> arr <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-built_in">Array</span>.isArray(arr) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>typeof</code>运算符只能显示数组的类型是<code>Object</code>，而<code>Array.isArray</code>方法可以识别数组  </p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="valueOf-，toString"><a href="#valueOf-，toString" class="headerlink" title="valueOf()，toString()"></a>valueOf()，toString()</h3><p><code>valueOf</code>方法是一个所有对象都拥有的方法，表示对该对象求值  </p><p>不同对象的<code>valueOf</code>方法不尽一致，数组的<code>valueOf</code>方法返回数组本身  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.valueOf() <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><p><code>toString</code>方法也是对象的通用方法，数组的<code>toString</code>方法返回数组的字符串形式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.toString() <span class="hljs-comment">// &quot;1,2,3&quot;</span><br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]];<br>arr.toString() <span class="hljs-comment">// &quot;1,2,3,4,5,6&quot;</span><br></code></pre></td></tr></table></figure><h3 id="push-，pop"><a href="#push-，pop" class="headerlink" title="push()，pop()"></a>push()，pop()</h3><p><code>push</code>方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<br><br>arr.push(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br>arr.push(<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">// 2</span><br>arr.push(<span class="hljs-literal">true</span>, &#123;&#125;) <span class="hljs-comment">// 4</span><br>arr <span class="hljs-comment">// [1, &#x27;a&#x27;, true, &#123;&#125;]</span><br></code></pre></td></tr></table></figure><p>上面代码使用<code>push</code>方法，往数组中添加了四个成员  </p><p><code>pop</code>方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>arr.pop() <span class="hljs-comment">// &#x27;c&#x27;</span><br>arr <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span><br></code></pre></td></tr></table></figure><p>对空数组使用<code>pop</code>方法，不会报错，而是返回<code>undefined</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[].pop() <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p><code>push</code>和<code>pop</code>结合使用，就构成了“后进先出”的栈结构（stack）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<br>arr.push(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>arr.push(<span class="hljs-number">3</span>);<br>arr.pop();<br>arr <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>3</code>是最后进入数组的，但是最早离开数组  </p><h3 id="shift-，unshift"><a href="#shift-，unshift" class="headerlink" title="shift()，unshift()"></a>shift()，unshift()</h3><p><code>shift()</code>方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>a.shift() <span class="hljs-comment">// &#x27;a&#x27;</span><br>a <span class="hljs-comment">// [&#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，使用<code>shift()</code>方法以后，原数组就变了  </p><p><code>shift()</code>方法可以遍历并清空一个数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> item;<br><br><span class="hljs-keyword">while</span> (item = list.shift()) &#123;<br>  <span class="hljs-built_in">console</span>.log(item);<br>&#125;<br><br>list <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><p>上面代码通过<code>list.shift()</code>方法每次取出一个元素，从而遍历数组  </p><p>它的前提是数组元素不能是<code>0</code>或任何布尔值等于<code>false</code>的元素，因此这样的遍历不是很可靠  </p><p><code>push()</code>和<code>shift()</code>结合使用，就构成了“先进先出”的队列结构（queue）  </p><p><code>unshift()</code>方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>a.unshift(<span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// 4</span><br>a <span class="hljs-comment">// [&#x27;x&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure><p><code>unshift()</code>方法可以接受多个参数，这些参数都会添加到目标数组头部  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [ <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span> ];<br>arr.unshift(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// 4</span><br>arr <span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span><br></code></pre></td></tr></table></figure><h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p><code>join()</code>方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br>a.join(<span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-comment">// &#x27;1 2 3 4&#x27;</span><br>a.join(<span class="hljs-string">&#x27; | &#x27;</span>) <span class="hljs-comment">// &quot;1 | 2 | 3 | 4&quot;</span><br>a.join() <span class="hljs-comment">// &quot;1,2,3,4&quot;</span><br></code></pre></td></tr></table></figure><p>如果数组成员是<code>undefined</code>或<code>null</code>或空位，会被转成空字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>].join(<span class="hljs-string">&#x27;#&#x27;</span>)<br><span class="hljs-comment">// &#x27;#&#x27;</span><br><br>[<span class="hljs-string">&#x27;a&#x27;</span>,, <span class="hljs-string">&#x27;b&#x27;</span>].join(<span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-comment">// &#x27;a--b&#x27;</span><br></code></pre></td></tr></table></figure><p>通过<code>call</code>方法，这个方法也可以用于字符串或类似数组的对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.join.call(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-comment">// &quot;h-e-l-l-o&quot;</span><br><br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-built_in">Array</span>.prototype.join.call(obj, <span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-comment">// &#x27;a-b&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p><code>concat</code>方法用于多个数组的合并  </p><p>它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;hello&#x27;</span>].concat([<span class="hljs-string">&#x27;world&#x27;</span>])<br><span class="hljs-comment">// [&quot;hello&quot;, &quot;world&quot;]</span><br><br>[<span class="hljs-string">&#x27;hello&#x27;</span>].concat([<span class="hljs-string">&#x27;world&#x27;</span>], [<span class="hljs-string">&#x27;!&#x27;</span>])<br><span class="hljs-comment">// [&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;]</span><br><br>[].concat(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;)<br><span class="hljs-comment">// [&#123; a: 1 &#125;, &#123; b: 2 &#125;]</span><br><br>[<span class="hljs-number">2</span>].concat(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;)<br><span class="hljs-comment">// [2, &#123;a: 1&#125;]</span><br></code></pre></td></tr></table></figure><p>除了数组作为参数，<code>concat</code>也接受其他类型的值作为参数，添加到目标数组尾部  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].concat(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br><span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><p>如果数组成员包括对象，<code>concat</code>方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">var</span> oldArray = [obj];<br><br><span class="hljs-keyword">var</span> newArray = oldArray.concat();<br><br>obj.a = <span class="hljs-number">2</span>;<br>newArray[<span class="hljs-number">0</span>].a <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，原数组包含一个对象，<code>concat</code>方法生成的新数组包含这个对象的引用。所以，改变原对象以后，新数组跟着改变  </p><h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p><code>reverse</code>方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>a.reverse() <span class="hljs-comment">// [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span><br>a <span class="hljs-comment">// [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span><br></code></pre></td></tr></table></figure><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p><code>slice()</code>方法用于提取目标数组的一部分，返回一个新数组，原数组不变  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.slice(start, end);<br></code></pre></td></tr></table></figure><p>它的第一个参数为起始位置（从0开始，会包括在返回的新数组之中），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>a.slice(<span class="hljs-number">0</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br>a.slice(<span class="hljs-number">1</span>) <span class="hljs-comment">// [&quot;b&quot;, &quot;c&quot;]</span><br>a.slice(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;b&quot;]</span><br>a.slice(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// [&quot;c&quot;]</span><br>a.slice() <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，最后一个例子<code>slice()</code>没有参数，实际上等于返回一个原数组的拷贝  </p><p>如果<code>slice()</code>方法的参数是负数，则表示倒数计算的位置  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>a.slice(-<span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;b&quot;, &quot;c&quot;]</span><br>a.slice(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment">// [&quot;b&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>-2</code>表示倒数计算的第二个位置，<code>-1</code>表示倒数计算的第一个位置  </p><p>如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>a.slice(<span class="hljs-number">4</span>) <span class="hljs-comment">// []</span><br>a.slice(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><p><code>slice()</code>方法的一个重要应用，是将类似数组的对象转为真正的数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.slice.call(&#123; <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">2</span> &#125;)<br><span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><br><span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;div&quot;</span>));<br><span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);<br></code></pre></td></tr></table></figure><p>上面代码的参数都不是数组，但是通过<code>call</code>方法，在它们上面调用<code>slice()</code>方法，就可以把它们转为真正的数组  </p><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p><code>splice()</code>方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">arr.splice(start, count, addElement1, addElement2, ...);<br></code></pre></td></tr></table></figure><p><code>splice</code>的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>];<br>a.splice(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;e&quot;, &quot;f&quot;]</span><br>a <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码从原数组4号位置，删除了两个数组成员  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>];<br>a.splice(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;e&quot;, &quot;f&quot;]</span><br>a <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2]</span><br></code></pre></td></tr></table></figure><p>上面代码除了删除成员，还插入了两个新成员  </p><p>起始位置如果是负数，就表示从倒数位置开始删除  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>];<br>a.splice(-<span class="hljs-number">4</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;c&quot;, &quot;d&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码表示，从倒数第四个位置<code>c</code>开始删除两个成员  </p><p>如果只是单纯地插入元素，<code>splice</code>方法的第二个参数可以设为<code>0</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>];<br><br>a.splice(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// []</span><br>a <span class="hljs-comment">// [1, 2, 1, 1]</span><br></code></pre></td></tr></table></figure><p>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>a.splice(<span class="hljs-number">2</span>) <span class="hljs-comment">// [3, 4]</span><br>a <span class="hljs-comment">// [1, 2]</span><br></code></pre></td></tr></table></figure><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p><code>sort</code>方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>].sort()<br><span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><br>[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>].sort()<br><span class="hljs-comment">// [1, 2, 3, 4]</span><br><br>[<span class="hljs-number">11</span>, <span class="hljs-number">101</span>].sort()<br><span class="hljs-comment">// [101, 11]</span><br><br>[<span class="hljs-number">10111</span>, <span class="hljs-number">1101</span>, <span class="hljs-number">111</span>].sort()<br><span class="hljs-comment">// [10111, 1101, 111]</span><br></code></pre></td></tr></table></figure><p>上面代码的最后两个例子，需要特殊注意。<code>sort()</code>方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以<code>101</code>排在<code>11</code>的前面  </p><p>如果想让<code>sort</code>方法按照自定义方式排序，可以传入一个函数作为参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">10111</span>, <span class="hljs-number">1101</span>, <span class="hljs-number">111</span>].sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a - b;<br>&#125;)<br><span class="hljs-comment">// [111, 1101, 10111]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>sort</code>的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于<code>0</code>，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">24</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span>  &#125;<br>].sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o1, o2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> o1.age - o2.age;<br>&#125;)<br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//   &#123; name: &quot;李四&quot;, age: 24 &#125;,</span><br><span class="hljs-comment">//   &#123; name: &quot;王五&quot;, age: 28  &#125;,</span><br><span class="hljs-comment">//   &#123; name: &quot;张三&quot;, age: 30 &#125;</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure><p>注意，自定义的排序函数应该返回数值，否则不同的浏览器可能有不同的实现，不能保证结果都一致  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a &gt; b)<br><br><span class="hljs-comment">// good</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)<br></code></pre></td></tr></table></figure><p>上面代码中，前一种排序算法返回的是布尔值，这是不推荐使用的。后一种是数值，才是更好的写法  </p><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><code>map</code>方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>numbers.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>&#125;);<br><span class="hljs-comment">// [2, 3, 4]</span><br><br>numbers<br><span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>numbers</code>数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化  </p><p><code>map</code>方法接受一个函数作为参数。该函数调用时，<code>map</code>方法向它传入三个参数：当前成员、当前位置和数组本身  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> elem * index;<br>&#125;);<br><span class="hljs-comment">// [0, 2, 6]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>map</code>方法的回调函数有三个参数，<code>elem</code>为当前成员的值，<code>index</code>为当前成员的位置，<code>arr</code>为原数组（<code>[1, 2, 3]</code>）  </p><p><code>map</code>方法还可以接受第二个参数，用来绑定回调函数内部的<code>this</code>变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>[e];<br>&#125;, arr)<br><span class="hljs-comment">// [&#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure><p>上面代码通过<code>map</code>方法的第二个参数，将回调函数内部的<code>this</code>对象，指向<code>arr</code>数组  </p><p>如果数组有空位，<code>map</code>方法的回调函数在这个位置不会执行，会跳过数组的空位  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>].map(f) <span class="hljs-comment">// [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>].map(f) <span class="hljs-comment">// [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br>[<span class="hljs-number">1</span>, , <span class="hljs-number">2</span>].map(f) <span class="hljs-comment">// [&quot;a&quot;, , &quot;a&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>map</code>方法不会跳过<code>undefined</code>和<code>null</code>，但是会跳过空位  </p><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p><code>forEach</code>方法与<code>map</code>方法很相似，也是对数组的所有成员依次执行参数函数。但是，<code>forEach</code>方法不返回值，只用来操作数据  </p><p>这就是说，如果数组遍历的目的是为了得到返回值，那么使用<code>map</code>方法，否则使用<code>forEach</code>方法  </p><p><code>forEach</code>的用法与<code>map</code>方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params">element, index, array</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;[&#x27;</span> + index + <span class="hljs-string">&#x27;] = &#x27;</span> + element);<br>&#125;<br><br>[<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>].forEach(log);<br><span class="hljs-comment">// [0] = 2</span><br><span class="hljs-comment">// [1] = 5</span><br><span class="hljs-comment">// [2] = 9</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>forEach</code>遍历数组不是为了得到返回值，而是为了在屏幕输出内容，所以不必使用<code>map</code>方法  </p><p><code>forEach</code>方法也可以接受第二个参数，绑定参数函数的<code>this</code>变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> out = [];<br><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.push(elem * elem);<br>&#125;, out);<br><br>out <span class="hljs-comment">// [1, 4, 9]</span><br></code></pre></td></tr></table></figure><p>上面代码中，空数组<code>out</code>是<code>forEach</code>方法的第二个参数，结果，回调函数内部的<code>this</code>关键字就指向<code>out</code>  </p><p>注意，<code>forEach</code>方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用<code>for</code>循环  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>  <span class="hljs-keyword">if</span> (arr[i] === <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;<br>  <span class="hljs-built_in">console</span>.log(arr[i]);<br>&#125;<br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，执行到数组的第二个成员时，就会中断执行。<code>forEach</code>方法做不到这一点  </p><p><code>forEach</code>方法也会跳过数组的空位  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> log = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(n + <span class="hljs-number">1</span>);<br>&#125;;<br><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>].forEach(log)<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 3</span><br><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>].forEach(log)<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 3</span><br><br>[<span class="hljs-number">1</span>, , <span class="hljs-number">2</span>].forEach(log)<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>forEach</code>方法不会跳过<code>undefined</code>和<code>null</code>，但会跳过空位  </p><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p><code>filter</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回  </p><p>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为<code>true</code>的成员组成一个新数组返回。该方法不会改变原数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (elem &gt; <span class="hljs-number">3</span>);<br>&#125;)<br><span class="hljs-comment">// [4, 5]</span><br></code></pre></td></tr></table></figure><p>上面代码将大于<code>3</code>的数组成员，作为一个新数组返回  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">false</span>];<br><br>arr.filter(<span class="hljs-built_in">Boolean</span>)<br><span class="hljs-comment">// [1, &quot;a&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>filter</code>方法返回数组<code>arr</code>里面所有布尔值为<code>true</code>的成员  </p><p><code>filter</code>方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> index % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;<br>&#125;);<br><span class="hljs-comment">// [1, 3, 5]</span><br></code></pre></td></tr></table></figure><p>上面代码返回偶数位置的成员组成的新数组  </p><p><code>filter</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">MAX</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">var</span> myFilter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (item &gt; <span class="hljs-built_in">this</span>.MAX) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>];<br>arr.filter(myFilter, obj) <span class="hljs-comment">// [8, 4, 9]</span><br></code></pre></td></tr></table></figure><p>上面代码中，过滤器<code>myFilter</code>内部有<code>this</code>变量，它可以被<code>filter</code>方法的第二个参数<code>obj</code>绑定，返回大于<code>3</code>的成员  </p><h3 id="some-，every"><a href="#some-，every" class="headerlink" title="some()，every()"></a>some()，every()</h3><p>这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件  </p><p>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值  </p><p><code>some</code>方法是只要一个成员的返回值是<code>true</code>，则整个<code>some</code>方法的返回值就是<code>true</code>，否则返回<code>false</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>arr.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> elem &gt;= <span class="hljs-number">3</span>;<br>&#125;);<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，如果数组<code>arr</code>有一个成员大于等于3，<code>some</code>方法就返回<code>true</code>  </p><p><code>every</code>方法是所有成员的返回值都是<code>true</code>，整个<code>every</code>方法才返回<code>true</code>，否则返回<code>false</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>arr.every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> elem &gt;= <span class="hljs-number">3</span>;<br>&#125;);<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，数组<code>arr</code>并非所有成员大于等于<code>3</code>，所以返回<code>false</code>  </p><p>注意，对于空数组，<code>some</code>方法返回<code>false</code>，<code>every</code>方法返回<code>true</code>，回调函数都不会执行  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">x</span>) </span>&#123; <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> &#125;<br><br>[].some(isEven) <span class="hljs-comment">// false</span><br>[].every(isEven) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>some</code>和<code>every</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量  </p><h3 id="reduce-，reduceRight"><a href="#reduce-，reduceRight" class="headerlink" title="reduce()，reduceRight()"></a>reduce()，reduceRight()</h3><p><code>reduce</code>方法和<code>reduceRight</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a, b);<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;)<br><span class="hljs-comment">// 1 2</span><br><span class="hljs-comment">// 3 3</span><br><span class="hljs-comment">// 6 4</span><br><span class="hljs-comment">// 10 5</span><br><span class="hljs-comment">//最后结果：15</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>reduce</code>方法求出数组所有成员的和。第一次执行，<code>a</code>是数组的第一个成员<code>1</code>，<code>b</code>是数组的第二个成员<code>2</code>。第二次执行，<code>a</code>为上一轮的返回值<code>3</code>，<code>b</code>为第三个成员<code>3</code>。第三次执行，<code>a</code>为上一轮的返回值<code>6</code>，<code>b</code>为第四个成员<code>4</code>。第四次执行，<code>a</code>为上一轮返回值<code>10</code>，<code>b</code>为第五个成员<code>5</code>。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值<code>15</code>。</p><p><code>reduce</code>方法和<code>reduceRight</code>方法的第一个参数都是一个函数。该函数接受以下四个参数  </p><ol><li>累积变量，默认为数组的第一个成员</li><li>当前变量，默认为数组的第二个成员</li><li>当前位置（从0开始）</li><li>原数组</li></ol><p>这四个参数之中，只有前两个是必须的，后两个则是可选的。</p><p>如果要对累积变量指定初值，可以把它放在<code>reduce</code>方法和<code>reduceRight</code>方法的第二个参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;, <span class="hljs-number">10</span>);<br><span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><p>上面代码指定参数<code>a</code>的初值为10，所以数组从10开始累加，最终结果为25。注意，这时<code>b</code>是从数组的第一个成员开始遍历  </p><p>上面的第二个参数相当于设定了默认值，处理空数组时尤其有用  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">prev, cur</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> prev + cur;<br>&#125;<br><br>[].reduce(add)<br><span class="hljs-comment">// TypeError: Reduce of empty array with no initial value</span><br>[].reduce(add, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，由于空数组取不到初始值，<code>reduce</code>方法会报错。这时，加上第二个参数，就能保证总是会返回一个值  </p><p>下面是一个<code>reduceRight</code>方法的例子  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subtract</span>(<span class="hljs-params">prev, cur</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> prev - cur;<br>&#125;<br><br>[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>].reduce(subtract) <span class="hljs-comment">// 0</span><br>[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>].reduceRight(subtract) <span class="hljs-comment">// -4</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>reduce</code>方法相当于<code>3</code>减去<code>2</code>再减去<code>1</code>，<code>reduceRight</code>方法相当于<code>1</code>减去<code>2</code>再减去<code>3</code>  </p><p>由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。比如，找出字符长度最长的数组成员  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLongest</span>(<span class="hljs-params">entries</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> entries.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">longest, entry</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> entry.length &gt; longest.length ? entry : longest;<br>  &#125;, <span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br><br>findLongest([<span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]) <span class="hljs-comment">// &quot;aaa&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>reduce</code>的参数函数会将字符长度较长的那个数组成员，作为累积值。这导致遍历所有成员之后，累积值就是字符长度最长的那个成员  </p><h3 id="indexOf-，lastIndexOf"><a href="#indexOf-，lastIndexOf" class="headerlink" title="indexOf()，lastIndexOf()"></a>indexOf()，lastIndexOf()</h3><p><code>indexOf</code>方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回<code>-1</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>a.indexOf(<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// 1</span><br>a.indexOf(<span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><p><code>indexOf</code>方法还可以接受第二个参数，表示搜索的开始位置  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>].indexOf(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><p>上面代码从1号位置开始搜索字符<code>a</code>，结果为<code>-1</code>，表示没有搜索到  </p><p><code>lastIndexOf</code>方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回<code>-1</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>];<br>a.lastIndexOf(<span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br>a.lastIndexOf(<span class="hljs-number">7</span>) <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><p>注意，这两个方法不能用来搜索<code>NaN</code>的位置，即它们无法确定数组成员是否包含<code>NaN</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-literal">NaN</span>].indexOf(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// -1</span><br>[<span class="hljs-literal">NaN</span>].lastIndexOf(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><p>这是因为这两个方法内部，使用严格相等运算符（<code>===</code>）进行比较，而<code>NaN</code>是唯一一个不等于自身的值  </p><h3 id="链式使用"><a href="#链式使用" class="headerlink" title="链式使用"></a>链式使用</h3><p>上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> users = [<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;tom@example.com&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;peter&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;peter@example.com&#x27;</span>&#125;<br>];<br><br>users<br>.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> user.email;<br>&#125;)<br>.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">email</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^t/</span>.test(email);<br>&#125;)<br>.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">email</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(email);<br>&#125;);<br><span class="hljs-comment">// &quot;tom@example.com&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，先产生一个所有 Email 地址组成的数组，然后再过滤出以<code>t</code>开头的 Email 地址，最后将它打印出来  </p><h2 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对象是 JavaScript 语言最主要的数据类型，三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”（wrapper）  </p><p>所谓“包装对象”，指的是与数值、字符串、布尔值分别相对应的<code>Number</code>、<code>String</code>、<code>Boolean</code>三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> v1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>);<br><span class="hljs-keyword">var</span> v2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);<br><span class="hljs-keyword">var</span> v3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-keyword">typeof</span> v1 <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> v2 <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> v3 <span class="hljs-comment">// &quot;object&quot;</span><br><br>v1 === <span class="hljs-number">123</span> <span class="hljs-comment">// false</span><br>v2 === <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-comment">// false</span><br>v3 === <span class="hljs-literal">true</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，基于原始类型的值，生成了三个对应的包装对象。可以看到，<code>v1</code>、<code>v2</code>、<code>v3</code>都是对象，且与对应的简单类型值不相等  </p><p>包装对象的设计目的，首先是使得“对象”这种类型可以覆盖 <code>Javascript</code> 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法  </p><p><code>Number</code>、<code>String</code>和<code>Boolean</code>这三个原生对象，如果不作为构造函数调用（即调用时不加<code>new</code>），而是作为普通函数调用，常常用于将任意类型的值转为数值、字符串和布尔值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 字符串转为数值</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;123&#x27;</span>) <span class="hljs-comment">// 123</span><br><br><span class="hljs-comment">// 数值转为字符串</span><br><span class="hljs-built_in">String</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// &quot;123&quot;</span><br><br><span class="hljs-comment">// 数值转为布尔值</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>总结一下，这三个对象作为构造函数使用（带有<code>new</code>）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有<code>new</code>），可以将任意类型的值，转为原始类型的值  </p><h3 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a>实例方法</h3><p>三种包装对象各自提供了许多实例方法。这里介绍两种它们共同具有、从<code>Object</code>对象继承的方法：<code>valueOf()</code>和<code>toString()</code>  </p><h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h4><p><code>valueOf()</code>方法返回包装对象实例对应的原始类型的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>).valueOf()  <span class="hljs-comment">// 123</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>).valueOf() <span class="hljs-comment">// &quot;abc&quot;</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>).valueOf() <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p><code>toString()</code>方法返回对应的字符串形式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>).toString() <span class="hljs-comment">// &quot;123&quot;</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>).toString() <span class="hljs-comment">// &quot;abc&quot;</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>).toString() <span class="hljs-comment">// &quot;true&quot;</span><br></code></pre></td></tr></table></figure><h3 id="原始类型与实例对象的自动转换"><a href="#原始类型与实例对象的自动转换" class="headerlink" title="原始类型与实例对象的自动转换"></a>原始类型与实例对象的自动转换</h3><p>某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法  </p><p>这时，<code>Javascript</code> 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例  </p><p>比如，字符串可以调用<code>length</code>属性，返回字符串的长度  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.length <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>abc</code>是一个字符串，本身不是对象，不能调用<code>length</code>属性。<code>Javascript</code> 引擎自动将其转为包装对象，在这个对象上调用<code>length</code>属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>str.length <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">var</span> strObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(str)<br><span class="hljs-comment">// String &#123;</span><br><span class="hljs-comment">//   0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;</span><br><span class="hljs-comment">// &#125;</span><br>strObj.length <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面代码中，字符串<code>abc</code>的包装对象提供了多个属性，<code>length</code>只是其中之一  </p><p>自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br>s.x = <span class="hljs-number">123</span>;<br>s.x <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>上面代码为字符串<code>s</code>添加了一个<code>x</code>属性，结果无效，总是返回<code>undefined</code>  </p><p>另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象<code>String.prototype</code>上定义  </p><h3 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h3><p>除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用   </p><p>比如，我们可以新增一个<code>double</code>方法，使得字符串和数字翻倍  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.prototype.double = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.valueOf() + <span class="hljs-built_in">this</span>.valueOf();<br>&#125;;<br><br><span class="hljs-string">&#x27;abc&#x27;</span>.double()<br><span class="hljs-comment">// abcabc</span><br><br><span class="hljs-built_in">Number</span>.prototype.double = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.valueOf() + <span class="hljs-built_in">this</span>.valueOf();<br>&#125;;<br><br>(<span class="hljs-number">123</span>).double() <span class="hljs-comment">// 246</span><br></code></pre></td></tr></table></figure><p>上面代码在<code>String</code>和<code>Number</code>这两个对象的原型上面，分别自定义了一个方法，从而可以在所有实例对象上调用。注意，最后一行的<code>123</code>外面必须要加上圆括号，否则后面的点运算符（<code>.</code>）会被解释成小数点  </p><h2 id="Boolean-对象"><a href="#Boolean-对象" class="headerlink" title="Boolean 对象"></a>Boolean 对象</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><code>Boolean</code>对象是 <code>Javascript</code> 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-keyword">typeof</span> b <span class="hljs-comment">// &quot;object&quot;</span><br>b.valueOf() <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码的变量<code>b</code>是一个<code>Boolean</code>对象的实例，它的类型是对象，值为布尔值<code>true</code>  </p><p>注意，<code>false</code>对应的包装对象实例，布尔运算结果也是<code>true</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>).valueOf()) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// 无输出</span><br></code></pre></td></tr></table></figure><p>上面代码的第一个例子之所以得到<code>true</code>，是因为<code>false</code>对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值<code>true</code>（因为所有对象对应的布尔值都是<code>true</code>）。而实例的<code>valueOf</code>方法，则返回实例对应的原始值，本例为<code>false</code>  </p><h3 id="Boolean-函数的类型转换作用"><a href="#Boolean-函数的类型转换作用" class="headerlink" title="Boolean 函数的类型转换作用"></a>Boolean 函数的类型转换作用</h3><p><code>Boolean</code>对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时<code>Boolean</code>就是一个单纯的工具方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span><br><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;false&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>([]) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>(&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-regexp">/foo/</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中几种得到<code>true</code>的情况，都值得认真记住  </p><p>顺便提一下，使用双重的否运算符（<code>!</code>）也可以将任意值转为对应的布尔值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">!!<span class="hljs-literal">undefined</span> <span class="hljs-comment">// false</span><br>!!<span class="hljs-literal">null</span> <span class="hljs-comment">// false</span><br>!!<span class="hljs-number">0</span> <span class="hljs-comment">// false</span><br>!!<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// false</span><br>!!<span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><br>!!<span class="hljs-number">1</span> <span class="hljs-comment">// true</span><br>!!<span class="hljs-string">&#x27;false&#x27;</span> <span class="hljs-comment">// true</span><br>!![] <span class="hljs-comment">// true</span><br>!!&#123;&#125; <span class="hljs-comment">// true</span><br>!!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125; <span class="hljs-comment">// true</span><br>!!<span class="hljs-regexp">/foo/</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>最后，对于一些特殊值，<code>Boolean</code>对象前面加不加<code>new</code>，会得到完全相反的结果，必须小心  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// 无输出</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// 无输出</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h2 id="Number-对象"><a href="#Number-对象" class="headerlink" title="Number 对象"></a>Number 对象</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><code>Number</code>对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用  </p><p>作为构造函数时，它用于生成值为数值的对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">typeof</span> n <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Number</code>对象作为构造函数使用，返回一个值为<code>1</code>的对象  </p><p>作为工具函数时，它可以将任何类型的值转为数值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码将布尔值<code>true</code>转为数值<code>1</code>  </p><h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p><code>Number</code>对象拥有以下一些静态属性（即直接定义在<code>Number</code>对象上的属性，而不是定义在实例上的属性）  </p><ul><li><code>Number.POSITIVE_INFINITY</code>：正的无限，指向<code>Infinity</code>  </li><li><code>Number.NEGATIVE_INFINITY</code>：负的无限，指向<code>-Infinity</code>  </li><li><code>Number.NaN</code>：表示非数值，指向<code>NaN</code>   </li><li><code>Number.MIN_VALUE</code>：表示最小的正数（即最接近0的正数，在64位浮点数体系中为<code>5e-324</code>），相应的，最接近0的负数为<code>-Number.MIN_VALUE</code>  </li><li><code>Number.MAX_SAFE_INTEGER</code>：表示能够精确表示的最大整数，即<code>9007199254740991</code>   </li><li><code>Number.MIN_SAFE_INTEGER</code>：表示能够精确表示的最小整数，即<code>-9007199254740991</code>  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>.POSITIVE_INFINITY <span class="hljs-comment">// Infinity</span><br><span class="hljs-built_in">Number</span>.NEGATIVE_INFINITY <span class="hljs-comment">// -Infinity</span><br><span class="hljs-built_in">Number</span>.NaN <span class="hljs-comment">// NaN</span><br><br><span class="hljs-built_in">Number</span>.MAX_VALUE<br><span class="hljs-comment">// 1.7976931348623157e+308</span><br><span class="hljs-built_in">Number</span>.MAX_VALUE &lt; <span class="hljs-literal">Infinity</span><br><span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">Number</span>.MIN_VALUE<br><span class="hljs-comment">// 5e-324</span><br><span class="hljs-built_in">Number</span>.MIN_VALUE &gt; <span class="hljs-number">0</span><br><span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER <span class="hljs-comment">// 9007199254740991</span><br><span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER <span class="hljs-comment">// -9007199254740991</span><br></code></pre></td></tr></table></figure><h3 id="实例方法-2"><a href="#实例方法-2" class="headerlink" title="实例方法"></a>实例方法</h3><p><code>Number</code>对象有4个实例方法，都跟将数值转换成指定格式有关  </p><h4 id="Number-prototype-toString"><a href="#Number-prototype-toString" class="headerlink" title="Number.prototype.toString()"></a>Number.prototype.toString()</h4><p><code>Number</code>对象部署了自己的<code>toString</code>方法，用来将一个数值转为字符串形式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-number">10</span>).toString() <span class="hljs-comment">// &quot;10&quot;</span><br></code></pre></td></tr></table></figure><p><code>toString</code>方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-number">10</span>).toString(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010&quot;</span><br>(<span class="hljs-number">10</span>).toString(<span class="hljs-number">8</span>) <span class="hljs-comment">// &quot;12&quot;</span><br>(<span class="hljs-number">10</span>).toString(<span class="hljs-number">16</span>) <span class="hljs-comment">// &quot;a&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>10</code>一定要放在括号里，这样表明后面的点表示调用对象属性。如果不加括号，这个点会被 <code>Javascript</code> 引擎解释成小数点，从而报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">10.</span>toString(<span class="hljs-number">2</span>)<br><span class="hljs-comment">// SyntaxError: Unexpected token ILLEGAL</span><br></code></pre></td></tr></table></figure><p>只要能够让 <code>Javascript</code> 引擎不混淆小数点和对象的点运算符，各种写法都能用。除了为<code>10</code>加上括号，还可以在<code>10</code>后面加两个点，<code>Javascript</code> 会把第一个点理解成小数点（即<code>10.0</code>），把第二个点理解成调用对象属性，从而得到正确结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">10.</span>.toString(<span class="hljs-number">2</span>)<br><span class="hljs-comment">// &quot;1010&quot;</span><br><br><span class="hljs-comment">// 其他方法还包括</span><br><span class="hljs-number">10</span> .toString(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010&quot;</span><br><span class="hljs-number">10.0</span>.toString(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010&quot;</span><br></code></pre></td></tr></table></figure><p>这实际上意味着，可以直接对一个小数使用<code>toString</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">10.5</span>.toString() <span class="hljs-comment">// &quot;10.5&quot;</span><br><span class="hljs-number">10.5</span>.toString(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010.1&quot;</span><br><span class="hljs-number">10.5</span>.toString(<span class="hljs-number">8</span>) <span class="hljs-comment">// &quot;12.4&quot;</span><br><span class="hljs-number">10.5</span>.toString(<span class="hljs-number">16</span>) <span class="hljs-comment">// &quot;a.8&quot;</span><br></code></pre></td></tr></table></figure><p>通过方括号运算符也可以调用<code>toString</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">10</span>[<span class="hljs-string">&#x27;toString&#x27;</span>](<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010&quot;</span><br></code></pre></td></tr></table></figure><p><code>toString</code>方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用<code>parseInt</code>方法  </p><h4 id="Number-prototype-toFixed"><a href="#Number-prototype-toFixed" class="headerlink" title="Number.prototype.toFixed()"></a>Number.prototype.toFixed()</h4><p><code>toFixed()</code>方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-number">10</span>).toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;10.00&quot;</span><br><span class="hljs-number">10.005</span>.toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;10.01&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>10</code>和<code>10.005</code>先转成2位小数，然后转成字符串。其中<code>10</code>必须放在括号里，否则后面的点会被处理成小数点  </p><p><code>toFixed()</code>方法的参数为小数位数，有效范围为0到100，超出这个范围将抛出 RangeError 错误  </p><p>由于浮点数的原因，小数<code>5</code>的四舍五入是不确定的，使用的时候必须小心  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-number">10.055</span>).toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// 10.05</span><br>(<span class="hljs-number">10.005</span>).toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// 10.01</span><br></code></pre></td></tr></table></figure><h4 id="Number-prototype-toExponential"><a href="#Number-prototype-toExponential" class="headerlink" title="Number.prototype.toExponential()"></a>Number.prototype.toExponential()</h4><p><code>toExponential</code>方法用于将一个数转为科学计数法形式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-number">10</span>).toExponential()  <span class="hljs-comment">// &quot;1e+1&quot;</span><br>(<span class="hljs-number">10</span>).toExponential(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;1.0e+1&quot;</span><br>(<span class="hljs-number">10</span>).toExponential(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1.00e+1&quot;</span><br><br>(<span class="hljs-number">1234</span>).toExponential()  <span class="hljs-comment">// &quot;1.234e+3&quot;</span><br>(<span class="hljs-number">1234</span>).toExponential(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;1.2e+3&quot;</span><br>(<span class="hljs-number">1234</span>).toExponential(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1.23e+3&quot;</span><br></code></pre></td></tr></table></figure><p><code>toExponential</code>方法的参数是小数点后有效数字的位数，范围为0到100，超出这个范围，会抛出一个 RangeError 错误  </p><h4 id="Number-prototype-toPrecision"><a href="#Number-prototype-toPrecision" class="headerlink" title="Number.prototype.toPrecision()"></a>Number.prototype.toPrecision()</h4><p><code>Number.prototype.toPrecision()</code>方法用于将一个数转为指定位数的有效数字  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-number">12.34</span>).toPrecision(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;1e+1&quot;</span><br>(<span class="hljs-number">12.34</span>).toPrecision(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;12&quot;</span><br>(<span class="hljs-number">12.34</span>).toPrecision(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;12.3&quot;</span><br>(<span class="hljs-number">12.34</span>).toPrecision(<span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;12.34&quot;</span><br>(<span class="hljs-number">12.34</span>).toPrecision(<span class="hljs-number">5</span>) <span class="hljs-comment">// &quot;12.340&quot;</span><br></code></pre></td></tr></table></figure><p>该方法的参数为有效数字的位数，范围是1到100，超出这个范围会抛出 RangeError 错误  </p><p>该方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-number">12.35</span>).toPrecision(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;12.3&quot;</span><br>(<span class="hljs-number">12.25</span>).toPrecision(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;12.3&quot;</span><br>(<span class="hljs-number">12.15</span>).toPrecision(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;12.2&quot;</span><br>(<span class="hljs-number">12.45</span>).toPrecision(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;12.4&quot;</span><br></code></pre></td></tr></table></figure><h4 id="Number-prototype-toLocaleString"><a href="#Number-prototype-toLocaleString" class="headerlink" title="Number.prototype.toLocaleString()"></a>Number.prototype.toLocaleString()</h4><p><code>Number.prototype.toLocaleString()</code>方法接受一个地区码作为参数，返回一个字符串，表示当前数字在该地区的当地书写形式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-number">123</span>).toLocaleString(<span class="hljs-string">&#x27;zh-Hans-CN-u-nu-hanidec&#x27;</span>)<br><span class="hljs-comment">// &quot;一二三&quot;</span><br></code></pre></td></tr></table></figure><p>该方法还可以接受第二个参数配置对象，用来定制指定用途的返回字符串。该对象的<code>style</code>属性指定输出样式，默认值是<code>decimal</code>，表示输出十进制形式。如果值为<code>percent</code>，表示输出百分数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-number">123</span>).toLocaleString(<span class="hljs-string">&#x27;zh-Hans-CN&#x27;</span>, &#123; <span class="hljs-attr">style</span>: <span class="hljs-string">&#x27;percent&#x27;</span> &#125;)<br><span class="hljs-comment">// &quot;12,300%&quot;</span><br></code></pre></td></tr></table></figure><p>如果<code>style</code>属性的值为<code>currency</code>，则可以搭配<code>currency</code>属性，输出指定格式的货币字符串形式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-number">123</span>).toLocaleString(<span class="hljs-string">&#x27;zh-Hans-CN&#x27;</span>, &#123; <span class="hljs-attr">style</span>: <span class="hljs-string">&#x27;currency&#x27;</span>, <span class="hljs-attr">currency</span>: <span class="hljs-string">&#x27;CNY&#x27;</span> &#125;)<br><span class="hljs-comment">// &quot;￥123.00&quot;</span><br><br>(<span class="hljs-number">123</span>).toLocaleString(<span class="hljs-string">&#x27;de-DE&#x27;</span>, &#123; <span class="hljs-attr">style</span>: <span class="hljs-string">&#x27;currency&#x27;</span>, <span class="hljs-attr">currency</span>: <span class="hljs-string">&#x27;EUR&#x27;</span> &#125;)<br><span class="hljs-comment">// &quot;123,00 €&quot;</span><br><br>(<span class="hljs-number">123</span>).toLocaleString(<span class="hljs-string">&#x27;en-US&#x27;</span>, &#123; <span class="hljs-attr">style</span>: <span class="hljs-string">&#x27;currency&#x27;</span>, <span class="hljs-attr">currency</span>: <span class="hljs-string">&#x27;USD&#x27;</span> &#125;)<br><span class="hljs-comment">// &quot;$123.00&quot;</span><br></code></pre></td></tr></table></figure><p>如果<code>Number.prototype.toLocaleString()</code>省略了参数，则由浏览器自行决定如何处理，通常会使用操作系统的地区设定。注意，该方法如果使用浏览器不认识的地区码，会抛出一个错误  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-number">123</span>).toLocaleString(<span class="hljs-string">&#x27;123&#x27;</span>) <span class="hljs-comment">// 出错</span><br></code></pre></td></tr></table></figure><h3 id="自定义方法-1"><a href="#自定义方法-1" class="headerlink" title="自定义方法"></a>自定义方法</h3><p>与其他对象一样，<code>Number.prototype</code>对象上面可以自定义方法，被<code>Number</code>的实例继承  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span> + x;<br>&#125;;<br><br><span class="hljs-number">8</span>[<span class="hljs-string">&#x27;add&#x27;</span>](<span class="hljs-number">2</span>) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>上面代码为<code>Number</code>对象实例定义了一个<code>add</code>方法。在数值上调用某个方法，数值会自动转为<code>Number</code>的实例对象，所以就可以调用<code>add</code>方法了。由于<code>add</code>方法返回的还是数值，所以可以链式运算  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>.prototype.subtract = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span> - x;<br>&#125;;<br><br>(<span class="hljs-number">8</span>).add(<span class="hljs-number">2</span>).subtract(<span class="hljs-number">4</span>)<br><span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><p>上面代码在<code>Number</code>对象的实例上部署了<code>subtract</code>方法，它可以与<code>add</code>方法链式调用  </p><p>我们还可以部署更复杂的方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>.prototype.iterate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> result = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-built_in">this</span>; i++) &#123;<br>    result.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br>(<span class="hljs-number">8</span>).iterate()<br><span class="hljs-comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8]</span><br></code></pre></td></tr></table></figure><p>上面代码在<code>Number</code>对象的原型上部署了<code>iterate</code>方法，将一个数值自动遍历为一个数组  </p><p>注意，数值的自定义方法，只能定义在它的原型对象<code>Number.prototype</code>上面，数值本身是无法自定义属性的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>;<br>n.x = <span class="hljs-number">1</span>;<br>n.x <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>n</code>是一个原始类型的数值。直接在它上面新增一个属性<code>x</code>，不会报错，但毫无作用，总是返回<code>undefined</code>。这是因为一旦被调用属性，<code>n</code>就自动转为<code>Number</code>的实例对象，调用结束后，该对象自动销毁。所以，下一次调用<code>n</code>的属性时，实际取到的是另一个对象，属性<code>x</code>当然就读不出来  </p><h2 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><code>String</code>对象是 <code>Javascript</code> 原生提供的三个包装对象之一，用来生成字符串对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);<br><br><span class="hljs-keyword">typeof</span> s1 <span class="hljs-comment">// &quot;string&quot;</span><br><span class="hljs-keyword">typeof</span> s2 <span class="hljs-comment">// &quot;object&quot;</span><br><br>s2.valueOf() <span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>s1</code>是字符串，<code>s2</code>是对象。由于<code>s2</code>是字符串对象，<code>s2.valueOf</code>方法返回的就是它所对应的原始字符串  </p><p>字符串对象是一个类似数组的对象（很像数组，但不是数组）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)<br><span class="hljs-comment">// String &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3&#125;</span><br><br>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>))[<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;b&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，字符串<code>abc</code>对应的字符串对象，有数值键（<code>0</code>、<code>1</code>、<code>2</code>）和<code>length</code>属性，所以可以像数组那样取值  </p><p>除了用作构造函数，<code>String</code>对象还可以当作工具方法使用，将任意类型的值转为字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// &quot;true&quot;</span><br><span class="hljs-built_in">String</span>(<span class="hljs-number">5</span>) <span class="hljs-comment">// &quot;5&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码将布尔值<code>true</code>和数值<code>5</code>，分别转换为字符串  </p><h3 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h3><h4 id="String-fromCharCode"><a href="#String-fromCharCode" class="headerlink" title="String.fromCharCode()"></a>String.fromCharCode()</h4><p><code>String</code>对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是<code>String.fromCharCode()</code>。该方法的参数是一个或多个数值，代表 <code>Unicode</code> 码点，返回值是这些码点组成的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.fromCharCode() <span class="hljs-comment">// &quot;&quot;</span><br><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">97</span>) <span class="hljs-comment">// &quot;a&quot;</span><br><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">104</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>)<br><span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>String.fromCharCode</code>方法的参数为空，就返回空字符串；否则，返回参数对应的 <code>Unicode</code> 字符串  </p><p>注意，该方法不支持 <code>Unicode</code> 码点大于<code>0xFFFF</code>的字符，即传入的参数不能大于<code>0xFFFF</code>（即十进制的 65535）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0x20BB7</span>)<br><span class="hljs-comment">// &quot;ஷ&quot;</span><br><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0x20BB7</span>) === <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0x0BB7</span>)<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>String.fromCharCode</code>参数<code>0x20BB7</code>大于<code>0xFFFF</code>，导致返回结果出错。<code>0x20BB7</code>对应的字符是汉字<code>𠮷</code>，但是返回结果却是另一个字符（码点<code>0x0BB7</code>）。这是因为<code>String.fromCharCode</code>发现参数值大于<code>0xFFFF</code>，就会忽略多出的位（即忽略<code>0x20BB7</code>里面的<code>2</code>）  </p><p>这种现象的根本原因在于，码点大于<code>0xFFFF</code>的字符占用四个字节，而 <code>Javascript</code> 默认支持两个字节的字符。这种情况下，必须把<code>0x20BB7</code>拆成两个字符表示  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0xD842</span>, <span class="hljs-number">0xDFB7</span>)<br><span class="hljs-comment">// &quot;𠮷&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>0x20BB7</code>拆成两个字符<code>0xD842</code>和<code>0xDFB7</code>（即两个两字节字符，合成一个四字节字符），就能得到正确的结果。码点大于<code>0xFFFF</code>的字符的四字节表示法，由 <code>UTF-16</code> 编码方法决定  </p><h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><h4 id="String-prototype-length"><a href="#String-prototype-length" class="headerlink" title="String.prototype.length"></a>String.prototype.length</h4><p>字符串实例的<code>length</code>属性返回字符串的长度  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.length <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h3 id="实例方法-3"><a href="#实例方法-3" class="headerlink" title="实例方法"></a>实例方法</h3><h4 id="String-prototype-charAt"><a href="#String-prototype-charAt" class="headerlink" title="String.prototype.charAt()"></a>String.prototype.charAt()</h4><p><code>charAt</code>方法返回指定位置的字符，参数是从<code>0</code>开始编号的位置  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);<br><br>s.charAt(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;b&quot;</span><br>s.charAt(s.length - <span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;c&quot;</span><br></code></pre></td></tr></table></figure><p>这个方法完全可以用数组下标替代  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.charAt(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;b&quot;</span><br><span class="hljs-string">&#x27;abc&#x27;</span>[<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;b&quot;</span><br></code></pre></td></tr></table></figure><p>如果参数为负数，或大于等于字符串的长度，<code>charAt</code>返回空字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.charAt(-<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;&quot;</span><br><span class="hljs-string">&#x27;abc&#x27;</span>.charAt(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="String-prototype-charCodeAt"><a href="#String-prototype-charCodeAt" class="headerlink" title="String.prototype.charCodeAt()"></a>String.prototype.charCodeAt()</h4><p><code>charCodeAt()</code>方法返回字符串指定位置的 <code>Unicode</code> 码点（十进制表示），相当于<code>String.fromCharCode()</code>的逆操作  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.charCodeAt(<span class="hljs-number">1</span>) <span class="hljs-comment">// 98</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>abc</code>的<code>1</code>号位置的字符是<code>b</code>，它的 <code>Unicode</code> 码点是<code>98</code>  </p><p>如果没有任何参数，<code>charCodeAt</code>返回首字符的 <code>Unicode</code> 码点  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.charCodeAt() <span class="hljs-comment">// 97</span><br></code></pre></td></tr></table></figure><p>如果参数为负数，或大于等于字符串的长度，<code>charCodeAt</code>返回<code>NaN</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.charCodeAt(-<span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-string">&#x27;abc&#x27;</span>.charCodeAt(<span class="hljs-number">4</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>注意，<code>charCodeAt</code>方法返回的 <code>Unicode</code> 码点不会大于65536（0xFFFF），也就是说，只返回两个字节的字符的码点。如果遇到码点大于 65536 的字符（四个字节的字符），必须连续使用两次<code>charCodeAt</code>，不仅读入<code>charCodeAt(i)</code>，还要读入<code>charCodeAt(i+1)</code>，将两个值放在一起，才能得到准确的字符  </p><h4 id="String-prototype-concat"><a href="#String-prototype-concat" class="headerlink" title="String.prototype.concat()"></a>String.prototype.concat()</h4><p><code>concat</code>方法用于连接两个字符串，返回一个新字符串，不改变原字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-string">&#x27;def&#x27;</span>;<br><br>s1.concat(s2) <span class="hljs-comment">// &quot;abcdef&quot;</span><br>s1 <span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></td></tr></table></figure><p>该方法可以接受多个参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a&#x27;</span>.concat(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></td></tr></table></figure><p>如果参数不是字符串，<code>concat</code>方法会将其先转为字符串，然后再连接  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> one = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> two = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">var</span> three = <span class="hljs-string">&#x27;3&#x27;</span>;<br><br><span class="hljs-string">&#x27;&#x27;</span>.concat(one, two, three) <span class="hljs-comment">// &quot;123&quot;</span><br>one + two + three <span class="hljs-comment">// &quot;33&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>concat</code>方法将参数先转成字符串再连接，所以返回的是一个三个字符的字符串。作为对比，加号运算符在两个运算数都是数值时，不会转换类型，所以返回的是一个两个字符的字符串  </p><h4 id="String-prototype-slice"><a href="#String-prototype-slice" class="headerlink" title="String.prototype.slice()"></a>String.prototype.slice()</h4><p><code>slice()</code>方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.slice(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;Java&quot;</span><br></code></pre></td></tr></table></figure><p>如果省略第二个参数，则表示子字符串一直到原字符串结束  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.slice(<span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br></code></pre></td></tr></table></figure><p>如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.slice(-<span class="hljs-number">6</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br><span class="hljs-string">&#x27;JavaScript&#x27;</span>.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">6</span>) <span class="hljs-comment">// &quot;Java&quot;</span><br><span class="hljs-string">&#x27;JavaScript&#x27;</span>.slice(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;p&quot;</span><br></code></pre></td></tr></table></figure><p>如果第一个参数大于第二个参数（正数情况下），<code>slice()</code>方法返回一个空字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.slice(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="String-prototype-substring"><a href="#String-prototype-substring" class="headerlink" title="String.prototype.substring()"></a>String.prototype.substring()</h4><p><code>substring</code>方法用于从原字符串取出子字符串并返回，不改变原字符串，跟<code>slice</code>方法很相像  </p><p>它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substring(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;Java&quot;</span><br></code></pre></td></tr></table></figure><p>如果省略第二个参数，则表示子字符串一直到原字符串的结束  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substring(<span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br></code></pre></td></tr></table></figure><p>如果第一个参数大于第二个参数，<code>substring</code>方法会自动更换两个参数的位置  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substring(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substring(<span class="hljs-number">4</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，调换<code>substring</code>方法的两个参数，都得到同样的结果  </p><p>如果参数是负数，<code>substring</code>方法会自动将负数转为0  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substring(-<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;JavaScript&quot;</span><br><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substring(<span class="hljs-number">4</span>, -<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;Java&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，第二个例子的参数<code>-3</code>会自动变成<code>0</code>，等同于<code>&#39;JavaScript&#39;.substring(4, 0)</code>。由于第二个参数小于第一个参数，会自动互换位置，所以返回<code>Java</code>  </p><p>由于这些规则违反直觉，因此不建议使用<code>substring</code>方法，应该优先使用<code>slice</code>  </p><h4 id="String-prototype-substr"><a href="#String-prototype-substr" class="headerlink" title="String.prototype.substr()"></a>String.prototype.substr()</h4><p><code>substr</code>方法用于从原字符串取出子字符串并返回，不改变原字符串，跟<code>slice</code>和<code>substring</code>方法的作用相同  </p><p><code>substr</code>方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substr(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br></code></pre></td></tr></table></figure><p>如果省略第二个参数，则表示子字符串一直到原字符串的结束  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substr(<span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br></code></pre></td></tr></table></figure><p>如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substr(-<span class="hljs-number">6</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substr(<span class="hljs-number">4</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，第二个例子的参数<code>-1</code>自动转为<code>0</code>，表示子字符串长度为<code>0</code>，所以返回空字符串  </p><h4 id="String-prototype-indexOf-，String-prototype-lastIndexOf"><a href="#String-prototype-indexOf-，String-prototype-lastIndexOf" class="headerlink" title="String.prototype.indexOf()，String.prototype.lastIndexOf()"></a>String.prototype.indexOf()，String.prototype.lastIndexOf()</h4><p><code>indexOf</code>方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回<code>-1</code>，就表示不匹配  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;hello world&#x27;</span>.indexOf(<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-comment">// 4</span><br><span class="hljs-string">&#x27;JavaScript&#x27;</span>.indexOf(<span class="hljs-string">&#x27;script&#x27;</span>) <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><p><code>indexOf</code>方法还可以接受第二个参数，表示从该位置开始向后匹配  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;hello world&#x27;</span>.indexOf(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 7</span><br></code></pre></td></tr></table></figure><p><code>lastIndexOf</code>方法的用法跟<code>indexOf</code>方法一致，主要的区别是<code>lastIndexOf</code>从尾部开始匹配，<code>indexOf</code>则是从头部开始匹配  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;hello world&#x27;</span>.lastIndexOf(<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-comment">// 7</span><br></code></pre></td></tr></table></figure><p>另外，<code>lastIndexOf</code>的第二个参数表示从该位置起向前匹配  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;hello world&#x27;</span>.lastIndexOf(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h4 id="String-prototype-trim"><a href="#String-prototype-trim" class="headerlink" title="String.prototype.trim()"></a>String.prototype.trim()</h4><p><code>trim</code>方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;  hello world  &#x27;</span>.trim() <span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p>该方法去除的不仅是空格，还包括制表符（<code>\t</code>、<code>\v</code>）、换行符（<code>\n</code>）和回车符（<code>\r</code>）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;\r\nabc \t&#x27;</span>.trim() <span class="hljs-comment">// &#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure><h4 id="String-prototype-toLowerCase-，String-prototype-toUpperCase"><a href="#String-prototype-toLowerCase-，String-prototype-toUpperCase" class="headerlink" title="String.prototype.toLowerCase()，String.prototype.toUpperCase()"></a>String.prototype.toLowerCase()，String.prototype.toUpperCase()</h4><p><code>toLowerCase</code>方法用于将一个字符串全部转为小写，<code>toUpperCase</code>则是全部转为大写。它们都返回一个新字符串，不改变原字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;Hello World&#x27;</span>.toLowerCase()<br><span class="hljs-comment">// &quot;hello world&quot;</span><br><br><span class="hljs-string">&#x27;Hello World&#x27;</span>.toUpperCase()<br><span class="hljs-comment">// &quot;HELLO WORLD&quot;</span><br></code></pre></td></tr></table></figure><h4 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h4><p><code>match</code>方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回<code>null</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;cat, bat, sat, fat&#x27;</span>.match(<span class="hljs-string">&#x27;at&#x27;</span>) <span class="hljs-comment">// [&quot;at&quot;]</span><br><span class="hljs-string">&#x27;cat, bat, sat, fat&#x27;</span>.match(<span class="hljs-string">&#x27;xt&#x27;</span>) <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p>返回的数组还有<code>index</code>属性和<code>input</code>属性，分别表示匹配字符串开始的位置和原始字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> matches = <span class="hljs-string">&#x27;cat, bat, sat, fat&#x27;</span>.match(<span class="hljs-string">&#x27;at&#x27;</span>);<br>matches.index <span class="hljs-comment">// 1</span><br>matches.input <span class="hljs-comment">// &quot;cat, bat, sat, fat&quot;</span><br></code></pre></td></tr></table></figure><p><code>match</code>方法还可以使用正则表达式作为参数  </p><h4 id="String-prototype-search"><a href="#String-prototype-search" class="headerlink" title="String.prototype.search()"></a>String.prototype.search()</h4><p><code>search</code>方法的用法基本等同于<code>match</code>，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回<code>-1</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;cat, bat, sat, fat&#x27;</span>.search(<span class="hljs-string">&#x27;at&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p><code>search</code>方法还可以使用正则表达式作为参数  </p><h4 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h4><p><code>replace</code>方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有<code>g</code>修饰符的正则表达式）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;aaa&#x27;</span>.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// &quot;baa&quot;</span><br></code></pre></td></tr></table></figure><p><code>replace</code>方法还可以使用正则表达式作为参数  </p><h4 id="String-prototype-split"><a href="#String-prototype-split" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h4><p><code>split</code>方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></code></pre></td></tr></table></figure><p>如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;]</span><br></code></pre></td></tr></table></figure><p>如果省略参数，则返回数组的唯一成员就是原字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split() <span class="hljs-comment">// [&quot;a|b|c&quot;]</span><br></code></pre></td></tr></table></figure><p>如果满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a||c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>) <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure><p>如果满足分割规则的部分处于字符串的开头或结尾（即它的前面或后面没有其他字符），则返回数组的第一个或最后一个成员是一个空字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>) <span class="hljs-comment">// [&quot;&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="hljs-string">&#x27;a|b|&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;&quot;]</span><br></code></pre></td></tr></table></figure><p><code>split</code>方法还可以接受第二个参数，限定返回数组的最大成员数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// []</span><br><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// [&quot;a&quot;]</span><br><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;]</span><br><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>split</code>方法的第二个参数，决定了返回数组的成员数  </p><p><code>split</code>方法还可以使用正则表达式作为参数  </p><h4 id="String-prototype-localeCompare"><a href="#String-prototype-localeCompare" class="headerlink" title="String.prototype.localeCompare()"></a>String.prototype.localeCompare()</h4><p><code>localeCompare</code>方法用于比较两个字符串。它返回一个整数  </p><p>如果小于0，表示第一个字符串小于第二个字符串  </p><p>如果等于0，表示两者相等  </p><p>如果大于0，表示第一个字符串大于第二个字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;apple&#x27;</span>.localeCompare(<span class="hljs-string">&#x27;banana&#x27;</span>) <span class="hljs-comment">// -1</span><br><span class="hljs-string">&#x27;apple&#x27;</span>.localeCompare(<span class="hljs-string">&#x27;apple&#x27;</span>) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>该方法的最大特点，就是会考虑自然语言的顺序。举例来说，正常情况下，大写的英文字母小于小写字母  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;B&#x27;</span> &gt; <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，字母<code>B</code>小于字母<code>a</code>。因为 <code>Javascript</code> 采用的是 <code>Unicode</code> 码点比较，<code>B</code>的码点是66，而<code>a</code>的码点是97  </p><p>但是，<code>localeCompare</code>方法会考虑自然语言的排序情况，将<code>B</code>排在<code>a</code>的前面  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;B&#x27;</span>.localeCompare(<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>localeCompare</code>方法返回整数1，表示<code>B</code>较大  </p><p><code>localeCompare</code>还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;ä&#x27;</span>.localeCompare(<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;de&#x27;</span>) <span class="hljs-comment">// -1</span><br><span class="hljs-string">&#x27;ä&#x27;</span>.localeCompare(<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;sv&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>de</code>表示德语，<code>sv</code>表示瑞典语。德语中，<code>ä</code>小于<code>z</code>，所以返回<code>-1</code>；瑞典语中，<code>ä</code>大于<code>z</code>，所以返回<code>1</code>    </p><h2 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h2><p><code>Math</code>是<code> Javascript</code> 的原生对象，提供各种数学功能  </p><p>该对象不是构造函数，不能生成实例，所有的属性和方法都必须在<code>Math</code>对象上调用  </p><h3 id="静态属性-1"><a href="#静态属性-1" class="headerlink" title="静态属性"></a>静态属性</h3><p><code>Math</code>对象的静态属性，提供以下一些数学常数  </p><ul><li><code>Math.E</code>：常数<code>e</code>  </li><li><code>Math.LN2</code>：2 的自然对数  </li><li><code>Math.LN10</code>：10 的自然对数  </li><li><code>Math.LOG2E</code>：以 2 为底的<code>e</code>的对数  </li><li><code>Math.LOG10E</code>：以 10 为底的<code>e</code>的对数  </li><li><code>Math.PI</code>：常数<code>π</code>  </li><li><code>Math.SQRT1_2</code>：0.5 的平方根  </li><li><code>Math.SQRT2</code>：2 的平方根  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.E <span class="hljs-comment">// 2.718281828459045</span><br><span class="hljs-built_in">Math</span>.LN2 <span class="hljs-comment">// 0.6931471805599453</span><br><span class="hljs-built_in">Math</span>.LN10 <span class="hljs-comment">// 2.302585092994046</span><br><span class="hljs-built_in">Math</span>.LOG2E <span class="hljs-comment">// 1.4426950408889634</span><br><span class="hljs-built_in">Math</span>.LOG10E <span class="hljs-comment">// 0.4342944819032518</span><br><span class="hljs-built_in">Math</span>.PI <span class="hljs-comment">// 3.141592653589793</span><br><span class="hljs-built_in">Math</span>.SQRT1_2 <span class="hljs-comment">// 0.7071067811865476</span><br><span class="hljs-built_in">Math</span>.SQRT2 <span class="hljs-comment">// 1.4142135623730951</span><br></code></pre></td></tr></table></figure><p>这些属性都是只读的，不能修改。</p><h3 id="静态方法-2"><a href="#静态方法-2" class="headerlink" title="静态方法"></a>静态方法</h3><p><code>Math</code>对象提供以下一些静态方法  </p><ul><li><code>Math.abs()</code>：绝对值</li><li><code>Math.ceil()</code>：向上取整</li><li><code>Math.floor()</code>：向下取整</li><li><code>Math.max()</code>：最大值</li><li><code>Math.min()</code>：最小值</li><li><code>Math.pow()</code>：幂运算</li><li><code>Math.sqrt()</code>：平方根</li><li><code>Math.log()</code>：自然对数</li><li><code>Math.exp()</code>：<code>e</code>的指数</li><li><code>Math.round()</code>：四舍五入</li><li><code>Math.random()</code>：随机数</li></ul><h4 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs()"></a>Math.abs()</h4><p><code>Math.abs</code>方法返回参数值的绝对值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.abs(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">Math</span>.abs(-<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h4 id="Math-max-，Math-min"><a href="#Math-max-，Math-min" class="headerlink" title="Math.max()，Math.min()"></a>Math.max()，Math.min()</h4><p><code>Math.max</code>方法返回参数之中最大的那个值，<code>Math.min</code>返回最小的那个值。如果参数为空, <code>Math.min</code>返回<code>Infinity</code>, <code>Math.max</code>返回<code>-Infinity</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.max(<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 5</span><br><span class="hljs-built_in">Math</span>.min(<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// -1</span><br><span class="hljs-built_in">Math</span>.min() <span class="hljs-comment">// Infinity</span><br><span class="hljs-built_in">Math</span>.max() <span class="hljs-comment">// -Infinity</span><br></code></pre></td></tr></table></figure><h4 id="Math-floor-，Math-ceil"><a href="#Math-floor-，Math-ceil" class="headerlink" title="Math.floor()，Math.ceil()"></a>Math.floor()，Math.ceil()</h4><p><code>Math.floor</code>方法返回小于或等于参数值的最大整数（地板值）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">3.2</span>) <span class="hljs-comment">// 3</span><br><span class="hljs-built_in">Math</span>.floor(-<span class="hljs-number">3.2</span>) <span class="hljs-comment">// -4</span><br></code></pre></td></tr></table></figure><p><code>Math.ceil</code>方法返回大于或等于参数值的最小整数（天花板值）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.ceil(<span class="hljs-number">3.2</span>) <span class="hljs-comment">// 4</span><br><span class="hljs-built_in">Math</span>.ceil(-<span class="hljs-number">3.2</span>) <span class="hljs-comment">// -3</span><br></code></pre></td></tr></table></figure><p>这两个方法可以结合起来，实现一个总是返回数值的整数部分的函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ToInteger</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  x = <span class="hljs-built_in">Number</span>(x);<br>  <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">Math</span>.ceil(x) : <span class="hljs-built_in">Math</span>.floor(x);<br>&#125;<br><br>ToInteger(<span class="hljs-number">3.2</span>) <span class="hljs-comment">// 3</span><br>ToInteger(<span class="hljs-number">3.5</span>) <span class="hljs-comment">// 3</span><br>ToInteger(<span class="hljs-number">3.8</span>) <span class="hljs-comment">// 3</span><br>ToInteger(-<span class="hljs-number">3.2</span>) <span class="hljs-comment">// -3</span><br>ToInteger(-<span class="hljs-number">3.5</span>) <span class="hljs-comment">// -3</span><br>ToInteger(-<span class="hljs-number">3.8</span>) <span class="hljs-comment">// -3</span><br></code></pre></td></tr></table></figure><p>上面代码中，不管正数或负数，<code>ToInteger</code>函数总是返回一个数值的整数部分  </p><h4 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h4><p><code>Math.round</code>方法用于四舍五入  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.round(<span class="hljs-number">0.1</span>) <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">Math</span>.round(<span class="hljs-number">0.5</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">Math</span>.round(<span class="hljs-number">0.6</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">Math</span>.floor(x + <span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><p>注意，它对负数的处理（主要是对<code>0.5</code>的处理）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.round(-<span class="hljs-number">1.1</span>) <span class="hljs-comment">// -1</span><br><span class="hljs-built_in">Math</span>.round(-<span class="hljs-number">1.5</span>) <span class="hljs-comment">// -1</span><br><span class="hljs-built_in">Math</span>.round(-<span class="hljs-number">1.6</span>) <span class="hljs-comment">// -2</span><br></code></pre></td></tr></table></figure><h4 id="Math-pow"><a href="#Math-pow" class="headerlink" title="Math.pow()"></a>Math.pow()</h4><p><code>Math.pow</code>方法返回以第一个参数为底数、第二个参数为指数的幂运算值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 等同于 2 ** 2</span><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 4</span><br><span class="hljs-comment">// 等同于 2 ** 3</span><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><p>下面是计算圆面积的方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> radius = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">var</span> area = <span class="hljs-built_in">Math</span>.PI * <span class="hljs-built_in">Math</span>.pow(radius, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h4 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt()"></a>Math.sqrt()</h4><p><code>Math.sqrt</code>方法返回参数值的平方根。如果参数是一个负值，则返回<code>NaN</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-number">4</span>) <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">Math</span>.sqrt(-<span class="hljs-number">4</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h4 id="Math-log"><a href="#Math-log" class="headerlink" title="Math.log()"></a>Math.log()</h4><p><code>Math.log</code>方法返回以<code>e</code>为底的自然对数值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.log(<span class="hljs-built_in">Math</span>.E) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">Math</span>.log(<span class="hljs-number">10</span>) <span class="hljs-comment">// 2.302585092994046</span><br></code></pre></td></tr></table></figure><p>如果要计算以10为底的对数，可以先用<code>Math.log</code>求出自然对数，然后除以<code>Math.LN10</code>；求以2为底的对数，可以除以<code>Math.LN2</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.log(<span class="hljs-number">100</span>)/<span class="hljs-built_in">Math</span>.LN10 <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">Math</span>.log(<span class="hljs-number">8</span>)/<span class="hljs-built_in">Math</span>.LN2 <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><h4 id="Math-exp"><a href="#Math-exp" class="headerlink" title="Math.exp()"></a>Math.exp()</h4><p><code>Math.exp</code>方法返回常数<code>e</code>的参数次方。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.exp(<span class="hljs-number">1</span>) <span class="hljs-comment">// 2.718281828459045</span><br><span class="hljs-built_in">Math</span>.exp(<span class="hljs-number">3</span>) <span class="hljs-comment">// 20.085536923187668</span><br></code></pre></td></tr></table></figure><h4 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h4><p><code>Math.random()</code>返回0到1之间的一个伪随机数，可能等于0，但是一定小于1  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.random() <span class="hljs-comment">// 0.7151307314634323</span><br></code></pre></td></tr></table></figure><p>任意范围的随机数生成函数如下   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandomArbitrary</span>(<span class="hljs-params">min, max</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() * (max - min) + min;<br>&#125;<br><br>getRandomArbitrary(<span class="hljs-number">1.5</span>, <span class="hljs-number">6.5</span>)<br><span class="hljs-comment">// 2.4942810038223864</span><br></code></pre></td></tr></table></figure><p>任意范围的随机整数生成函数如下  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandomInt</span>(<span class="hljs-params">min, max</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (max - min + <span class="hljs-number">1</span>)) + min;<br>&#125;<br><br>getRandomInt(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>返回随机字符的例子如下  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">random_str</span>(<span class="hljs-params">length</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> ALPHABET = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;<br>  ALPHABET += <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>;<br>  ALPHABET += <span class="hljs-string">&#x27;0123456789-_&#x27;</span>;<br>  <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>    <span class="hljs-keyword">var</span> rand = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * ALPHABET.length);<br>    str += ALPHABET.substring(rand, rand + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> str;<br>&#125;<br><br>random_str(<span class="hljs-number">6</span>) <span class="hljs-comment">// &quot;NdQKOr&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>random_str</code>函数接受一个整数作为参数，返回变量<code>ALPHABET</code>内的随机字符所组成的指定长度的字符串  </p><h4 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h4><p><code>Math</code>对象还提供一系列三角函数方法。</p><ul><li><code>Math.sin()</code>：返回参数的正弦（参数为弧度值）</li><li><code>Math.cos()</code>：返回参数的余弦（参数为弧度值）</li><li><code>Math.tan()</code>：返回参数的正切（参数为弧度值）</li><li><code>Math.asin()</code>：返回参数的反正弦（返回值为弧度值）</li><li><code>Math.acos()</code>：返回参数的反余弦（返回值为弧度值）</li><li><code>Math.atan()</code>：返回参数的反正切（返回值为弧度值）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.sin(<span class="hljs-number">0</span>) <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">Math</span>.cos(<span class="hljs-number">0</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">Math</span>.tan(<span class="hljs-number">0</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">Math</span>.sin(<span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">2</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">Math</span>.asin(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1.5707963267948966</span><br><span class="hljs-built_in">Math</span>.acos(<span class="hljs-number">1</span>) <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">Math</span>.atan(<span class="hljs-number">1</span>) <span class="hljs-comment">// 0.7853981633974483</span><br></code></pre></td></tr></table></figure><h2 id="Date-对象"><a href="#Date-对象" class="headerlink" title="Date 对象"></a>Date 对象</h2><p><code>Date</code>对象是 <code>Javascript</code> 原生的时间库。它以国际标准时间（UTC）1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）  </p><h3 id="普通函数的用法"><a href="#普通函数的用法" class="headerlink" title="普通函数的用法"></a>普通函数的用法</h3><p><code>Date</code>对象可以作为普通函数直接调用，返回一个代表当前时间的字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Date</span>()<br><span class="hljs-comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br></code></pre></td></tr></table></figure><p>注意，即使带有参数，<code>Date</code>作为普通函数使用时，返回的还是当前时间  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Date</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码说明，无论有没有参数，直接调用<code>Date</code>总是返回当前时间  </p><h3 id="构造函数的用法"><a href="#构造函数的用法" class="headerlink" title="构造函数的用法"></a>构造函数的用法</h3><p><code>Date</code>还可以当作构造函数使用。对它使用<code>new</code>命令，会返回一个<code>Date</code>对象的实例。如果不加参数，实例代表的就是当前时间  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> today = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br></code></pre></td></tr></table></figure><p><code>Date</code>实例有一个独特的地方。其他对象求值的时候，都是默认调用<code>.valueOf()</code>方法，但是<code>Date</code>实例求值的时候，默认调用的是<code>toString()</code>方法。这导致对<code>Date</code>实例求值，返回的是一个字符串，代表该实例对应的时间  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> today = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><br>today<br><span class="hljs-comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br><br><span class="hljs-comment">// 等同于</span><br>today.toString()<br><span class="hljs-comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>today</code>是<code>Date</code>的实例，直接求值等同于调用<code>toString</code>方法  </p><p>作为构造函数时，<code>Date</code>对象可以接受多种格式的参数，返回一个该参数对应的时间实例  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 参数为时间零点开始计算的毫秒数</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1378218728000</span>)<br><span class="hljs-comment">// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)</span><br><br><span class="hljs-comment">// 参数为日期字符串</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;January 6, 2013&#x27;</span>);<br><span class="hljs-comment">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span><br><br><span class="hljs-comment">// 参数为多个整数，</span><br><span class="hljs-comment">// 代表年、月、日、小时、分钟、秒、毫秒</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br></code></pre></td></tr></table></figure><p>关于<code>Date</code>构造函数的参数，有几点说明  </p><p>第一点，参数可以是负整数，代表1970年元旦之前的时间  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(-<span class="hljs-number">1378218728000</span>)<br><span class="hljs-comment">// Fri Apr 30 1926 17:27:52 GMT+0800 (CST)</span><br></code></pre></td></tr></table></figure><p>第二点，只要是能被<code>Date.parse()</code>方法解析的字符串，都可以当作参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;2013-2-15&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;2013/2/15&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;02/15/2013&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;2013-FEB-15&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;FEB, 15, 2013&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;FEB 15, 2013&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;February, 15, 2013&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;February 15, 2013&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;15 Feb 2013&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;15, February, 2013&#x27;</span>)<br><span class="hljs-comment">// Fri Feb 15 2013 00:00:00 GMT+0800 (CST)</span><br></code></pre></td></tr></table></figure><p>上面多种日期字符串的写法，返回的都是同一个时间  </p><p>第三，参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。也就是说，这时至少需要两个参数，因为如果只使用“年”这一个参数，<code>Date</code>会将其解释为毫秒数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>)<br><span class="hljs-comment">// Thu Jan 01 1970 08:00:02 GMT+0800 (CST)</span><br></code></pre></td></tr></table></figure><p>上面代码中，2013被解释为毫秒数，而不是年份  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br></code></pre></td></tr></table></figure><p>上面代码中，不管有几个参数，返回的都是2013年1月1日零点  </p><p>最后，各个参数的取值范围如下  </p><ul><li>年：使用四位数年份，比如<code>2000</code>。如果写成两位数或个位数，则加上<code>1900</code>，即<code>10</code>代表1910年。如果是负数，表示公元前  </li><li>月：<code>0</code>表示一月，依次类推，<code>11</code>表示12月  </li><li>日：<code>1</code>到<code>31</code>  </li><li>小时：<code>0</code>到<code>23</code>  </li><li>分钟：<code>0</code>到<code>59</code>  </li><li>秒：<code>0</code>到<code>59</code>  </li><li>毫秒：<code>0</code>到<code>999</code>  </li></ul><p>注意，月份从<code>0</code>开始计算，但是，天数从<code>1</code>开始计算。另外，除了日期的默认值为<code>1</code>，小时、分钟、秒钟和毫秒的默认值都是<code>0</code>。</p><p>这些参数如果超出了正常范围，会被自动折算。比如，如果月设为<code>15</code>，就折算为下一年的4月  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">15</span>)<br><span class="hljs-comment">// Tue Apr 01 2014 00:00:00 GMT+0800 (CST)</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// Mon Dec 31 2012 00:00:00 GMT+0800 (CST)</span><br></code></pre></td></tr></table></figure><p>上面代码的第二个例子，日期设为<code>0</code>，就代表上个月的最后一天  </p><p>参数还可以使用负数，表示扣去的时间  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, -<span class="hljs-number">1</span>)<br><span class="hljs-comment">// Sat Dec 01 2012 00:00:00 GMT+0800 (CST)</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)<br><span class="hljs-comment">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span><br></code></pre></td></tr></table></figure><p>上面代码中，分别对月和日使用了负数，表示从基准日扣去相应的时间  </p><h3 id="日期的运算"><a href="#日期的运算" class="headerlink" title="日期的运算"></a>日期的运算</h3><p>类型自动转换时，<code>Date</code>实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串  </p><p>所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">var</span> d2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br><br>d2 - d1<br><span class="hljs-comment">// 2678400000</span><br>d2 + d1<br><span class="hljs-comment">// &quot;Sat Apr 01 2000 00:00:00 GMT+0800 (CST)Wed Mar 01 2000 00:00:00 GMT+0800 (CST)&quot;</span><br></code></pre></td></tr></table></figure><h3 id="静态方法-3"><a href="#静态方法-3" class="headerlink" title="静态方法"></a>静态方法</h3><h4 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h4><p><code>Date.now</code>方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Date</span>.now() <span class="hljs-comment">// 1364026285194</span><br></code></pre></td></tr></table></figure><h4 id="Date-parse"><a href="#Date-parse" class="headerlink" title="Date.parse()"></a>Date.parse()</h4><p><code>Date.parse</code>方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数  </p><p>日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>格式，其中最后的<code>Z</code>表示时区。但是，其他格式也可以被解析  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;Aug 9, 1995&#x27;</span>)<br><span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;January 26, 2011 13:51:50&#x27;</span>)<br><span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;Mon, 25 Dec 1995 13:30:00 GMT&#x27;</span>)<br><span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;Mon, 25 Dec 1995 13:30:00 +0430&#x27;</span>)<br><span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;2011-10-10&#x27;</span>)<br><span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;2011-10-10T14:48:00&#x27;</span>)<br></code></pre></td></tr></table></figure><p>上面的日期字符串都可以解析  </p><p>如果解析失败，返回<code>NaN</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;xxx&#x27;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h4 id="Date-UTC"><a href="#Date-UTC" class="headerlink" title="Date.UTC()"></a>Date.UTC()</h4><p><code>Date.UTC</code>方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 格式</span><br><span class="hljs-built_in">Date</span>.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]])<br><br><span class="hljs-comment">// 用法</span><br><span class="hljs-built_in">Date</span>.UTC(<span class="hljs-number">2011</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">567</span>)<br><span class="hljs-comment">// 1293847384567</span><br></code></pre></td></tr></table></figure><p>该方法的参数用法与<code>Date</code>构造函数完全一致，比如月从<code>0</code>开始计算，日期从<code>1</code>开始计算。区别在于<code>Date.UTC</code>方法的参数，会被解释为 UTC 时间（世界标准时间），<code>Date</code>构造函数的参数会被解释为当前时区的时间  </p><h3 id="实例方法-4"><a href="#实例方法-4" class="headerlink" title="实例方法"></a>实例方法</h3><p><code>Date</code>的实例对象，有几十个自己的方法，除了<code>valueOf</code>和<code>toString</code>，可以分为以下三类  </p><ul><li><code>to</code>类：从<code>Date</code>对象返回一个字符串，表示指定的时间  </li><li><code>get</code>类：获取<code>Date</code>对象的日期和时间  </li><li><code>set</code>类：设置<code>Date</code>对象的日期和时间  </li></ul><h4 id="Date-prototype-valueOf"><a href="#Date-prototype-valueOf" class="headerlink" title="Date.prototype.valueOf()"></a>Date.prototype.valueOf()</h4><p><code>valueOf</code>方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于<code>getTime</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><br>d.valueOf() <span class="hljs-comment">// 1362790014817</span><br>d.getTime() <span class="hljs-comment">// 1362790014817</span><br></code></pre></td></tr></table></figure><p>预期为数值的场合，<code>Date</code>实例会自动调用该方法，所以可以用下面的方法计算时间的间隔  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">var</span> end = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><span class="hljs-keyword">var</span> elapsed = end - start;<br></code></pre></td></tr></table></figure><h4 id="to-类方法"><a href="#to-类方法" class="headerlink" title="to 类方法"></a>to 类方法</h4><p><strong>（1）Date.prototype.toString()</strong>  </p><p><code>toString</code>方法返回一个完整的日期字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>d.toString()<br><span class="hljs-comment">// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;</span><br>d<br><span class="hljs-comment">// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;</span><br></code></pre></td></tr></table></figure><p>因为<code>toString</code>是默认的调用方法，所以如果直接读取<code>Date</code>实例，就相当于调用这个方法  </p><p><strong>（2）Date.prototype.toUTCString()</strong>  </p><p><code>toUTCString</code>方法返回对应的 UTC 时间，也就是比北京时间晚8个小时  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>d.toUTCString()<br><span class="hljs-comment">// &quot;Mon, 31 Dec 2012 16:00:00 GMT&quot;</span><br></code></pre></td></tr></table></figure><p><strong>（3）Date.prototype.toISOString()</strong>  </p><p><code>toISOString</code>方法返回对应时间的 ISO8601 写法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>d.toISOString()<br><span class="hljs-comment">// &quot;2012-12-31T16:00:00.000Z&quot;</span><br></code></pre></td></tr></table></figure><p>注意，<code>toISOString</code>方法返回的总是 UTC 时区的时间  </p><p><strong>（4）Date.prototype.toJSON()</strong>  </p><p><code>toJSON</code>方法返回一个符合 JSON 格式的 ISO 日期字符串，与<code>toISOString</code>方法的返回结果完全相同  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>d.toJSON()<br><span class="hljs-comment">// &quot;2012-12-31T16:00:00.000Z&quot;</span><br></code></pre></td></tr></table></figure><p><strong>（5）Date.prototype.toDateString()</strong>  </p><p><code>toDateString</code>方法返回日期字符串（不含小时、分和秒）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>d.toDateString() <span class="hljs-comment">// &quot;Tue Jan 01 2013&quot;</span><br></code></pre></td></tr></table></figure><p><strong>（6）Date.prototype.toTimeString()</strong>  </p><p><code>toTimeString</code>方法返回时间字符串（不含年月日）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>d.toTimeString() <span class="hljs-comment">// &quot;00:00:00 GMT+0800 (CST)&quot;</span><br></code></pre></td></tr></table></figure><p><strong>（7）本地时间</strong>  </p><p>以下三种方法，可以将 Date 实例转为表示本地时间的字符串  </p><ul><li><code>Date.prototype.toLocaleString()</code>：完整的本地时间  </li><li><code>Date.prototype.toLocaleDateString()</code>：本地日期（不含小时、分和秒）  </li><li><code>Date.prototype.toLocaleTimeString()</code>：本地时间（不含年月日）  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>d.toLocaleString()<br><span class="hljs-comment">// 中文版浏览器为&quot;2013年1月1日 上午12:00:00&quot;</span><br><span class="hljs-comment">// 英文版浏览器为&quot;1/1/2013 12:00:00 AM&quot;</span><br><br>d.toLocaleDateString()<br><span class="hljs-comment">// 中文版浏览器为&quot;2013年1月1日&quot;</span><br><span class="hljs-comment">// 英文版浏览器为&quot;1/1/2013&quot;</span><br><br>d.toLocaleTimeString()<br><span class="hljs-comment">// 中文版浏览器为&quot;上午12:00:00&quot;</span><br><span class="hljs-comment">// 英文版浏览器为&quot;12:00:00 AM&quot;</span><br></code></pre></td></tr></table></figure><p>这三个方法都有两个可选的参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">dateObj.toLocaleString([locales[, options]])<br>dateObj.toLocaleDateString([locales[, options]])<br>dateObj.toLocaleTimeString([locales[, options]])<br></code></pre></td></tr></table></figure><p>这两个参数中，<code>locales</code>是一个指定所用语言的字符串，<code>options</code>是一个配置对象  </p><p>下面是<code>locales</code>的例子，分别采用<code>en-US</code>和<code>zh-CN</code>语言设定  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>d.toLocaleString(<span class="hljs-string">&#x27;en-US&#x27;</span>) <span class="hljs-comment">// &quot;1/1/2013, 12:00:00 AM&quot;</span><br>d.toLocaleString(<span class="hljs-string">&#x27;zh-CN&#x27;</span>) <span class="hljs-comment">// &quot;2013/1/1 上午12:00:00&quot;</span><br><br>d.toLocaleDateString(<span class="hljs-string">&#x27;en-US&#x27;</span>) <span class="hljs-comment">// &quot;1/1/2013&quot;</span><br>d.toLocaleDateString(<span class="hljs-string">&#x27;zh-CN&#x27;</span>) <span class="hljs-comment">// &quot;2013/1/1&quot;</span><br><br>d.toLocaleTimeString(<span class="hljs-string">&#x27;en-US&#x27;</span>) <span class="hljs-comment">// &quot;12:00:00 AM&quot;</span><br>d.toLocaleTimeString(<span class="hljs-string">&#x27;zh-CN&#x27;</span>) <span class="hljs-comment">// &quot;上午12:00:00&quot;</span><br></code></pre></td></tr></table></figure><p><code>options</code>配置对象有以下属性  </p><ul><li><code>dateStyle</code>：可能的值为<code>full</code>、<code>long</code>、<code>medium</code>、<code>short</code>  </li><li><code>timeStyle</code>：可能的值为<code>full</code>、<code>long</code>、<code>medium</code>、<code>short </code> </li><li><code>month</code>：可能的值为<code>numeric</code>、<code>2-digit</code>、<code>long</code>、<code>short</code>、<code>narrow </code> </li><li><code>year</code>：可能的值为<code>numeric</code>、<code>2-digit</code>  </li><li><code>weekday</code>：可能的值为<code>long</code>、<code>short</code>、<code>narrow</code>  </li><li><code>day</code>、<code>hour</code>、<code>minute</code>、<code>second</code>：可能的值为<code>numeric</code>、<code>2-digit </code> </li><li><code>timeZone</code>：可能的值为 IANA 的时区数据库  </li><li><code>timeZooneName</code>：可能的值为<code>long</code>、<code>short </code> </li><li><code>hour12</code>：24小时周期还是12小时周期，可能的值为<code>true</code>、<code>false</code>  </li></ul><p>下面是用法实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>d.toLocaleDateString(<span class="hljs-string">&#x27;en-US&#x27;</span>, &#123;<br>  weekday: <span class="hljs-string">&#x27;long&#x27;</span>,<br>  year: <span class="hljs-string">&#x27;numeric&#x27;</span>,<br>  month: <span class="hljs-string">&#x27;long&#x27;</span>,<br>  day: <span class="hljs-string">&#x27;numeric&#x27;</span><br>&#125;)<br><span class="hljs-comment">// &quot;Tuesday, January 1, 2013&quot;</span><br><br>d.toLocaleDateString(<span class="hljs-string">&#x27;en-US&#x27;</span>, &#123;<br>  day: <span class="hljs-string">&quot;2-digit&quot;</span>,<br>  month: <span class="hljs-string">&quot;long&quot;</span>,<br>  year: <span class="hljs-string">&quot;2-digit&quot;</span><br>&#125;);<br><span class="hljs-comment">// &quot;January 01, 13&quot;</span><br><br>d.toLocaleTimeString(<span class="hljs-string">&#x27;en-US&#x27;</span>, &#123;<br>  timeZone: <span class="hljs-string">&#x27;UTC&#x27;</span>,<br>  timeZoneName: <span class="hljs-string">&#x27;short&#x27;</span><br>&#125;)<br><span class="hljs-comment">// &quot;4:00:00 PM UTC&quot;</span><br><br>d.toLocaleTimeString(<span class="hljs-string">&#x27;en-US&#x27;</span>, &#123;<br>  timeZone: <span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span>,<br>  timeZoneName: <span class="hljs-string">&#x27;long&#x27;</span><br>&#125;)<br><span class="hljs-comment">// &quot;12:00:00 AM China Standard Time&quot;</span><br><br>d.toLocaleTimeString(<span class="hljs-string">&#x27;en-US&#x27;</span>, &#123;<br>  hour12: <span class="hljs-literal">false</span><br>&#125;)<br><span class="hljs-comment">// &quot;00:00:00&quot;</span><br><br>d.toLocaleTimeString(<span class="hljs-string">&#x27;en-US&#x27;</span>, &#123;<br>  hour12: <span class="hljs-literal">true</span><br>&#125;)<br><span class="hljs-comment">// &quot;12:00:00 AM&quot;</span><br></code></pre></td></tr></table></figure><h4 id="get-类方法"><a href="#get-类方法" class="headerlink" title="get 类方法"></a>get 类方法</h4><p><code>Date</code>对象提供了一系列<code>get*</code>方法，用来获取实例对象某个方面的值  </p><ul><li><code>getTime()</code>：返回实例距离1970年1月1日00:00:00的毫秒数，等同于<code>valueOf</code>方法  </li><li><code>getDate()</code>：返回实例对象对应每个月的几号（从1开始）  </li><li><code>getDay()</code>：返回星期几，星期日为0，星期一为1，以此类推  </li><li><code>getFullYear()</code>：返回四位的年份  </li><li><code>getMonth()</code>：返回月份（0表示1月，11表示12月）  </li><li><code>getHours()</code>：返回小时（0-23）  </li><li><code>getMilliseconds()</code>：返回毫秒（0-999）  </li><li><code>getMinutes()</code>：返回分钟（0-59）  </li><li><code>getSeconds()</code>：返回秒（0-59）  </li><li><code>getTimezoneOffset()</code>：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素  </li></ul><p>所有这些<code>get*</code>方法返回的都是整数，不同方法返回值的范围不一样  </p><ul><li>分钟和秒：0 到 59</li><li>小时：0 到 23</li><li>星期：0（星期天）到 6（星期六）</li><li>日期：1 到 31</li><li>月份：0（一月）到 11（十二月）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;January 6, 2013&#x27;</span>);<br><br>d.getDate() <span class="hljs-comment">// 6</span><br>d.getMonth() <span class="hljs-comment">// 0</span><br>d.getFullYear() <span class="hljs-comment">// 2013</span><br>d.getTimezoneOffset() <span class="hljs-comment">// -480</span><br></code></pre></td></tr></table></figure><p>上面代码中，最后一行返回<code>-480</code>，即 UTC 时间减去当前时间，单位是分钟。<code>-480</code>表示 UTC 比当前时间少480分钟，即当前时区比 UTC 早8个小时  </p><p>下面是一个例子，计算本年度还剩下多少天  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">leftDays</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> today = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>  <span class="hljs-keyword">var</span> endYear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(today.getFullYear(), <span class="hljs-number">11</span>, <span class="hljs-number">31</span>, <span class="hljs-number">23</span>, <span class="hljs-number">59</span>, <span class="hljs-number">59</span>, <span class="hljs-number">999</span>);<br>  <span class="hljs-keyword">var</span> msPerDay = <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round((endYear.getTime() - today.getTime()) / msPerDay);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这些<code>get*</code>方法返回的都是当前时区的时间，<code>Date</code>对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。</p><ul><li><code>getUTCDate()</code></li><li><code>getUTCFullYear()</code></li><li><code>getUTCMonth()</code></li><li><code>getUTCDay()</code></li><li><code>getUTCHours()</code></li><li><code>getUTCMinutes()</code></li><li><code>getUTCSeconds()</code></li><li><code>getUTCMilliseconds()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;January 6, 2013&#x27;</span>);<br><br>d.getDate() <span class="hljs-comment">// 6</span><br>d.getUTCDate() <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>上面代码中，实例对象<code>d</code>表示当前时区（东八时区）的1月6日0点0分0秒，这个时间对于当前时区来说是1月6日，所以<code>getDate</code>方法返回6，对于 UTC 时区来说是1月5日，所以<code>getUTCDate</code>方法返回5  </p><h4 id="set-类方法"><a href="#set-类方法" class="headerlink" title="set 类方法"></a>set 类方法</h4><p><code>Date</code>对象提供了一系列<code>set*</code>方法，用来设置实例对象的各个方面  </p><ul><li><code>setDate(date)</code>：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳  </li><li><code>setFullYear(year [, month, date])</code>：设置四位年份  </li><li><code>setHours(hour [, min, sec, ms])</code>：设置小时（0-23）  </li><li><code>setMilliseconds()</code>：设置毫秒（0-999）  </li><li><code>setMinutes(min [, sec, ms])</code>：设置分钟（0-59）  </li><li><code>setMonth(month [, date])</code>：设置月份（0-11）  </li><li><code>setSeconds(sec [, ms])</code>：设置秒（0-59）  </li><li><code>setTime(milliseconds)</code>：设置毫秒时间戳  </li></ul><p>这些方法基本是跟<code>get*</code>方法一一对应的，但是没有<code>setDay</code>方法，因为星期几是计算出来的，而不是设置的。另外，需要注意的是，凡是涉及到设置月份，都是从0开始算的，即<code>0</code>是1月，<code>11</code>是12月  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> (<span class="hljs-string">&#x27;January 6, 2013&#x27;</span>);<br><br>d <span class="hljs-comment">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span><br>d.setDate(<span class="hljs-number">9</span>) <span class="hljs-comment">// 1357660800000</span><br>d <span class="hljs-comment">// Wed Jan 09 2013 00:00:00 GMT+0800 (CST)</span><br></code></pre></td></tr></table></figure><p><code>set*</code>方法的参数都会自动折算。以<code>setDate()</code>为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;January 6, 2013&#x27;</span>);<br><br>d1.setDate(<span class="hljs-number">32</span>) <span class="hljs-comment">// 1359648000000</span><br>d1 <span class="hljs-comment">// Fri Feb 01 2013 00:00:00 GMT+0800 (CST)</span><br><br><span class="hljs-keyword">var</span> d2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> (<span class="hljs-string">&#x27;January 6, 2013&#x27;</span>);<br><br>d2.setDate(-<span class="hljs-number">1</span>) <span class="hljs-comment">// 1356796800000</span><br>d2 <span class="hljs-comment">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>d1.setDate(32)</code>将日期设为1月份的32号，因为1月份只有31号，所以自动折算为2月1日。<code>d2.setDate(-1)</code>表示设为上个月的倒数第二天，即12月30日  </p><p><code>set</code>类方法和<code>get</code>类方法，可以结合使用，得到相对时间  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><br><span class="hljs-comment">// 将日期向后推1000天</span><br>d.setDate(d.getDate() + <span class="hljs-number">1000</span>);<br><span class="hljs-comment">// 将时间设为6小时后</span><br>d.setHours(d.getHours() + <span class="hljs-number">6</span>);<br><span class="hljs-comment">// 将年份设为去年</span><br>d.setFullYear(d.getFullYear() - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><code>set*</code>系列方法除了<code>setTime()</code>，都有对应的 UTC 版本，即设置 UTC 时区的时间  </p><ul><li><code>setUTCDate()</code></li><li><code>setUTCFullYear()</code></li><li><code>setUTCHours()</code></li><li><code>setUTCMilliseconds()</code></li><li><code>setUTCMinutes()</code></li><li><code>setUTCMonth()</code></li><li><code>setUTCSeconds()</code></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;January 6, 2013&#x27;</span>);<br>d.getUTCHours() <span class="hljs-comment">// 16</span><br>d.setUTCHours(<span class="hljs-number">22</span>) <span class="hljs-comment">// 1357423200000</span><br>d <span class="hljs-comment">// Sun Jan 06 2013 06:00:00 GMT+0800 (CST)</span><br></code></pre></td></tr></table></figure><p>上面代码中，本地时区（东八时区）的1月6日0点0分，是 UTC 时区的前一天下午16点。设为 UTC 时区的22点以后，就变为本地时区的上午6点  </p><h2 id="RegExp-对象"><a href="#RegExp-对象" class="headerlink" title="RegExp 对象"></a>RegExp 对象</h2><p><code>RegExp</code>对象提供正则表达式的功能  </p><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本  </p><p>比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址  </p><p><code>Javascript</code> 的正则表达式体系是参照 Perl 5 建立的  </p><p>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/xyz/</span>;<br></code></pre></td></tr></table></figure><p>另一种是使用<code>RegExp</code>构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;xyz&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面两种写法是等价的，都新建了一个内容为<code>xyz</code>的正则表达式对象。它们的主要区别是</p><p>第一种方法在引擎编译代码时，就会新建正则表达式  </p><p>第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观  </p><p>所以实际应用中，基本上都采用字面量定义正则表达式  </p><p><code>RegExp</code>构造函数还可以接受第二个参数，表示修饰符  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;xyz&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>);<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/xyz/i</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，正则表达式<code>/xyz/</code>有一个修饰符<code>i</code>  </p><h3 id="实例属性-1"><a href="#实例属性-1" class="headerlink" title="实例属性"></a>实例属性</h3><p>正则对象的实例属性分成两类  </p><p>一类是修饰符相关，用于了解设置了什么修饰符  </p><ul><li><code>RegExp.prototype.ignoreCase</code>：返回一个布尔值，表示是否设置了<code>i</code>修饰符  </li><li><code>RegExp.prototype.global</code>：返回一个布尔值，表示是否设置了<code>g</code>修饰符  </li><li><code>RegExp.prototype.multiline</code>：返回一个布尔值，表示是否设置了<code>m</code>修饰符  </li><li><code>RegExp.prototype.flags</code>：返回一个字符串，包含了已经设置的所有修饰符，按字母排序  </li></ul><p>上面四个属性都是只读的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/abc/igm</span>;<br><br>r.ignoreCase <span class="hljs-comment">// true</span><br>r.global <span class="hljs-comment">// true</span><br>r.multiline <span class="hljs-comment">// true</span><br>r.flags <span class="hljs-comment">// &#x27;gim&#x27;</span><br></code></pre></td></tr></table></figure><p>另一类是与修饰符无关的属性，主要是下面两个  </p><ul><li><code>RegExp.prototype.lastIndex</code>：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文  </li><li><code>RegExp.prototype.source</code>：返回正则表达式的字符串形式（不包括反斜杠），该属性只读  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/abc/igm</span>;<br><br>r.lastIndex <span class="hljs-comment">// 0</span><br>r.source <span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></td></tr></table></figure><h3 id="实例方法-5"><a href="#实例方法-5" class="headerlink" title="实例方法"></a>实例方法</h3><h4 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test()"></a>RegExp.prototype.test()</h4><p>正则实例对象的<code>test</code>方法返回一个布尔值，表示当前模式是否能匹配参数字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/cat/.test(<span class="hljs-string">&#x27;cats and dogs&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码验证参数字符串之中是否包含<code>cat</code>，结果返回<code>true</code>  </p><p>如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都从上一次结束的位置开始向后匹配  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/x/g</span>;<br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;_x_x&#x27;</span>;<br><br>r.lastIndex <span class="hljs-comment">// 0</span><br>r.test(s) <span class="hljs-comment">// true</span><br><br>r.lastIndex <span class="hljs-comment">// 2</span><br>r.test(s) <span class="hljs-comment">// true</span><br><br>r.lastIndex <span class="hljs-comment">// 4</span><br>r.test(s) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码的正则表达式使用了<code>g</code>修饰符，表示是全局搜索，会有多个结果。接着，三次使用<code>test</code>方法，每一次开始搜索的位置都是上一次匹配的后一个位置  </p><p>带有<code>g</code>修饰符时，可以通过正则对象的<code>lastIndex</code>属性指定开始搜索的位置  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/x/g</span>;<br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;_x_x&#x27;</span>;<br><br>r.lastIndex = <span class="hljs-number">4</span>;<br>r.test(s) <span class="hljs-comment">// false</span><br><br>r.lastIndex <span class="hljs-comment">// 0</span><br>r.test(s)<br></code></pre></td></tr></table></figure><p>上面代码指定从字符串的第五个位置开始搜索，这个位置为空，所以返回<code>false</code>。同时，<code>lastIndex</code>属性重置为<code>0</code>，所以第二次执行<code>r.test(s)</code>会返回<code>true</code>  </p><p>注意，带有<code>g</code>修饰符时，正则表达式内部会记住上一次的<code>lastIndex</code>属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/bb/g</span>;<br>r.test(<span class="hljs-string">&#x27;bb&#x27;</span>) <span class="hljs-comment">// true</span><br>r.test(<span class="hljs-string">&#x27;-bb-&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，由于正则表达式<code>r</code>是从上一次的<code>lastIndex</code>位置开始匹配，导致第二次执行<code>test</code>方法时出现预期以外的结果  </p><p><code>lastIndex</code>属性只对同一个正则表达式有效，所以下面这样写是错误的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-regexp">/a/g</span>.test(<span class="hljs-string">&#x27;babaa&#x27;</span>)) count++;<br></code></pre></td></tr></table></figure><p>上面代码会导致无限循环，因为<code>while</code>循环的每次匹配条件都是一个新的正则表达式，导致<code>lastIndex</code>属性总是等于0  </p><p>如果正则模式是一个空字符串，则匹配所有字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;&#x27;</span>).test(<span class="hljs-string">&#x27;abc&#x27;</span>)<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="RegExp-prototype-exec"><a href="#RegExp-prototype-exec" class="headerlink" title="RegExp.prototype.exec()"></a>RegExp.prototype.exec()</h4><p>正则实例对象的<code>exec()</code>方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回<code>null</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;_x_x&#x27;</span>;<br><span class="hljs-keyword">var</span> r1 = <span class="hljs-regexp">/x/</span>;<br><span class="hljs-keyword">var</span> r2 = <span class="hljs-regexp">/y/</span>;<br><br>r1.exec(s) <span class="hljs-comment">// [&quot;x&quot;]</span><br>r2.exec(s) <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p>上面代码中，正则对象<code>r1</code>匹配成功，返回一个数组，成员是匹配结果；正则对象<code>r2</code>匹配失败，返回<code>null</code>  </p><p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员  </p><p>第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说  </p><p>第二个成员对应第一个括号  </p><p>第三个成员对应第二个括号，以此类推  </p><p>整个数组的<code>length</code>属性等于组匹配的数量再加1  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;_x_x&#x27;</span>;<br><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/_(x)/</span>;<br><br>r.exec(s) <span class="hljs-comment">// [&quot;_x&quot;, &quot;x&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码的<code>exec()</code>方法，返回一个数组。第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果  </p><p><code>exec()</code>方法的返回数组还包含以下两个属性  </p><ul><li><code>input</code>：整个原字符串。</li><li><code>index</code>：模式匹配成功的开始位置（从0开始计数）。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/a(b+)a/</span>;<br><span class="hljs-keyword">var</span> arr = r.exec(<span class="hljs-string">&#x27;_abbba_aba_&#x27;</span>);<br><br>arr <span class="hljs-comment">// [&quot;abbba&quot;, &quot;bbb&quot;]</span><br><br>arr.index <span class="hljs-comment">// 1</span><br>arr.input <span class="hljs-comment">// &quot;_abbba_aba_&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中的<code>index</code>属性等于1，是因为从原字符串的第二个位置开始匹配成功  </p><p>如果正则表达式加上<code>g</code>修饰符，则可以使用多次<code>exec()</code>方法，下一次搜索的位置从上一次匹配成功结束的位置开始  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/a/g</span>;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc_abc_abc&#x27;</span><br><br><span class="hljs-keyword">var</span> r1 = reg.exec(str);<br>r1 <span class="hljs-comment">// [&quot;a&quot;]</span><br>r1.index <span class="hljs-comment">// 0</span><br>reg.lastIndex <span class="hljs-comment">// 1</span><br><br><span class="hljs-keyword">var</span> r2 = reg.exec(str);<br>r2 <span class="hljs-comment">// [&quot;a&quot;]</span><br>r2.index <span class="hljs-comment">// 4</span><br>reg.lastIndex <span class="hljs-comment">// 5</span><br><br><span class="hljs-keyword">var</span> r3 = reg.exec(str);<br>r3 <span class="hljs-comment">// [&quot;a&quot;]</span><br>r3.index <span class="hljs-comment">// 8</span><br>reg.lastIndex <span class="hljs-comment">// 9</span><br><br><span class="hljs-keyword">var</span> r4 = reg.exec(str);<br>r4 <span class="hljs-comment">// null</span><br>reg.lastIndex <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>上面代码连续用了四次<code>exec()</code>方法，前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，匹配结果返回<code>null</code>，正则实例对象的<code>lastIndex</code>属性也重置为<code>0</code>，意味着第四次匹配将从头开始  </p><p>利用<code>g</code>修饰符允许多次匹配的特点，可以用一个循环完成全部匹配  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/a/g</span>;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc_abc_abc&#x27;</span><br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">var</span> match = reg.exec(str);<br>  <span class="hljs-keyword">if</span> (!match) <span class="hljs-keyword">break</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;#&#x27;</span> + match.index + <span class="hljs-string">&#x27;:&#x27;</span> + match[<span class="hljs-number">0</span>]);<br>&#125;<br><span class="hljs-comment">// #0:a</span><br><span class="hljs-comment">// #4:a</span><br><span class="hljs-comment">// #8:a</span><br></code></pre></td></tr></table></figure><p>上面代码中，只要<code>exec()</code>方法不返回<code>null</code>，就会一直循环下去，每次输出匹配的位置和匹配的文本  </p><p>正则实例对象的<code>lastIndex</code>属性不仅可读，还可写。设置了<code>g</code>修饰符的时候，只要手动设置了<code>lastIndex</code>的值，就会从指定位置开始匹配  </p><h3 id="字符串的实例方法"><a href="#字符串的实例方法" class="headerlink" title="字符串的实例方法"></a>字符串的实例方法</h3><p>字符串的实例方法之中，有4种与正则表达式有关  </p><ul><li><code>String.prototype.match()</code>：返回一个数组，成员是所有匹配的子字符串  </li><li><code>String.prototype.search()</code>：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置  </li><li><code>String.prototype.replace()</code>：按照给定的正则表达式进行替换，返回替换后的字符串  </li><li><code>String.prototype.split()</code>：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员  </li></ul><h4 id="String-prototype-match-1"><a href="#String-prototype-match-1" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h4><p>字符串实例对象的<code>match</code>方法对字符串进行正则匹配，返回匹配结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;_x_x&#x27;</span>;<br><span class="hljs-keyword">var</span> r1 = <span class="hljs-regexp">/x/</span>;<br><span class="hljs-keyword">var</span> r2 = <span class="hljs-regexp">/y/</span>;<br><br>s.match(r1) <span class="hljs-comment">// [&quot;x&quot;]</span><br>s.match(r2) <span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p>从上面代码可以看到，字符串的<code>match</code>方法与正则对象的<code>exec</code>方法非常类似：匹配成功返回一个数组，匹配失败返回<code>null</code>  </p><p>如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，会一次性返回所有匹配成功的结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;abba&#x27;</span>;<br><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/a/g</span>;<br><br>s.match(r) <span class="hljs-comment">// [&quot;a&quot;, &quot;a&quot;]</span><br>r.exec(s) <span class="hljs-comment">// [&quot;a&quot;]</span><br></code></pre></td></tr></table></figure><p>设置正则表达式的<code>lastIndex</code>属性，对<code>match</code>方法无效，匹配总是从字符串的第一个字符开始  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/a|b/g</span>;<br>r.lastIndex = <span class="hljs-number">7</span>;<br><span class="hljs-string">&#x27;xaxb&#x27;</span>.match(r) <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span><br>r.lastIndex <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>上面代码表示，设置正则对象的<code>lastIndex</code>属性是无效的  </p><h4 id="String-prototype-search-1"><a href="#String-prototype-search-1" class="headerlink" title="String.prototype.search()"></a>String.prototype.search()</h4><p>字符串对象的<code>search</code>方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回<code>-1</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;_x_x&#x27;</span>.search(<span class="hljs-regexp">/x/</span>)<br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，第一个匹配结果出现在字符串的<code>1</code>号位置  </p><h4 id="String-prototype-replace-1"><a href="#String-prototype-replace-1" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h4><p>字符串对象的<code>replace</code>方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.replace(search, replacement)<br></code></pre></td></tr></table></figure><p>正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;aaa&#x27;</span>.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// &quot;baa&quot;</span><br><span class="hljs-string">&#x27;aaa&#x27;</span>.replace(<span class="hljs-regexp">/a/</span>, <span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// &quot;baa&quot;</span><br><span class="hljs-string">&#x27;aaa&#x27;</span>.replace(<span class="hljs-regexp">/a/g</span>, <span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// &quot;bbb&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，最后一个正则表达式使用了<code>g</code>修饰符，导致所有的<code>a</code>都被替换掉了  </p><p><code>replace</code>方法的一个应用，就是消除字符串首尾两端的空格  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;  #id div.class  &#x27;</span>;<br><br>str.replace(<span class="hljs-regexp">/^\s+|\s+$/g</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment">// &quot;#id div.class&quot;</span><br></code></pre></td></tr></table></figure><p><code>replace</code>方法的第二个参数可以使用美元符号<code>$</code>，用来指代所替换的内容  </p><ul><li><code>$&amp;</code>：匹配的子字符串  </li><li><code>$`</code>：匹配结果前面的文本  </li><li><code>$&#39;</code>：匹配结果后面的文本  </li><li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数  </li><li><code>$$</code>：指代美元符号<code>$</code>  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;hello world&#x27;</span>.replace(<span class="hljs-regexp">/(\w+)\s(\w+)/</span>, <span class="hljs-string">&#x27;$2 $1&#x27;</span>)<br><span class="hljs-comment">// &quot;world hello&quot;</span><br><br><span class="hljs-string">&#x27;abc&#x27;</span>.replace(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;[$`-$&amp;-$\&#x27;]&#x27;</span>)<br><span class="hljs-comment">// &quot;a[a-b-c]c&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，第一个例子是将匹配的组互换位置，第二个例子是改写匹配的值  </p><p><code>replace</code>方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;3 and 5&#x27;</span>.replace(<span class="hljs-regexp">/[0-9]+/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * match;<br>&#125;)<br><span class="hljs-comment">// &quot;6 and 10&quot;</span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;The quick brown fox jumped over the lazy dog.&#x27;</span>;<br><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/quick|brown|lazy/ig</span>;<br><br>a.replace(pattern, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replacer</span>(<span class="hljs-params">match</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> match.toUpperCase();<br>&#125;);<br><span class="hljs-comment">// The QUICK BROWN fox jumped over the LAZY dog.</span><br></code></pre></td></tr></table></figure><p>作为<code>replace</code>方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> prices = &#123;<br>  <span class="hljs-string">&#x27;p1&#x27;</span>: <span class="hljs-string">&#x27;$1.99&#x27;</span>,<br>  <span class="hljs-string">&#x27;p2&#x27;</span>: <span class="hljs-string">&#x27;$9.99&#x27;</span>,<br>  <span class="hljs-string">&#x27;p3&#x27;</span>: <span class="hljs-string">&#x27;$5.00&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> template = <span class="hljs-string">&#x27;&lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;&#x27;</span><br>  + <span class="hljs-string">&#x27;&lt;span id=&quot;p2&quot;&gt;&lt;/span&gt;&#x27;</span><br>  + <span class="hljs-string">&#x27;&lt;span id=&quot;p3&quot;&gt;&lt;/span&gt;&#x27;</span>;<br><br>template.replace(<br>  /(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;)(.*?)(&quot;</span>&gt;</span>)(&lt;\/span&gt;)/g,</span><br><span class="xml">  function(match, $1, $2, $3, $4)&#123;</span><br><span class="xml">    return $1 + $2 + $3 + prices[$2] + $4;</span><br><span class="xml">  &#125;</span><br><span class="xml">);</span><br><span class="xml">// &quot;<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>$1.99<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span>$9.99<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p3&quot;</span>&gt;</span>$5.00<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用<code>$1</code>到<code>$4</code>表示。匹配函数的作用是将价格插入模板中  </p><h4 id="String-prototype-split-1"><a href="#String-prototype-split-1" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h4><p>字符串对象的<code>split</code>方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">str.split(separator, [limit])<br></code></pre></td></tr></table></figure><p>该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 非正则分隔</span><br><span class="hljs-string">&#x27;a,  b,c, d&#x27;</span>.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br><span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;  b&#x27;, &#x27;c&#x27;, &#x27; d&#x27; ]</span><br><br><span class="hljs-comment">// 正则分隔，去除多余的空格</span><br><span class="hljs-string">&#x27;a,  b,c, d&#x27;</span>.split(<span class="hljs-regexp">/, */</span>)<br><span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span><br><br><span class="hljs-comment">// 指定返回数组的最大成员</span><br><span class="hljs-string">&#x27;a,  b,c, d&#x27;</span>.split(<span class="hljs-regexp">/, */</span>, <span class="hljs-number">2</span>)<br>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span> ]<br></code></pre></td></tr></table></figure><p>上面代码使用正则表达式，去除了子字符串的逗号后面的空格  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例一</span><br><span class="hljs-string">&#x27;aaa*a*&#x27;</span>.split(<span class="hljs-regexp">/a*/</span>)<br><span class="hljs-comment">// [ &#x27;&#x27;, &#x27;*&#x27;, &#x27;*&#x27; ]</span><br><br><span class="hljs-comment">// 例二</span><br><span class="hljs-string">&#x27;aaa**a*&#x27;</span>.split(<span class="hljs-regexp">/a*/</span>)<br><span class="hljs-comment">// [&quot;&quot;, &quot;*&quot;, &quot;*&quot;, &quot;*&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码的分割规则是0次或多次的<code>a</code>，由于正则默认是贪婪匹配，所以例一的第一个分隔符是<code>aaa</code>，第二个分割符是<code>a</code>，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是<code>aaa</code>，第二个分隔符是0个<code>a</code>（即空字符），第三个分隔符是<code>a</code>，所以将字符串分成四个部分  </p><p>如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;aaa*a*&#x27;</span>.split(<span class="hljs-regexp">/(a*)/</span>)<br><span class="hljs-comment">// [ &#x27;&#x27;, &#x27;aaa&#x27;, &#x27;*&#x27;, &#x27;a&#x27;, &#x27;*&#x27; ]</span><br></code></pre></td></tr></table></figure><p>上面代码的正则表达式使用了括号，第一个组匹配是<code>aaa</code>，第二个组匹配是<code>a</code>，它们都作为数组成员返回  </p><h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><p>正则表达式的规则很复杂，下面一一介绍这些规则  </p><h4 id="字面量字符和元字符"><a href="#字面量字符和元字符" class="headerlink" title="字面量字符和元字符"></a>字面量字符和元字符</h4><p>大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”（literal characters）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/dog/.test(<span class="hljs-string">&#x27;old dog&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中正则表达式的<code>dog</code>，就是字面量字符，所以<code>/dog/</code>匹配<code>old dog</code>，因为它就表示<code>d</code>、<code>o</code>、<code>g</code>三个字母连在一起。</p><p>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。</p><p><strong>（1）点字符（.)</strong></p><p>点字符（<code>.</code>）匹配除回车（<code>\r</code>）、换行(<code>\n</code>) 、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。注意，对于码点大于<code>0xFFFF</code>字符，点字符不能正确匹配，会认为这是两个字符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/c.t/<br></code></pre></td></tr></table></figure><p>上面代码中，<code>c.t</code>匹配<code>c</code>和<code>t</code>之间包含任意一个字符的情况，只要这三个字符在同一行，比如<code>cat</code>、<code>c2t</code>、<code>c-t</code>等等，但是不匹配<code>coot</code>。</p><p><strong>（2）位置字符</strong></p><p>位置字符用来提示字符所处的位置，主要有两个字符。</p><ul><li><code>^</code> 表示字符串的开始位置</li><li><code>$</code> 表示字符串的结束位置</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test必须出现在开始位置</span><br>/^test/.test(<span class="hljs-string">&#x27;test123&#x27;</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// test必须出现在结束位置</span><br>/test$/.test(<span class="hljs-string">&#x27;new test&#x27;</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 从开始位置到结束位置只有test</span><br>/^test$/.test(<span class="hljs-string">&#x27;test&#x27;</span>) <span class="hljs-comment">// true</span><br>/^test$/.test(<span class="hljs-string">&#x27;test test&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>（3）选择符（<code>|</code>）</strong></p><p>竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR），即<code>cat|dog</code>表示匹配<code>cat</code>或<code>dog</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/<span class="hljs-number">11</span>|<span class="hljs-number">22</span>/.test(<span class="hljs-string">&#x27;911&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，正则表达式指定必须匹配<code>11</code>或<code>22</code>。</p><p>多个选择符可以联合使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 匹配fred、barney、betty之中的一个</span><br>/fred|barney|betty/<br></code></pre></td></tr></table></figure><p>选择符会包括它前后的多个字符，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配<code>b</code>或者<code>c</code>。如果想修改这个行为，可以使用圆括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/a( |\t)b/.test(<span class="hljs-string">&#x27;a\tb&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码指的是，<code>a</code>和<code>b</code>之间有一个空格或者一个制表符。</p><p>其他的元字符还包括<code>\</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>等，将在下文解释。</p><h4 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h4><p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配<code>+</code>，就要写成<code>\+</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/<span class="hljs-number">1</span>+<span class="hljs-number">1</span>/.test(<span class="hljs-string">&#x27;1+1&#x27;</span>)<br><span class="hljs-comment">// false</span><br><br>/<span class="hljs-number">1</span>\+<span class="hljs-number">1</span>/.test(<span class="hljs-string">&#x27;1+1&#x27;</span>)<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。</p><p>正则表达式中，需要反斜杠转义的，一共有12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;</code>和<code>\</code>。需要特别注意的是，如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;1\+1&#x27;</span>)).test(<span class="hljs-string">&#x27;1+1&#x27;</span>)<br><span class="hljs-comment">// false</span><br><br>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;1\\+1&#x27;</span>)).test(<span class="hljs-string">&#x27;1+1&#x27;</span>)<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>RegExp</code>作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。</p><h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p><ul><li><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是A-Z之中任一个英文字母，用来匹配控制字符。</li><li><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。</li><li><code>\n</code> 匹配换行键。</li><li><code>\r</code> 匹配回车键。</li><li><code>\t</code> 匹配制表符 tab（U+0009）。</li><li><code>\v</code> 匹配垂直制表符（U+000B）。</li><li><code>\f</code> 匹配换页符（U+000C）。</li><li><code>\0</code> 匹配<code>null</code>字符（U+0000）。</li><li><code>\xhh</code> 匹配一个以两位十六进制数（<code>\x00</code>-<code>\xFF</code>）表示的字符。</li><li><code>\uhhhh</code> 匹配一个以四位十六进制数（<code>\u0000</code>-<code>\uFFFF</code>）表示的 Unicode 字符。</li></ul><h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h4><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如<code>[xyz]</code> 表示<code>x</code>、<code>y</code>、<code>z</code>之中任选一个匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/[abc]/.test(<span class="hljs-string">&#x27;hello world&#x27;</span>) <span class="hljs-comment">// false</span><br>/[abc]/.test(<span class="hljs-string">&#x27;apple&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，字符串<code>hello world</code>不包含<code>a</code>、<code>b</code>、<code>c</code>这三个字母中的任一个，所以返回<code>false</code>；字符串<code>apple</code>包含字母<code>a</code>，所以返回<code>true</code>。</p><p>有两个字符在字符类中有特殊含义。</p><p><strong>（1）脱字符（&#94;）</strong></p><p>如果方括号内的第一个字符是<code>[^]</code>，则表示除了字符类之中的字符，其他字符都可以匹配。比如，<code>[^xyz]</code>表示除了<code>x</code>、<code>y</code>、<code>z</code>之外都可以匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/[^abc]/.test(<span class="hljs-string">&#x27;bbc news&#x27;</span>) <span class="hljs-comment">// true</span><br>/[^abc]/.test(<span class="hljs-string">&#x27;bbc&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，字符串<code>bbc news</code>包含<code>a</code>、<code>b</code>、<code>c</code>以外的其他字符，所以返回<code>true</code>；字符串<code>bbc</code>不包含<code>a</code>、<code>b</code>、<code>c</code>以外的其他字符，所以返回<code>false</code>。</p><p>如果方括号内没有其他字符，即只有<code>[^]</code>，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（<code>.</code>）是不包括换行符的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;Please yes\nmake my day!&#x27;</span>;<br><br>s.match(<span class="hljs-regexp">/yes.*day/</span>) <span class="hljs-comment">// null</span><br>s.match(<span class="hljs-regexp">/yes[^]*day/</span>) <span class="hljs-comment">// [ &#x27;yes\nmake my day&#x27;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，字符串<code>s</code>含有一个换行符，点号不包括换行符，所以第一个正则表达式匹配失败；第二个正则表达式<code>[^]</code>包含一切字符，所以匹配成功。</p><blockquote><p>注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。</p></blockquote><p><strong>（2）连字符（-）</strong></p><p>某些情况下，对于连续序列的字符，连字符（<code>-</code>）用来提供简写形式，表示字符的连续范围。比如，<code>[abc]</code>可以写成<code>[a-c]</code>，<code>[0123456789]</code>可以写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/a-z/.test(<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// false</span><br>/[a-z]/.test(<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符<code>b</code>。只有当连字号用在方括号之中，才表示连续的字符序列。</p><p>以下都是合法的字符类简写形式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">0</span>-<span class="hljs-number">9.</span>,]<br>[<span class="hljs-number">0</span>-9a-fA-F]<br>[a-zA-Z0-<span class="hljs-number">9</span>-]<br>[<span class="hljs-number">1</span>-<span class="hljs-number">31</span>]<br></code></pre></td></tr></table></figure><p>上面代码中最后一个字符类<code>[1-31]</code>，不代表<code>1</code>到<code>31</code>，只代表<code>1</code>到<code>3</code>。</p><p>连字符还可以用来指定 Unicode 字符的范围。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;\u0130\u0131\u0132&quot;</span>;<br>/[\u0128-\uFFFF]/.test(str)<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>\u0128-\uFFFF</code>表示匹配码点在<code>0128</code>到<code>FFFF</code>之间的所有字符。</p><p>另外，不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是<code>[A-z]</code>，表面上它是选中从大写的<code>A</code>到小写的<code>z</code>之间52个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/[A-z]/.test(<span class="hljs-string">&#x27;\\&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，由于反斜杠（’\‘）的ASCII码在大写字母与小写字母之间，结果会被选中。</p><h4 id="预定义模式"><a href="#预定义模式" class="headerlink" title="预定义模式"></a>预定义模式</h4><p>预定义模式指的是某些常见模式的简写方式。</p><ul><li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li><li><code>\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li><li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li><li><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li><li><code>\s</code> 匹配空格（包括换行符、制表符、空格符等），相等于<code>[ \t\r\n\v\f]</code>。</li><li><code>\S</code> 匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。</li><li><code>\b</code> 匹配词的边界。</li><li><code>\B</code> 匹配非词边界，即在词的内部。</li></ul><p>下面是一些例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// \s 的例子</span><br>/\s\w*<span class="hljs-regexp">/.exec(&#x27;hello world&#x27;) /</span><span class="hljs-regexp">/ [&quot; world&quot;]</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">/ \b 的例子</span><br><span class="hljs-regexp">/</span>\bworld/.test(<span class="hljs-string">&#x27;hello world&#x27;</span>) <span class="hljs-comment">// true</span><br>/\bworld/.test(<span class="hljs-string">&#x27;hello-world&#x27;</span>) <span class="hljs-comment">// true</span><br>/\bworld/.test(<span class="hljs-string">&#x27;helloworld&#x27;</span>) <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// \B 的例子</span><br>/\Bworld/.test(<span class="hljs-string">&#x27;hello-world&#x27;</span>) <span class="hljs-comment">// false</span><br>/\Bworld/.test(<span class="hljs-string">&#x27;helloworld&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>\s</code>表示空格，所以匹配结果会包括空格。<code>\b</code>表示词的边界，所以<code>world</code>的词首必须独立（词尾是否独立未指定），才会匹配。同理，<code>\B</code>表示非词的边界，只有<code>world</code>的词首不独立，才会匹配。</p><p>通常，正则表达式遇到换行符（<code>\n</code>）就会停止匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> html = <span class="hljs-string">&quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span>;<br><br>/.*/.exec(html)[<span class="hljs-number">0</span>]<br><span class="hljs-comment">// &quot;&lt;b&gt;Hello&lt;/b&gt;&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，字符串<code>html</code>包含一个换行符，结果点字符（<code>.</code>）不匹配换行符，导致匹配结果可能不符合原意。这时使用<code>\s</code>字符类，就能包括换行符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> html = <span class="hljs-string">&quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span>;<br><br>/[\S\s]*/.exec(html)[<span class="hljs-number">0</span>]<br><span class="hljs-comment">// &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>[\S\s]</code>指代一切字符。</p><h4 id="重复类"><a href="#重复类" class="headerlink" title="重复类"></a>重复类</h4><p>模式的精确匹配次数，使用大括号（<code>&#123;&#125;</code>）表示。<code>&#123;n&#125;</code>表示恰好重复<code>n</code>次，<code>&#123;n,&#125;</code>表示至少重复<code>n</code>次，<code>&#123;n,m&#125;</code>表示重复不少于<code>n</code>次，不多于<code>m</code>次。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/lo&#123;<span class="hljs-number">2</span>&#125;k/.test(<span class="hljs-string">&#x27;look&#x27;</span>) <span class="hljs-comment">// true</span><br>/lo&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;k/.test(<span class="hljs-string">&#x27;looook&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，第一个模式指定<code>o</code>连续出现2次，第二个模式指定<code>o</code>连续出现2次到5次之间。</p><h4 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h4><p>量词符用来设定某个模式出现的次数。</p><ul><li><code>?</code> 问号表示某个模式出现0次或1次，等同于<code>&#123;0, 1&#125;</code>。</li><li><code>*</code> 星号表示某个模式出现0次或多次，等同于<code>&#123;0,&#125;</code>。</li><li><code>+</code> 加号表示某个模式出现1次或多次，等同于<code>&#123;1,&#125;</code>。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// t 出现0次或1次</span><br>/t?est/.test(<span class="hljs-string">&#x27;test&#x27;</span>) <span class="hljs-comment">// true</span><br>/t?est/.test(<span class="hljs-string">&#x27;est&#x27;</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// t 出现1次或多次</span><br>/t+est/.test(<span class="hljs-string">&#x27;test&#x27;</span>) <span class="hljs-comment">// true</span><br>/t+est/.test(<span class="hljs-string">&#x27;ttest&#x27;</span>) <span class="hljs-comment">// true</span><br>/t+est/.test(<span class="hljs-string">&#x27;est&#x27;</span>) <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// t 出现0次或多次</span><br>/t*est/.test(<span class="hljs-string">&#x27;test&#x27;</span>) <span class="hljs-comment">// true</span><br>/t*est/.test(<span class="hljs-string">&#x27;ttest&#x27;</span>) <span class="hljs-comment">// true</span><br>/t*est/.test(<span class="hljs-string">&#x27;tttest&#x27;</span>) <span class="hljs-comment">// true</span><br>/t*est/.test(<span class="hljs-string">&#x27;est&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h4 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h4><p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配到下一个字符不满足匹配规则为止。这被称为贪婪模式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>s.match(<span class="hljs-regexp">/a+/</span>) <span class="hljs-comment">// [&quot;aaa&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，模式是<code>/a+/</code>，表示匹配1个<code>a</code>或多个<code>a</code>，那么到底会匹配几个<code>a</code>呢？因为默认是贪婪模式，会一直匹配到字符<code>a</code>不出现为止，所以匹配结果是3个<code>a</code>。</p><p>除了贪婪模式，还有非贪婪模式，即最小可能匹配。只要一发现匹配，就返回结果，不要往下检查。如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>s.match(<span class="hljs-regexp">/a+?/</span>) <span class="hljs-comment">// [&quot;a&quot;]</span><br></code></pre></td></tr></table></figure><p>上面例子中，模式结尾添加了一个问号<code>/a+?/</code>，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配，<code>+?</code>表示只要发现一个<code>a</code>，就不再往下匹配了。</p><p>除了非贪婪模式的加号（<code>+?</code>），还有非贪婪模式的星号（<code>*?</code>）和非贪婪模式的问号（<code>??</code>）。</p><ul><li><code>+?</code>：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</li><li><code>*?</code>：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</li><li><code>??</code>：表格某个模式出现0次或1次，匹配时采用非贪婪模式。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abb&#x27;</span>.match(<span class="hljs-regexp">/ab*/</span>) <span class="hljs-comment">// [&quot;abb&quot;]</span><br><span class="hljs-string">&#x27;abb&#x27;</span>.match(<span class="hljs-regexp">/ab*?/</span>) <span class="hljs-comment">// [&quot;a&quot;]</span><br><br><span class="hljs-string">&#x27;abb&#x27;</span>.match(<span class="hljs-regexp">/ab?/</span>) <span class="hljs-comment">// [&quot;ab&quot;]</span><br><span class="hljs-string">&#x27;abb&#x27;</span>.match(<span class="hljs-regexp">/ab??/</span>) <span class="hljs-comment">// [&quot;a&quot;]</span><br></code></pre></td></tr></table></figure><p>上面例子中，<code>/ab*/</code>表示如果<code>a</code>后面有多个<code>b</code>，那么匹配尽可能多的<code>b</code>；<code>/ab*?/</code>表示匹配尽可能少的<code>b</code>，也就是0个<code>b</code>。</p><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。</p><p>修饰符可以单个使用，也可以多个一起使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 单个修饰符</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/test/i</span>;<br><br><span class="hljs-comment">// 多个修饰符</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/test/ig</span>;<br></code></pre></td></tr></table></figure><p><strong>（1）g 修饰符</strong></p><p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。<code>g</code>修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/b/</span>;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abba&#x27;</span>;<br><br>regex.test(str); <span class="hljs-comment">// true</span><br>regex.test(str); <span class="hljs-comment">// true</span><br>regex.test(str); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，正则模式不含<code>g</code>修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回<code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/b/g</span>;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abba&#x27;</span>;<br><br>regex.test(str); <span class="hljs-comment">// true</span><br>regex.test(str); <span class="hljs-comment">// true</span><br>regex.test(str); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，正则模式含有<code>g</code>修饰符，每次都是从上一次匹配成功处，开始向后匹配。因为字符串<code>abba</code>只有两个<code>b</code>，所以前两次匹配结果为<code>true</code>，第三次匹配结果为<code>false</code>。</p><p><strong>（2）i 修饰符</strong></p><p>默认情况下，正则对象区分字母的大小写，加上<code>i</code>修饰符以后表示忽略大小写（ignoreCase）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/abc/.test(<span class="hljs-string">&#x27;ABC&#x27;</span>) <span class="hljs-comment">// false</span><br>/abc/i.test(<span class="hljs-string">&#x27;ABC&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码表示，加了<code>i</code>修饰符以后，不考虑大小写，所以模式<code>abc</code>匹配字符串<code>ABC</code>。</p><p><strong>（3）m 修饰符</strong></p><p><code>m</code>修饰符表示多行模式（multiline），会修改<code>^</code>和<code>$</code>的行为。默认情况下（即不加<code>m</code>修饰符时），<code>^</code>和<code>$</code>匹配字符串的开始处和结尾处，加上<code>m</code>修饰符以后，<code>^</code>和<code>$</code>还会匹配行首和行尾，即<code>^</code>和<code>$</code>会识别换行符（<code>\n</code>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/world$/.test(<span class="hljs-string">&#x27;hello world\n&#x27;</span>) <span class="hljs-comment">// false</span><br>/world$/m.test(<span class="hljs-string">&#x27;hello world\n&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面的代码中，字符串结尾处有一个换行符。如果不加<code>m</code>修饰符，匹配不成功，因为字符串的结尾不是<code>world</code>；加上以后，<code>$</code>可以匹配行尾。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/^b/m.test(<span class="hljs-string">&#x27;a\nb&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码要求匹配行首的<code>b</code>，如果不加<code>m</code>修饰符，就相当于<code>b</code>只能处在字符串的开始处。加上<code>m</code>修饰符以后，换行符<code>\n</code>也会被认为是一行的开始。</p><h4 id="组匹配"><a href="#组匹配" class="headerlink" title="组匹配"></a>组匹配</h4><p><strong>（1）概述</strong></p><p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/fred+<span class="hljs-regexp">/.test(&#x27;fredd&#x27;) /</span><span class="hljs-regexp">/ true</span><br><span class="hljs-regexp">/</span>(fred)+<span class="hljs-regexp">/.test(&#x27;fredfred&#x27;) /</span><span class="hljs-regexp">/ true</span><br></code></pre></td></tr></table></figure><p>上面代码中，第一个模式没有括号，结果<code>+</code>只表示重复字母<code>d</code>，第二个模式有括号，结果<code>+</code>就表示匹配<code>fred</code>这个词。</p><p>下面是另外一个分组捕获的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-string">&#x27;abcabc&#x27;</span>.match(<span class="hljs-regexp">/(.)b(.)/</span>);<br>m<br><span class="hljs-comment">// [&#x27;abc&#x27;, &#x27;a&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，正则表达式<code>/(.)b(.)/</code>一共使用两个括号，第一个括号捕获<code>a</code>，第二个括号捕获<code>c</code>。</p><p>注意，使用组匹配时，不宜同时使用<code>g</code>修饰符，否则<code>match</code>方法不会捕获分组的内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-string">&#x27;abcabc&#x27;</span>.match(<span class="hljs-regexp">/(.)b(.)/g</span>);<br>m <span class="hljs-comment">// [&#x27;abc&#x27;, &#x27;abc&#x27;]</span><br></code></pre></td></tr></table></figure><p>上面代码使用带<code>g</code>修饰符的正则表达式，结果<code>match</code>方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的<code>exec</code>方法，配合循环，才能读到每一轮匹配的组捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abcabc&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(.)b(.)/g</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">var</span> result = reg.exec(str);<br>  <span class="hljs-keyword">if</span> (!result) <span class="hljs-keyword">break</span>;<br>  <span class="hljs-built_in">console</span>.log(result);<br>&#125;<br><span class="hljs-comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]</span><br><span class="hljs-comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]</span><br></code></pre></td></tr></table></figure><p>正则表达式内部，还可以用<code>\n</code>引用括号匹配的内容，<code>n</code>是从1开始的自然数，表示对应顺序的括号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/(.)b(.)\1b\<span class="hljs-number">2</span>/.test(<span class="hljs-string">&quot;abcabc&quot;</span>)<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面的代码中，<code>\1</code>表示第一个括号匹配的内容（即<code>a</code>），<code>\2</code>表示第二个括号匹配的内容（即<code>c</code>）。</p><p>下面是另外一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/y(..)(.)\<span class="hljs-number">2</span>\<span class="hljs-number">1</span>/.test(<span class="hljs-string">&#x27;yabccab&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>括号还可以嵌套。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/y((..)\<span class="hljs-number">2</span>)\<span class="hljs-number">1</span>/.test(<span class="hljs-string">&#x27;yabababab&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>\1</code>指向外层括号，<code>\2</code>指向内层括号。</p><p>组匹配非常有用，下面是一个匹配网页标签的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tagName = <span class="hljs-regexp">/&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/</span>;<br><br>tagName.exec(<span class="hljs-string">&quot;&lt;b&gt;bold&lt;/b&gt;&quot;</span>)[<span class="hljs-number">1</span>]<br><span class="hljs-comment">// &#x27;b&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中，圆括号匹配尖括号之中的标签，而<code>\1</code>就表示对应的闭合标签。</p><p>上面代码略加修改，就能捕获带有属性的标签。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> html = <span class="hljs-string">&#x27;&lt;b class=&quot;hello&quot;&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;&#x27;</span>;<br><span class="hljs-keyword">var</span> tag = <span class="hljs-regexp">/&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g</span>;<br><br><span class="hljs-keyword">var</span> match = tag.exec(html);<br><br>match[<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;b&quot;</span><br>match[<span class="hljs-number">2</span>] <span class="hljs-comment">// &quot; class=&quot;hello&quot;&quot;</span><br>match[<span class="hljs-number">3</span>] <span class="hljs-comment">// &quot;Hello&quot;</span><br><br>match = tag.exec(html);<br><br>match[<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;i&quot;</span><br>match[<span class="hljs-number">2</span>] <span class="hljs-comment">// &quot;&quot;</span><br>match[<span class="hljs-number">3</span>] <span class="hljs-comment">// &quot;world&quot;</span><br></code></pre></td></tr></table></figure><p><strong>（2）非捕获组</strong></p><p><code>(?:x)</code>称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</p><p>非捕获组的作用请考虑这样一个场景，假定需要匹配<code>foo</code>或者<code>foofoo</code>，正则表达式就应该写成<code>/(foo)&#123;1, 2&#125;/</code>，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为<code>/(?:foo)&#123;1, 2&#125;/</code>，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。</p><p>请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-string">&#x27;abc&#x27;</span>.match(<span class="hljs-regexp">/(?:.)b(.)/</span>);<br>m <span class="hljs-comment">// [&quot;abc&quot;, &quot;c&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。</p><p>下面是用来分解网址的正则表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 正常匹配</span><br><span class="hljs-keyword">var</span> url = <span class="hljs-regexp">/(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/</span>;<br><br>url.exec(<span class="hljs-string">&#x27;http://google.com/&#x27;</span>);<br><span class="hljs-comment">// [&quot;http://google.com/&quot;, &quot;http&quot;, &quot;google.com&quot;, &quot;/&quot;]</span><br><br><span class="hljs-comment">// 非捕获组匹配</span><br><span class="hljs-keyword">var</span> url = <span class="hljs-regexp">/(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/</span>;<br><br>url.exec(<span class="hljs-string">&#x27;http://google.com/&#x27;</span>);<br><span class="hljs-comment">// [&quot;http://google.com/&quot;, &quot;google.com&quot;, &quot;/&quot;]</span><br></code></pre></td></tr></table></figure><p>上面的代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。</p><p><strong>（3）先行断言</strong></p><p><code>x(?=y)</code>称为先行断言（Positive look-ahead），<code>x</code>只有在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成<code>/\d+(?=%)/</code>。</p><p>“先行断言”中，括号里的部分是不会返回的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-string">&#x27;abc&#x27;</span>.match(<span class="hljs-regexp">/b(?=c)/</span>);<br>m <span class="hljs-comment">// [&quot;b&quot;]</span><br></code></pre></td></tr></table></figure><p>上面的代码使用了先行断言，<code>b</code>在<code>c</code>前面所以被匹配，但是括号对应的<code>c</code>不会被返回。</p><p><strong>（4）先行否定断言</strong></p><p><code>x(?!y)</code>称为先行否定断言（Negative look-ahead），<code>x</code>只有不在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成<code>/\d+(?!%)/</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">/\d+(?!\.)/.exec(<span class="hljs-string">&#x27;3.14&#x27;</span>)<br><span class="hljs-comment">// [&quot;14&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是<code>14</code>。</p><p>“先行否定断言”中，括号里的部分是不会返回的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-string">&#x27;abd&#x27;</span>.match(<span class="hljs-regexp">/b(?!c)/</span>);<br>m <span class="hljs-comment">// [&#x27;b&#x27;]</span><br></code></pre></td></tr></table></figure><p>上面的代码使用了先行否定断言，<code>b</code>不在<code>c</code>前面所以被匹配，而且括号对应的<code>d</code>不会被返回  </p><h2 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h2><h3 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h3><p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。</p><p>相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准  </p><p>每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值  </p><p>JSON 对值的类型和格式有严格的规定  </p><blockquote><ol><li><p>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</p></li><li><p>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和<code>null</code>（不能使用<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>和<code>undefined</code>）。</p></li><li><p>字符串必须使用双引号表示，不能使用单引号。</p></li><li><p>对象的键名必须放在双引号里面。</p></li><li><p>数组或对象最后一个成员的后面，不能加逗号。</p></li></ol></blockquote><p>以下都是合法的 JSON  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>]<br><br>&#123; <span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;three&quot;</span>: <span class="hljs-number">3</span> &#125;<br><br>&#123;<span class="hljs-string">&quot;names&quot;</span>: [<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>] &#125;<br><br>[ &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;李四&quot;</span>&#125; ]<br></code></pre></td></tr></table></figure><p>以下都是不合法的 JSON  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">32</span> &#125;  <span class="hljs-comment">// 属性名必须使用双引号</span><br><br>[<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">128</span>, <span class="hljs-number">0xFFF</span>] <span class="hljs-comment">// 不能使用十六进制值</span><br><br>&#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-literal">undefined</span> &#125; <span class="hljs-comment">// 不能使用 undefined</span><br><br>&#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-string">&quot;birthday&quot;</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;Fri, 26 Aug 2011 07:13:10 GMT&#x27;</span>),<br>  <span class="hljs-string">&quot;getName&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>  &#125;<br>&#125; <span class="hljs-comment">// 属性值不能使用函数和日期对象</span><br></code></pre></td></tr></table></figure><p>注意，<code>null</code>、空数组和空对象都是合法的 JSON 值  </p><h3 id="JSON-对象-1"><a href="#JSON-对象-1" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><p><code>JSON</code>对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：<code>JSON.stringify()</code>和<code>JSON.parse()</code>  </p><h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>JSON.stringify()</code>方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被<code>JSON.parse()</code>方法还原。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">&#x27;abc&#x27;</span>) <span class="hljs-comment">// &quot;&quot;abc&quot;&quot;</span><br><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;1&quot;</span><br><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-literal">false</span>) <span class="hljs-comment">// &quot;false&quot;</span><br><span class="hljs-built_in">JSON</span>.stringify([]) <span class="hljs-comment">// &quot;[]&quot;</span><br><span class="hljs-built_in">JSON</span>.stringify(&#123;&#125;) <span class="hljs-comment">// &quot;&#123;&#125;&quot;</span><br><br><span class="hljs-built_in">JSON</span>.stringify([<span class="hljs-number">1</span>, <span class="hljs-string">&quot;false&quot;</span>, <span class="hljs-literal">false</span>])<br><span class="hljs-comment">// &#x27;[1,&quot;false&quot;,false]&#x27;</span><br><br><span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span> &#125;)<br><span class="hljs-comment">// &#x27;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码将各种类型的值，转成 JSON 字符串  </p><p>注意，对于原始类型的字符串，转换结果会带双引号  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">&#x27;foo&#x27;</span>) === <span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-comment">// false</span><br><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">&#x27;foo&#x27;</span>) === <span class="hljs-string">&quot;\&quot;foo\&quot;&quot;</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，字符串<code>foo</code>，被转成了<code>&quot;\&quot;foo\&quot;&quot;</code>。这是因为将来还原的时候，内层双引号可以让 JavaScript 引擎知道，这是一个字符串，而不是其他类型的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-literal">false</span>) <span class="hljs-comment">// &quot;false&quot;</span><br><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">&#x27;false&#x27;</span>) <span class="hljs-comment">// &quot;\&quot;false\&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，如果不是内层的双引号，将来还原的时候，引擎就无法知道原始值是布尔值还是字符串  </p><p>如果对象的属性是<code>undefined</code>、函数或 XML 对象，该属性会被<code>JSON.stringify()</code>过滤  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  a: <span class="hljs-literal">undefined</span>,<br>  b: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-built_in">JSON</span>.stringify(obj) <span class="hljs-comment">// &quot;&#123;&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>的<code>a</code>属性是<code>undefined</code>，而<code>b</code>属性是一个函数，结果都被<code>JSON.stringify</code>过滤  </p><p>如果数组的成员是<code>undefined</code>、函数或 XML 对象，则这些值被转成<code>null</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-literal">undefined</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;];<br><span class="hljs-built_in">JSON</span>.stringify(arr) <span class="hljs-comment">// &quot;[null,null]&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，数组<code>arr</code>的成员是<code>undefined</code>和函数，它们都被转成了<code>null</code>  </p><p>正则对象会被转成空对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-regexp">/foo/</span>) <span class="hljs-comment">// &quot;&#123;&#125;&quot;</span><br></code></pre></td></tr></table></figure><p><code>JSON.stringify()</code>方法会忽略对象的不可遍历的属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperties(obj, &#123;<br>  <span class="hljs-string">&#x27;foo&#x27;</span>: &#123;<br>    value: <span class="hljs-number">1</span>,<br>    enumerable: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-string">&#x27;bar&#x27;</span>: &#123;<br>    value: <span class="hljs-number">2</span>,<br>    enumerable: <span class="hljs-literal">false</span><br>  &#125;<br>&#125;);<br><br><span class="hljs-built_in">JSON</span>.stringify(obj); <span class="hljs-comment">// &quot;&#123;&quot;foo&quot;:1&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>bar</code>是<code>obj</code>对象的不可遍历属性，<code>JSON.stringify</code>方法会忽略这个属性  </p><h4 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h4><p><code>JSON.stringify()</code>方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-string">&#x27;prop1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>,<br>  <span class="hljs-string">&#x27;prop2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>,<br>  <span class="hljs-string">&#x27;prop3&#x27;</span>: <span class="hljs-string">&#x27;value3&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> selectedProperties = [<span class="hljs-string">&#x27;prop1&#x27;</span>, <span class="hljs-string">&#x27;prop2&#x27;</span>];<br><br><span class="hljs-built_in">JSON</span>.stringify(obj, selectedProperties)<br><span class="hljs-comment">// &quot;&#123;&quot;prop1&quot;:&quot;value1&quot;,&quot;prop2&quot;:&quot;value2&quot;&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>JSON.stringify()</code>方法的第二个参数指定，只转<code>prop1</code>和<code>prop2</code>两个属性  </p><p>这个类似白名单的数组，只对对象的属性有效，对数组无效  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>], [<span class="hljs-string">&#x27;0&#x27;</span>])<br><span class="hljs-comment">// &quot;[&quot;a&quot;,&quot;b&quot;]&quot;</span><br><br><span class="hljs-built_in">JSON</span>.stringify(&#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>&#125;, [<span class="hljs-string">&#x27;0&#x27;</span>])<br><span class="hljs-comment">// &quot;&#123;&quot;0&quot;:&quot;a&quot;&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，第二个参数指定 JSON 格式只转<code>0</code>号属性，实际上对数组是无效的，只对对象有效  </p><p>第二个参数还可以是一个函数，用来更改<code>JSON.stringify()</code>的返回值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">key, value</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    value = <span class="hljs-number">2</span> * value;<br>  &#125;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;, f)<br><span class="hljs-comment">// &#x27;&#123;&quot;a&quot;: 2,&quot;b&quot;: 4&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中的<code>f</code>函数，接受两个参数，分别是被转换的对象的键名和键值。如果键值是数值，就将它乘以<code>2</code>，否则就原样返回  </p><p>注意，这个处理函数是递归处理所有的键  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: <span class="hljs-number">1</span>&#125;&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">key, value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[&quot;</span>+ key +<span class="hljs-string">&quot;]:&quot;</span> + value);<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-built_in">JSON</span>.stringify(obj, f)<br><span class="hljs-comment">// []:[object Object]</span><br><span class="hljs-comment">// [a]:[object Object]</span><br><span class="hljs-comment">// [b]:1</span><br><span class="hljs-comment">// &#x27;&#123;&quot;a&quot;:&#123;&quot;b&quot;:1&#125;&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>一共会被<code>f</code>函数处理三次，输出的最后那行是<code>JSON.stringify()</code>的默认输出。第一次键名为空，键值是整个对象<code>obj</code>；第二次键名为<code>a</code>，键值是<code>&#123;b: 1&#125;</code>；第三次键名为<code>b</code>，键值为1  </p><p>递归处理中，每一次处理的对象，都是前一次返回的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">key, value</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;;<br>  &#125;<br>  <span class="hljs-keyword">return</span> value * <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-built_in">JSON</span>.stringify(obj, f)<br><span class="hljs-comment">// &quot;&#123;&quot;b&quot;: 4&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>f</code>函数修改了对象<code>obj</code>，接着<code>JSON.stringify()</code>方法就递归处理修改后的对象<code>obj</code>  </p><p>如果处理函数返回<code>undefined</code>或没有返回值，则该属性会被忽略  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">key, value</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(value) === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">123</span> &#125;, f)<br><span class="hljs-comment">// &#x27;&#123;&quot;b&quot;: 123&#125;&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>a</code>属性经过处理后，返回<code>undefined</code>，于是该属性被忽略了  </p><h4 id="第三个参数"><a href="#第三个参数" class="headerlink" title="第三个参数"></a>第三个参数</h4><p><code>JSON.stringify()</code>还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性  </p><p>默认返回的是单行字符串，对于大型的 JSON 对象，可读性非常差。第三个参数使得每个属性单独占据一行，并且将每个属性前面添加指定的前缀（不超过10个字符）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 默认输出</span><br><span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">p1</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">p2</span>: <span class="hljs-number">2</span> &#125;)<br><span class="hljs-comment">// JSON.stringify(&#123; p1: 1, p2: 2 &#125;)</span><br><br><span class="hljs-comment">// 分行输出</span><br><span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">p1</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">p2</span>: <span class="hljs-number">2</span> &#125;, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;\t&#x27;</span>)<br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">// &quot;p1&quot;: 1,</span><br><span class="hljs-comment">// &quot;p2&quot;: 2</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>上面例子中，第三个属性<code>\t</code>在每个属性前面添加一个制表符，然后分行显示  </p><p>第三个属性如果是一个数字，则表示每个属性前面添加的空格（最多不超过10个）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">p1</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">p2</span>: <span class="hljs-number">2</span> &#125;, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&quot;&#123;</span><br><span class="hljs-comment">  &quot;p1&quot;: 1,</span><br><span class="hljs-comment">  &quot;p2&quot;: 2</span><br><span class="hljs-comment">&#125;&quot;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h4 id="参数对象的-toJSON-方法"><a href="#参数对象的-toJSON-方法" class="headerlink" title="参数对象的 toJSON() 方法"></a>参数对象的 toJSON() 方法</h4><p>如果参数对象有自定义的<code>toJSON()</code>方法，那么<code>JSON.stringify()</code>会使用这个方法的返回值作为参数，而忽略原对象的其他属性  </p><p>下面是一个普通的对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;<br>  firstName: <span class="hljs-string">&#x27;三&#x27;</span>,<br>  lastName: <span class="hljs-string">&#x27;张&#x27;</span>,<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.lastName + <span class="hljs-built_in">this</span>.firstName;<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">JSON</span>.stringify(user)<br><span class="hljs-comment">// &quot;&#123;&quot;firstName&quot;:&quot;三&quot;,&quot;lastName&quot;:&quot;张&quot;,&quot;fullName&quot;:&quot;张三&quot;&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>现在，为这个对象加上<code>toJSON()</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;<br>  firstName: <span class="hljs-string">&#x27;三&#x27;</span>,<br>  lastName: <span class="hljs-string">&#x27;张&#x27;</span>,<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.lastName + <span class="hljs-built_in">this</span>.firstName;<br>  &#125;,<br><br>  toJSON: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      name: <span class="hljs-built_in">this</span>.lastName + <span class="hljs-built_in">this</span>.firstName<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">JSON</span>.stringify(user)<br><span class="hljs-comment">// &quot;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>JSON.stringify()</code>发现参数对象有<code>toJSON()</code>方法，就直接使用这个方法的返回值作为参数，而忽略原对象的其他参数  </p><p><code>Date</code>对象就有一个自己的<code>toJSON()</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;2015-01-01&#x27;</span>);<br>date.toJSON() <span class="hljs-comment">// &quot;2015-01-01T00:00:00.000Z&quot;</span><br><span class="hljs-built_in">JSON</span>.stringify(date) <span class="hljs-comment">// &quot;&quot;2015-01-01T00:00:00.000Z&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>JSON.stringify()</code>发现处理的是<code>Date</code>对象实例，就会调用这个实例对象的<code>toJSON()</code>方法，将该方法的返回值作为参数  </p><p><code>toJSON()</code>方法的一个应用是，将正则对象自动转为字符串。因为<code>JSON.stringify()</code>默认不能转换正则对象，但是设置了<code>toJSON()</code>方法以后，就可以转换正则对象了  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  reg: <span class="hljs-regexp">/foo/</span><br>&#125;;<br><br><span class="hljs-comment">// 不设置 toJSON 方法时</span><br><span class="hljs-built_in">JSON</span>.stringify(obj) <span class="hljs-comment">// &quot;&#123;&quot;reg&quot;:&#123;&#125;&#125;&quot;</span><br><br><span class="hljs-comment">// 设置 toJSON 方法时</span><br><span class="hljs-built_in">RegExp</span>.prototype.toJSON = <span class="hljs-built_in">RegExp</span>.prototype.toString;<br><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-regexp">/foo/</span>) <span class="hljs-comment">// &quot;&quot;/foo/&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码在正则对象的原型上面部署了<code>toJSON()</code>方法，将其指向<code>toString()</code>方法，因此转换成 JSON 格式时，正则对象就先调用<code>toJSON()</code>方法转为字符串，然后再被<code>JSON.stringify()</code>方法处理  </p><h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h3><p><code>JSON.parse()</code>方法用于将 JSON 字符串转换成对应的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>) <span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;true&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&quot;foo&quot;&#x27;</span>) <span class="hljs-comment">// &quot;foo&quot;</span><br><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;[1, 5, &quot;false&quot;]&#x27;</span>) <span class="hljs-comment">// [1, 5, &quot;false&quot;]</span><br><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;null&#x27;</span>) <span class="hljs-comment">// null</span><br><br><span class="hljs-keyword">var</span> o = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;张三&quot;&#125;&#x27;</span>);<br>o.name <span class="hljs-comment">// 张三</span><br></code></pre></td></tr></table></figure><p>如果传入的字符串不是有效的 JSON 格式，<code>JSON.parse()</code>方法将报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&quot;&#x27;String&#x27;&quot;</span>) <span class="hljs-comment">// illegal single quotes</span><br><span class="hljs-comment">// SyntaxError: Unexpected token ILLEGAL</span><br></code></pre></td></tr></table></figure><p>上面代码中，双引号字符串中是一个单引号字符串，因为单引号字符串不符合 JSON 格式，所以报错  </p><p>为了处理解析错误，可以将<code>JSON.parse()</code>方法放在<code>try...catch</code>代码块中  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&quot;&#x27;String&#x27;&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parsing error&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>JSON.parse()</code>方法可以接受一个处理函数，作为第二个参数，用法与<code>JSON.stringify()</code>方法类似  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">key, value</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> value + <span class="hljs-number">10</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#x27;</span>, f)<br><span class="hljs-comment">// &#123;a: 11, b: 2&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>JSON.parse()</code>的第二个参数是一个函数，如果键名是<code>a</code>，该函数会将键值加上10    </p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="实例对象与-new-命令"><a href="#实例对象与-new-命令" class="headerlink" title="实例对象与 new 命令"></a>实例对象与 new 命令</h2><p><code>Javascript</code> 语言具有很强的面向对象编程能力，本章介绍 <code>Javascript</code> 面向对象编程的基础知识  </p><h3 id="对象是什么"><a href="#对象是什么" class="headerlink" title="对象是什么"></a>对象是什么</h3><p>面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟  </p><p>每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目  </p><p>那么，“对象”（object）到底是什么？我们从两个层次来理解  </p><p><strong>（1）对象是单个实物的抽象</strong>  </p><p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个远程服务器连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程  </p><p><strong>（2）对象是一个容器，封装了属性（property）和方法（method）</strong>  </p><p>属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为<code>animal</code>对象，使用“属性”记录具体是哪一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）  </p><h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成  </p><p>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，<code>Javascript</code> 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）  </p><p><code>Javascript</code> 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构  </p><p>构造函数就是一个普通的函数，但具有自己的特征和用法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Vehicle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.price = <span class="hljs-number">1000</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>Vehicle</code>就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写  </p><p>构造函数的特点有两个  </p><ul><li>函数体内部使用了<code>this</code>关键字，代表了所要生成的对象实例  </li><li>生成对象的时候，必须使用<code>new</code>命令  </li></ul><p>下面先介绍<code>new</code>命令  </p><h3 id="new-命令"><a href="#new-命令" class="headerlink" title="new 命令"></a>new 命令</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>new</code>命令的作用，就是执行构造函数，返回一个实例对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Vehicle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.price = <span class="hljs-number">1000</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Vehicle();<br>v.price <span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure><p>上面代码通过<code>new</code>命令，让构造函数<code>Vehicle</code>生成一个实例对象，保存在变量<code>v</code>中。这个新生成的实例对象，从构造函数<code>Vehicle</code>得到了<code>price</code>属性。<code>new</code>命令执行时，构造函数内部的<code>this</code>，就代表了新生成的实例对象，<code>this.price</code>表示实例对象有一个<code>price</code>属性，值是1000  </p><p>使用<code>new</code>命令时，根据需要，构造函数也可以接受参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Vehicle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">p</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.price = p;<br>&#125;;<br><br><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Vehicle(<span class="hljs-number">500</span>);<br></code></pre></td></tr></table></figure><p><code>new</code>命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 推荐的写法</span><br><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Vehicle();<br><span class="hljs-comment">// 不推荐的写法</span><br><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Vehicle;<br></code></pre></td></tr></table></figure><p>一个很自然的问题是，如果忘了使用<code>new</code>命令，直接调用构造函数会发生什么事？  </p><p>这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，<code>this</code>这时代表全局对象，将造成一些意想不到的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Vehicle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">this</span>.price = <span class="hljs-number">1000</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> v = Vehicle();<br>v <span class="hljs-comment">// undefined</span><br>price <span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure><p>上面代码中，调用<code>Vehicle</code>构造函数时，忘了加上<code>new</code>命令。结果，变量<code>v</code>变成了<code>undefined</code>，而<code>price</code>属性变成了全局变量。因此，应该非常小心，避免不使用<code>new</code>命令、直接调用构造函数  </p><p>为了保证构造函数必须与<code>new</code>命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上<code>use strict</code>。这样的话，一旦忘了使用<code>new</code>命令，直接调用构造函数就会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fubar</span>(<span class="hljs-params">foo, bar</span>)</span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-built_in">this</span>._foo = foo;<br>  <span class="hljs-built_in">this</span>._bar = bar;<br>&#125;<br><br>Fubar()<br><span class="hljs-comment">// TypeError: Cannot set property &#x27;_foo&#x27; of undefined</span><br></code></pre></td></tr></table></figure><p>上面代码的<code>Fubar</code>为构造函数，<code>use strict</code>命令保证了该函数在严格模式下运行。由于严格模式中，函数内部的<code>this</code>不能指向全局对象，默认等于<code>undefined</code>，导致不加<code>new</code>调用会报错（<code>Javascript</code> 不允许对<code>undefined</code>添加属性）  </p><p>另一个解决办法，构造函数内部判断是否使用<code>new</code>命令，如果发现没有使用，则直接返回一个实例对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fubar</span>(<span class="hljs-params">foo, bar</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> Fubar)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fubar(foo, bar);<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>._foo = foo;<br>  <span class="hljs-built_in">this</span>._bar = bar;<br>&#125;<br><br>Fubar(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)._foo <span class="hljs-comment">// 1</span><br>(<span class="hljs-keyword">new</span> Fubar(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))._foo <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中的构造函数，不管加不加<code>new</code>命令，都会得到同样的结果  </p><h4 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h4><p>使用<code>new</code>命令时，它后面的函数依次执行下面的步骤  </p><ol><li>创建一个空对象，作为将要返回的对象实例  </li><li>将这个空对象的原型，指向构造函数的<code>prototype</code>属性  </li><li>将这个空对象赋值给函数内部的<code>this</code>关键字  </li><li>开始执行构造函数内部的代码  </li></ol><p>也就是说，构造函数内部，<code>this</code>指的是一个新生成的空对象，所有针对<code>this</code>的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即<code>this</code>对象），将其“构造”为需要的样子  </p><p>如果构造函数内部有<code>return</code>语句，而且<code>return</code>后面跟着一个对象，<code>new</code>命令会返回<code>return</code>语句指定的对象；否则，就会不管<code>return</code>语句，返回<code>this</code>对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Vehicle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.price = <span class="hljs-number">1000</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span>;<br>&#125;;<br><br>(<span class="hljs-keyword">new</span> Vehicle()) === <span class="hljs-number">1000</span><br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，构造函数<code>Vehicle</code>的<code>return</code>语句返回一个数值。这时，<code>new</code>命令就会忽略这个<code>return</code>语句，返回“构造”后的<code>this</code>对象  </p><p>但是，如果<code>return</code>语句返回的是一个跟<code>this</code>无关的新对象，<code>new</code>命令会返回这个新对象，而不是<code>this</code>对象。这一点需要特别引起注意  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Vehicle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">this</span>.price = <span class="hljs-number">1000</span>;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">price</span>: <span class="hljs-number">2000</span> &#125;;<br>&#125;;<br><br>(<span class="hljs-keyword">new</span> Vehicle()).price<br><span class="hljs-comment">// 2000</span><br></code></pre></td></tr></table></figure><p>上面代码中，构造函数<code>Vehicle</code>的<code>return</code>语句，返回的是一个新对象。<code>new</code>命令会返回这个对象，而不是<code>this</code>对象  </p><p>另一方面，如果对普通函数（内部没有<code>this</code>关键字的函数）使用<code>new</code>命令，则会返回一个空对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMessage</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;this is a message&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> msg = <span class="hljs-keyword">new</span> getMessage();<br><br>msg <span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-keyword">typeof</span> msg <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>getMessage</code>是一个普通函数，返回一个字符串。对它使用<code>new</code>命令，会得到一个空对象。这是因为<code>new</code>命令总是返回一个对象，要么是实例对象，要么是<code>return</code>语句指定的对象。本例中，<code>return</code>语句返回的是字符串，所以<code>new</code>命令就忽略了该语句  </p><p><code>new</code>命令简化的内部流程，可以用下面的代码表示  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_new</span>(<span class="hljs-params"><span class="hljs-comment">/* 构造函数 */</span> constructor, <span class="hljs-comment">/* 构造函数参数 */</span> params</span>) </span>&#123;<br>  <span class="hljs-comment">// 将 arguments 对象转为数组</span><br>  <span class="hljs-keyword">var</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>);<br>  <span class="hljs-comment">// 取出构造函数</span><br>  <span class="hljs-keyword">var</span> <span class="hljs-title">constructor</span> = <span class="hljs-title">args</span>.<span class="hljs-title">shift</span>(<span class="hljs-params"></span>);<br>  <span class="hljs-comment">// 创建一个空对象，继承构造函数的 prototype 属性</span><br>  <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">Object</span>.create(<span class="hljs-title">constructor</span>.<span class="hljs-title">prototype</span>);<br>  <span class="hljs-comment">// 执行构造函数</span><br>  <span class="hljs-keyword">var</span> result = <span class="hljs-title">constructor</span>.<span class="hljs-title">apply</span>(<span class="hljs-params">context, args</span>);<br>  <span class="hljs-comment">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; result != <span class="hljs-literal">null</span>) ? result : context;<br>&#125;<br><br><span class="hljs-comment">// 实例</span><br><span class="hljs-keyword">var</span> actor = _new(Person, <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">28</span>);<br></code></pre></td></tr></table></figure><h4 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h4><p>函数内部可以使用<code>new.target</code>属性。如果当前函数是<code>new</code>命令调用，<code>new.target</code>指向当前函数，否则为<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span>.target === f);<br>&#125;<br><br>f() <span class="hljs-comment">// false</span><br><span class="hljs-keyword">new</span> f() <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>使用这个属性，可以判断函数调用的时候，是否使用<code>new</code>命令。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.target) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;请使用 new 命令调用！&#x27;</span>);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>f() <span class="hljs-comment">// Uncaught Error: 请使用 new 命令调用！</span><br></code></pre></td></tr></table></figure><p>上面代码中，构造函数<code>f</code>调用时，没有使用<code>new</code>命令，就抛出一个错误。</p><h3 id="Object-create-创建实例对象"><a href="#Object-create-创建实例对象" class="headerlink" title="Object.create() 创建实例对象"></a>Object.create() 创建实例对象</h3><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用<code>Object.create()</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person1 = &#123;<br>  name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  age: <span class="hljs-number">38</span>,<br>  greeting: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;.&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> person2 = <span class="hljs-built_in">Object</span>.create(person1);<br><br>person2.name <span class="hljs-comment">// 张三</span><br>person2.greeting() <span class="hljs-comment">// Hi! I&#x27;m 张三.</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>person1</code>是<code>person2</code>的模板，后者继承了前者的属性和方法  </p><h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p><code>this</code>关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成  </p><p>前一章已经提到，<code>this</code>可以用在构造函数之中，表示实例对象。除此之外，<code>this</code>还可以用在别的场合。但不管是什么场合，<code>this</code>都有一个共同点：它总是返回一个对象  </p><p>简单说，<code>this</code>就是属性或方法“当前”所在的对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.property<br></code></pre></td></tr></table></figure><p>上面代码中，<code>this</code>就代表<code>property</code>属性当前所在的对象  </p><p>下面是一个实际的例子  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>  name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  describe: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;姓名：&#x27;</span>+ <span class="hljs-built_in">this</span>.name;<br>  &#125;<br>&#125;;<br><br>person.describe()<br><span class="hljs-comment">// &quot;姓名：张三&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>this.name</code>表示<code>name</code>属性所在的那个对象。由于<code>this.name</code>是在<code>describe</code>方法中调用，而<code>describe</code>方法所在的当前对象是<code>person</code>，因此<code>this</code>指向<code>person</code>，<code>this.name</code>就是<code>person.name</code>  </p><p>由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即<code>this</code>的指向是可变的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> A = &#123;<br>  name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  describe: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;姓名：&#x27;</span>+ <span class="hljs-built_in">this</span>.name;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> B = &#123;<br>  name: <span class="hljs-string">&#x27;李四&#x27;</span><br>&#125;;<br><br>B.describe = A.describe;<br>B.describe()<br><span class="hljs-comment">// &quot;姓名：李四&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>A.describe</code>属性被赋给<code>B</code>，于是<code>B.describe</code>就表示<code>describe</code>方法所在的当前对象是<code>B</code>，所以<code>this.name</code>就指向<code>B.name</code>  </p><p>稍稍重构这个例子，<code>this</code>的动态指向就能看得更清楚  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;姓名：&#x27;</span>+ <span class="hljs-built_in">this</span>.name;<br>&#125;<br><br><span class="hljs-keyword">var</span> A = &#123;<br>  name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  describe: f<br>&#125;;<br><br><span class="hljs-keyword">var</span> B = &#123;<br>  name: <span class="hljs-string">&#x27;李四&#x27;</span>,<br>  describe: f<br>&#125;;<br><br>A.describe() <span class="hljs-comment">// &quot;姓名：张三&quot;</span><br>B.describe() <span class="hljs-comment">// &quot;姓名：李四&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>内部使用了<code>this</code>关键字，随着<code>f</code>所在的对象不同，<code>this</code>的指向也不同  </p><p>只要函数被赋给另一个变量，<code>this</code>的指向就会变  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> A = &#123;<br>  name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  describe: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;姓名：&#x27;</span>+ <span class="hljs-built_in">this</span>.name;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;李四&#x27;</span>;<br><span class="hljs-keyword">var</span> f = A.describe;<br>f() <span class="hljs-comment">// &quot;姓名：李四&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>A.describe</code>被赋值给变量<code>f</code>，内部的<code>this</code>就会指向<code>f</code>运行时所在的对象（本例是顶层对象）  </p><p>再看一个网页编程的例子  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">3</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&quot;validate(this, 18, 99);&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validate</span>(<span class="hljs-params">obj, lowval, hival</span>)</span>&#123;</span><br><span class="javascript">  <span class="hljs-keyword">if</span> ((obj.value &lt; lowval) || (obj.value &gt; hival))</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Invalid Value!&#x27;</span>);</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面代码是一个文本输入框，每当用户输入一个值，就会调用<code>onChange</code>回调函数，验证这个值是否在指定范围。浏览器会向回调函数传入当前对象，因此<code>this</code>就代表传入当前对象（即文本框），然后就可以从<code>this.value</code>上面读到用户的输入值  </p><p>总结一下，<code>Javascript</code> 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，<code>this</code>就是函数运行时所在的对象（环境）  </p><p>这本来并不会让用户糊涂，但是 <code>Javascript</code> 支持运行环境动态切换，也就是说，<code>this</code>的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方  </p><h3 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h3><p><code>Javascript</code> 语言之所以有 <code>this</code> 的设计，跟内存里面的数据结构有关系  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">foo</span>:  <span class="hljs-number">5</span> &#125;;<br></code></pre></td></tr></table></figure><p>上面的代码将一个对象赋值给变量<code>obj</code>  </p><p><code>Javascript</code> 引擎会先在内存里面，生成一个对象<code>&#123; foo: 5 &#125;</code>，然后把这个对象的内存地址赋值给变量<code>obj</code>。也就是说，变量<code>obj</code>是一个地址（reference）。后面如果要读取<code>obj.foo</code>，引擎先从<code>obj</code>拿到内存地址，然后再从该地址读出原始的对象，返回它的<code>foo</code>属性  </p><p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的<code>foo</code>属性，实际上是以下面的形式保存的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  foo: &#123;<br>    [[value]]: <span class="hljs-number">5</span><br>    [[writable]]: <span class="hljs-literal">true</span><br>    [[enumerable]]: <span class="hljs-literal">true</span><br>    [[configurable]]: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，<code>foo</code>属性的值保存在属性描述对象的<code>value</code>属性里面  </p><p>这样的结构是很清晰的，问题在于属性的值可能是一个函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125; &#125;;<br></code></pre></td></tr></table></figure><p>这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给<code>foo</code>属性的<code>value</code>属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  foo: &#123;<br>    [[value]]: 函数的地址<br>    ...<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">f</span>: f &#125;;<br><br><span class="hljs-comment">// 单独执行</span><br>f()<br><br><span class="hljs-comment">// obj 环境执行</span><br>obj.f()<br></code></pre></td></tr></table></figure><p>JavaScript 允许在函数体内部，引用当前环境的其他变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(x);<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码中，函数体里面使用了变量<code>x</code>。该变量由运行环境提供  </p><p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，函数体里面的<code>this.x</code>就是指当前运行环境的<code>x</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>&#125;<br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  f: f,<br>  x: <span class="hljs-number">2</span>,<br>&#125;;<br><br><span class="hljs-comment">// 单独执行</span><br>f() <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// obj 环境执行</span><br>obj.f() <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>在全局环境执行，<code>this.x</code>指向全局环境的<code>x</code>；在<code>obj</code>环境执行，<code>this.x</code>指向<code>obj.x</code>  </p><h3 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h3><p><code>this</code>主要有以下几个使用场合  </p><p><strong>（1）全局环境</strong>  </p><p>全局环境使用<code>this</code>，它指的就是顶层对象<code>window</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span> === <span class="hljs-built_in">window</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === <span class="hljs-built_in">window</span>);<br>&#125;<br>f() <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，<code>this</code>就是指顶层对象<code>window</code>  </p><p><strong>（2）构造函数</strong>  </p><p>构造函数中的<code>this</code>，指的是实例对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Obj = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">p</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.p = p;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码定义了一个构造函数<code>Obj</code>。由于<code>this</code>指向实例对象，所以在构造函数内部定义<code>this.p</code>，就相当于定义实例对象有一个<code>p</code>属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> Obj(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br>o.p <span class="hljs-comment">// &quot;Hello World!&quot;</span><br></code></pre></td></tr></table></figure><p>**（3）对象的方法 ** </p><p>如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变<code>this</code>的指向  </p><p>但是，这条规则很不容易把握。请看下面的代码  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj =&#123;<br>  foo: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;;<br><br>obj.foo() <span class="hljs-comment">// obj</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.foo</code>方法执行时，它内部的<code>this</code>指向<code>obj</code>  </p><p>但是，下面这几种用法，都会改变<code>this</code>的指向  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 情况一</span><br>(obj.foo = obj.foo)() <span class="hljs-comment">// window</span><br><span class="hljs-comment">// 情况二</span><br>(<span class="hljs-literal">false</span> || obj.foo)() <span class="hljs-comment">// window</span><br><span class="hljs-comment">// 情况三</span><br>(<span class="hljs-number">1</span>, obj.foo)() <span class="hljs-comment">// window</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.foo</code>就是一个值。这个值真正调用的时候，运行环境已经不是<code>obj</code>了，而是全局环境，所以<code>this</code>不再指向<code>obj</code>  </p><p>可以这样理解，<code>Javascript</code> 引擎内部，<code>obj</code>和<code>obj.foo</code>储存在两个内存地址，称为地址一和地址二。<code>obj.foo()</code>这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，<code>this</code>指向<code>obj</code>。但是，上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此<code>this</code>指向全局环境。上面三种情况等同于下面的代码  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 情况一</span><br>(obj.foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;)()<br><span class="hljs-comment">// 等同于</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;)()<br><br><span class="hljs-comment">// 情况二</span><br>(<span class="hljs-literal">false</span> || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;)()<br><br><span class="hljs-comment">// 情况三</span><br>(<span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;)()<br></code></pre></td></tr></table></figure><p>如果<code>this</code>所在的方法不在对象的第一层，这时<code>this</code>只是指向当前一层的对象，而不会继承更上面的层  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;<br>  p: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>  b: &#123;<br>    m: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.p);<br>    &#125;<br>  &#125;<br>&#125;;<br><br>a.b.m() <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>a.b.m</code>方法在<code>a</code>对象的第二层，该方法内部的<code>this</code>不是指向<code>a</code>，而是指向<code>a.b</code>，因为实际执行的是下面的代码  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> b = &#123;<br>  m: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.p);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> a = &#123;<br>  p: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>  b: b<br>&#125;;<br><br>(a.b).m() <span class="hljs-comment">// 等同于 b.m()</span><br></code></pre></td></tr></table></figure><p>如果要达到预期效果，只有写成下面这样  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;<br>  b: &#123;<br>    m: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.p);<br>    &#125;,<br>    p: <span class="hljs-string">&#x27;Hello&#x27;</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>如果这时将嵌套对象内部的方法赋值给一个变量，<code>this</code>依然会指向全局对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;<br>  b: &#123;<br>    m: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.p);<br>    &#125;,<br>    p: <span class="hljs-string">&#x27;Hello&#x27;</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> hello = a.b.m;<br>hello() <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>m</code>是多层对象内部的一个方法。为求简便，将其赋值给<code>hello</code>变量，结果调用时，<code>this</code>指向了顶层对象。为了避免这个问题，可以只将<code>m</code>所在的对象赋值给<code>hello</code>，这样调用时，<code>this</code>的指向就不会变  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hello = a.b;<br>hello.m() <span class="hljs-comment">// Hello</span><br></code></pre></td></tr></table></figure><h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><h4 id="避免多层-this"><a href="#避免多层-this" class="headerlink" title="避免多层 this"></a>避免多层 this</h4><p>由于<code>this</code>的指向是不确定的，所以切勿在函数中包含多层的<code>this</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>  f1: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    &#125;();<br>  &#125;<br>&#125;<br><br>o.f1()<br><span class="hljs-comment">// Object</span><br><span class="hljs-comment">// Window</span><br></code></pre></td></tr></table></figure><p>上面代码包含两层<code>this</code>，结果运行后，第一层指向对象<code>o</code>，第二层指向全局对象，因为实际执行的是下面的代码  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> temp = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> o = &#123;<br>  f1: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">var</span> f2 = temp();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个解决方法是在第二层改用一个指向外层<code>this</code>的变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>  f1: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(that);<br>    &#125;();<br>  &#125;<br>&#125;<br><br>o.f1()<br><span class="hljs-comment">// Object</span><br><span class="hljs-comment">// Object</span><br></code></pre></td></tr></table></figure><p>上面代码定义了变量<code>that</code>，固定指向外层的<code>this</code>，然后在内层使用<code>that</code>，就不会发生<code>this</code>指向的改变  </p><p>事实上，使用一个变量固定<code>this</code>的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握  </p><p>JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的<code>this</code>指向顶层对象，就会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> counter = &#123;<br>  count: <span class="hljs-number">0</span><br>&#125;;<br>counter.inc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.count++<br>&#125;;<br><span class="hljs-keyword">var</span> f = counter.inc;<br>f()<br><span class="hljs-comment">// TypeError: Cannot read property &#x27;count&#x27; of undefined</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>inc</code>方法通过<code>&#39;use strict&#39;</code>声明采用严格模式，这时内部的<code>this</code>一旦指向顶层对象，就会报错  </p><h4 id="避免数组处理方法中的-this"><a href="#避免数组处理方法中的-this" class="headerlink" title="避免数组处理方法中的 this"></a>避免数组处理方法中的 this</h4><p>数组的<code>map</code>和<code>foreach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用<code>this</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>  v: <span class="hljs-string">&#x27;hello&#x27;</span>,<br>  p: [ <span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;a2&#x27;</span> ],<br>  f: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.p.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.v + <span class="hljs-string">&#x27; &#x27;</span> + item);<br>    &#125;);<br>  &#125;<br>&#125;<br><br>o.f()<br><span class="hljs-comment">// undefined a1</span><br><span class="hljs-comment">// undefined a2</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>foreach</code>方法的回调函数中的<code>this</code>，其实是指向<code>window</code>对象，因此取不到<code>o.v</code>的值。原因跟上一段的多层<code>this</code>是一样的，就是内层的<code>this</code>不指向外部，而指向顶层对象  </p><p>解决这个问题的一种方法，就是前面提到的，使用中间变量固定<code>this</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>  v: <span class="hljs-string">&#x27;hello&#x27;</span>,<br>  p: [ <span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;a2&#x27;</span> ],<br>  f: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-built_in">this</span>.p.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(that.v+<span class="hljs-string">&#x27; &#x27;</span>+item);<br>    &#125;);<br>  &#125;<br>&#125;<br><br>o.f()<br><span class="hljs-comment">// hello a1</span><br><span class="hljs-comment">// hello a2</span><br></code></pre></td></tr></table></figure><p>另一种方法是将<code>this</code>当作<code>foreach</code>方法的第二个参数，固定它的运行环境  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>  v: <span class="hljs-string">&#x27;hello&#x27;</span>,<br>  p: [ <span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;a2&#x27;</span> ],<br>  f: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.p.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.v + <span class="hljs-string">&#x27; &#x27;</span> + item);<br>    &#125;, <span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br><br>o.f()<br><span class="hljs-comment">// hello a1</span><br><span class="hljs-comment">// hello a2</span><br></code></pre></td></tr></table></figure><h4 id="避免回调函数中的-this"><a href="#避免回调函数中的-this" class="headerlink" title="避免回调函数中的 this"></a>避免回调函数中的 this</h4><p>回调函数中的<code>this</code>往往会改变指向，最好避免使用  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>o.f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === o);<br>&#125;<br><br><span class="hljs-comment">// jQuery 的写法</span><br>$(<span class="hljs-string">&#x27;#button&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>, o.f);<br></code></pre></td></tr></table></figure><p>上面代码中，点击按钮以后，控制台会显示<code>false</code>。原因是此时<code>this</code>不再指向<code>o</code>对象，而是指向按钮的 DOM 对象，因为<code>f</code>方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误  </p><p>为了解决这个问题，可以采用下面的一些方法对<code>this</code>进行绑定，也就是使得<code>this</code>固定指向某个对象，减少不确定性  </p><h3 id="绑定-this-的方法"><a href="#绑定-this-的方法" class="headerlink" title="绑定 this 的方法"></a>绑定 this 的方法</h3><p><code>this</code>的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把<code>this</code>固定下来，避免出现意想不到的情况。JavaScript 提供了<code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换/固定<code>this</code>的指向  </p><h4 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h4><p>函数实例的<code>call</code>方法，可以指定函数内部<code>this</code>的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;;<br><br>f() === <span class="hljs-built_in">window</span> <span class="hljs-comment">// true</span><br>f.call(obj) === obj <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，全局环境运行函数<code>f</code>时，<code>this</code>指向全局环境（浏览器为<code>window</code>对象）；<code>call</code>方法可以改变<code>this</code>的指向，指定<code>this</code>指向对象<code>obj</code>，然后在对象<code>obj</code>的作用域中运行函数<code>f</code>  </p><p><code>call</code>方法的参数，应该是一个对象。如果参数为空、<code>null</code>和<code>undefined</code>，则默认传入全局对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">n</span>: <span class="hljs-number">456</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.n);<br>&#125;<br><br>a.call() <span class="hljs-comment">// 123</span><br>a.call(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 123</span><br>a.call(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 123</span><br>a.call(<span class="hljs-built_in">window</span>) <span class="hljs-comment">// 123</span><br>a.call(obj) <span class="hljs-comment">// 456</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>a</code>函数中的<code>this</code>关键字，如果指向全局对象，返回结果为<code>123</code>。如果使用<code>call</code>方法将<code>this</code>关键字指向<code>obj</code>对象，返回结果为<code>456</code>。可以看到，如果<code>call</code>方法没有参数，或者参数为<code>null</code>或<code>undefined</code>，则等同于指向全局对象  </p><p>如果<code>call</code>方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入<code>call</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;;<br><br>f.call(<span class="hljs-number">5</span>)<br><span class="hljs-comment">// Number &#123;[[PrimitiveValue]]: 5&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>call</code>的参数为<code>5</code>，不是对象，会被自动转成包装对象（<code>Number</code>的实例），绑定<code>f</code>内部的<code>this</code>。</p><p><code>call</code>方法还可以接受多个参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">func.call(thisValue, arg1, arg2, ...)<br></code></pre></td></tr></table></figure><p><code>call</code>的第一个参数就是<code>this</code>所要指向的那个对象，后面的参数则是函数调用时所需的参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br>add.call(<span class="hljs-built_in">this</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>call</code>方法指定函数<code>add</code>内部的<code>this</code>绑定当前环境（对象），并且参数为<code>1</code>和<code>2</code>，因此函数<code>add</code>运行后得到<code>3</code>  </p><p><code>call</code>方法的一个应用是调用对象的原生方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.hasOwnProperty(<span class="hljs-string">&#x27;toString&#x27;</span>) <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 覆盖掉继承的 hasOwnProperty 方法</span><br>obj.hasOwnProperty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br>obj.hasOwnProperty(<span class="hljs-string">&#x27;toString&#x27;</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, <span class="hljs-string">&#x27;toString&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>hasOwnProperty</code>是<code>obj</code>对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。<code>call</code>方法可以解决这个问题，它将<code>hasOwnProperty</code>方法的原始定义放到<code>obj</code>对象上执行，这样无论<code>obj</code>上有没有同名方法，都不会影响结果  </p><h4 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h4><p><code>apply</code>方法的作用与<code>call</code>方法类似，也是改变<code>this</code>指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">func.apply(thisValue, [arg1, arg2, ...])<br></code></pre></td></tr></table></figure><p><code>apply</code>方法的第一个参数也是<code>this</code>所要指向的那个对象，如果设为<code>null</code>或<code>undefined</code>，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在<code>call</code>方法中必须一个个添加，但是在<code>apply</code>方法中，必须以数组形式添加  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">x, y</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(x + y);<br>&#125;<br><br>f.call(<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 2</span><br>f.apply(<span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>f</code>函数本来接受两个参数，使用<code>apply</code>方法以后，就变成可以接受一个数组作为参数。</p><p>利用这一点，可以做一些有趣的应用  </p><p><strong>（1）找出数组最大元素</strong>  </p><p>JavaScript 不提供找出数组最大元素的函数。结合使用<code>apply</code>方法和<code>Math.max</code>方法，就可以返回数组的最大元素  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>];<br><span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, a) <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p><strong>（2）将数组的空元素变为<code>undefined</code></strong>  </p><p>通过<code>apply</code>方法，利用<code>Array</code>构造函数将数组的空元素变成<code>undefined</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, ,<span class="hljs-string">&#x27;b&#x27;</span>])<br><span class="hljs-comment">// [ &#x27;a&#x27;, undefined, &#x27;b&#x27; ]</span><br></code></pre></td></tr></table></figure><p>空元素与<code>undefined</code>的差别在于，数组的<code>forEach</code>方法会跳过空元素，但是不会跳过<code>undefined</code>。因此，遍历内部元素的时候，会得到不同的结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, , <span class="hljs-string">&#x27;b&#x27;</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">i</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br><br>a.forEach(print)<br><span class="hljs-comment">// a</span><br><span class="hljs-comment">// b</span><br><br><span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, a).forEach(print)<br><span class="hljs-comment">// a</span><br><span class="hljs-comment">// undefined</span><br><span class="hljs-comment">// b</span><br></code></pre></td></tr></table></figure><p><strong>（3）转换类似数组的对象</strong>  </p><p>另外，利用数组对象的<code>slice</code>方法，可以将一个类似数组的对象（比如<code>arguments</code>对象）转为真正的数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.slice.apply(&#123;<span class="hljs-number">0</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// [1]</span><br><span class="hljs-built_in">Array</span>.prototype.slice.apply(&#123;<span class="hljs-number">0</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// []</span><br><span class="hljs-built_in">Array</span>.prototype.slice.apply(&#123;<span class="hljs-number">0</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>&#125;) <span class="hljs-comment">// [1, undefined]</span><br><span class="hljs-built_in">Array</span>.prototype.slice.apply(&#123;<span class="hljs-attr">length</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// [undefined]</span><br></code></pre></td></tr></table></figure><p>上面代码的<code>apply</code>方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有<code>length</code>属性，以及相对应的数字键  </p><p><strong>（4）绑定回调函数的对象</strong>  </p><p>前面的按钮点击事件的例子，可以改写如下  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br>o.f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === o);<br>&#125;<br><br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>  o.f.apply(o);<br>  <span class="hljs-comment">// 或者 o.f.call(o);</span><br>&#125;;<br><br><span class="hljs-comment">// jQuery 的写法</span><br>$(<span class="hljs-string">&#x27;#button&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>, f);<br></code></pre></td></tr></table></figure><p>上面代码中，点击按钮以后，控制台将会显示<code>true</code>。由于<code>apply()</code>方法（或者<code>call()</code>方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的<code>bind()</code>方法  </p><h4 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h4><p><code>bind()</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>d.getTime() <span class="hljs-comment">// 1481869925657</span><br><br><span class="hljs-keyword">var</span> print = d.getTime;<br>print() <span class="hljs-comment">// Uncaught TypeError: this is not a Date object.</span><br></code></pre></td></tr></table></figure><p>上面代码中，我们将<code>d.getTime()</code>方法赋给变量<code>print</code>，然后调用<code>print()</code>就报错了。这是因为<code>getTime()</code>方法内部的<code>this</code>，绑定<code>Date</code>对象的实例，赋给变量<code>print</code>以后，内部的<code>this</code>已经不指向<code>Date</code>对象的实例了  </p><p><code>bind()</code>方法可以解决这个问题  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> print = d.getTime.bind(d);<br>print() <span class="hljs-comment">// 1481869925657</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>bind()</code>方法将<code>getTime()</code>方法内部的<code>this</code>绑定到<code>d</code>对象，这时就可以安全地将这个方法赋值给其他变量了  </p><p><code>bind</code>方法的参数就是所要绑定<code>this</code>的对象，下面是一个更清晰的例子  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> counter = &#123;<br>  count: <span class="hljs-number">0</span>,<br>  inc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.count++;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> func = counter.inc.bind(counter);<br>func();<br>counter.count <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>counter.inc()</code>方法被赋值给变量<code>func</code>。这时必须用<code>bind()</code>方法将<code>inc()</code>内部的<code>this</code>，绑定到<code>counter</code>，否则就会出错  </p><p><code>this</code>绑定到其他对象也是可以的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> counter = &#123;<br>  count: <span class="hljs-number">0</span>,<br>  inc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.count++;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  count: <span class="hljs-number">100</span><br>&#125;;<br><span class="hljs-keyword">var</span> func = counter.inc.bind(obj);<br>func();<br>obj.count <span class="hljs-comment">// 101</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>bind()</code>方法将<code>inc()</code>方法内部的<code>this</code>，绑定到<code>obj</code>对象。结果调用<code>func</code>函数以后，递增的就是<code>obj</code>内部的<code>count</code>属性  </p><p><code>bind()</code>还可以接受更多的参数，将这些参数绑定原函数的参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x * <span class="hljs-built_in">this</span>.m + y * <span class="hljs-built_in">this</span>.n;<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  m: <span class="hljs-number">2</span>,<br>  n: <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> newAdd = add.bind(obj, <span class="hljs-number">5</span>);<br>newAdd(<span class="hljs-number">5</span>) <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>bind()</code>方法除了绑定<code>this</code>对象，还将<code>add()</code>函数的第一个参数<code>x</code>绑定成<code>5</code>，然后返回一个新函数<code>newAdd()</code>，这个函数只要再接受一个参数<code>y</code>就能运行了  </p><p>如果<code>bind()</code>方法的第一个参数是<code>null</code>或<code>undefined</code>，等于将<code>this</code>绑定到全局对象，函数运行时<code>this</code>指向顶层对象（浏览器为<code>window</code>）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-keyword">var</span> plus5 = add.bind(<span class="hljs-literal">null</span>, <span class="hljs-number">5</span>);<br>plus5(<span class="hljs-number">10</span>) <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>add()</code>内部并没有<code>this</code>，使用<code>bind()</code>方法的主要目的是绑定参数<code>x</code>，以后每次运行新函数<code>plus5()</code>，就只需要提供另一个参数<code>y</code>就够了。而且因为<code>add()</code>内部没有<code>this</code>，所以<code>bind()</code>的第一个参数是<code>null</code>，不过这里如果是其他对象，也没有影响  </p><p><code>bind()</code>方法有一些使用注意点  </p><p><strong>（1）每一次返回一个新函数</strong></p><p><code>bind()</code>方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">element.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, o.m.bind(o));<br></code></pre></td></tr></table></figure><p>上面代码中，<code>click</code>事件绑定<code>bind()</code>方法生成的一个匿名函数。这样会导致无法取消绑定，所以下面的代码是无效的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">element.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, o.m.bind(o));<br></code></pre></td></tr></table></figure><p>正确的方法是写成下面这样：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> listener = o.m.bind(o);<br>element.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, listener);<br><span class="hljs-comment">//  ...</span><br>element.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, listener);<br></code></pre></td></tr></table></figure><p>**（2）结合回调函数使用 ** </p><p>回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含<code>this</code>的方法直接当作回调函数。解决方法就是使用<code>bind()</code>方法，将<code>counter.inc()</code>绑定<code>counter</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> counter = &#123;<br>  count: <span class="hljs-number">0</span>,<br>  inc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">    &#x27;use strict&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.count++;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callIt</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  callback();<br>&#125;<br><br>callIt(counter.inc.bind(counter));<br>counter.count <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>callIt()</code>方法会调用回调函数。这时如果直接把<code>counter.inc</code>传入，调用时<code>counter.inc()</code>内部的<code>this</code>就会指向全局对象。使用<code>bind()</code>方法将<code>counter.inc</code>绑定<code>counter</code>以后，就不会有这个问题，<code>this</code>总是指向<code>counter</code>  </p><p>还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的<code>this</code>指向，很可能也会出错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  times: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>  print: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.times.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>    &#125;);<br>  &#125;<br>&#125;;<br><br>obj.print()<br><span class="hljs-comment">// 没有任何输出</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.print</code>内部<code>this.times</code>的<code>this</code>是指向<code>obj</code>的，这个没有问题。但是，<code>forEach()</code>方法的回调函数内部的<code>this.name</code>却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj.print = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.times.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === <span class="hljs-built_in">window</span>);<br>  &#125;);<br>&#125;;<br><br>obj.print()<br><span class="hljs-comment">// true</span><br><span class="hljs-comment">// true</span><br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>解决这个问题，也是通过<code>bind()</code>方法绑定<code>this</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj.print = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.times.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;.bind(<span class="hljs-built_in">this</span>));<br>&#125;;<br><br>obj.print()<br><span class="hljs-comment">// 张三</span><br><span class="hljs-comment">// 张三</span><br><span class="hljs-comment">// 张三</span><br></code></pre></td></tr></table></figure><p>**（3）结合<code>call()</code>方法使用  **</p><p>利用<code>bind()</code>方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的<code>slice()</code>方法为例  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// [1]</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">Array</span>.prototype.slice.call([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// [1]</span><br></code></pre></td></tr></table></figure><p>上面的代码中，数组的<code>slice</code>方法从<code>[1, 2, 3]</code>里面，按照指定的开始位置和结束位置，切分出另一个数组。这样做的本质是在<code>[1, 2, 3]</code>上面调用<code>Array.prototype.slice()</code>方法，因此可以用<code>call</code>方法表达这个过程，得到同样的结果  </p><p><code>call()</code>方法实质上是调用<code>Function.prototype.call()</code>方法，因此上面的表达式可以用<code>bind()</code>方法改写  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> slice = <span class="hljs-built_in">Function</span>.prototype.call.bind(<span class="hljs-built_in">Array</span>.prototype.slice);<br>slice([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// [1]</span><br></code></pre></td></tr></table></figure><p>上面代码的含义就是，将<code>Array.prototype.slice</code>变成<code>Function.prototype.call</code>方法所在的对象，调用时就变成了<code>Array.prototype.slice.call</code>。类似的写法还可以用于其他数组方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> push = <span class="hljs-built_in">Function</span>.prototype.call.bind(<span class="hljs-built_in">Array</span>.prototype.push);<br><span class="hljs-keyword">var</span> pop = <span class="hljs-built_in">Function</span>.prototype.call.bind(<span class="hljs-built_in">Array</span>.prototype.pop);<br><br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span> ,<span class="hljs-number">2</span> ,<span class="hljs-number">3</span>];<br>push(a, <span class="hljs-number">4</span>)<br>a <span class="hljs-comment">// [1, 2, 3, 4]</span><br><br>pop(a)<br>a <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>如果再进一步，将<code>Function.prototype.call</code>方法绑定到<code>Function.prototype.bind</code>对象，就意味着<code>bind</code>的调用形式也可以被改写  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.v);<br>&#125;<br><br><span class="hljs-keyword">var</span> o = &#123; <span class="hljs-attr">v</span>: <span class="hljs-number">123</span> &#125;;<br><span class="hljs-keyword">var</span> bind = <span class="hljs-built_in">Function</span>.prototype.call.bind(<span class="hljs-built_in">Function</span>.prototype.bind);<br>bind(f, o)() <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>上面代码的含义就是，将<code>Function.prototype.bind</code>方法绑定在<code>Function.prototype.call</code>上面，所以<code>bind</code>方法就可以直接使用，不需要在函数实例上使用  </p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>面向对象编程很重要的一个方面，就是对象的继承  </p><p>A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的  </p><p>大部分面向对象的编程语言，都是通过“类”（class）实现对象的继承。传统上，<code>Javascript</code> 语言的继承不通过 class，而是通过“原型对象”（prototype）实现，本章介绍 <code>Javascript</code> 的原型链继承  </p><blockquote><p>ES6 引入了 class 语法，基于 class 的继承不在这个教程介绍  </p></blockquote><h3 id="原型对象概述"><a href="#原型对象概述" class="headerlink" title="原型对象概述"></a>原型对象概述</h3><h4 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h4><p><code>Javascript</code> 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span> (<span class="hljs-params">name, color</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.color = color;<br>&#125;<br><br><span class="hljs-keyword">var</span> cat1 = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;大毛&#x27;</span>, <span class="hljs-string">&#x27;白色&#x27;</span>);<br><br>cat1.name <span class="hljs-comment">// &#x27;大毛&#x27;</span><br>cat1.color <span class="hljs-comment">// &#x27;白色&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Cat</code>函数是一个构造函数，函数内部定义了<code>name</code>属性和<code>color</code>属性，所有实例对象（上例是<code>cat1</code>）都会生成这两个属性，即这两个属性会定义在实例对象上面  </p><p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name, color</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.color = color;<br>  <span class="hljs-built_in">this</span>.meow = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;喵喵&#x27;</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> cat1 = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;大毛&#x27;</span>, <span class="hljs-string">&#x27;白色&#x27;</span>);<br><span class="hljs-keyword">var</span> cat2 = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;二毛&#x27;</span>, <span class="hljs-string">&#x27;黑色&#x27;</span>);<br><br>cat1.meow === cat2.meow<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>cat1</code>和<code>cat2</code>是同一个构造函数的两个实例，它们都具有<code>meow</code>方法。由于<code>meow</code>方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个<code>meow</code>方法。这既没有必要，又浪费系统资源，因为所有<code>meow</code>方法都是同样的行为，完全应该共享  </p><p>这个问题的解决方法，就是 <code>Javascript</code> 的原型对象（prototype）  </p><h4 id="prototype-属性的作用"><a href="#prototype-属性的作用" class="headerlink" title="prototype 属性的作用"></a>prototype 属性的作用</h4><p><code>Javascript</code> 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系  </p><p>下面，先看怎么为对象指定原型。<code>Javascript</code> 规定，每个函数都有一个<code>prototype</code>属性，指向一个对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">typeof</span> f.prototype <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>默认具有<code>prototype</code>属性，指向一个对象  </p><p>对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br>Animal.prototype.color = <span class="hljs-string">&#x27;white&#x27;</span>;<br><br><span class="hljs-keyword">var</span> cat1 = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;大毛&#x27;</span>);<br><span class="hljs-keyword">var</span> cat2 = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;二毛&#x27;</span>);<br><br>cat1.color <span class="hljs-comment">// &#x27;white&#x27;</span><br>cat2.color <span class="hljs-comment">// &#x27;white&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中，构造函数<code>Animal</code>的<code>prototype</code>属性，就是实例对象<code>cat1</code>和<code>cat2</code>的原型对象。原型对象上添加一个<code>color</code>属性，结果，实例对象都共享了该属性  </p><p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在<strong>所有</strong>实例对象上  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Animal.prototype.color = <span class="hljs-string">&#x27;yellow&#x27;</span>;<br><br>cat1.color <span class="hljs-comment">// &quot;yellow&quot;</span><br>cat2.color <span class="hljs-comment">// &quot;yellow&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，原型对象的<code>color</code>属性的值变为<code>yellow</code>，两个实例对象的<code>color</code>属性立刻跟着变了。这是因为实例对象其实没有<code>color</code>属性，都是读取原型对象的<code>color</code>属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处  </p><p>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">cat1.color = <span class="hljs-string">&#x27;black&#x27;</span>;<br><br>cat1.color <span class="hljs-comment">// &#x27;black&#x27;</span><br>cat2.color <span class="hljs-comment">// &#x27;yellow&#x27;</span><br>Animal.prototype.color <span class="hljs-comment">// &#x27;yellow&#x27;;</span><br></code></pre></td></tr></table></figure><p>上面代码中，实例对象<code>cat1</code>的<code>color</code>属性改为<code>black</code>，就使得它不再去原型对象读取<code>color</code>属性，后者的值依然为<code>yellow</code>  </p><p>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Animal.prototype.walk = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27; is walking&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>Animal.prototype</code>对象上面定义了一个<code>walk</code>方法，这个方法将可以在所有<code>Animal</code>实例对象上面调用  </p><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p><code>Javascript</code> 规定，所有对象都有自己的原型对象（prototype）  </p><p>一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p><p>如果一层层地上溯，所有对象的原型最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的  </p><p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是<code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是<code>null</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-built_in">Object</span>.prototype)<br><span class="hljs-comment">// null</span><br></code></pre></td></tr></table></figure><p>上面代码表示，<code>Object.prototype</code>对象的原型是<code>null</code>，由于<code>null</code>没有任何属性，所以原型链到此为止。<code>Object.getPrototypeOf</code>方法返回参数对象的原型，具体介绍请看后文  </p><p>读取对象的某个属性时，<code>Javascript</code> 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的<code>Object.prototype</code>还是找不到，则返回<code>undefined</code>。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）  </p><p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链   </p><p>举例来说，如果让构造函数的<code>prototype</code>属性指向一个数组，就意味着实例对象可以调用数组方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> MyArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><br>MyArray.prototype = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<br>MyArray.prototype.constructor = MyArray;<br><br><span class="hljs-keyword">var</span> mine = <span class="hljs-keyword">new</span> MyArray();<br>mine.push(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>mine.length <span class="hljs-comment">// 3</span><br>mine <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>mine</code>是构造函数<code>MyArray</code>的实例对象，由于<code>MyArray.prototype</code>指向一个数组实例，使得<code>mine</code>可以调用数组方法（这些方法定义在数组实例的<code>prototype</code>对象上面）。最后那行<code>instanceof</code>表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明<code>mine</code>为<code>Array</code>的实例，<code>instanceof</code>运算符的详细解释详见后文  </p><h4 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h4><p><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">P</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>P.prototype.constructor === P <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">P</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> P();<br><br>p.constructor === P <span class="hljs-comment">// true</span><br>p.constructor === P.prototype.constructor <span class="hljs-comment">// true</span><br>p.hasOwnProperty(<span class="hljs-string">&#x27;constructor&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上面的<code>P.prototype.constructor</code>属性  </p><p><code>constructor</code>属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> F();<br><br>f.constructor === F <span class="hljs-comment">// true</span><br>f.constructor === <span class="hljs-built_in">RegExp</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>constructor</code>属性确定了实例对象<code>f</code>的构造函数是<code>F</code>，而不是<code>RegExp</code>  </p><p>另一方面，有了<code>constructor</code>属性，就可以从一个实例对象新建另一个实例  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Constr</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> Constr();<br><br><span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> x.constructor();<br>y <span class="hljs-keyword">instanceof</span> Constr <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>x</code>是构造函数<code>Constr</code>的实例，可以从<code>x.constructor</code>间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Constr.prototype.createCopy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">this</span>.constructor();<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>createCopy</code>方法调用构造函数，新建另一个实例  </p><p><code>constructor</code>属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改<code>constructor</code>属性，防止引用的时候出错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><br>Person.prototype.constructor === Person <span class="hljs-comment">// true</span><br><br>Person.prototype = &#123;<br>  method: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>&#125;;<br><br>Person.prototype.constructor === Person <span class="hljs-comment">// false</span><br>Person.prototype.constructor === <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，构造函数<code>Person</code>的原型对象改掉了，但是没有修改<code>constructor</code>属性，导致这个属性不再指向<code>Person</code>。由于<code>Person</code>的新原型是一个普通对象，而普通对象的<code>constructor</code>属性指向<code>Object</code>构造函数，导致<code>Person.prototype.constructor</code>变成了<code>Object</code>  </p><p>所以，修改原型对象时，一般要同时修改<code>constructor</code>属性的指向  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 坏的写法</span><br>C.prototype = &#123;<br>  method1: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...</span>) </span>&#123; ... &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// 好的写法</span><br>C.prototype = &#123;<br>  <span class="hljs-title">constructor</span>: <span class="hljs-title">C</span>,<br>  <span class="hljs-title">method1</span>: <span class="hljs-title">function</span> (<span class="hljs-params">...</span>) &#123; ... &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// 更好的写法</span><br>C.prototype.method1 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...</span>) </span>&#123; ... &#125;;<br></code></pre></td></tr></table></figure><p>上面代码中，要么将<code>constructor</code>属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证<code>instanceof</code>运算符不会失真  </p><p>如果不能确定<code>constructor</code>属性是什么函数，还有一个办法：通过<code>name</code>属性，从实例得到构造函数的名称  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> Foo();<br>f.constructor.name <span class="hljs-comment">// &quot;Foo&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>若是至此依然云里雾里，可以参考B站的一个<a href="https://www.bilibili.com/video/BV117411v76o/?spm_id_from=333.788.recommend_more_video.0">视频</a>  </p></blockquote><h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p><code>instanceof</code>运算符返回一个布尔值，表示对象是否为某个构造函数的实例  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Vehicle();<br>v <span class="hljs-keyword">instanceof</span> Vehicle <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>v</code>是构造函数<code>Vehicle</code>的实例，所以返回<code>true</code>  </p><p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">v <span class="hljs-keyword">instanceof</span> Vehicle<br><span class="hljs-comment">// 等同于</span><br>Vehicle.prototype.isPrototypeOf(v)<br></code></pre></td></tr></table></figure><p>上面代码中，<code>Vehicle</code>是对象<code>v</code>的构造函数，它的原型对象是<code>Vehicle.prototype</code>，<code>isPrototypeOf()</code>方法是 <code>Javascript</code> 提供的原生方法，用于检查某个对象是否为另一个对象的原型，详细解释见后文  </p><p>由于<code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>d <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span> <span class="hljs-comment">// true</span><br>d <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>d</code>同时是<code>Date</code>和<code>Object</code>的实例，因此对这两个构造函数都返回<code>true</code>  </p><p>由于任意对象（除了<code>null</code>）都是<code>Object</code>的实例，所以<code>instanceof</code>运算符可以判断一个值是否为非<code>null</code>的对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span> &#125;;<br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-literal">null</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，除了<code>null</code>，其他对象的<code>instanceOf Object</code>的运算结果都是<code>true</code>  </p><p><code>instanceof</code>的原理是检查右边构造函数的<code>prototype</code>属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">typeof</span> obj <span class="hljs-comment">// &quot;object&quot;</span><br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create()</code>的详细介绍见后文）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。这是唯一的<code>instanceof</code>运算符判断会失真的情况（一个对象的原型是<code>null</code>）  </p><p><code>instanceof</code>运算符的一个用处，是判断值的类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> y = &#123;&#125;;<br>x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// true</span><br>y <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>instanceof</code>运算符判断，变量<code>x</code>是数组，变量<code>y</code>是对象  </p><p>注意，<code>instanceof</code>运算符只能用于对象，不适用原始类型的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>s <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，字符串不是<code>String</code>对象的实例（因为字符串不是对象），所以返回<code>false</code>  </p><p>此外，对于<code>undefined</code>和<code>null</code>，<code>instanceof</code>运算符总是返回<code>false</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">undefined</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">null</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>利用<code>instanceof</code>运算符，还可以巧妙地解决，调用构造函数时，忘了加<code>new</code>命令的问题  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fubar</span> (<span class="hljs-params">foo, bar</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> Fubar) &#123;<br>    <span class="hljs-built_in">this</span>._foo = foo;<br>    <span class="hljs-built_in">this</span>._bar = bar;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fubar(foo, bar);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码使用<code>instanceof</code>运算符，在函数体内部判断<code>this</code>关键字是否为构造函数<code>Fubar</code>的实例。如果不是，就表明忘了加<code>new</code>命令。</p><h3 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h3><p>让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  Super.call(<span class="hljs-built_in">this</span>);<br>  <span class="hljs-built_in">this</span>.prop = value;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>Sub</code>是子类的构造函数，<code>this</code>是子类的实例。在实例上调用父类的构造函数<code>Super</code>，就会让子类实例具有父类实例的属性  </p><p>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Sub.prototype = <span class="hljs-built_in">Object</span>.create(Super.prototype);<br>Sub.prototype.constructor = Sub;<br>Sub.prototype.method = <span class="hljs-string">&#x27;...&#x27;</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>Sub.prototype</code>是子类的原型，要将它赋值为<code>Object.create(Super.prototype)</code>，而不是直接等于<code>Super.prototype</code>。否则后面两行对<code>Sub.prototype</code>的操作，会连父类的原型<code>Super.prototype</code>一起修改掉。</p><p>另外一种写法是<code>Sub.prototype</code>等于一个父类实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Sub.prototype = <span class="hljs-keyword">new</span> Super();<br></code></pre></td></tr></table></figure><p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。</p><p>举例来说，下面是一个<code>Shape</code>构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Shape</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.x = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">this</span>.y = <span class="hljs-number">0</span>;<br>&#125;<br><br>Shape.prototype.move = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.x += x;<br>  <span class="hljs-built_in">this</span>.y += y;<br>  <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&#x27;Shape moved.&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们需要让<code>Rectangle</code>构造函数继承<code>Shape</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一步，子类继承父类的实例</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"></span>) </span>&#123;<br>  Shape.call(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 调用父类构造函数</span><br>&#125;<br><span class="hljs-comment">// 另一种写法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.base = Shape;<br>  <span class="hljs-built_in">this</span>.base();<br>&#125;<br><br><span class="hljs-comment">// 第二步，子类继承父类的原型</span><br>Rectangle.prototype = <span class="hljs-built_in">Object</span>.create(Shape.prototype);<br>Rectangle.prototype.constructor = Rectangle;<br></code></pre></td></tr></table></figure><p>采用这样的写法以后，<code>instanceof</code>运算符会对子类和父类的构造函数，都返回<code>true</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> rect = <span class="hljs-keyword">new</span> Rectangle();<br><br>rect <span class="hljs-keyword">instanceof</span> Rectangle  <span class="hljs-comment">// true</span><br>rect <span class="hljs-keyword">instanceof</span> Shape  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ClassB.prototype.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  ClassA.prototype.print.call(<span class="hljs-built_in">this</span>);<br>  <span class="hljs-comment">// some code</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，子类<code>B</code>的<code>print</code>方法先调用父类<code>A</code>的<code>print</code>方法，再部署自己的代码。这就等于继承了父类<code>A</code>的<code>print</code>方法  </p><blockquote><p>若是至此依然云里雾里，可以参考B站的一个<a href="https://www.bilibili.com/video/BV1N7411k7D2?from=search&seid=3699264387570966853">视频</a>  </p></blockquote><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p><code>Javascript</code> 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.hello = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.world = <span class="hljs-string">&#x27;world&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">S</span>(<span class="hljs-params"></span>) </span>&#123;<br>  M1.call(<span class="hljs-built_in">this</span>);<br>  M2.call(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 继承 M1</span><br>S.prototype = <span class="hljs-built_in">Object</span>.create(M1.prototype);<br><span class="hljs-comment">// 继承链上加入 M2</span><br><span class="hljs-built_in">Object</span>.assign(S.prototype, M2.prototype);<br><br><span class="hljs-comment">// 指定构造函数</span><br>S.prototype.constructor = S;<br><br><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> S();<br>s.hello <span class="hljs-comment">// &#x27;hello&#x27;</span><br>s.world <span class="hljs-comment">// &#x27;world&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中，子类<code>S</code>同时继承了父类<code>M1</code>和<code>M2</code>。这种模式又称为 Mixin（混入）  </p><h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>随着网站逐渐变成“互联网应用程序”，嵌入网页的 <code>Javascript</code> 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑  </p><p><code>Javascript</code> 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块  </p><p>但是，<code>Javascript</code> 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果  </p><h4 id="基本的实现方法"><a href="#基本的实现方法" class="headerlink" title="基本的实现方法"></a>基本的实现方法</h4><p>模块是实现特定功能的一组属性和方法的封装  </p><p>简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> module1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(&#123;<br>　_count : <span class="hljs-number">0</span>,<br>　m1 : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>　　<span class="hljs-comment">//...</span><br>　&#125;,<br>　m2 : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>  　<span class="hljs-comment">//...</span><br>　&#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>上面的函数<code>m1</code>和<code>m2</code>，都封装在<code>module1</code>对象里。使用的时候，就是调用这个对象的属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">module1.m1();<br></code></pre></td></tr></table></figure><p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">module1._count = <span class="hljs-number">5</span>;<br></code></pre></td></tr></table></figure><h4 id="封装私有变量：构造函数的写法"><a href="#封装私有变量：构造函数的写法" class="headerlink" title="封装私有变量：构造函数的写法"></a>封装私有变量：构造函数的写法</h4><p>我们可以利用构造函数，封装私有变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">StringBuilder</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> buffer = [];<br><br>  <span class="hljs-built_in">this</span>.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123;<br>     buffer.push(str);<br>  &#125;;<br><br>  <span class="hljs-built_in">this</span>.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> buffer.join(<span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>buffer</code>是模块的私有变量。一旦生成实例对象，外部是无法直接访问<code>buffer</code>的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">StringBuilder</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>._buffer = [];<br>&#125;<br><br>StringBuilder.prototype = &#123;<br>  <span class="hljs-title">constructor</span>: <span class="hljs-title">StringBuilder</span>,<br>  <span class="hljs-title">add</span>: <span class="hljs-title">function</span> (<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-built_in">this</span>._buffer.push(str);<br>  &#125;,<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._buffer.join(<span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。</p><h4 id="封装私有变量：立即执行函数的写法"><a href="#封装私有变量：立即执行函数的写法" class="headerlink" title="封装私有变量：立即执行函数的写法"></a>封装私有变量：立即执行函数的写法</h4><p>另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> module1 = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>　<span class="hljs-keyword">var</span> _count = <span class="hljs-number">0</span>;<br>　<span class="hljs-keyword">var</span> m1 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>　  <span class="hljs-comment">//...</span><br>　&#125;;<br>　<span class="hljs-keyword">var</span> m2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>　　<span class="hljs-comment">//...</span><br>　&#125;;<br>　<span class="hljs-keyword">return</span> &#123;<br>　　m1 : m1,<br>　　m2 : m2<br>　&#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>使用上面的写法，外部代码无法读取内部的<code>_count</code>变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.info(module1._count); <span class="hljs-comment">//undefined</span><br></code></pre></td></tr></table></figure><p>上面的<code>module1</code>就是 <code>Javascript</code> 模块的基本写法。下面，再对这种写法进行加工  </p><h4 id="模块的放大模式"><a href="#模块的放大模式" class="headerlink" title="模块的放大模式"></a>模块的放大模式</h4><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> module1 = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mod</span>)</span>&#123;<br>　mod.m3 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>　　<span class="hljs-comment">//...</span><br>　&#125;;<br>　<span class="hljs-keyword">return</span> mod;<br>&#125;)(module1);<br></code></pre></td></tr></table></figure><p>上面的代码为<code>module1</code>模块添加了一个新方法<code>m3()</code>，然后返回新的<code>module1</code>模块。</p><p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> module1 = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mod</span>) </span>&#123;<br>　<span class="hljs-comment">//...</span><br>　<span class="hljs-keyword">return</span> mod;<br>&#125;)(<span class="hljs-built_in">window</span>.module1 || &#123;&#125;);<br></code></pre></td></tr></table></figure><p>与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象  </p><h4 id="输入全局变量"><a href="#输入全局变量" class="headerlink" title="输入全局变量"></a>输入全局变量</h4><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</p><p>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> module1 = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$, YAHOO</span>) </span>&#123;<br>　<span class="hljs-comment">//...</span><br>&#125;)(jQuery, YAHOO);<br></code></pre></td></tr></table></figure><p>上面的<code>module1</code>模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入<code>module1</code>。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p><p>立即执行函数还可以起到命名空间的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$, <span class="hljs-built_in">window</span>, <span class="hljs-built_in">document</span></span>) </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">go</span>(<span class="hljs-params">num</span>) </span>&#123;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleEvents</span>(<span class="hljs-params"></span>) </span>&#123;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialize</span>(<span class="hljs-params"></span>) </span>&#123;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dieCarouselDie</span>(<span class="hljs-params"></span>) </span>&#123;<br>  &#125;<br><br>  <span class="hljs-comment">//attach to the global scope</span><br>  <span class="hljs-built_in">window</span>.finalCarousel = &#123;<br>    init : initialize,<br>    destroy : dieCarouselDie<br>  &#125;<br><br>&#125;)( jQuery, <span class="hljs-built_in">window</span>, <span class="hljs-built_in">document</span> );<br></code></pre></td></tr></table></figure><p>上面代码中，<code>finalCarousel</code>对象输出到全局，对外暴露<code>init</code>和<code>destroy</code>接口，内部方法<code>go</code>、<code>handleEvents</code>、<code>initialize</code>、<code>dieCarouselDie</code>都是外部无法调用的  </p><h2 id="Object-对象的相关方法"><a href="#Object-对象的相关方法" class="headerlink" title="Object 对象的相关方法"></a>Object 对象的相关方法</h2><p><code>Javascript</code> 在<code>Object</code>对象上面，提供了很多相关方法，处理面向对象编程的相关操作。本章介绍这些方法  </p><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p><code>Object.getPrototypeOf</code>方法返回参数对象的原型。这是获取原型对象的标准方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> F();<br><span class="hljs-built_in">Object</span>.getPrototypeOf(f) === F.prototype <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，实例对象<code>f</code>的原型是<code>F.prototype</code>  </p><p>下面是几种特殊对象的原型  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 空对象的原型是 Object.prototype</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(&#123;&#125;) === <span class="hljs-built_in">Object</span>.prototype <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// Object.prototype 的原型是 null</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-built_in">Object</span>.prototype) === <span class="hljs-literal">null</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 函数的原型是 Function.prototype</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-built_in">Object</span>.getPrototypeOf(f) === <span class="hljs-built_in">Function</span>.prototype <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;&#125;;<br><span class="hljs-keyword">var</span> b = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">Object</span>.setPrototypeOf(a, b);<br><br><span class="hljs-built_in">Object</span>.getPrototypeOf(a) === b <span class="hljs-comment">// true</span><br>a.x <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Object.setPrototypeOf</code>方法将对象<code>a</code>的原型，设置为对象<code>b</code>，因此<code>a</code>可以共享<code>b</code>的属性  </p><p><code>new</code>命令可以使用<code>Object.setPrototypeOf</code>方法模拟  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> F();<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-built_in">Object</span>.setPrototypeOf(&#123;&#125;, F.prototype);<br>F.call(f);<br></code></pre></td></tr></table></figure><p>上面代码中，<code>new</code>命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的<code>prototype</code>属性（上例是<code>F.prototype</code>）；第二步，将构造函数内部的<code>this</code>绑定这个空对象，然后执行构造函数，使得定义在<code>this</code>上面的方法和属性（上例是<code>this.foo</code>），都转移到这个空对象上  </p><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>生成实例对象的常用方法是，使用<code>new</code>命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？  </p><p><code>Javascript</code> 提供了<code>Object.create()</code>方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 原型对象</span><br><span class="hljs-keyword">var</span> A = &#123;<br>  print: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 实例对象</span><br><span class="hljs-keyword">var</span> B = <span class="hljs-built_in">Object</span>.create(A);<br><br><span class="hljs-built_in">Object</span>.getPrototypeOf(B) === A <span class="hljs-comment">// true</span><br>B.print() <span class="hljs-comment">// hello</span><br>B.print === A.print <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Object.create()</code>方法以<code>A</code>对象为原型，生成了<code>B</code>对象。<code>B</code>继承了<code>A</code>的所有属性和方法  </p><p>实际上，<code>Object.create()</code>方法可以用下面的代码代替  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.create !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>  <span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>    F.prototype = obj;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码表明，<code>Object.create()</code>方法的实质是新建一个空的构造函数<code>F</code>，然后让<code>F.prototype</code>属性指向参数对象<code>obj</code>，最后返回一个<code>F</code>的实例，从而实现让该实例继承<code>obj</code>的属性  </p><p>下面三种方式生成的新对象是等价的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = <span class="hljs-built_in">Object</span>.create(&#123;&#125;);<br><span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.prototype);<br><span class="hljs-keyword">var</span> obj3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br></code></pre></td></tr></table></figure><p>如果想要生成一个不继承任何属性（比如没有<code>toString()</code>和<code>valueOf()</code>方法）的对象，可以将<code>Object.create()</code>的参数设为<code>null</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br><br>obj.valueOf()<br><span class="hljs-comment">// TypeError: Object [object Object] has no method &#x27;valueOf&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>的原型是<code>null</code>，它就不具备一些定义在<code>Object.prototype</code>对象上面的属性，比如<code>valueOf()</code>方法  </p><p>使用<code>Object.create()</code>方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.create()<br><span class="hljs-comment">// TypeError: Object prototype may only be an Object or null</span><br><span class="hljs-built_in">Object</span>.create(<span class="hljs-number">123</span>)<br><span class="hljs-comment">// TypeError: Object prototype may only be an Object or null</span><br></code></pre></td></tr></table></figure><p><code>Object.create()</code>方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">Object</span>.create(obj1);<br><br>obj1.p = <span class="hljs-number">2</span>;<br>obj2.p <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，修改对象原型<code>obj1</code>会影响到实例对象<code>obj2</code>  </p><p>除了对象的原型，<code>Object.create()</code>方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(&#123;&#125;, &#123;<br>  p1: &#123;<br>    value: <span class="hljs-number">123</span>,<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    writable: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  p2: &#123;<br>    value: <span class="hljs-string">&#x27;abc&#x27;</span>,<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    writable: <span class="hljs-literal">true</span>,<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(&#123;&#125;);<br>obj.p1 = <span class="hljs-number">123</span>;<br>obj.p2 = <span class="hljs-string">&#x27;abc&#x27;</span>;<br></code></pre></td></tr></table></figure><p><code>Object.create()</code>方法生成的对象，继承了它的原型对象的构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> A();<br><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">Object</span>.create(a);<br><br>b.constructor === A <span class="hljs-comment">// true</span><br>b <span class="hljs-keyword">instanceof</span> A <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>b</code>对象的原型是<code>a</code>对象，因此继承了<code>a</code>对象的构造函数<code>A</code>  </p><h3 id="Object-prototype-isPrototypeOf"><a href="#Object-prototype-isPrototypeOf" class="headerlink" title="Object.prototype.isPrototypeOf()"></a>Object.prototype.isPrototypeOf()</h3><p>实例对象的<code>isPrototypeOf</code>方法，用来判断该对象是否为参数对象的原型  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123;&#125;;<br><span class="hljs-keyword">var</span> o2 = <span class="hljs-built_in">Object</span>.create(o1);<br><span class="hljs-keyword">var</span> o3 = <span class="hljs-built_in">Object</span>.create(o2);<br><br>o2.isPrototypeOf(o3) <span class="hljs-comment">// true</span><br>o1.isPrototypeOf(o3) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>o1</code>和<code>o2</code>都是<code>o3</code>的原型。这表明只要实例对象处在参数对象的原型链上，<code>isPrototypeOf</code>方法都返回<code>true</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.isPrototypeOf(&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.prototype.isPrototypeOf([]) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.prototype.isPrototypeOf(<span class="hljs-regexp">/xyz/</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.prototype.isPrototypeOf(<span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，由于<code>Object.prototype</code>处于原型链的最顶端，所以对各种实例都返回<code>true</code>，只有直接继承自<code>null</code>的对象除外  </p><h3 id="Object-prototype-proto"><a href="#Object-prototype-proto" class="headerlink" title="Object.prototype.__proto__"></a>Object.prototype.__proto__</h3><p>实例对象的<code>__proto__</code>属性（前后各两个下划线），返回该对象的原型。该属性可读写  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-keyword">var</span> p = &#123;&#125;;<br><br>obj.__proto__ = p;<br><span class="hljs-built_in">Object</span>.getPrototypeOf(obj) === p <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码通过<code>__proto__</code>属性，将<code>p</code>对象设为<code>obj</code>对象的原型。</p><p>根据语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>，进行原型对象的读写操作  </p><p>原型链可以用<code>__proto__</code>很直观地表示  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> A = &#123;<br>  name: <span class="hljs-string">&#x27;张三&#x27;</span><br>&#125;;<br><span class="hljs-keyword">var</span> B = &#123;<br>  name: <span class="hljs-string">&#x27;李四&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> proto = &#123;<br>  print: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br>&#125;;<br><br>A.__proto__ = proto;<br>B.__proto__ = proto;<br><br>A.print() <span class="hljs-comment">// 张三</span><br>B.print() <span class="hljs-comment">// 李四</span><br><br>A.print === B.print <span class="hljs-comment">// true</span><br>A.print === proto.print <span class="hljs-comment">// true</span><br>B.print === proto.print <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>A</code>对象和<code>B</code>对象的原型都是<code>proto</code>对象，它们都共享<code>proto</code>对象的<code>print</code>方法。也就是说，<code>A</code>和<code>B</code>的<code>print</code>方法，都是在调用<code>proto</code>对象的<code>print</code>方法  </p><h3 id="获取原型对象方法的比较"><a href="#获取原型对象方法的比较" class="headerlink" title="获取原型对象方法的比较"></a>获取原型对象方法的比较</h3><p>如前所述，<code>__proto__</code>属性指向当前对象的原型对象，即构造函数的<code>prototype</code>属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br>obj.__proto__ === <span class="hljs-built_in">Object</span>.prototype<br><span class="hljs-comment">// true</span><br>obj.__proto__ === obj.constructor.prototype<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码首先新建了一个对象<code>obj</code>，它的<code>__proto__</code>属性，指向构造函数（<code>Object</code>或<code>obj.constructor</code>）的<code>prototype</code>属性  </p><p>因此，获取实例对象<code>obj</code>的原型对象，有三种方法  </p><ul><li><code>obj.__proto__</code></li><li><code>obj.constructor.prototype</code></li><li><code>Object.getPrototypeOf(obj)</code></li></ul><p>上面三种方法之中，前两种都不是很可靠。<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以不部署。而<code>obj.constructor.prototype</code>在手动改变原型对象时，可能会失效  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> P = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> P();<br><br><span class="hljs-keyword">var</span> C = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>C.prototype = p;<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> C();<br><br>c.constructor.prototype === p <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，构造函数<code>C</code>的原型对象被改成了<code>p</code>，但是实例对象的<code>c.constructor.prototype</code>却没有指向<code>p</code>。所以，在改变原型对象时，一般要同时设置<code>constructor</code>属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">C.prototype = p;<br>C.prototype.constructor = C;<br><br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> C();<br>c.constructor.prototype === p <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>因此，推荐使用第三种<code>Object.getPrototypeOf</code>方法，获取原型对象  </p><h3 id="Object-getOwnPropertyNames-1"><a href="#Object-getOwnPropertyNames-1" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.getOwnPropertyNames(<span class="hljs-built_in">Date</span>)<br><span class="hljs-comment">// [&quot;parse&quot;, &quot;arguments&quot;, &quot;UTC&quot;, &quot;caller&quot;, &quot;name&quot;, &quot;prototype&quot;, &quot;now&quot;, &quot;length&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Object.getOwnPropertyNames</code>方法返回<code>Date</code>所有自身的属性名  </p><p>对象本身的属性之中，有的是可以遍历的（enumerable），有的是不可以遍历。<code>Object.getOwnPropertyNames</code>方法返回所有键名，不管是否可以遍历。只获取那些可以遍历的属性，使用<code>Object.keys</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">Date</span>) <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><p>上面代码表明，<code>Date</code>对象所有自身的属性，都是不可以遍历的  </p><h3 id="Object-prototype-hasOwnProperty-1"><a href="#Object-prototype-hasOwnProperty-1" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h3><p>对象实例的<code>hasOwnProperty</code>方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Date</span>.hasOwnProperty(<span class="hljs-string">&#x27;length&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Date</span>.hasOwnProperty(<span class="hljs-string">&#x27;toString&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码表明，<code>Date.length</code>（构造函数<code>Date</code>可以接受多少个参数）是<code>Date</code>自身的属性，<code>Date.toString</code>是继承的属性。</p><p>另外，<code>hasOwnProperty</code>方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法  </p><h3 id="in-运算符和-for…in-循环"><a href="#in-运算符和-for…in-循环" class="headerlink" title="in 运算符和 for…in 循环"></a>in 运算符和 for…in 循环</h3><p><code>in</code>运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;length&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">Date</span> <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">Date</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>in</code>运算符常用于检查一个属性是否存在  </p><p>获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用<code>for...in</code>循环  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123; <span class="hljs-attr">p1</span>: <span class="hljs-number">123</span> &#125;;<br><br><span class="hljs-keyword">var</span> o2 = <span class="hljs-built_in">Object</span>.create(o1, &#123;<br>  p2: &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> &#125;<br>&#125;);<br><br><span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> o2) &#123;<br>  <span class="hljs-built_in">console</span>.info(p);<br>&#125;<br><span class="hljs-comment">// p2</span><br><span class="hljs-comment">// p1</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>o2</code>的<code>p2</code>属性是自身的，<code>p1</code>属性是继承的。这两个属性都会被<code>for...in</code>循环遍历  </p><p>为了在<code>for...in</code>循环中获得对象自身的属性，可以采用<code>hasOwnProperty</code>方法判断一下  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> object ) &#123;<br>  <span class="hljs-keyword">if</span> ( object.hasOwnProperty(name) ) &#123;<br>    <span class="hljs-comment">/* loop code */</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获得对象的所有属性（不管是自身的还是继承的，也不管是否可枚举），可以使用下面的函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritedPropertyNames</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> props = &#123;&#125;;<br>  <span class="hljs-keyword">while</span>(obj) &#123;<br>    <span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p</span>) </span>&#123;<br>      props[p] = <span class="hljs-literal">true</span>;<br>    &#125;);<br>    obj = <span class="hljs-built_in">Object</span>.getPrototypeOf(obj);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyNames(props);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码依次获取<code>obj</code>对象的每一级原型对象“自身”的属性，从而获取<code>obj</code>对象的“所有”属性，不管是否可遍历  </p><p>下面是一个例子，列出<code>Date</code>对象的所有属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">inheritedPropertyNames(<span class="hljs-built_in">Date</span>)<br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//  &quot;caller&quot;,</span><br><span class="hljs-comment">//  &quot;constructor&quot;,</span><br><span class="hljs-comment">//  &quot;toString&quot;,</span><br><span class="hljs-comment">//  &quot;UTC&quot;,</span><br><span class="hljs-comment">//  ...</span><br><span class="hljs-comment">// ]</span><br></code></pre></td></tr></table></figure><h3 id="对象的拷贝-1"><a href="#对象的拷贝-1" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h3><p>如果要拷贝一个对象，需要做到下面两件事情  </p><ul><li>确保拷贝后的对象，与原对象具有同样的原型  </li><li>确保拷贝后的对象，与原对象具有同样的实例属性  </li></ul><p>下面就是根据上面两点，实现的对象拷贝函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyObject</span>(<span class="hljs-params">orig</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> copy = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.getPrototypeOf(orig));<br>  copyOwnPropertiesFrom(copy, orig);<br>  <span class="hljs-keyword">return</span> copy;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyOwnPropertiesFrom</span>(<span class="hljs-params">target, source</span>) </span>&#123;<br>  <span class="hljs-built_in">Object</span><br>    .getOwnPropertyNames(source)<br>    .forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">propKey</span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> desc = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, propKey);<br>      <span class="hljs-built_in">Object</span>.defineProperty(target, propKey, desc);<br>    &#125;);<br>  <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure><p>另一种更简单的写法，是利用 ES2017 才引入标准的<code>Object.getOwnPropertyDescriptors</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyObject</span>(<span class="hljs-params">orig</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.create(<br>    <span class="hljs-built_in">Object</span>.getPrototypeOf(orig),<br>    <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(orig)<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>除了正常的运行模式，<code>Javascript</code> 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 <code>JavaScript</code> 语法  </p><p>同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行  </p><h3 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h3><p>早期的 <code>Javacript</code> 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法  </p><p>严格模式是从 ES5 进入标准的，主要目的有以下几个  </p><ul><li>明确禁止一些不合理、不严谨的语法，减少 `Javascripts 语言的一些怪异行为  </li><li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全  </li><li>提高编译器效率，增加运行速度  </li><li>为未来新版本的 <code>JavaScript</code> 语法做好铺垫  </li></ul><p>总之，严格模式体现了 <code>Javascript</code> 更合理、更安全、更严谨的发展方向  </p><h3 id="启用方法"><a href="#启用方法" class="headerlink" title="启用方法"></a>启用方法</h3><p>进入严格模式的标志，是一行字符串<code>use strict</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br></code></pre></td></tr></table></figure><p>老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式  </p><p>严格模式可以用于整个脚本，也可以只用于单个函数  </p><p><strong>（1） 整个脚本文件</strong></p><p><code>use strict</code>放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，<code>use strict</code>可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)   </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-meta">  &#x27;use strict&#x27;</span>;</span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是严格模式&#x27;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是正常模式&#x27;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面代码中，一个网页文件依次有两段 JavaScript 代码。前一个<code>&lt;script&gt;</code>标签是严格模式，后一个不是  </p><p>如果<code>use strict</code>写成下面这样，则不起作用，严格模式必须从代码一开始就生效  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是正常模式&#x27;</span>);</span><br><span class="javascript"><span class="hljs-meta">  &#x27;use strict&#x27;</span>;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>（2）单个函数</strong></p><p><code>use strict</code>放在函数体的第一行，则整个函数以严格模式运行  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strict</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这是严格模式&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strict2</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这也是严格模式&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> f();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notStrict</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这是正常模式&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-comment">// some code here</span><br>&#125;)();<br></code></pre></td></tr></table></figure><h3 id="显式报错"><a href="#显式报错" class="headerlink" title="显式报错"></a>显式报错</h3><p>严格模式使得 <code>Javascript</code> 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错   </p><h3 id="只读属性不可写"><a href="#只读属性不可写" class="headerlink" title="只读属性不可写"></a>只读属性不可写</h3><p>严格模式下，设置字符串的<code>length</code>属性，会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-string">&#x27;abc&#x27;</span>.length = <span class="hljs-number">5</span>;<br><span class="hljs-comment">// TypeError: Cannot assign to read only property &#x27;length&#x27; of string &#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码报错，因为<code>length</code>是只读属性，严格模式下不可写。正常模式下，改变<code>length</code>属性是无效的，但不会报错  </p><p>严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 对只读属性赋值会报错</span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<br>  value: <span class="hljs-number">37</span>,<br>  writable: <span class="hljs-literal">false</span><br>&#125;);<br>obj.a = <span class="hljs-number">123</span>;<br><span class="hljs-comment">// TypeError: Cannot assign to read only property &#x27;a&#x27; of object #&lt;Object&gt;</span><br><br><span class="hljs-comment">// 删除不可配置的属性会报错</span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">1</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><span class="hljs-keyword">delete</span> obj.p<br><span class="hljs-comment">// TypeError: Cannot delete property &#x27;p&#x27; of #&lt;Object&gt;</span><br></code></pre></td></tr></table></figure><h4 id="只设置了取值器的属性不可写"><a href="#只设置了取值器的属性不可写" class="headerlink" title="只设置了取值器的属性不可写"></a>只设置了取值器的属性不可写</h4><p>严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">v</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br>&#125;;<br>obj.v = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// Uncaught TypeError: Cannot set property v of #&lt;Object&gt; which has only a getter</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.v</code>只有取值器，没有存值器，对它进行赋值就会报错  </p><h4 id="禁止扩展的对象不可扩展"><a href="#禁止扩展的对象不可扩展" class="headerlink" title="禁止扩展的对象不可扩展"></a>禁止扩展的对象不可扩展</h4><p>严格模式下，对禁止扩展的对象添加新属性，会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.preventExtensions(obj);<br>obj.v = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// Uncaught TypeError: Cannot add property v, object is not extensible</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj</code>对象禁止扩展，添加属性就会报错  </p><h4 id="eval、arguments-不可用作标识名"><a href="#eval、arguments-不可用作标识名" class="headerlink" title="eval、arguments 不可用作标识名"></a>eval、arguments 不可用作标识名</h4><p>严格模式下，使用<code>eval</code>或者<code>arguments</code>作为标识名，将会报错。下面的语句都会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">eval</span> = <span class="hljs-number">17</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">arguments</span> = <span class="hljs-number">17</span>;<br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-keyword">set</span> <span class="hljs-title">p</span>(<span class="hljs-params"><span class="hljs-built_in">arguments</span></span>) &#123; &#125; &#125;;<br><span class="hljs-keyword">try</span> &#123; &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">arguments</span>) &#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"><span class="hljs-built_in">eval</span></span>) </span>&#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arguments</span>(<span class="hljs-params"></span>) </span>&#123; &#125;<br><span class="hljs-keyword">var</span> y = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eval</span>(<span class="hljs-params"></span>) </span>&#123; &#125;;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;arguments&#x27;</span>, <span class="hljs-string">&quot;&#x27;use strict&#x27;; return 17;&quot;</span>);<br><span class="hljs-comment">// SyntaxError: Unexpected eval or arguments in strict mode</span><br></code></pre></td></tr></table></figure><h4 id="函数不能有重名的参数"><a href="#函数不能有重名的参数" class="headerlink" title="函数不能有重名的参数"></a>函数不能有重名的参数</h4><p>正常模式下，如果函数有多个重名的参数，可以用<code>arguments[i]</code>读取。严格模式下，这属于语法错误  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, a, b</span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span><br></code></pre></td></tr></table></figure><h4 id="禁止八进制的前缀0表示法"><a href="#禁止八进制的前缀0表示法" class="headerlink" title="禁止八进制的前缀0表示法"></a>禁止八进制的前缀0表示法</h4><p>正常模式下，整数的第一位如果是<code>0</code>，表示这是八进制数，比如<code>0100</code>等于十进制的64。严格模式禁止这种表示法，整数第一位为<code>0</code>，将报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">0100</span>;<br><span class="hljs-comment">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span><br></code></pre></td></tr></table></figure><h3 id="增强的安全措施"><a href="#增强的安全措施" class="headerlink" title="增强的安全措施"></a>增强的安全措施</h3><p>严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误  </p><h4 id="全局变量显式声明"><a href="#全局变量显式声明" class="headerlink" title="全局变量显式声明"></a>全局变量显式声明</h4><p>正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br>v = <span class="hljs-number">1</span>; <span class="hljs-comment">// 报错，v未声明</span><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123; <span class="hljs-comment">// 报错，i 未声明</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  x = <span class="hljs-number">123</span>;<br>&#125;<br>f() <span class="hljs-comment">// 报错，未声明就创建一个全局变量</span><br></code></pre></td></tr></table></figure><p>因此，严格模式下，变量都必须先声明，然后再使用  </p><h4 id="禁止-this-关键字指向全局对象"><a href="#禁止-this-关键字指向全局对象" class="headerlink" title="禁止 this 关键字指向全局对象"></a>禁止 this 关键字指向全局对象</h4><p>正常模式下，函数内部的<code>this</code>可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 正常模式</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === <span class="hljs-built_in">window</span>);<br>&#125;<br>f() <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 严格模式</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === <span class="hljs-literal">undefined</span>);<br>&#125;<br>f() <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，严格模式的函数体内部<code>this</code>是<code>undefined</code>  </p><p>这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加<code>new</code>，这时<code>this</code>不再指向全局对象，而是报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.a = <span class="hljs-number">1</span>;<br>&#125;;<br><br>f();<span class="hljs-comment">// 报错，this 未定义</span><br></code></pre></td></tr></table></figure><p>严格模式下，函数直接调用时（不使用<code>new</code>调用），函数内部的<code>this</code>表示<code>undefined</code>（未定义），因此可以用<code>call</code>、<code>apply</code>和<code>bind</code>方法，将任意值绑定在<code>this</code>上面。正常模式下，<code>this</code>指向全局对象，如果绑定的值是非对象，将被自动转为对象再绑定上去，而<code>null</code>和<code>undefined</code>这两个无法转成对象的值，将被忽略  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 正常模式</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><br>fun() <span class="hljs-comment">// window</span><br>fun.call(<span class="hljs-number">2</span>) <span class="hljs-comment">// Number &#123;2&#125;</span><br>fun.call(<span class="hljs-literal">true</span>) <span class="hljs-comment">// Boolean &#123;true&#125;</span><br>fun.call(<span class="hljs-literal">null</span>) <span class="hljs-comment">// window</span><br>fun.call(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// window</span><br><br><span class="hljs-comment">// 严格模式</span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><br>fun() <span class="hljs-comment">//undefined</span><br>fun.call(<span class="hljs-number">2</span>) <span class="hljs-comment">// 2</span><br>fun.call(<span class="hljs-literal">true</span>) <span class="hljs-comment">// true</span><br>fun.call(<span class="hljs-literal">null</span>) <span class="hljs-comment">// null</span><br>fun.call(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>上面代码中，可以把任意类型的值，绑定在<code>this</code>上面  </p><h4 id="禁止使用-fn-callee、fn-caller"><a href="#禁止使用-fn-callee、fn-caller" class="headerlink" title="禁止使用 fn.callee、fn.caller"></a>禁止使用 fn.callee、fn.caller</h4><p>函数内部不得使用<code>fn.caller</code>、<code>fn.arguments</code>，否则会报错。这意味着不能在函数内部得到调用栈了  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  f1.caller;    <span class="hljs-comment">// 报错</span><br>  f1.arguments; <span class="hljs-comment">// 报错</span><br>&#125;<br><br>f1();<br></code></pre></td></tr></table></figure><h4 id="禁止使用-arguments-callee、arguments-caller"><a href="#禁止使用-arguments-callee、arguments-caller" class="headerlink" title="禁止使用 arguments.callee、arguments.caller"></a>禁止使用 arguments.callee、arguments.caller</h4><p><code>arguments.callee</code>和<code>arguments.caller</code>是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用<code>arguments.callee</code>、<code>arguments.caller</code>将会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.callee;<br>&#125;;<br><br>f(); <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><h4 id="禁止删除变量"><a href="#禁止删除变量" class="headerlink" title="禁止删除变量"></a>禁止删除变量</h4><p>严格模式下无法删除变量，如果使用<code>delete</code>命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的<code>configurable</code>属性设置为<code>true</code>，才能被<code>delete</code>命令删除  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> x;<br><span class="hljs-keyword">delete</span> x; <span class="hljs-comment">// 语法错误</span><br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>, &#123;<br>  x: &#123;<br>    value: <span class="hljs-number">1</span>,<br>    configurable: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;);<br><span class="hljs-keyword">delete</span> obj.x; <span class="hljs-comment">// 删除成功</span><br></code></pre></td></tr></table></figure><h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><p><code>Javascript</code> 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的  </p><p>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外  </p><p>具体来说，涉及以下几个方面  </p><h4 id="禁止使用-with-语句"><a href="#禁止使用-with-语句" class="headerlink" title="禁止使用 with 语句"></a>禁止使用 with 语句</h4><p>严格模式下，使用<code>with</code>语句将报错。因为<code>with</code>语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> v  = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-keyword">with</span> (obj) &#123;<br>  v = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// Uncaught SyntaxError: Strict mode code may not include a with statement</span><br></code></pre></td></tr></table></figure><h4 id="创设-eval-作用域"><a href="#创设-eval-作用域" class="headerlink" title="创设 eval 作用域"></a>创设 eval 作用域</h4><p>正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：<code>eval</code>作用域  </p><p>正常模式下，<code>eval</code>语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，<code>eval</code>语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，<code>eval</code>所生成的变量只能用于<code>eval</code>内部  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;var x = 5; x&#x27;</span>)) <span class="hljs-comment">// 5</span><br>  <span class="hljs-built_in">console</span>.log(x) <span class="hljs-comment">// 2</span><br>&#125;)()<br></code></pre></td></tr></table></figure><p>上面代码中，由于<code>eval</code>语句内部是一个独立作用域，所以内部的变量<code>x</code>不会泄露到外部  </p><p>注意，如果希望<code>eval</code>语句也使用严格模式，有两种方式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方式一</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">str</span>)</span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(str);<br>&#125;<br>f1(<span class="hljs-string">&#x27;undeclared_variable = 1&#x27;</span>); <span class="hljs-comment">// 报错</span><br><br><span class="hljs-comment">// 方式二</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params">str</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(str);<br>&#125;<br>f2(<span class="hljs-string">&#x27;&quot;use strict&quot;;undeclared_variable = 1&#x27;</span>)  <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>上面两种写法，<code>eval</code>内部使用的都是严格模式  </p><h4 id="arguments-不再追踪参数的变化"><a href="#arguments-不再追踪参数的变化" class="headerlink" title="arguments 不再追踪参数的变化"></a>arguments 不再追踪参数的变化</h4><p>变量<code>arguments</code>代表函数的参数。严格模式下，函数内部改变参数与<code>arguments</code>的联系被切断了，两者不再存在联动关系。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a</span>) </span>&#123;<br>  a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> [a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]];<br>&#125;<br>f(<span class="hljs-number">1</span>); <span class="hljs-comment">// 正常模式为[2, 2]</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a</span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> [a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]];<br>&#125;<br>f(<span class="hljs-number">1</span>); <span class="hljs-comment">// 严格模式为[2, 1]</span><br></code></pre></td></tr></table></figure><p>上面代码中，改变函数的参数，不会反应到<code>arguments</code>对象上来。</p><h3 id="向下一个版本的-Javascript-过渡"><a href="#向下一个版本的-Javascript-过渡" class="headerlink" title="向下一个版本的 Javascript 过渡"></a>向下一个版本的 Javascript 过渡</h3><p>JavaScript 语言的下一个版本是 ECMAScript 6，为了平稳过渡，严格模式引入了一些 ES6 语法。</p><h4 id="非函数代码块不得声明函数"><a href="#非函数代码块不得声明函数" class="headerlink" title="非函数代码块不得声明函数"></a>非函数代码块不得声明函数</h4><p>ES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123; &#125; <span class="hljs-comment">// 语法错误</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123; &#125; <span class="hljs-comment">// 语法错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码在<code>if</code>代码块和<code>for</code>代码块中声明了函数，ES5 环境会报错  </p><p>注意，如果是 ES6 环境，上面的代码不会报错，因为 ES6 允许在代码块之中声明函数  </p><h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><p>为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">package</span>(<span class="hljs-params">protected</span>) </span>&#123; <span class="hljs-comment">// 语法错误</span><br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-keyword">var</span> implements; <span class="hljs-comment">// 语法错误</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="异步操作概述"><a href="#异步操作概述" class="headerlink" title="异步操作概述"></a>异步操作概述</h2><h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>单线程模型指的是，<code>Javascript</code> 只在一个线程上运行。也就是说，<code>Javascript</code> 同时只能执行一个任务，其他任务都必须在后面排队等待  </p><p>注意，<code>Javascript</code> 只在一个线程上运行，不代表 <code>Javascript</code> 引擎只有一个线程。事实上，<code>Javascript</code> 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合  </p><p><code>Javascript</code> 之所以采用单线程，而不是多线程，跟历史有关系。<code>Javascript</code> 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 <code>Javascript</code> 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，<code>Javascript</code> 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p><p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 <code>Javascript</code> 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p><p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。<code>Javascript</code> 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 <code>Javascript</code> 内部采用的“事件循环”机制（Event Loop）。</p><p>单线程模型虽然对 <code>Javascript</code> 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。</p><p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 <code>Javascript</code> 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 <code>Javascript</code> 单线程的本质。</p><h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h3><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p><p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p><p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p><p>举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p><h3 id="任务队列和事件循环"><a href="#任务队列和事件循环" class="headerlink" title="任务队列和事件循环"></a>任务队列和事件循环</h3><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p><p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行  </p><p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作  </p><p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。<a href="http://en.wikipedia.org/wiki/Event_loop">维基百科</a>的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”  </p><h3 id="异步操作的模式"><a href="#异步操作的模式" class="headerlink" title="异步操作的模式"></a>异步操作的模式</h3><p>下面总结一下异步操作的几种模式。</p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>回调函数是异步操作最基本的方法。</p><p>下面是两个函数<code>f1</code>和<code>f2</code>，编程的意图是<code>f2</code>必须等到<code>f1</code>执行完成，才能执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>f1();<br>f2();<br></code></pre></td></tr></table></figure><p>上面代码的问题在于，如果<code>f1</code>是异步操作，<code>f2</code>会立即执行，不会等到<code>f1</code>结束再执行。</p><p>这时，可以考虑改写<code>f1</code>，把<code>f2</code>写成<code>f1</code>的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  callback();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>f1(f2);<br></code></pre></td></tr></table></figure><p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度<a href="http://en.wikipedia.org/wiki/Coupling_(computer_programming)">耦合</a>（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p><h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p><p>还是以<code>f1</code>和<code>f2</code>为例。首先，为<code>f1</code>绑定一个事件（这里采用的 jQuery 的<a href="http://api.jquery.com/on/">写法</a>）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">f1.on(<span class="hljs-string">&#x27;done&#x27;</span>, f2);<br></code></pre></td></tr></table></figure><p>上面这行代码的意思是，当<code>f1</code>发生<code>done</code>事件，就执行<code>f2</code>。然后，对<code>f1</code>进行改写：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    f1.trigger(<span class="hljs-string">&#x27;done&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>f1.trigger(&#39;done&#39;)</code>表示，执行完成后，立即触发<code>done</code>事件，从而开始执行<code>f2</code>。</p><p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“<a href="http://en.wikipedia.org/wiki/Decoupling">去耦合</a>”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p><h4 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h4><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<a href="http://en.wikipedia.org/wiki/Publish-subscribe_pattern">发布/订阅模式</a>”（publish-subscribe pattern），又称“<a href="http://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>”（observer pattern）。</p><p>这个模式有多种<a href="http://msdn.microsoft.com/en-us/magazine/hh201955.aspx">实现</a>，下面采用的是 Ben Alman 的 <a href="https://gist.github.com/661855">Tiny Pub/Sub</a>，这是 jQuery 的一个插件。</p><p>首先，<code>f2</code>向信号中心<code>jQuery</code>订阅<code>done</code>信号。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">jQuery.subscribe(<span class="hljs-string">&#x27;done&#x27;</span>, f2);<br></code></pre></td></tr></table></figure><p>然后，<code>f1</code>进行如下改写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    jQuery.publish(<span class="hljs-string">&#x27;done&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>jQuery.publish(&#39;done&#39;)</code>的意思是，<code>f1</code>执行完成后，向信号中心<code>jQuery</code>发布<code>done</code>信号，从而引发<code>f2</code>的执行。</p><p><code>f2</code>完成执行后，可以取消订阅（unsubscribe）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">jQuery.unsubscribe(<span class="hljs-string">&#x27;done&#x27;</span>, f2);<br></code></pre></td></tr></table></figure><p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p><h3 id="异步操作的流程控制"><a href="#异步操作的流程控制" class="headerlink" title="异步操作的流程控制"></a>异步操作的流程控制</h3><p>如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span>(<span class="hljs-params">arg, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;参数为 &#x27;</span> + arg +<span class="hljs-string">&#x27; , 1秒后返回结果&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; callback(arg * <span class="hljs-number">2</span>); &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码的<code>async</code>函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。</p><p>如果有六个这样的异步任务，需要全部完成后，才能执行最后的<code>final</code>函数。请问应该如何安排操作流程？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">final</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成: &#x27;</span>, value);<br>&#125;<br><br><span class="hljs-keyword">async</span>(<span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">async</span>(<span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">async</span>(<span class="hljs-number">3</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>      <span class="hljs-keyword">async</span>(<span class="hljs-number">4</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>        <span class="hljs-keyword">async</span>(<span class="hljs-number">5</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>          <span class="hljs-keyword">async</span>(<span class="hljs-number">6</span>, final);<br>        &#125;);<br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;);<br><span class="hljs-comment">// 参数为 1 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 2 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 3 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 4 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 5 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 6 , 1秒后返回结果</span><br><span class="hljs-comment">// 完成:  12</span><br></code></pre></td></tr></table></figure><p>上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。</p><h4 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h4><p>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> items = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> ];<br><span class="hljs-keyword">var</span> results = [];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span>(<span class="hljs-params">arg, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;参数为 &#x27;</span> + arg +<span class="hljs-string">&#x27; , 1秒后返回结果&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; callback(arg * <span class="hljs-number">2</span>); &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">final</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成: &#x27;</span>, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">series</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(item) &#123;<br>    <span class="hljs-keyword">async</span>( item, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>&#123;<br>      results.push(result);<br>      <span class="hljs-keyword">return</span> series(items.shift());<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> final(results[results.length - <span class="hljs-number">1</span>]);<br>  &#125;<br>&#125;<br><br>series(items.shift());<br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>series</code>就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行<code>final</code>函数。<code>items</code>数组保存每一个异步任务的参数，<code>results</code>数组保存每一个异步任务的运行结果。</p><p>注意，上面的写法需要六秒，才能完成整个脚本。</p><h4 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h4><p>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行<code>final</code>函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> items = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> ];<br><span class="hljs-keyword">var</span> results = [];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span>(<span class="hljs-params">arg, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;参数为 &#x27;</span> + arg +<span class="hljs-string">&#x27; , 1秒后返回结果&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; callback(arg * <span class="hljs-number">2</span>); &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">final</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成: &#x27;</span>, value);<br>&#125;<br><br>items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">async</span>(item, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>)</span>&#123;<br>    results.push(result);<br>    <span class="hljs-keyword">if</span>(results.length === items.length) &#123;<br>      final(results[results.length - <span class="hljs-number">1</span>]);<br>    &#125;<br>  &#125;)<br>&#125;);<br></code></pre></td></tr></table></figure><p>上面代码中，<code>forEach</code>方法会同时发起六个异步任务，等到它们全部完成以后，才会执行<code>final</code>函数。</p><p>相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</p><h4 id="并行与串行的结合"><a href="#并行与串行的结合" class="headerlink" title="并行与串行的结合"></a>并行与串行的结合</h4><p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行<code>n</code>个异步任务，这样就避免了过分占用系统资源。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> items = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> ];<br><span class="hljs-keyword">var</span> results = [];<br><span class="hljs-keyword">var</span> running = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> limit = <span class="hljs-number">2</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span>(<span class="hljs-params">arg, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;参数为 &#x27;</span> + arg +<span class="hljs-string">&#x27; , 1秒后返回结果&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; callback(arg * <span class="hljs-number">2</span>); &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">final</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成: &#x27;</span>, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">launcher</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">while</span>(running &lt; limit &amp;&amp; items.length &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">var</span> item = items.shift();<br>    <span class="hljs-keyword">async</span>(item, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>&#123;<br>      results.push(result);<br>      running--;<br>      <span class="hljs-keyword">if</span>(items.length &gt; <span class="hljs-number">0</span>) &#123;<br>        launcher();<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(running == <span class="hljs-number">0</span>) &#123;<br>        final(results);<br>      &#125;<br>    &#125;);<br>    running++;<br>  &#125;<br>&#125;<br><br>launcher();<br></code></pre></td></tr></table></figure><p>上面代码中，最多只能同时运行两个异步任务。变量<code>running</code>记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于<code>0</code>，就表示所有任务都执行完了，这时就执行<code>final</code>函数。</p><p>这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节<code>limit</code>变量，达到效率和资源的最佳平衡  </p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由<code>setTimeout()</code>和<code>setInterval()</code>这两个函数来完成。它们向任务队列添加定时任务。</p><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h3><p><code>setTimeout</code>函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> timerId = <span class="hljs-built_in">setTimeout</span>(func|code, delay);<br></code></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout</code>函数接受两个参数，第一个参数<code>func|code</code>是将要推迟执行的函数名或者一段代码，第二个参数<code>delay</code>是推迟执行的毫秒数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&#x27;console.log(2)&#x27;</span>,<span class="hljs-number">1000</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码会先输出1和3，然后等待1000毫秒再输出2。注意，<code>console.log(2)</code>必须以字符串的形式，作为<code>setTimeout</code>的参数。</p><p>如果推迟执行的是函数，就直接将函数名，作为<code>setTimeout</code>的参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p><code>setTimeout</code>的第二个参数如果省略，则默认为0。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(f)<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>除了前两个参数，<code>setTimeout</code>还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a,b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a + b);<br>&#125;, <span class="hljs-number">1000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>上面代码中，<code>setTimeout</code>共有4个参数。最后那两个参数，将在1000毫秒之后回调函数执行时，作为回调函数的参数。</p><p>还有一个需要注意的地方，如果回调函数是对象的方法，那么<code>setTimeout</code>使得方法内部的<code>this</code>关键字指向全局环境，而不是定义时所在的那个对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  x: <span class="hljs-number">2</span>,<br>  y: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">setTimeout</span>(obj.y, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码输出的是1，而不是2。因为当<code>obj.y</code>在1000毫秒后运行时，<code>this</code>所指向的已经不是<code>obj</code>了，而是全局环境。</p><p>为了防止出现这个问题，一种解决方法是将<code>obj.y</code>放入一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  x: <span class="hljs-number">2</span>,<br>  y: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  obj.y();<br>&#125;, <span class="hljs-number">1000</span>);<br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>obj.y</code>放在一个匿名函数之中，这使得<code>obj.y</code>在<code>obj</code>的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。</p><p>另一种解决方法是，使用<code>bind</code>方法，将<code>obj.y</code>这个方法绑定在<code>obj</code>上面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  x: <span class="hljs-number">2</span>,<br>  y: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">setTimeout</span>(obj.y.bind(obj), <span class="hljs-number">1000</span>)<br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h3><p><code>setInterval</code>函数的用法与<code>setTimeout</code>完全一致，区别仅仅在于<code>setInterval</code>指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>上面代码中，每隔1000毫秒就输出一个2，会无限运行下去，直到关闭当前窗口。</p><p>与<code>setTimeout</code>一样，除了前两个参数，<code>setInterval</code>方法还可以接受更多的参数，它们会传入回调函数。</p><p>下面是一个通过<code>setInterval</code>方法实现网页动画的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;someDiv&#x27;</span>);<br><span class="hljs-keyword">var</span> opacity = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> fader = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  opacity -= <span class="hljs-number">0.1</span>;<br>  <span class="hljs-keyword">if</span> (opacity &gt;= <span class="hljs-number">0</span>) &#123;<br>    div.style.opacity = opacity;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">clearInterval</span>(fader);<br>  &#125;<br>&#125;, <span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure><p>上面代码每隔100毫秒，设置一次<code>div</code>元素的透明度，直至其完全透明为止。</p><p><code>setInterval</code>的一个常见用途是实现轮询。下面是一个轮询 URL 的 Hash 值是否发生变化的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hash = <span class="hljs-built_in">window</span>.location.hash;<br><span class="hljs-keyword">var</span> hashWatcher = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.location.hash != hash) &#123;<br>    updatePage();<br>  &#125;<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p><code>setInterval</code>指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，<code>setInterval</code>指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。</p><p>为了确保两次执行之间有固定的间隔，可以不用<code>setInterval</code>，而是每次执行结束后，使用<code>setTimeout</code>指定下一次执行的具体时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  timer = <span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">2000</span>);<br>&#125;, <span class="hljs-number">2000</span>);<br></code></pre></td></tr></table></figure><p>上面代码可以确保，下一次执行总是在本次执行结束之后的2000毫秒开始。</p><h3 id="clearTimeout-，clearInterval"><a href="#clearTimeout-，clearInterval" class="headerlink" title="clearTimeout()，clearInterval()"></a>clearTimeout()，clearInterval()</h3><p><code>setTimeout</code>和<code>setInterval</code>函数，都返回一个整数值，表示计数器编号。将该整数传入<code>clearTimeout</code>和<code>clearInterval</code>函数，就可以取消对应的定时器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> id1 = <span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">1000</span>);<br><span class="hljs-keyword">var</span> id2 = <span class="hljs-built_in">setInterval</span>(f, <span class="hljs-number">1000</span>);<br><br><span class="hljs-built_in">clearTimeout</span>(id1);<br><span class="hljs-built_in">clearInterval</span>(id2);<br></code></pre></td></tr></table></figure><p>上面代码中，回调函数<code>f</code>不会再执行了，因为两个定时器都被取消了。</p><p><code>setTimeout</code>和<code>setInterval</code>返回的整数值是连续的，也就是说，第二个<code>setTimeout</code>方法返回的整数值，将比第一个的整数值大1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 11</span><br><span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 12</span><br></code></pre></td></tr></table></figure><p>上面代码中，连续调用三次<code>setTimeout</code>，返回值都比上一次大了1。</p><p>利用这一点，可以写一个函数，取消当前所有的<code>setTimeout</code>定时器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 每轮事件循环检查一次</span><br>  <span class="hljs-keyword">var</span> gid = <span class="hljs-built_in">setInterval</span>(clearAllTimeouts, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearAllTimeouts</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> id = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (id &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (id !== gid) &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(id);<br>      &#125;<br>      id--;<br>    &#125;<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><p>上面代码中，先调用<code>setTimeout</code>，得到一个计算器编号，然后把编号比它小的计数器全部取消。</p><h3 id="实例：debounce-函数"><a href="#实例：debounce-函数" class="headerlink" title="实例：debounce 函数"></a>实例：debounce 函数</h3><p>有时，我们不希望回调函数被频繁调用。比如，用户填入网页输入框的内容，希望通过 Ajax 方法传回服务器，jQuery 的写法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;textarea&#x27;</span>).on(<span class="hljs-string">&#x27;keydown&#x27;</span>, ajaxAction);<br></code></pre></td></tr></table></figure><p>这样写有一个很大的缺点，就是如果用户连续击键，就会连续触发<code>keydown</code>事件，造成大量的 Ajax 通信。这是不必要的，而且很可能产生性能问题。正确的做法应该是，设置一个门槛值，表示两次 Ajax 通信的最小间隔时间。如果在间隔时间内，发生新的<code>keydown</code>事件，则不触发 Ajax 通信，并且重新开始计时。如果过了指定时间，没有发生新的<code>keydown</code>事件，再将数据发送出去。</p><p>这种做法叫做 debounce（防抖动）。假定两次 Ajax 通信的间隔不得小于2500毫秒，上面的代码可以改写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;textarea&#x27;</span>).on(<span class="hljs-string">&#x27;keydown&#x27;</span>, debounce(ajaxAction, <span class="hljs-number">2500</span>));<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 声明计时器</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-built_in">clearTimeout</span>(timer);<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      fn.apply(context, args);<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，只要在2500毫秒之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是2500毫秒。</p><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p><code>setTimeout</code>和<code>setInterval</code>的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。</p><p>这意味着，<code>setTimeout</code>和<code>setInterval</code>指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，<code>setTimeout</code>和<code>setInterval</code>指定的任务，一定会按照预定时间执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(someTask, <span class="hljs-number">100</span>);<br>veryLongTask();<br></code></pre></td></tr></table></figure><p>上面代码的<code>setTimeout</code>，指定100毫秒以后运行一个任务。但是，如果后面的<code>veryLongTask</code>函数（同步任务）运行时间非常长，过了100毫秒还无法结束，那么被推迟运行的<code>someTask</code>就只有等着，等到<code>veryLongTask</code>运行结束，才轮到它执行。</p><p>再看一个<code>setInterval</code>的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br>sleep(<span class="hljs-number">3000</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> start = <span class="hljs-built_in">Date</span>.now();<br>  <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">Date</span>.now() - start) &lt; ms) &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>setInterval</code>要求每隔1000毫秒，就输出一个2。但是，紧接着的<code>sleep</code>语句需要3000毫秒才能完成，那么<code>setInterval</code>就必须推迟到3000毫秒之后才开始生效。注意，生效后<code>setInterval</code>不会产生累积效应，即不会一下子输出三个2，而是只会输出一个2。</p><h3 id="setTimeout-f-0"><a href="#setTimeout-f-0" class="headerlink" title="setTimeout(f, 0)"></a>setTimeout(f, 0)</h3><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><p><code>setTimeout</code>的作用是将代码推迟到指定时间执行，如果指定时间为<code>0</code>，即<code>setTimeout(f, 0)</code>，那么会立刻执行吗？</p><p>答案是不会。因为上一节说过，必须要等到当前脚本的同步任务，全部处理完以后，才会执行<code>setTimeout</code>指定的回调函数<code>f</code>。也就是说，<code>setTimeout(f, 0)</code>会在下一轮事件循环一开始就执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码先输出<code>2</code>，再输出<code>1</code>。因为<code>2</code>是同步任务，在本轮事件循环执行，而<code>1</code>是下一轮事件循环执行。</p><p>总之，<code>setTimeout(f, 0)</code>这种写法的目的是，尽可能早地执行<code>f</code>，但是并不能保证立刻就执行<code>f</code>。</p><p>实际上，<code>setTimeout(f, 0)</code>不会真的在0毫秒之后运行，不同的浏览器有不同的实现。以 Edge 浏览器为例，会等到4毫秒之后运行。如果电脑正在使用电池供电，会等到16毫秒之后运行；如果网页不在当前 Tab 页，会推迟到1000毫秒（1秒）之后运行。这样是为了节省系统资源。</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><code>setTimeout(f, 0)</code>有几个非常重要的用途。它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，想让父元素的事件回调函数先发生，就要用到<code>setTimeout(f, 0)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// HTML 代码如下</span><br><span class="hljs-comment">// &lt;input type=&quot;button&quot; id=&quot;myButton&quot; value=&quot;click&quot;&gt;</span><br><br><span class="hljs-keyword">var</span> input = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myButton&#x27;</span>);<br><br>input.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;<br>    input.value +=<span class="hljs-string">&#x27; input&#x27;</span>;<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;;<br><br><span class="hljs-built_in">document</span>.body.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">C</span>(<span class="hljs-params"></span>) </span>&#123;<br>  input.value += <span class="hljs-string">&#x27; body&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码在点击按钮后，先触发回调函数<code>A</code>，然后触发函数<code>C</code>。函数<code>A</code>中，<code>setTimeout</code>将函数<code>B</code>推迟到下一轮事件循环执行，这样就起到了，先触发父元素的回调函数<code>C</code>的目的了。</p><p>另一个应用是，用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，<code>keypress</code>事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// HTML 代码如下</span><br><span class="hljs-comment">// &lt;input type=&quot;text&quot; id=&quot;input-box&quot;&gt;</span><br><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;input-box&#x27;</span>).onkeypress = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.value = <span class="hljs-built_in">this</span>.value.toUpperCase();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码想在用户每次输入文本后，立即将字符转为大写。但是实际上，它只能将本次输入前的字符转为大写，因为浏览器此时还没接收到新的文本，所以<code>this.value</code>取不到最新输入的那个字符。只有用<code>setTimeout</code>改写，上面的代码才能发挥作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;input-box&#x27;</span>).onkeypress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    self.value = self.value.toUpperCase();<br>  &#125;, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码将代码放入<code>setTimeout</code>之中，就能使得它在浏览器接收到文本之后触发。</p><p>由于<code>setTimeout(f, 0)</code>实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到<code>setTimeout(f, 0)</code>里面执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// 写法一</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0xA00000</span>; i &lt; <span class="hljs-number">0xFFFFFF</span>; i++) &#123;<br>  div.style.backgroundColor = <span class="hljs-string">&#x27;#&#x27;</span> + i.toString(<span class="hljs-number">16</span>);<br>&#125;<br><br><span class="hljs-comment">// 写法二</span><br><span class="hljs-keyword">var</span> timer;<br><span class="hljs-keyword">var</span> i=<span class="hljs-number">0x100000</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  timer = <span class="hljs-built_in">setTimeout</span>(func, <span class="hljs-number">0</span>);<br>  div.style.backgroundColor = <span class="hljs-string">&#x27;#&#x27;</span> + i.toString(<span class="hljs-number">16</span>);<br>  <span class="hljs-keyword">if</span> (i++ == <span class="hljs-number">0xFFFFFF</span>) <span class="hljs-built_in">clearTimeout</span>(timer);<br>&#125;<br><br>timer = <span class="hljs-built_in">setTimeout</span>(func, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为 JavaScript 执行速度远高于 DOM，会造成大量 DOM 操作“堆积”，而写法二就不会，这就是<code>setTimeout(f, 0)</code>的好处。</p><p>另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成<code>setTimeout(highlightNext, 50)</code>的样子，性能压力就会减轻  </p><h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p><p>注意，本章只是 Promise 对象的简单介绍。为了避免与后续教程的重复，更完整的介绍请看<a href="http://es6.ruanyifeng.com/">《ES6 标准入门》</a>的<a href="http://es6.ruanyifeng.com/#docs/promise">《Promise 对象》</a>一章。</p><p>首先，Promise 是一个对象，也是一个构造函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// 异步代码...</span><br>&#125;<br><br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(f1);<br></code></pre></td></tr></table></figure><p>上面代码中，<code>Promise</code>构造函数接受一个回调函数<code>f1</code>作为参数，<code>f1</code>里面是异步操作的代码。然后，返回的<code>p1</code>就是一个 Promise 实例。</p><p>Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个<code>then</code>方法，用来指定下一步的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(f1);<br>p1.then(f2);<br></code></pre></td></tr></table></figure><p>上面代码中，<code>f1</code>的异步操作执行完成，就会执行<code>f2</code>。</p><p>传统的写法可能需要把<code>f2</code>作为回调函数传入<code>f1</code>，比如写成<code>f1(f2)</code>，异步操作完成后，在<code>f1</code>内部调用<code>f2</code>。Promise 使得<code>f1</code>和<code>f2</code>变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 传统写法</span><br>step1(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value1</span>) </span>&#123;<br>  step2(value1, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value2</span>) </span>&#123;<br>    step3(value2, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value3</span>) </span>&#123;<br>      step4(value3, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value4</span>) </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;);<br><br><span class="hljs-comment">// Promise 的写法</span><br>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(step1))<br>  .then(step2)<br>  .then(step3)<br>  .then(step4);<br></code></pre></td></tr></table></figure><p>从上面代码可以看到，采用 Promises 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的<code>Promise</code>实例的生成格式，做了简化，真正的语法请参照下文。</p><p>总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程。</p><p>Promise 原本只是社区提出的一个构想，一些函数库率先实现了这个功能。ECMAScript 6 将其写入语言标准，目前 JavaScript 原生支持 Promise 对象。</p><h3 id="Promise-对象的状态"><a href="#Promise-对象的状态" class="headerlink" title="Promise 对象的状态"></a>Promise 对象的状态</h3><p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p><ul><li>异步操作未完成（pending）</li><li>异步操作成功（fulfilled）</li><li>异步操作失败（rejected）</li></ul><p>上面三种状态里面，<code>fulfilled</code>和<code>rejected</code>合在一起称为<code>resolved</code>（已定型）。</p><p>这三种的状态的变化途径只有两种。</p><ul><li>从“未完成”到“成功”</li><li>从“未完成”到“失败”</li></ul><p>一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。</p><p>因此，Promise 的最终结果只有两种。</p><ul><li>异步操作成功，Promise 实例传回一个值（value），状态变为<code>fulfilled</code>。</li><li>异步操作失败，Promise 实例抛出一个错误（error），状态变为<code>rejected</code>。</li></ul><h3 id="Promise-构造函数"><a href="#Promise-构造函数" class="headerlink" title="Promise 构造函数"></a>Promise 构造函数</h3><p>JavaScript 提供原生的<code>Promise</code>构造函数，用来生成 Promise 实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;<br>    resolve(value);<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 异步操作失败 */</span><br>    reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>());<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>上面代码中，<code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</p><p><code>resolve</code>函数的作用是，将<code>Promise</code>实例的状态从“未完成”变为“成功”（即从<code>pending</code>变为<code>fulfilled</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。<code>reject</code>函数的作用是，将<code>Promise</code>实例的状态从“未完成”变为“失败”（即从<code>pending</code>变为<code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, ms, <span class="hljs-string">&#x27;done&#x27;</span>);<br>  &#125;);<br>&#125;<br><br>timeout(<span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>上面代码中，<code>timeout(100)</code>返回一个 Promise 实例。100毫秒以后，该实例的状态会变为<code>fulfilled</code>。</p><h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p>Promise 实例的<code>then</code>方法，用来添加回调函数。</p><p><code>then</code>方法可以接受两个回调函数，第一个是异步操作成功时（变为<code>fulfilled</code>状态）的回调函数，第二个是异步操作失败（变为<code>rejected</code>）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  resolve(<span class="hljs-string">&#x27;成功&#x27;</span>);<br>&#125;);<br>p1.then(<span class="hljs-built_in">console</span>.log, <span class="hljs-built_in">console</span>.error);<br><span class="hljs-comment">// &quot;成功&quot;</span><br><br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;失败&#x27;</span>));<br>&#125;);<br>p2.then(<span class="hljs-built_in">console</span>.log, <span class="hljs-built_in">console</span>.error);<br><span class="hljs-comment">// Error: 失败</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>和<code>p2</code>都是Promise 实例，它们的<code>then</code>方法绑定两个回调函数：成功时的回调函数<code>console.log</code>，失败时的回调函数<code>console.error</code>（可以省略）。<code>p1</code>的状态变为成功，<code>p2</code>的状态变为失败，对应的回调函数会收到异步操作传回的值，然后在控制台输出。</p><p><code>then</code>方法可以链式使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">p1<br>  .then(step1)<br>  .then(step2)<br>  .then(step3)<br>  .then(<br>    <span class="hljs-built_in">console</span>.log,<br>    <span class="hljs-built_in">console</span>.error<br>  );<br></code></pre></td></tr></table></figure><p>上面代码中，<code>p1</code>后面有四个<code>then</code>，意味依次有四个回调函数。只要前一步的状态变为<code>fulfilled</code>，就会依次执行紧跟在后面的回调函数。</p><p>最后一个<code>then</code>方法，回调函数是<code>console.log</code>和<code>console.error</code>，用法上有一点重要的区别。<code>console.log</code>只显示<code>step3</code>的返回值，而<code>console.error</code>可以显示<code>p1</code>、<code>step1</code>、<code>step2</code>、<code>step3</code>之中任意一个发生的错误。举例来说，如果<code>step1</code>的状态变为<code>rejected</code>，那么<code>step2</code>和<code>step3</code>都不会执行了（因为它们是<code>resolved</code>的回调函数）。Promise 开始寻找，接下来第一个为<code>rejected</code>的回调函数，在上面代码中是<code>console.error</code>。这就是说，Promise 对象的报错具有传递性。</p><h3 id="then-用法辨析"><a href="#then-用法辨析" class="headerlink" title="then() 用法辨析"></a>then() 用法辨析</h3><p>Promise 的用法，简单说就是一句话：使用<code>then</code>方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法一</span><br>f1().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> f2();<br>&#125;);<br><br><span class="hljs-comment">// 写法二</span><br>f1().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  f2();<br>&#125;);<br><br><span class="hljs-comment">// 写法三</span><br>f1().then(f2());<br><br><span class="hljs-comment">// 写法四</span><br>f1().then(f2);<br></code></pre></td></tr></table></figure><p>为了便于讲解，下面这四种写法都再用<code>then</code>方法接一个回调函数<code>f3</code>。写法一的<code>f3</code>回调函数的参数，是<code>f2</code>函数的运行结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">f1().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> f2();<br>&#125;).then(f3);<br></code></pre></td></tr></table></figure><p>写法二的<code>f3</code>回调函数的参数是<code>undefined</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">f1().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  f2();<br>  <span class="hljs-keyword">return</span>;<br>&#125;).then(f3);<br></code></pre></td></tr></table></figure><p>写法三的<code>f3</code>回调函数的参数，是<code>f2</code>函数返回的函数的运行结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">f1().then(f2())<br>  .then(f3);<br></code></pre></td></tr></table></figure><p>写法四与写法一只有一个差别，那就是<code>f2</code>会接收到<code>f1()</code>返回的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">f1().then(f2)<br>  .then(f3);<br></code></pre></td></tr></table></figure><h3 id="实例：图片加载"><a href="#实例：图片加载" class="headerlink" title="实例：图片加载"></a>实例：图片加载</h3><p>下面是使用 Promise 完成图片的加载。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> preloadImage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image();<br>    image.onload  = resolve;<br>    image.onerror = reject;<br>    image.src = path;<br>  &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>image</code>是一个图片对象的实例。它有两个事件监听属性，<code>onload</code>属性在图片加载成功后调用，<code>onerror</code>属性在加载失败调用。</p><p>上面的<code>preloadImage()</code>函数用法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">preloadImage(<span class="hljs-string">&#x27;https://example.com/my.jpg&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123; <span class="hljs-built_in">document</span>.body.append(e.target) &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;加载成功&#x27;</span>) &#125;)<br></code></pre></td></tr></table></figure><p>上面代码中，图片加载成功以后，<code>onload</code>属性会返回一个事件对象，因此第一个<code>then()</code>方法的回调函数，会接收到这个事件对象。该对象的<code>target</code>属性就是图片加载后生成的 DOM 节点。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。</p><p>而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。</p><p>Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆<code>then</code>，必须自己在<code>then</code>的回调函数里面理清逻辑。</p><h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>Promise 的回调函数属于异步任务，会在同步任务之后执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  resolve(<span class="hljs-number">1</span>);<br>&#125;).then(<span class="hljs-built_in">console</span>.log);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码会先输出2，再输出1。因为<code>console.log(2)</code>是同步任务，而<code>then</code>的回调函数属于异步任务，一定晚于同步任务执行。</p><p>但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  resolve(<span class="hljs-number">2</span>);<br>&#125;).then(<span class="hljs-built_in">console</span>.log);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码的输出结果是<code>321</code>。这说明<code>then</code>的回调函数的执行时间，早于<code>setTimeout(fn, 0)</code>。因为<code>then</code>是本轮事件循环执行，<code>setTimeout(fn, 0)</code>在下一轮事件循环开始时执行。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络-网关、代理、隧道异同</title>
    <link href="/post/14a04139/"/>
    <url>/post/14a04139/</url>
    
    <content type="html"><![CDATA[<h1 id="代理-Proxy"><a href="#代理-Proxy" class="headerlink" title="代理 Proxy"></a>代理 Proxy</h1><p>代理（英语：Proxy）也称网络代理，是一种特殊的网络服务，允许一个（一般为客户端）通过这个服务与另一个网络终端（一般为服务器）进行非直接的连接<br>一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，防止攻击  </p><p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求<code>URI</code>，并不会直接发送给前方持有资源的目标服务器  </p><p>持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端  </p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>提高访问速度<br>通常代理服务器都设置一个较大的缓冲区，当有外界的信息通过时，同时也将其保存到缓冲区中，当其他用户再访问相同的信息时， 则直接由缓冲区中取出信息，传给用户，以提高访问速度  </li><li>控制对内部资源的访问<br>如某大学FTP（前提是该代理地址在该资源的允许访问范围之内），使用教育网内地址段免费代理服务器，就可以用于对教育网开放的各类FTP下载上传，以及各类资料查询共享等服务  </li><li>过滤内容<br>例如限制对特定计算机的访问，将一种语言的数据翻译成另一种语言，或是防御代理服务器两边的攻击性访问  </li><li>隐藏真实IP<br>上网者也可以通过代理服务器隐藏自己的IP，免受攻击。但是只一个代理很难保证安全，更安全的方法是利用特定的工具创建代理链（如：Tor）  </li><li>突破自身IP访问限制  </li><li>突破内容过滤机制限制，访问被过滤网站<br>如防火长城对中国境内互联网访问的限制可透过使用代理服务器浏览而突破。但是每到国庆、两会等敏感时期，防火长城的封锁力度会大大加强，大多数代理服务器和代理软件都会无法连接  </li></ul><p><strong>代理服务器的特点：</strong>  </p><ul><li>通信协议一致<br>客户端与代理服务器使用的通讯协议，代理服务器与服务器使用的通讯协议是一致的  </li><li>解析重发<br>客户端/服务器 发送给代理服务器的 请求/响应 都会被代理服务器解析，重新封装后再发送给对方  </li></ul><h1 id="网关-Gateway"><a href="#网关-Gateway" class="headerlink" title="网关 Gateway"></a>网关 Gateway</h1><p>网关（英语：Gateway）是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关  </p><p>区别于路由器（由于历史的原因，许多有关TCP/IP的文献曾经把网络层使用的路由器（英语：Router）称为网关，在今天很多局域网采用都是路由来接入网络，因此现在通常指的网关就是路由器的IP），经常在家庭中或者小型企业网络中使用，用于连接局域网和互联网  </p><p>网关也经常指把一种协议转成另一种协议的设备  </p><p>在现代网络术语中，网关（gateway）与路由器（router）的定义不同。网关（gateway）能在不同协议间移动数据，而路由器（router）是在不同网络间移动数据，相当于传统所说的IP网关（IP gateway）  </p><p>对于以太网中的网关只能转发三层以上数据包，这一点和路由是一样的。而不同的是网关中并没有路由表，他只能按照预先设定的不同网段来进行转发<br>网关最重要的一点就是端口映射，子网内用户在外网看来只是外网的IP地址对应着不同的端口，这样看来就会保护子网内的用户  </p><p><strong>网关特点：</strong></p><ul><li>屏蔽<br>客户端不知道真正的服务器是谁，服务器也不知道客户端是什么样的  </li><li>通信协议不一致<br>客户端同代理服务器，代理服务器同服务器，这两者之间使用的通讯协议或者协议的版本是不一样的  </li><li>解析+协议转换<br>代理服务器会对接收的请求进行解析，转换协议后再发送给服务器；在服务器响应后，对响应进行解析，转换协议后再发送给客户端  </li></ul><h1 id="隧道协议-Tunneling-Protocol"><a href="#隧道协议-Tunneling-Protocol" class="headerlink" title="隧道协议 Tunneling Protocol"></a>隧道协议 Tunneling Protocol</h1><p>隧道协议（英语：Tunneling Protocol）是一种网络协议<br>使用一种网络协议（发送协议），将另一个不同的网络协议，封装在负载部分<br>使用隧道的原因是在不兼容的网络上传输数据，或在不安全网络上提供一个安全路径  </p><p>隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序  </p><p>隧道协议通常（但并非总是）在一个比负载协议还高的层级，或同一层  </p><p><strong>隧道本身不会去解析请求</strong><br>请求保持原样中转给之后的服务器。隧道本身是透明的，客户端不用在意隧道的存在  </p><h2 id="常见隧道协议"><a href="#常见隧道协议" class="headerlink" title="常见隧道协议"></a>常见隧道协议</h2><ul><li>TLS  </li><li>SSH  </li><li>SOCKS  </li><li>IPsec  </li><li>一般路由封装（GRE），支持多种网络层协议和多路技术  </li><li>L2TP（资料链接层隧道协议）  </li><li>PPTP（点对点隧道协议）  </li><li>PPPoE（基于以太网的点对点隧道）  </li><li>PPPoA（基于ATM的点对点隧道）  </li></ul><h2 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h2><h3 id="规避防火墙"><a href="#规避防火墙" class="headerlink" title="规避防火墙"></a>规避防火墙</h3><p>一个被防火墙阻挡的协议可被包在另一个没被防火墙阻挡的协议里，如<code>HTTP</code><br>如果防火墙并没有排除此种包装，这技巧可用来逃避防火墙政策<br>隧道可按要求创建起一条与其他服务器的通信线路，届时使用 <code>SSL</code> 等加密手段进行通信  </p><h3 id="加密网络流量"><a href="#加密网络流量" class="headerlink" title="加密网络流量"></a>加密网络流量</h3><p>将明文网络流量加密以在互联网上安全地传输  </p><p><strong>隧道的特点：</strong>  </p><ul><li>该协议是为承载协议自身以外的流量而编写的协议  </li><li>允许数据从一个网络移动到另一个网络  </li><li>只关心流量的传输，不对承载的流量进行解析  </li></ul><h1 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h1><table><thead><tr><th></th><th>代理</th><th>网关</th><th>隧道</th></tr></thead><tbody><tr><td>服务器客户端相互知晓</td><td>True/False</td><td>False</td><td>True</td></tr><tr><td>解析数据</td><td>True</td><td>True</td><td>False</td></tr><tr><td>协议一致</td><td>True</td><td>False</td><td>True</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>代理</tag>
      
      <tag>网络</tag>
      
      <tag>网关</tag>
      
      <tag>隧道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码规范</title>
    <link href="/post/caa523c5/"/>
    <url>/post/caa523c5/</url>
    
    <content type="html"><![CDATA[<h1 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h1><p>编程界常⽤的⼏种命名⻛格分别是：⼤驼峰⻛格、⼩驼峰⻛格、匈⽛利⻛格和蛇形⻛格  </p><table><thead><tr><th>名称</th><th>规则</th><th>例子</th></tr></thead><tbody><tr><td>⼤驼峰⻛格</td><td>每个单词的⾸字⺟均以⼤写呈现</td><td>UserModel、 CrontabRule、 PandaCount</td></tr><tr><td>⼩驼峰⻛格</td><td>第⼀个单词的⾸字⺟以⼩写呈现</td><td>userModel、 crontabRule、 pandaCount</td></tr><tr><td>匈⽛利⻛格</td><td>命名⻛格剑⾛偏锋，不是很好描述</td><td>m_lpszStr 表示指向⼀个以 0 字符结尾的字符串的⻓指针成员变量</td></tr><tr><td>蛇形⻛格</td><td>⽤下划线作为单词之间的连接符号，所有字⺟均以⼩写呈现</td><td>user_model、crontab_rule、 panda_count</td></tr></tbody></table><p>不同编程语⾔所推崇的⻛格亦不相同  </p><ul><li>Java 开发者、Golang 开发者习惯使⽤驼峰⻛格  </li><li>Python 开发者则推崇蛇形⻛格  </li><li>Rust 开发者就会同时使⽤驼峰⻛格和蛇形⻛格。</li></ul><h1 id="命名原则"><a href="#命名原则" class="headerlink" title="命名原则"></a>命名原则</h1><p>给对象起⼀个有意义、含义明确、⽆副作⽤、不会引起误导的名称，名字⻓⼀些不要紧<br>重要的是<strong>要让人一眼就明白它的含义</strong>  </p><ul><li>类名、包名、⽂件名、项⽬名、变量名、常量名⽤名词  </li><li>函数名⽤动词或者动词配合名词<br>例如 get、 take、 push、 extract、extract_digest、get_number、 take_tickets  </li><li>项⽬名、包名、⽂件名、类名对应的单词可以⽤复数形式表示  </li><li>⻓度控制在 5 个单词内，追求⻅名知意  </li><li>不要占⽤语⾔或者系统保留词  </li><li>不要使⽤简短的字⺟或者单词缩写作为名称  </li><li>类名、包名、⽂件名、项⽬名、变量名、常量名不应包含动词；  </li><li>名称中除了字⺟和下划线外，不应包含其他字符  </li><li>接⼝名、抽象类名、基类名、异常类名、错误类名以特定的单词开头或结尾，例如 TimeException、StorageBase、 PermissionInterface、 ParseError  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>代码规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-注释</title>
    <link href="/post/1b3e3fef/"/>
    <url>/post/1b3e3fef/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>相较于既给⼈看也给编译器看的代码⽽⾔，注释完全就是写给⼈看的，因此注释要更偏向于⼈类阅读习惯。好的注释能够让⼈快速理解对象的逻辑或者含义，⽽不好的注释则有可能让阅读者产⽣另⼀种理解，从⽽把⼈带到坑⾥。</p><p>编程新⼿很容易产⽣两种截然不同的注释⻛格:  </p><ul><li>根本不知道要些注释或者些什么样的注释，你很难在他的代码⾥找到注释内容  </li><li>很喜欢在代码⾥写上⾮常详细的注释，深怕⾃⼰或者阅读代码的其他⼈看不懂  </li></ul><h2 id="使用注释之前"><a href="#使用注释之前" class="headerlink" title="使用注释之前"></a>使用注释之前</h2><p>有些对象在起名的时候就已经具备了表达含义的能⼒，我们只需要⽤注释表达⼀些处理逻辑或者特别要留意的内容即可<br>如果你的注释需要写的很详细或者⽤来标注⼀个函数、⼀个变量的作⽤，那么你应该考虑的是给那个对象换⼀个更能表达含义的名字，⽽不是给它加上注释  </p><p>实际上，如果能通过给变量起⼀个好名字能解决问题，那么直接起一个好名字更好    </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">t = <span class="hljs-built_in">int</span>(time.time()) * <span class="hljs-number">1000</span> <span class="hljs-comment"># 获取 13 位时间戳</span><br>timestamp_thirteen = <span class="hljs-built_in">int</span>(time.time()) * <span class="hljs-number">1000</span><br></code></pre></td></tr></table></figure><h1 id="变量注释"><a href="#变量注释" class="headerlink" title="变量注释"></a>变量注释</h1><h2 id="变量注释-1"><a href="#变量注释-1" class="headerlink" title="变量注释"></a>变量注释</h2><p><code>Python</code> 的变量或常量注释以 <code>#</code> 符号作为标记，后续跟随 1 个空格和对应的⽂字描述即可。如果在代码尾部编写注释时需要空出 2 个空格  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 如果在代码尾部编写注释时需要空出 2 个空格  </span><br>a = <span class="hljs-number">1</span>  <span class="hljs-comment"># 注释</span><br></code></pre></td></tr></table></figure><h2 id="类型注释"><a href="#类型注释" class="headerlink" title="类型注释"></a>类型注释</h2><p>⽤静态语⾔编写代码在定义对象时必须要指定对象的类型例如 int、 string、 []int 等，如果没有定义则会在编译时报错<br>虽然 <code>Python</code> 不是静态语⾔，也不⽀持编译时的类型检查，但是它⽀持类型注释  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">number: <span class="hljs-built_in">int</span> = <span class="hljs-number">1</span><br>name: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;Recluse&quot;</span><br></code></pre></td></tr></table></figure><p>可以使用更加复杂的类型，不过需要引入  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Tuple, List, Dict<br><br>coupons: Tuple[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>] = (<span class="hljs-string">&quot;z&quot;</span>, <span class="hljs-string">&quot;z&quot;</span>, <span class="hljs-number">5</span>)<br>message: List[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>] = [<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;lb&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>]<br>information: Dict[<span class="hljs-built_in">str</span>: <span class="hljs-built_in">str</span>] = &#123;<span class="hljs-string">&quot;a&quot;</span>: <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>: <span class="hljs-string">&quot;c&quot;</span>&#125;<br></code></pre></td></tr></table></figure><p>这个注释在函数的参数里也有应用  </p><h1 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h1><h2 id="函数体注释"><a href="#函数体注释" class="headerlink" title="函数体注释"></a>函数体注释</h2><p>函数注释常以 <code>#</code> 号或者 <code>&quot;&quot;&quot;</code> 号开头，其中 <code>&quot;&quot;&quot;</code> 号通常在函数名下的第⼀⾏开始，⽤以描述与函数相关的信息  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send</span>(<span class="hljs-params">message, host, name</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot; 消息推送器</span><br><span class="hljs-string">    将消息推送到指定服务器的指定队列中</span><br><span class="hljs-string">    :param message: 消息体</span><br><span class="hljs-string">    :param host: 服务器地址</span><br><span class="hljs-string">    :param name: 队列名称</span><br><span class="hljs-string">    :return: 推送结果</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="函数注释-1"><a href="#函数注释-1" class="headerlink" title="函数注释"></a>函数注释</h2><p>函数注释（Function Annotations），是函数的一种额外的注释<br>主要用于提示函数的返回值类型  </p><h3 id="存在的原因"><a href="#存在的原因" class="headerlink" title="存在的原因"></a>存在的原因</h3><p><code>Python</code>2 并没有对函数参数和返回值进行注释的标准方法<br>不少人创建了许多的库，尝试用不同的方式来解决这个问题。各个库使用的方法，实现的方法各不相同，使用起来相对麻烦<br>为了解决问题，统一标准。<code>Python</code>3 引入了 函数注释  </p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><h4 id="参数注释"><a href="#参数注释" class="headerlink" title="参数注释"></a>参数注释</h4><p>在参数后以<code>:</code>标记，表示对特定参数的注释<br>可以填入包含 类型 或者 字符串   </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">a:<span class="hljs-string">&quot;我就是注释&quot;</span>, b:<span class="hljs-string">&quot;我也是注释&quot;</span>=<span class="hljs-number">5</span>, c:<span class="hljs-built_in">int</span>=<span class="hljs-number">2</span></span>):</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h4 id="返回值注释"><a href="#返回值注释" class="headerlink" title="返回值注释"></a>返回值注释</h4><p>在括号以后以 <code>-&gt;</code> 标记, 表示对函数返回值的注释。可以填入类型注释或者表达式  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a</span>() -&gt; list:</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span>() -&gt; max(1,5):</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="访问函数注释"><a href="#访问函数注释" class="headerlink" title="访问函数注释"></a>访问函数注释</h4><p>函数对象有一个名为 <code>__annotations__</code> 的属性，它是一个映射（dict），用于将每个参数名（key）映射到其相关的注释（value）  </p><blockquote><p>注意： 映射中有一个特殊的 key，叫做“return”，仅当为函数的返回值提供注释时，才会显示该 key  </p></blockquote><p>回到上述示例，并检查它的注释：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b: <span class="hljs-built_in">int</span>, c: <span class="hljs-string">&#x27;The default value is 5&#x27;</span> = <span class="hljs-number">5</span></span>) -&gt; float:</span><br>    <span class="hljs-keyword">return</span> a + b + c<br><span class="hljs-built_in">type</span>(<span class="hljs-built_in">sum</span>.__annotations__)<br>&gt;&gt;&gt;&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> &#x27;<span class="hljs-title">dict</span>&#x27;&gt;</span><br><span class="hljs-class"><span class="hljs-title">sum</span>.<span class="hljs-title">__annotations__</span></span><br>&gt;&gt;&gt;&#123;&#x27;c&#x27;: &#x27;The default value is 5&#x27;, &#x27;return&#x27;: &lt;class &#x27;float&#x27;&gt;, &#x27;b&#x27;: &lt;class &#x27;int&#x27;&gt;&#125;<br></code></pre></td></tr></table></figure><p>返回值的键是<code>return</code>。由于这个字符本身是Python的一个关键字，不存在”return参数”的可能性，所以并不会与其它参数发生冲突  </p><h4 id="多个注释"><a href="#多个注释" class="headerlink" title="多个注释"></a>多个注释</h4><p>倘若，函数注释中要同时包含类型和帮助字符串，可以使用具有两个 key（例如：type 和 help）的 dict：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">def div(<br>    a: dict(<span class="hljs-attribute">type</span>=float, <span class="hljs-attribute">help</span>=<span class="hljs-string">&#x27;被除数&#x27;</span>),<br>    b: dict(<span class="hljs-attribute">type</span>=float, <span class="hljs-attribute">help</span>=<span class="hljs-string">&#x27;除数,必须不为0&#x27;</span>)<br>) -&gt; dict(<span class="hljs-attribute">type</span>=float, <span class="hljs-attribute">help</span>=<span class="hljs-string">&#x27;会得到a/b的结果&#x27;</span>):<br>    return a / b<br><br>div.__annotations__<br>&gt;&gt;&gt;&#123;<span class="hljs-string">&#x27;a&#x27;</span>: &#123;<span class="hljs-string">&#x27;type&#x27;</span>: &lt;class <span class="hljs-string">&#x27;float&#x27;</span>&gt;, <span class="hljs-string">&#x27;help&#x27;</span>: <span class="hljs-string">&#x27;被除数&#x27;</span>&#125;, <span class="hljs-string">&#x27;return&#x27;</span>: &#123;<span class="hljs-string">&#x27;type&#x27;</span>: &lt;class <span class="hljs-string">&#x27;float&#x27;</span>&gt;, <span class="hljs-string">&#x27;help&#x27;</span>: <span class="hljs-string">&#x27;会得到a/b的结果&#x27;</span>&#125;, <span class="hljs-string">&#x27;b&#x27;</span>: &#123;<span class="hljs-string">&#x27;type&#x27;</span>: &lt;class <span class="hljs-string">&#x27;float&#x27;</span>&gt;, <span class="hljs-string">&#x27;help&#x27;</span>: <span class="hljs-string">&#x27;除数,必须不为0&#x27;</span>&#125;&#125;<br><br></code></pre></td></tr></table></figure><h4 id="动态注释"><a href="#动态注释" class="headerlink" title="动态注释"></a>动态注释</h4><p><code>__annotations__</code> 是函数的一个属性，是可以在程序运行时动态地修改的<br>你甚至可以在函数内部对它进行更改  </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">def <span class="hljs-built_in">sum</span>(<span class="hljs-keyword">a</span>, b) -&gt; <span class="hljs-number">0</span>:<br>    <span class="hljs-built_in">result</span> = <span class="hljs-keyword">a</span> + b<br>    <span class="hljs-built_in">sum</span>.__annotations__[<span class="hljs-string">&#x27;return&#x27;</span>] += <span class="hljs-built_in">result</span><br>    <span class="hljs-literal">return</span> <span class="hljs-built_in">result</span><br></code></pre></td></tr></table></figure><h1 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h1><p>⽂件注释通常写在⽂件的开头，后续才是代码内容<br>⽂件注释通常被⽤于表明法律或版权信息、作者介绍以及⽂件内容的相关信息<br><code>Python</code> 的⽂件注释以 <code>#</code> 符号或者 <code>&quot;&quot;&quot;</code> 符号标记，通常情况下，单⾏内容⽤<br><code>#</code> 符号标记，⽽多⾏内容⽤ <code>&quot;&quot;&quot;</code> 标记。⽂字的格式并没有要求，可以按照团队约定的⻛格或者⾃⼰的习惯编写  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>注释</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Wireshark-抓包-网络分析工具</title>
    <link href="/post/576b6f0f/"/>
    <url>/post/576b6f0f/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Wireshark</code> 是网络数据包分析器<br>它会尽可能详细地显示捕获的数据包数据<br>你可以通过它来对网络情况进行分析<br>特点：开源免费，跨平台，具有GUI，多种协议支持  </p><p>官网：<a href="https://www.wireshark.org/">https://www.wireshark.org/</a><br>官方文档: <a href="https://www.wireshark.org/docs/wsug_html_chunked/index.html">https://www.wireshark.org/docs/wsug_html_chunked/index.html</a>  </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>进入官网下载安装包安装即可，并无特殊操作<br>官网下载地址：<a href="https://www.wireshark.org/download.html">https://www.wireshark.org/download.html</a>  </p><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><p>此处会演示基本的抓包流程  </p><h2 id="选择网卡"><a href="#选择网卡" class="headerlink" title="选择网卡"></a>选择网卡</h2><p><strong>欢迎界面</strong><br><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/20210111090947056.png"><br>进入<code>Wireshark</code> 后，首先会来到选择网卡来的欢迎界面<br>此时需要你选择一个需要监听网卡即可来到主界面<br>你可以通过查看网卡名称或者观察其右方对应的流量数据图来识别网卡<br>在选择好一个网卡后，会来到主界面  </p><p><strong>主界面</strong><br><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/20210111092336029.png"><br>主界面主要由：菜单，主工具栏，过滤器工具栏，数据包列表窗口，数据包信息窗口，数据包字节信息窗口，状态栏 这些要素组成<br>可以对各个元素留个印象，后续会时不时提起  </p><h2 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h2><p><strong>开始抓包</strong><br><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/20210111101226917.png"><br>点击主工具栏的 鲨鱼图标 即可开始抓包  </p><p><strong>停止抓包</strong><br><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/20210111102024640.png"><br>在认为需要的包已经被抓到以后了，点击主工具栏的 停止图标 即可停止抓包  </p><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><p>在停止抓包后，数据包列表窗口会显示已经抓到的包<br>其数量一般都会很多，此时需要 编写过滤器 来获取需要的包<br><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/1.gif"><br>实际上，也可以先编写过滤器再进行抓包，二者顺序并不冲突<br>此处只是指定协议来过滤，更复杂的过滤器编写见后文  </p><p>过滤完毕后，就能找到需要的数据报文  </p><h2 id="对捕获结果进行分析"><a href="#对捕获结果进行分析" class="headerlink" title="对捕获结果进行分析"></a>对捕获结果进行分析</h2><h3 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h3><p><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/3.gif"><br>点击 数据包列表窗口 中的数据包，在窗口最左边会出现箭头和线段  </p><p><strong>线段</strong>：实线：代表着会话的各个阶段。虚线：代表着与当前会话无关的其它包<br><strong>线段上的圆点</strong>：代表连续的数据帧<br>对于连续的数据帧，在数据包信息窗口有一个栏位用于合并显示<br><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/20210112101806134.png"><br><strong>箭头</strong>：代表这是一个 <code>HTTP</code> 请求。向右指的箭头为请求，向左指的箭头为响应<br><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/2.gif"><br><strong>弯勾</strong>：<code>TCP</code>的请求数据包<br><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/20210112101414575.png">  </p><h2 id="保存抓包数据"><a href="#保存抓包数据" class="headerlink" title="保存抓包数据"></a>保存抓包数据</h2><p><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/20210111103641915.png"><br>网络环境复杂多变，可以将已经抓到的数据进行保存，以后再打开进行分析  </p><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><h2 id="辅助编写过滤器表达式对话框"><a href="#辅助编写过滤器表达式对话框" class="headerlink" title="辅助编写过滤器表达式对话框"></a>辅助编写过滤器表达式对话框</h2><p>在过滤器工具栏里，能直接编写过滤器<br>但对于新手而言，可能并不能直接过滤器，这时就要借助一些提示来编写<br><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/20210112103056510.png"><br>主菜单中点击 <code>分析</code>-<code>Display Filter Expression</code> 就能进入到 显示过滤器表达式对话框<br><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/20210112104606027.png"><br>使用这个辅助工具的主要思路：  </p><ol><li>搜索，选择一个协议（或者进一步指定字段）  </li><li>选择关系  </li><li>填入对应值  </li></ol><p>然后就能在下方获得对应的表达式了  </p><h2 id="显示过滤器对话框"><a href="#显示过滤器对话框" class="headerlink" title="显示过滤器对话框"></a>显示过滤器对话框</h2><p>此对话框用于管理已经编写好的过滤器，就像书签那样<br>毕竟大多数时候，过滤器内容都比较类似，若是只是差一点点，就没有完全重写编写的必要<br>将旧的过滤器稍微改写，或者导入已经写好的模板，就能很快速的编写出适应场景的过滤器<br><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/20210112105914533.png"><br>过滤器工具栏中的书签图标-<code>管理显示过滤器</code>即可打开该对话框<br>在打开过程中能看到一些已经在记录中的过滤器, 点击就能应用<br><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/20210112110717623.png"><br>这个过滤器管理也很简单，左边是过滤器名称，右边是过滤器表达式<br>左下角有 添加、删除、复制按钮 来帮助操作。使用上足够简单，无需多言<br>唯一需要记住的是，只有按OK才会保存操作  </p><h1 id="搜索数据包"><a href="#搜索数据包" class="headerlink" title="搜索数据包"></a>搜索数据包</h1><p>应用过滤器，会使得数据包不在 数据包列表窗口 显示。这也许你并不希望这样<br>如果希望在当前显示的数据包中找到目标数据包，并且不对过滤结果进行操作，那么就需要使用搜索功能<br>在 数据包列表窗口 按 <code>ctrl</code>+<code>F</code> 会弹出搜索框<br><img src="/Wireshark-%E6%8A%93%E5%8C%85-%E7%BD%91%E7%BB%9C%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/4.gif"><br>在搜索框的内容里填上过滤器表达式即可进行搜索<br>当然也可以进行其它方式的搜索  </p>]]></content>
    
    
    
    <tags>
      
      <tag>抓包</tag>
      
      <tag>Wireshark</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TLS指纹-JA3</title>
    <link href="/post/e877fad7/"/>
    <url>/post/e877fad7/</url>
    
    <content type="html"><![CDATA[<p>前置知识：<br><a href="https://evilrecluse.top/post/ff374aa2/">Https-TLS相关</a>  </p><p>在线测试JA3: <a href="https://ja3er.com/json">https://ja3er.com/json</a><br>github页：<a href="https://github.com/salesforce/ja3">https://github.com/salesforce/ja3</a><br>老外的指导：<a href="https://github.com/yolossn/JA3-Fingerprint-Introduction">https://github.com/yolossn/JA3-Fingerprint-Introduction</a>  </p><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>JA3</code>特征值是根据<code>TLS</code>的<code>Client Hello 报文</code>生成的，对于同一台主机对服务器的访问而言，这个值会保持一致<br>类似的，<code>JA3S</code>的特征值是根据<code>TLS</code>的<code>Server Hello 报文</code>生成的，对于同一台服务器对同一台主机的响应而言，这个值会保持一致  </p><p>应用的策略相对简单<br>服务器可以利用 <code>JA3</code>值 用来标识客户端<br>客户端可以利用 <code>JA3S</code>值 用来标识服务器  </p><p>利用同主机 <code>JA3</code>值 不变的特点来限制并发访问<br>利用同 服务器&amp;主机 <code>JA3S</code>值不变的特点，防止渗透/欺骗  </p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h2><p>打开<code>wireshark</code>，捕获数据包<br>访问 <a href="https://ja3er.com/json">在线测试JA3</a>，得到测试值  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;ja3_hash&quot;</span>:<span class="hljs-string">&quot;b32309a26951912be7dba376398abc3b&quot;</span>,<br>    <span class="hljs-attr">&quot;ja3&quot;</span>:<span class="hljs-string">&quot;771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,0-23-65281-10-11-35-16-5-13-18-51-45-43-27-21,29-23-24,0&quot;</span>, <br>    <span class="hljs-attr">&quot;User-Agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/87.0.4280.141 Safari/537.36&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里会拿到两个值 <code>JA3</code> 和 <code>JA3_Hash</code>  </p><h2 id="JA3-收集-Client-Hello-报文-特征信息"><a href="#JA3-收集-Client-Hello-报文-特征信息" class="headerlink" title="JA3 收集 Client Hello 报文 特征信息"></a>JA3 收集 <code>Client Hello 报文</code> 特征信息</h2><p>第一次握手中，客户端会发送<code>Client Hello 报文</code>  </p><p><img src="/TLS%E6%8C%87%E7%BA%B9-JA3/hello1.png"><br><code>JA3</code> 会收集 <code>Client Hello 报文</code>的以下字段的十进制字节值  </p><table><thead><tr><th>TLS版本</th><th>加密组件</th><th>扩展类型列表</th><th>支持组</th><th>椭圆曲线密码格式</th></tr></thead><tbody><tr><td>Version</td><td>CipherSuites</td><td>Type List of Extensions</td><td>Supported Group</td><td>Elliptic Curve Formats</td></tr></tbody></table><p>将这些值串联在一起。同一字段中的各值用<code>-</code>来分隔，不同字段用<code>,</code>来分隔<br>最终组合成 <code>JA3</code> 值：<br><code>771,4865-4866-4867-49195-49199-49196-49200-52393-52392-49171-49172-156-157-47-53,0-23-65281-10-11-35-16-5-13-18-51-45-43-27-21,29-23-24,0</code><br>与在测试网页上获取的信息一致  </p><h2 id="JA3S-MD5-Hash-32-收集-Server-Hello-报文-信息"><a href="#JA3S-MD5-Hash-32-收集-Server-Hello-报文-信息" class="headerlink" title="JA3S MD5-Hash-32 收集 Server Hello 报文 信息"></a>JA3S MD5-Hash-32 收集 <code>Server Hello 报文</code> 信息</h2><p>第二次握手中，客户端会发送<code>Server Hello 报文</code><br>和第一步类似<br><code>JA3</code> 会收集 <code>Server Hello 报文</code>的以下字段的十进制字节值  </p><table><thead><tr><th>TLS版本</th><th>加密组件</th><th>扩展类型列表</th></tr></thead><tbody><tr><td>TLSVersion</td><td>CipherSuites</td><td>Extensions</td></tr></tbody></table><p>也能算出类似的值<br>然后进行MD5计算即可  </p>]]></content>
    
    
    
    <tags>
      
      <tag>TLS</tag>
      
      <tag>指纹</tag>
      
      <tag>JA3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-zipfile-zip压缩文件相关操作</title>
    <link href="/post/9dec4d72/"/>
    <url>/post/9dec4d72/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>zipfile</code>是<code>Python</code>官方用于对zip压缩文件文件进行操作的库<br>这个模块提供了创建、读取、写入、添加及列出 <code>ZIP</code> 文件的工具  </p><p>由于是官方的库，所以你并不需要担心安装的事情（它本身就在环境中了）  </p><p>此模块目前不能处理分卷 <code>ZIP</code> 文件。它可以处理使用 <code>ZIP64</code> 扩展（超过 4 GB 的 <code>ZIP</code> 文件）的 <code>ZIP</code> 文件。它支持解密 <code>ZIP</code> 归档中的加密文件，但是目前不能创建一个加密的文件。解密非常慢，因为它是使用原生 <code>Python</code> 而不是 <code>C</code> 实现的  </p><p>官方文档: <a href="https://docs.python.org/zh-cn/3/library/zipfile.html#zipfile-objects">https://docs.python.org/zh-cn/3/library/zipfile.html#zipfile-objects</a>  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="基础-创建-关闭-zipfile-ZipFile-对象"><a href="#基础-创建-关闭-zipfile-ZipFile-对象" class="headerlink" title="基础-创建/关闭 zipfile.ZipFile 对象"></a>基础-创建/关闭 zipfile.ZipFile 对象</h2><p>使用<code>zipfile</code>库基本就是围绕着 <code>ZipFile</code> 类/对象 做各种各样的操作  </p><blockquote><p>例：生成一个空的压缩文件  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> zipfile<br><br><br>zip_f = zipfile.ZipFile(<br>    file=<span class="hljs-string">&#x27;folder/helloworld.zip&#x27;</span>,<br>    mode=<span class="hljs-string">&#x27;w&#x27;</span>,<br>    allowZip64=<span class="hljs-literal">False</span>,<br>    compression=zipfile.ZIP_DEFLATED,<br>    compresslevel=<span class="hljs-number">5</span>,<br>)<br>zip_f.close()<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>信息</th></tr></thead><tbody><tr><td>file</td><td>传入<code>str</code>时为<code>ZipFile</code>对象关闭后，文件保存的路径<br> 也可以传入<code>ByteIO</code>对象来承接保存的<code>zip</code>文件二进制内容</td></tr><tr><td>mode</td><td>操作模式, 和 open() 里的模式类似<br><code>r</code> 来读取一个存在的文件<br><code>w</code> 来截断并写入新的文件<br><code>a</code> 来添加到一个存在的文件<br><code>x</code> 来仅新建并写入新的文件, 如果 <code>file</code> 指向已经存在的文件,会报错</td></tr><tr><td>allowZip64</td><td>是否使用Zip64创建扩展的zip文件，默认为<code>True</code>。<br>如果指定为<code>False</code>, 且最总<code>zip</code>文件大于 4GB，那么文件处理会报错</td></tr><tr><td>compression</td><td>压缩方法 可填入 <code>ZIP_STORED</code>, <code>ZIP_DEFLATED</code>, <code>ZIP_BZIP2</code><br>如果不支持设定的模式可能会报错</td></tr><tr><td>compresslevel</td><td>压缩级别，默认根据压缩方法自动计算<br>可以填入一个 0~9之间的整数 来设置。传入的 数字越小，压缩速度越快，压缩率越低。 具体参考<a href="https://docs.python.org/zh-cn/3/library/zlib.html#zlib.compressobj">官方说明</a></td></tr></tbody></table><p>创建一个 <code>ZipFile</code> 对象并不会立刻在对应路径中创建文件<br>执行其 <code>close</code> 方法时才真正创建文件  </p><p>可以使用 <code>with</code> 来自动调用 <code>close</code>方法。使代码更加美观  </p><h2 id="写入压缩内容"><a href="#写入压缩内容" class="headerlink" title="写入压缩内容"></a>写入压缩内容</h2><p>实际上就是写入东西到 <code>ZipFile</code> 对象中<br><code>ZipFile</code> 有两个方法可以将内容写到压缩文件中</p><ul><li><code>write</code>方法 传入文件路径，用于将已经存在的文件写入</li><li><code>writestr</code>方法 直接写入新的内容</li></ul><blockquote><p>例：添加一些压缩内容  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> zipfile<br><br>folder_path = <span class="hljs-string">&#x27;example/0_Basic_usage_of_the_library/python_zipfile&#x27;</span><br><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">&#x27;&#123;&#125;/&#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(folder_path, <span class="hljs-string">&#x27;helloworld.zip&#x27;</span>), <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(<br>        <span class="hljs-comment"># 已经存在的文件的路径</span><br>        filename=<span class="hljs-string">&#x27;&#123;&#125;/example.txt&#x27;</span>.<span class="hljs-built_in">format</span>(folder_path),<br>        <span class="hljs-comment"># 压缩文件中的文件路径</span><br>        arcname=<span class="hljs-string">&#x27;a_folder/z.txt&#x27;</span>,<br>    )<br>    f.writestr(<br>        <span class="hljs-comment"># 压缩文件中的文件路径</span><br>        zinfo_or_arcname=<span class="hljs-string">&#x27;a.txt&#x27;</span>,<br>        <span class="hljs-comment"># 文件数据，可写入 str类型 或 byte类型 数据</span><br>        <span class="hljs-comment">#   如果传入str类型，默认会用 utf-8 进行编码写入</span><br>        data=<span class="hljs-string">&#x27;Hello&#x27;</span>,<br>    )<br></code></pre></td></tr></table></figure><h2 id="解压压缩文件"><a href="#解压压缩文件" class="headerlink" title="解压压缩文件"></a>解压压缩文件</h2><blockquote><p>例: 将压缩文件内容解压出来  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> zipfile<br><br>folder_path = <span class="hljs-string">&#x27;example/0_Basic_usage_of_the_library/python_zipfile&#x27;</span><br><span class="hljs-keyword">with</span> zipfile.ZipFile(<span class="hljs-string">&#x27;&#123;&#125;/helloworld.zip&#x27;</span>.<span class="hljs-built_in">format</span>(folder_path), <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> f.namelist():<br>        f.extract(file, <span class="hljs-string">&#x27;&#123;&#125;/unzip/&#x27;</span>.<span class="hljs-built_in">format</span>(folder_path))<br></code></pre></td></tr></table></figure><p><code>ZipFile.namelist()</code>返回列表，列表中的元素为压缩文件中的每个文件  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>zipfile</tag>
      
      <tag>zip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-Babel-API</title>
    <link href="/post/77d57432/"/>
    <url>/post/77d57432/</url>
    
    <content type="html"><![CDATA[<h1 id="API信息"><a href="#API信息" class="headerlink" title="API信息"></a>API信息</h1><p>這些記錄是我自行查閲文檔/源代碼，來進行編寫的<br>大多數都會編寫一個小例子來進行説明  </p><p>内容并不一定準確，要是發現有什麽問題，歡迎通過 <a href="https://github.com/RecluseXU">Github</a> 聯係我  </p><h1 id="babel-parse"><a href="#babel-parse" class="headerlink" title="@babel/parse"></a>@babel/parse</h1><h2 id="解析函数"><a href="#解析函数" class="headerlink" title="解析函数"></a>解析函数</h2><h3 id="babelParser-parse-code-options"><a href="#babelParser-parse-code-options" class="headerlink" title="babelParser.parse(code, [options])"></a>babelParser.parse(code, [options])</h3><p>将提供的代码作为一个完整的<code>ECMAScript</code>程序进行解析  </p><h3 id="babelParser-parseExpression-code-options"><a href="#babelParser-parseExpression-code-options" class="headerlink" title="babelParser.parseExpression(code, [options])"></a>babelParser.parseExpression(code, [options])</h3><p>用于解析单个<code>Expression</code>，性能比<code>parse()</code>要高  </p><h3 id="options-函数参数"><a href="#options-函数参数" class="headerlink" title="options 函数参数"></a>options 函数参数</h3><ul><li><p>allowImportExportEverywhere<br>默认情况下，<code>import</code> 和 <code>export</code> 声明语句只能出现在程序的最顶层<br>把这个设置为<code>true</code>，可以使得语句在任何地方都可以声明  </p></li><li><p>allowAwaitOutsideFunction<br>默认情况下，仅在 异步函数内部 或 启用<code>topLevelAwait插件</code>时 在模块的顶层内允许使用<code>await</code><br>把这个设置为<code>true</code>，可以使得语句在任何地方都可以声明  </p></li><li><p>allowReturnOutsideFunction<br>默认情况下，如果在顶层中使用<code>return</code>语句会引起错误<br>把这个设置为<code>true</code>，就不会报错  </p></li><li><p>allowSuperOutsideMethod<br>默认情况下，在类和对象方法之外不允许使用<code>super</code><br>把这个设置为<code>true</code>就可以声明  </p></li><li><p>allowUndeclaredExports<br>默认情况下，<code>export</code>一个在当前作用域下未声明的内容会报错<br>把这个设置为<code>true</code>就可以防止解析器过早地抛出未声明的错误  </p></li><li><p>createParenthesizedExpressions<br>默认情况下，<code>parser</code>会在<code>expression</code>节点设置<code>extra.parenthesized</code><br>把这个设置为<code>true</code>，则会设置<code>ParenthesizedExpression</code>AST节点  </p></li><li><p>errorRecovery<br>默认情况下，如果<code>Babel</code>发现一些 不正常的代码 就会抛出错误<br>把这个设置为<code>true</code>，则会在保存解析错误的同时继续解析代码，错误的记录将被保存在 最终生成的AST的<code>errors</code>属性中<br>注意，那些严重的错误依然会终止解析  </p></li><li><p>plugins<br>记录希望启动的插件的数组  </p></li><li><p>sourceType<br>代码的解析方式，你可以填入<code>&quot;script&quot;</code>（默认）,<code>&quot;module&quot;</code> 或 <code>&quot;unambiguous&quot;</code><br>如果设置为”unambiguous”，那么系统会根据ES6语法中的<code>imports</code>和<code>export</code>来判断是<code>&quot;module&quot;</code>还是<code>&quot;script&quot;</code>  </p></li><li><p>sourceFilename<br>将输出的AST节点与其源文件名相关联<br>在你处理多个文件时，这个功能会很有用  </p></li><li><p>startLine<br>默认情况下，第一行代码就是<code>line 1</code>。你可以传入一个数字，作为起始行数<br>这个功能在你整合其他插件的时候会很有用  </p></li><li><p>strictMode<br>默认情况下，只有在声明了”use strict”条件下，ECMAScript代码才会被严格解析<br>将此选项设置为<code>true</code>则始终以严格模式解析文件  </p></li><li><p>ranges<br>添加ranges属性到每一个节点中  </p><blockquote><p>ranges: [node.start, node.end]  </p></blockquote></li><li><p>tokens<br>将所有已经解析的<code>tokens</code>保存到<code>File</code>节点的<code>tokens</code>属性中  </p></li></ul><h2 id="输出-Output"><a href="#输出-Output" class="headerlink" title="输出 Output"></a>输出 Output</h2><p><code>Babel parser</code>是根据 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md">Babel AST format</a> 创建AST的<br>而<code>Babel AST format</code>是基于 <a href="https://github.com/estree/estree">ESTree 规范</a> 建立的  </p><p><a href="https://github.com/estree/estree/blob/master/es5.md#literal">ESTree 代码生成对应节点文档</a><br><a href="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md#stringliteral">Babel parser 代码生成对应节点文档</a></p><blockquote><p><code>Babel parser</code>与<code>ESTree</code>的不同之处  </p><ul><li>用<a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#stringliteral"><code>StringLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#numericliteral"><code>NumericLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#booleanliteral"><code>BooleanLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#nullliteral"><code>NullLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#regexpliteral"><code>RegExpLiteral</code></a>取代<a href="https://github.com/estree/estree/blob/master/es5.md#literal"><code>Literal</code></a>  </li><li>用 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectproperty"><code>ObjectProperty</code></a> 和 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectmethod"><code>ObjectMethod</code></a>取代<a href="https://github.com/estree/estree/blob/master/es5.md#property"><code>Property</code></a>  </li><li>用<a href="https://github.com/estree/estree/blob/master/es2015.md#methoddefinition"><code>MethodDefinition</code></a>取代<a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#classmethod"><code>ClassMethod</code></a></li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#programs"><code>Program</code></a> and <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#blockstatement"><code>BlockStatement</code></a> 包含的<code>directives</code>用 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#directive"><code>Directive</code></a> 和 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#directiveliteral"><code>DirectiveLiteral</code></a>来填充  </li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#functionexpression"><code>FunctionExpression</code></a>中的 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#classmethod"><code>ClassMethod</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectproperty"><code>ObjectProperty</code></a>,<a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectmethod"><code>ObjectMethod</code></a>属性被引入到<code>main方法</code>节点中  </li></ul></blockquote><h1 id="babel-generator"><a href="#babel-generator" class="headerlink" title="@babel/generator"></a>@babel/generator</h1><p>官方文档：<a href="https://babeljs.io/docs/en/babel-generator">https://babeljs.io/docs/en/babel-generator</a>    </p><h2 id="generate-ast-options-code"><a href="#generate-ast-options-code" class="headerlink" title="generate(ast,  options,  code);"></a>generate(ast,  options,  code);</h2><p>函数用于根据ast生成代码，可以传入一些参数  </p><h3 id="options-参数"><a href="#options-参数" class="headerlink" title="options 参数"></a>options 参数</h3><table><thead><tr><th>name 参数名</th><th>type 类型</th><th>default 默认值</th><th>description 描述</th></tr></thead><tbody><tr><td>auxiliaryCommentAfter</td><td>string</td><td></td><td>Optional 在输出文件内容末尾添加的注释块文字</td></tr><tr><td>auxiliaryCommentBefore</td><td>string</td><td></td><td>Optional 在输出文件内容头部添加的注释块文字</td></tr><tr><td>comments</td><td>boolean</td><td><code>true</code></td><td>输出内容是否包含注释</td></tr><tr><td>compact</td><td>boolean or <code>&#39;auto&#39;</code></td><td><code>opts.minified</code></td><td>是否不添加空格来让代码看起来紧密</td></tr><tr><td>concise</td><td>boolean</td><td><code>false</code></td><td>是否减少空格来让代码看起来紧凑一些<br>只是减少空格，而不是不添加</td></tr><tr><td>decoratorsBeforeExport</td><td>boolean</td><td></td><td>是否在导出之前<code>print</code>一下装饰器</td></tr><tr><td>filename</td><td>string</td><td></td><td>Used in warning messages</td></tr><tr><td>jsescOption</td><td>object</td><td></td><td>Use <code>jsesc</code> to process literals. <code>jsesc</code> is applied to numbers only if <code>jsescOption.numbers</code> (added in <code>v7.9.0</code>) is present. You can customize <code>jsesc</code> by <a href="https://github.com/mathiasbynens/jsesc#api">passing options</a> to it.</td></tr><tr><td>jsonCompatibleStrings</td><td>boolean</td><td><code>false</code></td><td>Set to true to run <code>jsesc</code> with “json”: true to print “\u00A9” vs. “©”;</td></tr><tr><td>minified</td><td>boolean</td><td><code>false</code></td><td>Should the output be minified<br>是否压缩代码</td></tr><tr><td>retainFunctionParens</td><td>boolean</td><td><code>false</code></td><td>Retain parens around function expressions (could be used to change engine parsing behavior)</td></tr><tr><td>retainLines</td><td>boolean</td><td><code>false</code></td><td>尝试在输出代码中使用与源代码中相同的行号(用于追踪堆栈)</td></tr><tr><td>shouldPrintComment</td><td>function</td><td><code>opts.comments</code></td><td>Function that takes a comment (as a string) and returns <code>true</code> if the comment should be included in the output. <br>By default, comments are included if <code>opts.comments</code> is <code>true</code> or if <code>opts.minified</code> is <code>false</code> and the comment contains <code>@preserve</code> or <code>@license</code></td></tr></tbody></table><h1 id="babel-traverse"><a href="#babel-traverse" class="headerlink" title="@babel/traverse"></a>@babel/traverse</h1><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><h3 id="NodePath基础属性"><a href="#NodePath基础属性" class="headerlink" title="NodePath基础属性"></a>NodePath基础属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = [&#x27;a&#x27;, &#x27;b&#x27;];</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    BlockStatement(path)<br>    &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 源码:\n&#x27;</span>, path.toString());<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 节点:\n&#x27;</span>, path.node)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 父级节点:\n&#x27;</span>, path.parent);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 父级路径:\n&#x27;</span>, path.parentPath)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 类型:\n&#x27;</span>, path.type)<br><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 contexts:\n&#x27;</span>, path.contexts);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 hub:\n&#x27;</span>, path.hub);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 state:\n&#x27;</span>, path.state);<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 opts:\n&#x27;</span>, path.opts)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 skipKeys:\n&#x27;</span>, path.skipKeys)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 container:\n&#x27;</span>, path.container)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 key:\n&#x27;</span>, path.key)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 scope:\n&#x27;</span>, path.scope)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>你会发现其中有不少值都是没有定义的，这是因为很多值都是懒加载的<br>而且会给与专门的方法进行获取，并不是这样直接获取的  </p><h3 id="NodePath-inList"><a href="#NodePath-inList" class="headerlink" title="NodePath.inList()"></a>NodePath.inList()</h3><p><code>@return bool</code>  </p><p>是否在列表中/是否存在兄弟节点</p><p>一般只有那些能存放多个节点的节点才会将节点存放在列表中  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  var a = 1;</span><br><span class="hljs-string">  a += 2;</span><br><span class="hljs-string">  if(a + 1 == 4)&#123;return a-2&#125;</span><br><span class="hljs-string">  return a;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">Statement</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前节点：&#x27;</span>, path.toString())<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前语句&#x27;</span>, path.getStatementParent().toString())<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是否在列表中/是否存在兄弟节点&#x27;</span>, path.inList)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---------------------------------&#x27;</span>)<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><h2 id="replacement"><a href="#replacement" class="headerlink" title="replacement"></a>replacement</h2><p>替换相关  </p><h3 id="NodePath-replaceWith-replacement-Node"><a href="#NodePath-replaceWith-replacement-Node" class="headerlink" title="NodePath.replaceWith(replacement:Node)"></a>NodePath.replaceWith(replacement:Node)</h3><p>方法用于将传入的  <code>Node</code> 替换对应 <code>NodePath</code> 的 <code>Node</code>   </p><p>此方法只能用一个节点替换一个节点  </p><ul><li>如果不传入 <code>replacement</code>会提示：<code>NodePath.removed()</code>才是用来删除节点的方法  </li><li>如果传入数组会提示：<code>Path.replaceWithMultiple()</code> 才是一次性用多个节点替换目标节点的方法  </li><li>如果传入字符串会提示：<code>path.replaceWithSourceString()</code> 才是用源码替换目标节点的方法  </li><li>只能用 <code>Program</code>类型的节点替换 根节点<code>Program</code>  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<br><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  return n + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">BinaryExpression</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    path.replaceWith(<br>      t.BinaryExpression(<span class="hljs-string">&quot;**&quot;</span>, path.node.left, t.NumericLiteral(<span class="hljs-number">2</span>))<br>    );<br>    <span class="hljs-comment">// 由于是用 BinaryExpression 代替 BinaryExpression</span><br>    <span class="hljs-comment">// visitor会认为替换后的节点是新的节点，会传入，所以这里直接停止，防止递归进入</span><br>    path.stop();<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><h3 id="NodePath-replaceWithMultiple-nodes"><a href="#NodePath-replaceWithMultiple-nodes" class="headerlink" title="NodePath.replaceWithMultiple(nodes)"></a>NodePath.replaceWithMultiple(nodes)</h3><p>方法用于将传入的 多个 <code>Node</code> 替换对应 <code>NodePath</code> 的 <code>Node</code>  </p><p>此方法能用多个节点替换一个节点  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<br><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  return n + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-keyword">let</span> nodes = [<br>      t.expressionStatement(t.stringLiteral(<span class="hljs-string">&quot;who&quot;</span>)),<br>      t.expressionStatement(t.stringLiteral(<span class="hljs-string">&quot;I&quot;</span>)),<br>      t.expressionStatement(t.stringLiteral(<span class="hljs-string">&quot;am&quot;</span>)),<br>    ]<br>    path.replaceWithMultiple(nodes);<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><h3 id="NodePath-replaceWithSourceString-replacement-String"><a href="#NodePath-replaceWithSourceString-replacement-String" class="headerlink" title="NodePath.replaceWithSourceString(replacement:String)"></a>NodePath.replaceWithSourceString(replacement:String)</h3><p>此方法用 传入的源码字符串 解析成对应节点后 替换 对应<code>NodePath</code>的<code>Node</code>   </p><p>写入的内容解析成 <code>Node</code>后，必须为 <code>Expression</code>类型   </p><p>十分不方便，而且性能较差，不建议使用   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<br><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  return n + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    path.replaceWithSourceString(<span class="hljs-string">&#x27;1 + 1&#x27;</span>);<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><h3 id="NodePath-replaceInline-nodes"><a href="#NodePath-replaceInline-nodes" class="headerlink" title="NodePath.replaceInline(nodes)"></a>NodePath.replaceInline(nodes)</h3><p>用于用传入的一个或多个<code>Node</code>替换对应 Node  </p><p>此函数视传入的内容去调用 <code>NodePath.replaceWithMultiple()</code> 或 <code>NodePath.replaceWith()</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<br><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(js_env + <span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  return 1 + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">BinaryExpression</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">eval</span>(path.toString())  <span class="hljs-comment">// 计算表达式结果</span><br>    <span class="hljs-keyword">var</span> node = t.NumericLiteral(result)  <span class="hljs-comment">// 使用 types 来生成一个数字节点</span><br>    path.replaceInline(node);   <span class="hljs-comment">// 用新的节点来替换表达式内容</span><br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><h2 id="ancestry"><a href="#ancestry" class="headerlink" title="ancestry"></a>ancestry</h2><p>父级/祖先相关  </p><p><a id="path_findParent"></a></p><h3 id="NodePath-findParent-callback"><a href="#NodePath-findParent-callback" class="headerlink" title="NodePath.findParent(callback)"></a>NodePath.findParent(callback)</h3><p><code>@return NodePath | None</code><br>逐级递归寻找父级节点的Path，并将<code>Path</code>作为参数传入的判断函数进行判断<br>当判断函数返回<code>true</code>, 则<code>Path.findParent(callback)</code>返回对应<code>Path</code><br>当判断函数返回<code>false</code>, 则递归继续寻找父级, 进行判断。若已无父级，则返回<code>null</code>  </p><blockquote><p>例: 寻找当前Path的父级函数节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br>        <br>        <span class="hljs-comment">// 寻找父级</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">to_parent_function_path</span>(<span class="hljs-params">x</span>)</span>&#123;  <span class="hljs-comment">// 进行判断是否是函数声明节点的判断函数</span><br>            <span class="hljs-keyword">if</span>(x.isFunctionDeclaration())&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>        &#125;<br>        <span class="hljs-comment">//      将判断函数传入，进行递归寻找父级path</span><br>        the_path = path.findParent(to_parent_function_path)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;to_parent_function_path 最终路径源码:\n&#x27;</span>, the_path.toString())<br><br>        <span class="hljs-comment">//      递归后如果没有发现符合要求的父级</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">to_null</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>        the_path = path.findParent(to_null)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;to_null 最终路径:\n&#x27;</span>, the_path)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到的输出结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> a = b + <span class="hljs-number">1</span><br>to_parent_function_path 最终路径源码:<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">123</span>;<br>  a = b + <span class="hljs-number">1</span>;<br>&#125;<br>to_null 最终路径:<br> <span class="hljs-literal">null</span><br></code></pre></td></tr></table></figure><h3 id="NodePath-find-callback"><a href="#NodePath-find-callback" class="headerlink" title="NodePath.find(callback)"></a>NodePath.find(callback)</h3><p><code>@return NodePath | None</code><br>此函数与 <code>Path.findParent</code> 基本相同, 但这个判断包含对 当前Path 的判断<br>它会先对 当前Path 进行一次判断. 如果自身符合条件，那就返回 当前Path，然后才递归调用父级进行判断  </p><blockquote><p>例子：当前或父级Path  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br>        <br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">to_path</span>(<span class="hljs-params">x</span>)</span>&#123;  <br>            <span class="hljs-keyword">if</span>(x.isAssignmentExpression())&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>        &#125;<br>        the_path = path.find(to_path)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;to_path最终路径源码:\n&#x27;</span>, the_path.toString())<br><br>        <span class="hljs-comment">// 寻找父级</span><br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">to_parent_function_path</span>(<span class="hljs-params">x</span>)</span>&#123;  <span class="hljs-comment">// 进行判断是否是函数声明节点的判断函数</span><br>            <span class="hljs-keyword">if</span>(x.isFunctionDeclaration())&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">else</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<br>        &#125;<br>        the_path = path.find(to_parent_function_path)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;to_parent_function_path最终路径源码:\n&#x27;</span>, the_path.toString())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到的输出结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> a = b + <span class="hljs-number">1</span><br>to_path最终路径源码:<br> a = b + <span class="hljs-number">1</span><br>to_parent_function_path最终路径源码:<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">123</span>;<br>  a = b + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NodePath-getFunctionParent"><a href="#NodePath-getFunctionParent" class="headerlink" title="NodePath.getFunctionParent()"></a>NodePath.getFunctionParent()</h3><p><code>@return NodePath | None</code><br>得到当前节点的第一个 父级/祖先 函数声明节点的Path  </p><p>此方法通过调用 <a href="#path_findParent"><code>Path.findParent(callback)</code></a> 传入内置的判断函数，来得到对应的结果  </p><blockquote><p>例: 寻找 父级/祖先 函数声明节点的Path  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br><br>        the_path = path.getFunctionParent()<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;最终路径源码:\n&#x27;</span>, the_path.toString())<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到对应结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> a = b + <span class="hljs-number">1</span><br>最终路径源码:<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">123</span>;<br>  a = b + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NodePath-getStatementParent"><a href="#NodePath-getStatementParent" class="headerlink" title="NodePath.getStatementParent()"></a>NodePath.getStatementParent()</h3><p><code>@return NodePath</code><br>返回第一个 父级/祖先 声明节点的<code>NodePath</code><br>(向上遍历语法树，直到找到在列表中的父/祖先节点<code>NodePath</code> )  </p><p>声明节点所包含的节点类型见：<a href="https://github.com/babel/babylon/blob/master/ast/spec.md#blockstatement">Github文档</a><br>若找不到目标，会报错  </p><blockquote><p>例：返回第一个 父级/祖先 声明节点的 Path  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f2()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    return b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">Identifier</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br>        the_path = path.getStatementParent()<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;最终路径源码:\n&#x27;</span>, the_path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;------------------------------------&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到的结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> f2<br>最终路径源码:<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">123</span>;<br>  <span class="hljs-keyword">return</span> b + <span class="hljs-number">1</span>;<br>&#125;<br>------------------------------------<br>当前路径源码:<br> b<br>最终路径源码:<br> <span class="hljs-keyword">var</span> b = <span class="hljs-number">123</span>;<br>------------------------------------<br>当前路径源码:<br> b<br>最终路径源码:<br> <span class="hljs-keyword">return</span> b + <span class="hljs-number">1</span>;<br>------------------------------------<br></code></pre></td></tr></table></figure><h3 id="NodePath-getAncestry"><a href="#NodePath-getAncestry" class="headerlink" title="NodePath.getAncestry()"></a>NodePath.getAncestry()</h3><p><code>@return Array</code><br>返回所有 父级/祖先 的Path  </p><blockquote><p>例：得到当前Path的所有 父级/祖先 的Path  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f2()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br>        the_paths = path.getAncestry()<br><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;返回类型:\n&#x27;</span>, the_paths <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;结果路径源码:\n&#x27;</span>, the_paths.join(<span class="hljs-string">&#x27;\n\n&#x27;</span>))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>输出结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> a = b + <span class="hljs-number">1</span><br>返回类型:<br> <span class="hljs-literal">true</span><br>结果路径源码:<br> a = b + <span class="hljs-number">1</span><br><br>a = b + <span class="hljs-number">1</span>;<br><br>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">123</span>;<br>  a = b + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">123</span>;<br>  a = b + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">123</span>;<br>  a = b + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a id="path_isdescendant"></a>  </p><h3 id="NodePath-isDescendant-path"><a href="#NodePath-isDescendant-path" class="headerlink" title="NodePath.isDescendant(path)"></a>NodePath.isDescendant(path)</h3><p><code>@return bool</code><br>判断当前 Path 是否是指定 Path 的后代  </p><p>此方法通过调用 <a href="#path_findParent"><code>Path.findParent()</code></a> 来进行判断，得到结果  </p><blockquote><p>例:辈分判断  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f2()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;儿子是爸爸的后代：&#x27;</span>, path.isDescendant(path.parentPath))<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;儿子是爷爷的后代：&#x27;</span>, path.isDescendant(path.parentPath.parentPath))<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;儿子是孙子的后代：&#x27;</span>, path.isDescendant(path.get(<span class="hljs-string">&#x27;left&#x27;</span>)))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>输出结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> a = b + <span class="hljs-number">1</span><br>儿子是爸爸的后代： <span class="hljs-literal">true</span><br>儿子是爷爷的后代： <span class="hljs-literal">true</span><br>儿子是孙子的后代： <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h3 id="NodePath-isAncestor-path"><a href="#NodePath-isAncestor-path" class="headerlink" title="NodePath.isAncestor(path)"></a>NodePath.isAncestor(path)</h3><p><code>@return bool</code><br>判断当前 Path 是否是指定 Path 的后代  </p><p>此方法是调用 传入的path的<a href="#path_isdescendant"><code>Path.isDescendant()</code></a> 来进行判断的  </p><blockquote><p>例：判断是否是后代  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f2()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;儿子是爸爸的祖先：&#x27;</span>, path.isAncestor(path.parentPath))<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;儿子是爷爷的祖先：&#x27;</span>, path.isAncestor(path.parentPath.parentPath))<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;儿子是孙子的祖先：&#x27;</span>, path.isAncestor(path.get(<span class="hljs-string">&#x27;left&#x27;</span>)))<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到结果:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> a = b + <span class="hljs-number">1</span><br>儿子是爸爸的祖先： <span class="hljs-literal">false</span><br>儿子是爷爷的祖先： <span class="hljs-literal">false</span><br>儿子是孙子的祖先： <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="NodePath-inType-NodeType-str"><a href="#NodePath-inType-NodeType-str" class="headerlink" title="NodePath.inType(**NodeType_str)"></a>NodePath.inType(**NodeType_str)</h3><p><code>@return bool</code><br>判断当前<code>Path</code>对应节点，或其 父/祖先 节点 是否包含特定类型的节点<br>可以一次性传入多个类型，只要有一个符合就会返回 <code>true</code>, 否则返回 <code>false</code>  </p><blockquote><p>例: 是否包含特定类型的节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f2()&#123;</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">AssignmentExpression</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码:\n&#x27;</span>, path.toString());<br>        _is = path.inType(<span class="hljs-string">&#x27;FunctionDeclaration&#x27;</span>)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;父级或自身包含函数声明节点：&#x27;</span>, _is);<br>        _is = path.inType(<span class="hljs-string">&#x27;WithStatement&#x27;</span>, <span class="hljs-string">&#x27;DebuggerStatement&#x27;</span>)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;父级或自身包含 with 或 debugger：&#x27;</span>, path.inType(_is));<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>输出的结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前路径源码:<br> a = b + <span class="hljs-number">1</span><br>父级或自身包含函数声明节点： <span class="hljs-literal">true</span><br>父级或自身包含 <span class="hljs-keyword">with</span> 或 <span class="hljs-keyword">debugger</span>： <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><a id="traverse_getDeepestCommonAncestorFrom"></a></p><h3 id="NodePath-getDeepestCommonAncestorFrom-paths-filter"><a href="#NodePath-getDeepestCommonAncestorFrom-paths-filter" class="headerlink" title="NodePath.getDeepestCommonAncestorFrom(paths, filter)"></a>NodePath.getDeepestCommonAncestorFrom(paths, filter)</h3><p><code>@return NodePath | 自定义</code><br>获取传入的<code>Path</code>对应节点的 最大深度共同祖先节点的<code>Path</code>  </p><ul><li>当 <code>paths</code>不存在<code>length</code>属性时，报错  </li><li>当 <code>paths</code> 长度为0时，返回 <code>null</code>  </li><li>当 <code>paths</code> 长度为1时，返回唯一的<code>Path</code>  </li><li>当 <code>paths</code> 大于1  <ul><li>计算 最大深度共同祖先节点 的<code>Path</code>并返回  </li><li>当传入一个<code>filter</code>函数，那么返回结果会作为参数进行回调。返回结果变为<code>filter(最大深度共同祖先节点Path:NodePath, 深度:int, 所有path的祖先信息:list);</code>  </li></ul></li><li>如果并不存在共同的祖先节点，报错  </li></ul><blockquote><p>例：最大深度的共同祖先节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f()&#123;</span><br><span class="hljs-string">    function f3()&#123;</span><br><span class="hljs-string">        function f1()&#123;return 1;&#125;</span><br><span class="hljs-string">        function f2()&#123;return 2;&#125;</span><br><span class="hljs-string">        return 3;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;`</span>;<br><br><br><span class="hljs-keyword">let</span> paths = []<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;路径源码:\n&#x27;</span>, path.toString());<br>        paths.push(path)<br>        <span class="hljs-keyword">if</span> (paths.length &gt; <span class="hljs-number">1</span>)&#123;<br>            _is = path.getDeepestCommonAncestorFrom(paths)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;最大深度的共同祖先节点 源代码：&#x27;</span>, _is.toString());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript">路径源码:<br> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>路径源码:<br> <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>最大深度的共同祖先节点 源代码： &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br>路径源码:<br> <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>最大深度的共同祖先节点 源代码： &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="NodePath-getEarliestCommonAncestorFrom-paths"><a href="#NodePath-getEarliestCommonAncestorFrom-paths" class="headerlink" title="NodePath.getEarliestCommonAncestorFrom(paths)"></a>NodePath.getEarliestCommonAncestorFrom(paths)</h3><p><code>@return NodePath</code><br>获取<code>paths</code>中最早出现的共同祖先<br>方法会遍历计算，共同祖先一旦出现, 则返回，不再继续计算所有的path  </p><p>此方法是调用 <a href="#traverse_getDeepestCommonAncestorFrom">getDeepestCommonAncestorFrom(paths, filter)</a> 方法，传入固定的<code>filter</code>函数来实现    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function f()&#123;</span><br><span class="hljs-string">    function f3()&#123;</span><br><span class="hljs-string">        function f1()&#123;return 1;&#125;</span><br><span class="hljs-string">        function f2()&#123;return 2;&#125;</span><br><span class="hljs-string">        return 3;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;`</span>;<br><br><br><span class="hljs-keyword">let</span> paths = []<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;路径源码:\n&#x27;</span>, path.toString());<br>        paths.push(path)<br>        <span class="hljs-keyword">if</span> (paths.length &gt; <span class="hljs-number">1</span>)&#123;<br>            _is = path.getEarliestCommonAncestorFrom(paths)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;最早的共同祖先节点 源代码：&#x27;</span>, _is.toString());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><h2 id="family"><a href="#family" class="headerlink" title="family"></a>family</h2><p>主要用于获取同级/前后 <code>NodePath</code>  </p><p><a id="NodePathgetSibling"></a></p><h3 id="NodePath-getSibling-key"><a href="#NodePath-getSibling-key" class="headerlink" title="NodePath.getSibling(key)"></a>NodePath.getSibling(key)</h3><p><code>@return NodePath</code>  </p><p>通过父级，获取同级节点的 <code>NodePath</code> 或 其它内容  </p><ul><li><p>如果传入数字，则尝试获取 同级节点 指定位置的 <code>NodePath</code>  </p></li><li><p>如果传入数字，则尝试获取 父级节点 指定位置的 <code>NodePath</code>  </p></li><li><p>也可以传入一些特殊的key, 获取一些特殊的内容。</p><p>可以使用 <code>NodePath.listKey</code>属性 查看可以获取的key  </p></li></ul><blockquote><p>例: 寻找其它内容  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function x()&#123;</span><br><span class="hljs-string">  console.log(&#x27;code 1&#x27;);</span><br><span class="hljs-string">  console.log(&#x27;code 2&#x27;);</span><br><span class="hljs-string">  var a = 1;</span><br><span class="hljs-string">  console.log(&#x27;code 3&#x27;);</span><br><span class="hljs-string">  console.log(&#x27;code 4&#x27;);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前节点源码:\n&#x27;</span>, path.toString());<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---------------------------------------------&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第1个兄弟的源码&#x27;</span>, path.getSibling(<span class="hljs-number">0</span>).toString());<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第2个兄弟的源码&#x27;</span>, path.getSibling(<span class="hljs-number">1</span>).toString());<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第3个兄弟的源码&#x27;</span>, path.getSibling(<span class="hljs-number">2</span>).toString());<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第4个兄弟的源码&#x27;</span>, path.getSibling(<span class="hljs-number">3</span>).toString());<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;第5个兄弟的源码&#x27;</span>, path.getSibling(<span class="hljs-number">4</span>).toString());<br>    <span class="hljs-built_in">console</span>.log(path.listKey)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---------------------------------------------&#x27;</span>);<br>  &#125;<br>&#125;<br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到的结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前节点源码:<br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>---------------------------------------------<br>第<span class="hljs-number">1</span>个兄弟的源码 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;code 1&#x27;</span>);<br>第<span class="hljs-number">2</span>个兄弟的源码 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;code 2&#x27;</span>);<br>第<span class="hljs-number">3</span>个兄弟的源码 <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>第<span class="hljs-number">4</span>个兄弟的源码 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;code 3&#x27;</span>);<br>第<span class="hljs-number">5</span>个兄弟的源码 <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;code 4&#x27;</span>);<br>body<br>---------------------------------------------<br></code></pre></td></tr></table></figure><h3 id="NodePath-getOpposite"><a href="#NodePath-getOpposite" class="headerlink" title="NodePath.getOpposite()"></a>NodePath.getOpposite()</h3><p><code>@return Node</code>  </p><p>获取相对的对位节点 (left 与 right)  </p><p>此函数通过调用 <a href="#NodePathgetSibling"><code>NodePath.getSibling(key)</code></a> , 传入 当前节点的 <code>left</code> 或 <code>right</code> <code>key</code>实现  </p><blockquote><p>例：获取对位节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">  var a = 1 + 9;</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">NumericLiteral</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前节点源码:\n&#x27;</span>, path.toString())<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;对应节点源码:\n&#x27;</span>, path.getOpposite().toString())<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;----------------&#x27;</span>)<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前节点源码:<br> <span class="hljs-number">1</span><br>对应节点源码:<br> <span class="hljs-number">9</span><br>----------------<br>当前节点源码:<br> <span class="hljs-number">9</span><br>对应节点源码:<br> <span class="hljs-number">1</span><br>----------------<br></code></pre></td></tr></table></figure><h3 id="NodePath-getPrevSibling"><a href="#NodePath-getPrevSibling" class="headerlink" title="NodePath.getPrevSibling()"></a>NodePath.getPrevSibling()</h3><p><code>@return Node</code>  </p><p>获取同级前一个节点的 <code>NodePath</code></p><p>此函数源码就一句  <code>return this.getSibling(this.key - 1);</code>   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(js_env + <span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(js_env + <span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string"> var a = 1 + 9;</span><br><span class="hljs-string"> a = a + a;</span><br><span class="hljs-string"> console.log(a);</span><br><span class="hljs-string"> console.log(b);</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br> <span class="hljs-function"><span class="hljs-title">ExpressionStatement</span>(<span class="hljs-params">path</span>)</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前节点源码:\n&#x27;</span>, path.toString())<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;同级前一个节点源码:\n&#x27;</span>, path.getPrevSibling().toString())<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;----------------&#x27;</span>)<br> &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到结果:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">当前节点源码:<br> a = a + a;<br>同级前一个节点源码:<br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">9</span>;<br>----------------<br>当前节点源码:<br> console.log(a);<br>同级前一个节点源码:<br> a = a + a;<br>----------------<br>当前节点源码:<br> console.log(b);<br>同级前一个节点源码:<br> console.log(a);<br>----------------<br></code></pre></td></tr></table></figure><h3 id="NodePath-getNextSibling"><a href="#NodePath-getNextSibling" class="headerlink" title="NodePath.getNextSibling()"></a>NodePath.getNextSibling()</h3><p><code>@return Node</code>  </p><p>获取同级后一个节点的 <code>NodePath</code></p><p>此函数源码就一句 <code>return this.getSibling(this.key + 1);</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">  var a = 1 + 9;</span><br><span class="hljs-string">  a = a + a;</span><br><span class="hljs-string">  console.log(a);</span><br><span class="hljs-string">  console.log(b);</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">ExpressionStatement</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前节点源码:\n&#x27;</span>, path.toString())<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;同级后一个节点源码:\n&#x27;</span>, path.getNextSibling().toString())<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;----------------&#x27;</span>)<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>输出结果:    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前节点源码:<br> a = a + a;<br>同级前一个节点源码:<br> <span class="hljs-built_in">console</span>.log(a);<br>----------------<br>当前节点源码:<br> <span class="hljs-built_in">console</span>.log(a);<br>同级前一个节点源码:<br> <span class="hljs-built_in">console</span>.log(b);<br>----------------<br>当前节点源码:<br> <span class="hljs-built_in">console</span>.log(b);<br>同级前一个节点源码:<br> <br>----------------<br></code></pre></td></tr></table></figure><h3 id="NodePath-getAllPrevSiblings"><a href="#NodePath-getAllPrevSiblings" class="headerlink" title="NodePath.getAllPrevSiblings()"></a>NodePath.getAllPrevSiblings()</h3><p><code>@return Array</code>  </p><p>获取当前节点前的兄弟节点的 <code>NodePath</code>，结果存放在一个数组中返回  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">  var a = 1 + 9;</span><br><span class="hljs-string">  a = a + a;</span><br><span class="hljs-string">  console.log(a);</span><br><span class="hljs-string">  console.log(b);</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">ExpressionStatement</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前节点源码:\n&#x27;</span>, path.toString())<br>    <span class="hljs-keyword">const</span> pre_nodepath = path.getAllPrevSiblings()<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;前面的兄弟节点源码:&#x27;</span>)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> nodepath <span class="hljs-keyword">of</span> pre_nodepath)&#123;<br>      <span class="hljs-built_in">console</span>.log(nodepath.toString())<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;----------------&#x27;</span>)<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>输出结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript">当前节点源码:<br> a = a + a;<br>前面的兄弟节点源码:<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">9</span>;<br>----------------<br>当前节点源码:<br> <span class="hljs-built_in">console</span>.log(a);<br>前面的兄弟节点源码:<br>a = a + a;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">9</span>;<br>----------------<br>当前节点源码:<br> <span class="hljs-built_in">console</span>.log(b);<br>前面的兄弟节点源码:<br><span class="hljs-built_in">console</span>.log(a);<br>a = a + a;<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">9</span>;<br>----------------<br></code></pre></td></tr></table></figure><h3 id="NodePath-get-key-context"><a href="#NodePath-get-key-context" class="headerlink" title="NodePath.get(key, context)"></a>NodePath.get(key, context)</h3><p><code>@return NodePath</code></p><p>用于获取子孙节点</p><p>如果不传入 <code>context</code> 参数, 则以当前 <code>path</code> 对应节点为起点  </p><p>如果传入，则以传入的 <code>path</code> 对应节点为起点  </p><p>如果想要获取更多层级的子孙，可以用’.’隔开进行获取</p><ul><li><p>获取某个单个属性节点 <code>.名字</code></p></li><li><p>获取某个节点的第 x 个节点 <code>.x</code></p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  var a = 1;</span><br><span class="hljs-string">  return 1 + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">FunctionDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;  <span class="hljs-comment">// 找到变量声明节点，删除</span><br>      <span class="hljs-keyword">var</span> p1 = path.get(<span class="hljs-string">&#x27;body&#x27;</span>)<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;body 子节点源码:\n&#x27;</span>, p1.toString())<br>      <span class="hljs-keyword">var</span> p2 = path.get(<span class="hljs-string">&#x27;body.body.0&#x27;</span>)<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;body.body.0 子节点源码:\n&#x27;</span>, p2.toString())<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>输出结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">body 子节点源码:<br> &#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>&#125;<br>body.body<span class="hljs-number">.0</span> 子节点源码:<br> <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="NodePath-getBindingIdentifiers"><a href="#NodePath-getBindingIdentifiers" class="headerlink" title="NodePath.getBindingIdentifiers()"></a>NodePath.getBindingIdentifiers()</h3><p><code>@return dict(Node&#125;</code>  </p><p>用于获取当前 <code>NodePath</code> 所包含的 <code>Identifier</code> 节点  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  var a = 1;</span><br><span class="hljs-string">  a += 2;</span><br><span class="hljs-string">  return a;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">exit</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (t.isProgram(path))&#123;<span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前节点：&#x27;</span>, path.toString())<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前语句&#x27;</span>, path.getStatementParent().toString())<br>    <span class="hljs-keyword">let</span> _ids = path.getBindingIdentifiers()<br>    <span class="hljs-keyword">if</span>(_ids == <span class="hljs-literal">null</span>)&#123;<span class="hljs-keyword">return</span>;&#125;<br>    <span class="hljs-built_in">console</span>.log(_ids)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;--------------------------------&#x27;</span>)<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><h2 id="removal"><a href="#removal" class="headerlink" title="removal"></a>removal</h2><p>移除相关  </p><h3 id="NodePath-remove"><a href="#NodePath-remove" class="headerlink" title="NodePath.remove()"></a>NodePath.remove()</h3><p><code>@return null</code><br>删除路径对应的节点  </p><p>删除以后，对应的<code>removed</code>标识为会被设定，内容会被设定为只读<br>如果再次执行<code>remove</code>方法，则会报错  </p><blockquote><p>例：删除 path 对应的节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  var a = 1;</span><br><span class="hljs-string">  return 1 + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span>&#123;  <span class="hljs-comment">// 找到变量声明节点，删除</span><br>      path.remove()<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><p>得到结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h2><p>此模块与作用域相关  </p><h3 id="Scope"><a href="#Scope" class="headerlink" title="Scope"></a>Scope</h3><p>和 作用域 相关的内容被定义在了 Scope类 中<br>这个类定义位于 <code>@babel/traverse/lib/scope/index.js</code> 文件中  </p><h4 id="Scope属性"><a href="#Scope属性" class="headerlink" title="Scope属性"></a>Scope属性</h4><blockquote><p>例：输出一些属性，一般不会直接使用，但可以留个印象，后面的函数可能会使用属性    </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function squire(i)&#123;</span><br><span class="hljs-string">    return i * g * i;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">function i()</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    var i = 123;</span><br><span class="hljs-string">    i += 2;</span><br><span class="hljs-string">    return 123;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;--------------------------------&#x27;</span>)<br>        sc = path.scope  <span class="hljs-comment">// 获取对应的 Scope对象</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这个对象是否已经初始化：&#x27;</span>, sc.inited)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;uid 属性&#x27;</span>, sc.uid)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;cached 属性&#x27;</span>, sc.cached)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;node 属性&#x27;</span>, sc.node)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;作用域节点：&#x27;</span>, sc.block)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;作用对应的path：&#x27;</span>, sc.path.node == sc.block)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;labels 属性&#x27;</span>, sc.labels)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;绑定 的信息：&#x27;</span>, sc.bindings)<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;--------------------------------&#x27;</span>)<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>你能够直接访问<code>Scope</code>对象的属性，它本身也提供了一些方法来访问  </p><h4 id="Scope-parent"><a href="#Scope-parent" class="headerlink" title="Scope.parent"></a>Scope.parent</h4><p><code>@return Scope | undefined</code>  </p><p>获取当前作用域的父级作用域  </p><p>此方法通过引用其 <code>Scope.path</code> 属性的 <a href="#path_findParent"><code>PathNode.findParent()</code></a>方法 获取对应<code>PathNode</code>后再次获取作用域的方式获取  </p><blockquote><p>例：获取父级作用域</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function squire(i)&#123;</span><br><span class="hljs-string">    return i * g * i;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">function i()</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    var i = 123;</span><br><span class="hljs-string">    i += 2;</span><br><span class="hljs-string">    return 123;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;--------------------------------&#x27;</span>)<br>        sc = path.scope  <span class="hljs-comment">// 获取对应的 Scope对象</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parent结果：&#x27;</span>, sc.parent)<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><details>    <summary>结果</summary>       <pre><code>           这里是 var g = 1;    --------------------------------    parent结果： undefined    这里是 var i = 123;    --------------------------------    parent结果： Scope &#123;      uid: 0,      block: Node &#123;        type: 'Program',        start: 0,        end: 118,        loc: SourceLocation &#123; start: [Position], end: [Position] &#125;,        sourceType: 'script',        interpreter: null,        body: [ [Node], [Node], [Node] ],        directives: []      &#125;,      path: NodePath &#123;        parent: Node &#123;          type: 'File',          start: 0,          end: 118,          loc: [SourceLocation],          errors: [],          program: [Node],          comments: []        &#125;,        hub: undefined,        contexts: [ [TraversalContext] ],        data: null,        _traverseFlags: 0,        state: undefined,        opts: &#123; VariableDeclaration: [Object], _exploded: true, _verified: true &#125;,        skipKeys: null,        parentPath: null,        context: TraversalContext &#123;          queue: [Array],          parentPath: undefined,          scope: undefined,          state: undefined,          opts: [Object],          priorityQueue: []        &#125;,        container: Node &#123;          type: 'File',          start: 0,          end: 118,          loc: [SourceLocation],          errors: [],          program: [Node],          comments: []        &#125;,        listKey: undefined,        key: 'program',        node: Node &#123;          type: 'Program',          start: 0,          end: 118,          loc: [SourceLocation],          sourceType: 'script',          interpreter: null,          body: [Array],          directives: []        &#125;,        scope: [Circular],        type: 'Program'      &#125;,      labels: Map &#123;&#125;,      inited: true,      references: [Object: null prototype] &#123; g: true, i: true, squire: true &#125;,      bindings: [Object: null prototype] &#123;        g: Binding &#123;          identifier: [Node],          scope: [Circular],          path: [NodePath],          kind: 'var',          constantViolations: [],          constant: true,          referencePaths: [Array],          referenced: true,          references: 1,          hasDeoptedValue: false,          hasValue: false,          value: null        &#125;,        squire: Binding &#123;          identifier: [Node],          scope: [Circular],          path: [NodePath],          kind: 'hoisted',          constantViolations: [],          constant: true,          referencePaths: [],          referenced: false,          references: 0,          hasDeoptedValue: false,          hasValue: false,          value: null        &#125;,        i: Binding &#123;          identifier: [Node],          scope: [Circular],          path: [NodePath],          kind: 'hoisted',          constantViolations: [],          constant: true,          referencePaths: [],          referenced: false,          references: 0,          hasDeoptedValue: false,          hasValue: false,          value: null        &#125;      &#125;,      globals: [Object: null prototype] &#123;&#125;,      uids: [Object: null prototype] &#123;&#125;,      data: [Object: null prototype] &#123;&#125;,      crawling: false    &#125;    </code></pre> </details><h4 id="Scope-rename-oldName-newName-block"><a href="#Scope-rename-oldName-newName-block" class="headerlink" title="Scope.rename(oldName, newName, block)"></a>Scope.rename(oldName, newName, block)</h4><p>更改绑定名称，更改后会牵连所有引用的位置，留意是否会造成问题  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function a(n)&#123;</span><br><span class="hljs-string">    return n * n</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">FunctionDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;<br>        path.scope.rename(<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-string">&quot;_x_&quot;</span>);<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br><br></code></pre></td></tr></table></figure><p>得到结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">_x_</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> _x_ * _x_;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Scope-dump"><a href="#Scope-dump" class="headerlink" title="Scope.dump()"></a>Scope.dump()</h4><p><code>return null</code>  </p><p>输出到自底向上的 作用域与被绑定量的信息  </p><p>执行后会得到类似于这样的输出信息  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># FunctionDeclaration</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">i</span> &#123; <span class="hljs-attr">constant:</span> <span class="hljs-literal">false</span>, <span class="hljs-attr">references:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">violations:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">kind:</span> <span class="hljs-string">&#x27;var&#x27;</span> &#125;<br><span class="hljs-comment"># Program</span><br> <span class="hljs-bullet">-</span> <span class="hljs-string">squire</span> &#123; <span class="hljs-attr">constant:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">references:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">violations:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">kind:</span> <span class="hljs-string">&#x27;hoisted&#x27;</span> &#125;<br> <span class="hljs-bullet">-</span> <span class="hljs-string">i</span> &#123; <span class="hljs-attr">constant:</span> <span class="hljs-literal">true</span>, <span class="hljs-attr">references:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">violations:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">kind:</span> <span class="hljs-string">&#x27;hoisted&#x27;</span> &#125;<br></code></pre></td></tr></table></figure><p>作用域 以<code>#</code>划分，此处有两个作用域 <code>FunctionDeclaration</code> 与 <code>Program</code>  </p><p>被绑定量 以最前方设置<code>-</code>来标识，一般显示其中的4种信息  </p><ul><li>constant<br> 量 在声明后，在作用域内是否为常量<br> 实际上对应对应量的 <a href="#Binding"><code>Binding</code></a> 对象的<code>Binding.constant</code>属性  </li><li>references<br> 被引用次数<br> 实际上对应对应量的 <a href="#Binding"><code>Binding</code></a> 对象的<code>Binding.references</code>属性  </li><li>violations<br> 量 被 重新定义/赋值 的次数<br> 实际上对应对应量的 <a href="#Binding"><code>Binding</code></a> 对象的<code>Binding.constantViolations</code>的长度。这个属性被用于记录变更位置（每次变更都添加内容）  </li><li>kind<br> 函数声明类型。常见的有：<code>hoisted</code>提升，<code>var</code>变量， <code>local</code>内部<br> 实际上对应对应量的 <a href="#Binding"><code>Binding</code></a> 对象的<code>Binding.kind</code>属性  </li></ul><p>实际上这些信息大部分 （以一个被绑定量，一个  <a href="#Binding"><code>Binding</code></a> 对象的方式）储存在 <code>Scope.bindings</code> 这个属性中  </p><blockquote><p>例：使用案例  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function squire(i)&#123;</span><br><span class="hljs-string">    return i * i * i;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">function i()&#123;</span><br><span class="hljs-string">    var i = 123;</span><br><span class="hljs-string">    i += 2;</span><br><span class="hljs-string">    return 123;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-string">&quot;FunctionDeclaration&quot;</span>(path)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n\n这里是函数 &quot;</span>, path.node.id.name + <span class="hljs-string">&#x27;()&#x27;</span>)<br>        path.scope.dump();<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到结果：  </p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">这里是函数  squire()<br>------------------------------------------------------------<br># FunctionDeclaration<br><span class="hljs-code"> - i &#123; constant: true, references: 3, violations: 0, kind: &#x27;param&#x27; &#125;</span><br># Program<br><span class="hljs-code"> - squire &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br><span class="hljs-code"> - i &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br>------------------------------------------------------------<br><br><br>这里是函数  i()<br>------------------------------------------------------------<br># FunctionDeclaration<br><span class="hljs-code"> - i &#123; constant: false, references: 0, violations: 1, kind: &#x27;var&#x27; &#125;</span><br># Program<br><span class="hljs-code"> - squire &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br><span class="hljs-code"> - i &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br>------------------------------------------------------------<br></code></pre></td></tr></table></figure><h4 id="Scope-parentBlock-name"><a href="#Scope-parentBlock-name" class="headerlink" title="Scope.parentBlock(name)"></a>Scope.parentBlock(name)</h4><p><code>@return Node</code>  </p><p>获取 作用域路径 的父级<br>它的源码就一句 <code>return this.path.parent;</code>    </p><blockquote><p>例: 获取作用域路径的父级  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function a()&#123;return g;&#125;</span><br><span class="hljs-string">function b()&#123;var z=2; return z;&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> n = path.node.argument.name<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;结果：&#x27;</span>, path.scope.parentBlock)<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><details>    <summary>结果</summary>       <pre><code>           这里是 return g;    结果： Node &#123;      type: 'Program',      start: 0,      end: 69,      loc: SourceLocation &#123;        start: Position &#123; line: 1, column: 0 &#125;,        end: Position &#123; line: 5, column: 0 &#125;      &#125;,      sourceType: 'script',      interpreter: null,      body: [        Node &#123;          type: 'VariableDeclaration',          start: 1,          end: 11,          loc: [SourceLocation],          declarations: [Array],          kind: 'var'        &#125;,        Node &#123;          type: 'FunctionDeclaration',          start: 12,          end: 35,          loc: [SourceLocation],          id: [Node],          generator: false,          async: false,          params: [],          body: [Node]        &#125;,        Node &#123;          type: 'FunctionDeclaration',          start: 36,          end: 68,          loc: [SourceLocation],          id: [Node],          generator: false,          async: false,          params: [],          body: [Node]        &#125;      ],      directives: []    &#125;    这里是 return z;    结果： Node &#123;      type: 'Program',      start: 0,      end: 69,      loc: SourceLocation &#123;        start: Position &#123; line: 1, column: 0 &#125;,        end: Position &#123; line: 5, column: 0 &#125;      &#125;,      sourceType: 'script',      interpreter: null,      body: [        Node &#123;          type: 'VariableDeclaration',          start: 1,          end: 11,          loc: [SourceLocation],          declarations: [Array],          kind: 'var'        &#125;,        Node &#123;          type: 'FunctionDeclaration',          start: 12,          end: 35,          loc: [SourceLocation],          id: [Node],          generator: false,          async: false,          params: [],          body: [Node]        &#125;,        Node &#123;          type: 'FunctionDeclaration',          start: 36,          end: 68,          loc: [SourceLocation],          id: [Node],          generator: false,          async: false,          params: [],          body: [Node]        &#125;      ],      directives: []    &#125;    </code></pre> </details><p><a id="Scope_getBinding"></a></p><h4 id="Scope-getBinding-name"><a href="#Scope-getBinding-name" class="headerlink" title="Scope.getBinding(name)"></a>Scope.getBinding(name)</h4><p><code>@return Binding</code>  </p><p>获取指定 被绑定量 的 <a href="#Binding"><code>Binding</code></a>对象  </p><p>如果在 当前作用域 找不到指定的 被绑定量，那么就会递归在父级作用域中寻找  </p><blockquote><p>例：获取指定的 被绑定量对象  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function a()&#123;return g;&#125;</span><br><span class="hljs-string">function b()&#123;var z=2; return z;&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> n = path.node.argument.name<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被绑定量：&#x27;</span>, path.scope.getBinding(n))<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><h4 id="Scope-getOwnBinding-name"><a href="#Scope-getOwnBinding-name" class="headerlink" title="Scope.getOwnBinding(name)"></a>Scope.getOwnBinding(name)</h4><p><code>@return Binding</code>  </p><p>传入一个名称，从当前的 作用域 中拿到指定的 被绑定量对象<a href="#Binding"><code>Binding</code></a><br>实际上方法的源码就一句<code>return this.bindings[name];</code>    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function a()&#123;var a=1;return g;&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> n = path.node.argument.name<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;获取挡墙定义域里 a的Binding，结果：&#x27;</span>, path.scope.bindings[<span class="hljs-string">&#x27;a&#x27;</span>])<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><h4 id="Scope-getBindingIdentifier-name"><a href="#Scope-getBindingIdentifier-name" class="headerlink" title="Scope.getBindingIdentifier(name)"></a>Scope.getBindingIdentifier(name)</h4><p><code>@return Node | void 0</code><br>获取指定的  <a href="#Binding"><code>Binding</code></a> 的定义节点<code>Node</code>  </p><p>方法作用域获取 <a href="#Binding"><code>Binding</code></a> ，再通过这个  <a href="#Binding"><code>Binding</code></a>  获取其定义的节点  </p><p>这个方法通过 <a href="#Scope_getBinding"><code>Scope.getBinding(name)</code></a> 方法获取 <a href="#Binding"><code>Binding</code></a>  ，所以会存在递归向上的情况  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function a()&#123;return g;&#125;</span><br><span class="hljs-string">function b()&#123;var z=2; return z;&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> n = path.node.argument.name<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(n, <span class="hljs-string">&#x27;的定义：&#x27;</span>, path.scope.getBindingIdentifier(n))<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><h4 id="Scope-getOwnBindingIdentifier-name"><a href="#Scope-getOwnBindingIdentifier-name" class="headerlink" title="Scope.getOwnBindingIdentifier(name)"></a>Scope.getOwnBindingIdentifier(name)</h4><p><code>@return Node|void 0</code><br>获取指定的 <a href="#Binding"><code>Binding</code></a> ，并通过这个  <a href="#Binding"><code>Binding</code></a>  获取其定义的节点<br>这个方法只关注 当前作用域，并不会去上级作用域中寻找    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function a()&#123;return g;&#125;</span><br><span class="hljs-string">function b()&#123;var z=2; return z;&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> n = path.node.argument.name<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(n, <span class="hljs-string">&#x27;的定义：&#x27;</span>, path.scope.getOwnBindingIdentifier(n))<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>得到结果:  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs less">这里是 <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">g</span>;<br><span class="hljs-selector-tag">g</span> 的定义： <span class="hljs-selector-tag">undefined</span><br><br>这里是 <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">z</span>;<br><span class="hljs-selector-tag">z</span> 的定义： <span class="hljs-selector-tag">Node</span> &#123;<br>  <span class="hljs-attribute">type</span>: <span class="hljs-string">&#x27;Identifier&#x27;</span>,<br>  <span class="hljs-attribute">start</span>: <span class="hljs-number">53</span>,<br>  <span class="hljs-attribute">end</span>: <span class="hljs-number">54</span>,<br>  <span class="hljs-attribute">loc</span>: SourceLocation &#123;<br>    <span class="hljs-attribute">start</span>: Position &#123; <span class="hljs-attribute">line</span>: <span class="hljs-number">4</span>, <span class="hljs-attribute">column</span>: <span class="hljs-number">17</span> &#125;,<br>    <span class="hljs-attribute">end</span>: Position &#123; <span class="hljs-attribute">line</span>: <span class="hljs-number">4</span>, <span class="hljs-attribute">column</span>: <span class="hljs-number">18</span> &#125;,<br>    <span class="hljs-attribute">identifierName</span>: <span class="hljs-string">&#x27;z&#x27;</span><br>  &#125;,<br>  <span class="hljs-attribute">name</span>: <span class="hljs-string">&#x27;z&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Scope-hasOwnBinding-name"><a href="#Scope-hasOwnBinding-name" class="headerlink" title="Scope.hasOwnBinding(name)"></a>Scope.hasOwnBinding(name)</h4><p><code>@return bool</code>  </p><p>获知当前作用域是否有某个 <a href="#Binding"><code>Binding</code></a>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function a()&#123;return g;&#125;</span><br><span class="hljs-string">function b()&#123;var z=2; return z;&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> n = path.node.argument.name<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前作用域有 绑定 z:&#x27;</span>, path.scope.hasOwnBinding(<span class="hljs-string">&#x27;z&#x27;</span>))<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前作用域有 绑定 g:&#x27;</span>, path.scope.hasOwnBinding(<span class="hljs-string">&#x27;g&#x27;</span>))<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><br></code></pre></td></tr></table></figure><p>得到结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">这里是 <span class="hljs-keyword">return</span> g;<br>当前作用域有 绑定 z: <span class="hljs-literal">false</span><br>当前作用域有 绑定 g: <span class="hljs-literal">false</span><br><br>这里是 <span class="hljs-keyword">return</span> z;<br>当前作用域有 绑定 z: <span class="hljs-literal">true</span><br>当前作用域有 绑定 g: <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>两个函数的作用域内都不会有g的绑定，因为它被绑定在更上级作用域中  </p><h4 id="Scope-hasBinding-name-noGlobals"><a href="#Scope-hasBinding-name-noGlobals" class="headerlink" title="Scope.hasBinding(name, noGlobals)"></a>Scope.hasBinding(name, noGlobals)</h4><p><code>@return bool</code><br>向上递归作用域，获知是否有某个被绑定变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var g = 1;</span><br><span class="hljs-string">function a()&#123;return g;&#125;</span><br><span class="hljs-string">function b()&#123;var z=2; return z;&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">ReturnStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n这里是&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;作用域有 被绑定变量 z:&#x27;</span>, path.scope.hasBinding(<span class="hljs-string">&#x27;z&#x27;</span>))<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;作用域有 被绑定变量 g:&#x27;</span>, path.scope.hasBinding(<span class="hljs-string">&#x27;g&#x27;</span>))<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p><a id="Binding"></a></p><h3 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h3><p><code>Binding</code> 对象用于存储 被绑定在作用域的量 的信息<br>你可以在 <code>@babel/traverse/lib/scope/binding.js</code> 查看到它的定义  </p><p><a id="Bindingattrs"></a></p><h4 id="Binding属性"><a href="#Binding属性" class="headerlink" title="Binding属性"></a>Binding属性</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function a()&#123;</span><br><span class="hljs-string">    var a = 1;</span><br><span class="hljs-string">    a = a + 1;</span><br><span class="hljs-string">    return a;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">function b()&#123;</span><br><span class="hljs-string">    var b = 1;</span><br><span class="hljs-string">    var c = 2;</span><br><span class="hljs-string">    b = b - c;</span><br><span class="hljs-string">    return b;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">BlockStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n此块节点源码：\n&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;----------------------------------------&#x27;</span>)<br>        <span class="hljs-keyword">var</span> bindings = path.scope.bindings<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;作用域内 被绑定量 数量：&#x27;</span>, <span class="hljs-built_in">Object</span>.keys(bindings).length)<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> binding_ <span class="hljs-keyword">in</span> bindings)&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;名字：&#x27;</span>, binding_)<br>            binding_ = bindings[binding_];<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;类型：&#x27;</span>, binding_.kind)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;定义：&#x27;</span>, binding_.identifier)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是否为常量：&#x27;</span>, binding_.constant)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被修改信息信息记录&#x27;</span>, binding_.constantViolations)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是否会被引用：&#x27;</span>, binding_.referenced)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被引用次数&#x27;</span>, binding_.references)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被引用信息NodePath记录&#x27;</span>, binding_.referencePaths)<br>        &#125;<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><br></code></pre></td></tr></table></figure><h2 id="comments"><a href="#comments" class="headerlink" title="comments"></a>comments</h2><p>注释相关  </p><h3 id="NodePath-addComment-type-content-line"><a href="#NodePath-addComment-type-content-line" class="headerlink" title="NodePath.addComment(type, content, line)"></a>NodePath.addComment(type, content, line)</h3><p><code>@return None</code>  </p><p>添加注释  </p><p>实际上只是调用<code>types.addComment</code> 的方法而已  </p><p>参数:  </p><ul><li><p><code>type</code> <code>str</code> 指定添加的注释方式，如果填入<code>&quot;leading&quot;</code>，则添加的注释会插入已有注释之前，否则在原有注释之后  </p></li><li><p><code>content</code> <code>str</code> 注释内容  </p></li><li><p><code>line</code> <code>bool</code> 插入行注释还是块注释  </p></li></ul><blockquote><p>例：插入注释  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">  var a = 1 + 9;</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">NumericLiteral</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前节点源码:\n&#x27;</span>, path.toString());<br>    path.addComment(<span class="hljs-string">&#x27;trailing&#x27;</span>, <span class="hljs-string">&quot;注释&quot;</span>, <span class="hljs-literal">false</span>);<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><h1 id="babel-types"><a href="#babel-types" class="headerlink" title="@babel/types"></a>@babel/types</h1><h2 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h2><p><a id='types_shallowEqual'></a></p><h3 id="Types-shallowEqual-actual-expected"><a href="#Types-shallowEqual-actual-expected" class="headerlink" title="Types.shallowEqual(actual, expected)"></a>Types.shallowEqual(actual, expected)</h3><p><code>@return bool</code>  </p><p>对比函数，<code>expected</code>传入一个字典进行 <code>key</code>, <code>value</code> 遍历  </p><p>获取 <code>actual</code>.<code>key</code> 的值与 <code>value</code> 进行对比  </p><p>如果有一个不一致，那么返回 <code>false</code>, 否则返回 <code>true</code>  </p><p>其定义在： <code>@babel/types/lib/validators/generated/index.js</code>  </p><blockquote><p>例：判断节点的name是否为<code>a</code>  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs j\avascript">const parser &#x3D; require(&quot;@babel&#x2F;parser&quot;);<br>const traverse &#x3D; require(&quot;@babel&#x2F;traverse&quot;).default;<br>const t &#x3D; require(&quot;@babel&#x2F;types&quot;);<br><br>const jscode &#x3D; &#39;var a&#x3D;1; var b&#x3D;1+1;&#39;;<br>let ast &#x3D; parser.parse(jscode);<br><br>const visitor &#x3D; &#123;<br>  enter(path)&#123;<br>    console.log(&#39;当前节点源码：&#39;, path.toString())<br>    console.log(&#39;其属性name为a:&#39;, t.shallowEqual(path.node, &#123;&#39;name&#39;:&#39;a&#39;&#125;))<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><h2 id="validators"><a href="#validators" class="headerlink" title="validators"></a>validators</h2><h3 id="Types-isNodeType-node-opts"><a href="#Types-isNodeType-node-opts" class="headerlink" title="Types.isNodeType(node, opts)"></a>Types.isNodeType(node, opts)</h3><p><code>@return bool</code>  </p><p>这并不是一个函数，这是一大堆由生成代码生成的函数，大约有290个</p><p>这些函数定义在 <code>@babel/types/lib/validators/generated/index.js</code></p><p>函数逻辑都是类似的  </p><ol><li><p>if( 没有node ) return <code>false</code>  </p></li><li><p>if(<code>node.type</code> == <code>声明类型</code>) return <code>false</code>  </p></li><li><p>else if( 没有opts ) return <code>true</code></p></li><li><p>else return <a href="#types_shallowEqual">types.shallowEqual(node, opts)</a></p></li></ol><blockquote><p>例: 判断节点是否符合判断  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">&#x27;var a=1;var b=1+1;&#x27;</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br> <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前节点源码：&#x27;</span>, path.toString())<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是 Identifier&#x27;</span>, t.isIdentifier(path.node))<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是 Identifier 且其属性name为a:&#x27;</span>, t.isIdentifier(path.node, &#123;<span class="hljs-string">&#x27;name&#x27;</span>:<span class="hljs-string">&#x27;a&#x27;</span>&#125;))<br> &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><hr><ul><li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-bindings">https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md#toc-bindings</a>  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>Babel</tag>
      
      <tag>API</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-aiofiles-异步文件操作</title>
    <link href="/post/246948e6/"/>
    <url>/post/246948e6/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>aiofiles</code> 是一个异步操作文件的库  </p><p>普通IO操作会阻塞程序。造成一些问题<br><code>aiofiles</code> 能通过将 IO操作 委派给单独的线程池来处理 来解决这个问题  </p><p>pypi链接: <a href="https://pypi.org/project/aiofiles/">https://pypi.org/project/aiofiles/</a>  </p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><code>aiofiles</code> 为文件操作提供 简但的 阻塞的 API  </li><li>支持缓冲读取  </li><li>支持 <code>async</code>/<code>await</code></li></ul><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install aiofiles<br></code></pre></td></tr></table></figure><h2 id="open"><a href="#open" class="headerlink" title="open()"></a>open()</h2><p>它的操作和原生的<code>open()</code>函数非常类似  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiofiles.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;filename&#x27;</span>, mode=<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    contents = <span class="hljs-keyword">await</span> f.read()<br>print(contents)<br></code></pre></td></tr></table></figure><p>在操作成功以后，返回的对象包含以下的方法可以使用  </p><ul><li>close</li><li>flush</li><li>isatty</li><li>read</li><li>readall</li><li>read1</li><li>readinto</li><li>readline</li><li>readlines</li><li>seek</li><li>seekable</li><li>tell</li><li>truncate</li><li>writable</li><li>write</li><li>writelines<br>如果操作并不成功，那么会抛出错误  </li></ul><h2 id="aiofiles-os"><a href="#aiofiles-os" class="headerlink" title="aiofiles.os"></a>aiofiles.os</h2><p><code>aiofiles</code>.<code>os</code> 模块包含一些用于处理文件的有用 <code>os</code>函数的协程版本  </p><ul><li>stat</li><li>sendfile</li><li>rename</li><li>remove</li><li>mkdir</li><li>rmdir</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>aiofile</tag>
      
      <tag>异步</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-Babel-AST-traverse-NodePath.evaluate方法增强</title>
    <link href="/post/1ce07853/"/>
    <url>/post/1ce07853/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>NodePath.evaluate()</code>方法非常的好用，但本身也存在着一些限制<br>进行一些源码修改能提升它的能力  </p><h1 id="处理更多全局函数"><a href="#处理更多全局函数" class="headerlink" title="处理更多全局函数"></a>处理更多全局函数</h1><p><a href=""><code>NodePath.evaluate()</code></a> 方法不支持对<code>parseInt</code>等全局函数的处理<br>我们可以通过修改源码，让其支持  </p><ol><li>打开方法定义文件，查看函数处理定义<br>文件路径：<code>node_modules\@babel\traverse\lib\path\evaluation.js</code>  </li><li>在文件中找到会处理的全局函数定义<br>在代码中找到定义位置  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> VALID_CALLEES = [<span class="hljs-string">&quot;String&quot;</span>, <span class="hljs-string">&quot;Number&quot;</span>, <span class="hljs-string">&quot;Math&quot;</span>];<br><span class="hljs-keyword">const</span> INVALID_METHODS = [<span class="hljs-string">&quot;random&quot;</span>];<br></code></pre></td></tr></table></figure>定义包含两种：  </li></ol><ul><li><p><code>VALID_CALLEES</code> 会进行处理的全局函数  </p></li><li><p><code>INVALID_METHODS</code> 只要包含就不会处理的全局函数  </p><p>根据你的需要对定义进行修改即可    </p></li></ul><blockquote><p>例:希望支持处理 <code>parseInt</code> 函数  </p></blockquote><p>在会进行处理的定义里添加函数名即可  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> VALID_CALLEES = [<span class="hljs-string">&quot;String&quot;</span>, <span class="hljs-string">&quot;Number&quot;</span>, <span class="hljs-string">&quot;Math&quot;</span>，<span class="hljs-string">&quot;parseInt&quot;</span>];<br></code></pre></td></tr></table></figure><h1 id="quot-string-quot-quot-length-quot-引用不支持"><a href="#quot-string-quot-quot-length-quot-引用不支持" class="headerlink" title="&quot;string&quot;[&quot;length&quot;]引用不支持"></a><code>&quot;string&quot;[&quot;length&quot;]</code>引用不支持</h1><p>我们知道访问object对象有两种方法，<code>&quot;string&quot;[&quot;length&quot;]</code> 和 <code>&quot;string&quot;.length</code>  </p><p>但 <code>NodePath.evaluate()</code> 只会处理 <code>&quot;string&quot;.length</code> 这种方式的表达式，而 <code>&quot;string&quot;[&quot;length&quot;]</code>  是不会直接进行处理的  </p><p>你可以通过可以把 <code>&quot;string&quot;[&quot;length&quot;]</code> 转变为 <code>&quot;string&quot;.length</code> 这种形式的方式来实现适配<br>也可以通过修改源码达到目的  </p><ol><li><p>打开方法定义文件，查看函数处理定义<br>文件路径：<code>node_modules\@babel\traverse\lib\path\evaluation.js</code> </p></li><li><p>找到 <code>_evaluate</code> 函数，查看 对 <code>MemberExpression</code> 表达式的处理    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (path.isMemberExpression() &amp;&amp; !path.parentPath.isCallExpression(&#123;<br>  callee: node<br>&#125;)) &#123;<br>  <span class="hljs-keyword">const</span> property = path.get(<span class="hljs-string">&quot;property&quot;</span>);<br>  <span class="hljs-keyword">const</span> object = path.get(<span class="hljs-string">&quot;object&quot;</span>);<br>  <span class="hljs-keyword">if</span> (object.isLiteral() &amp;&amp; property.isIdentifier()) &#123;<br>    <span class="hljs-keyword">const</span> value = object.node.value;<br>    <span class="hljs-keyword">const</span> type = <span class="hljs-keyword">typeof</span> value;<br>    <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&quot;number&quot;</span> || type === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>      <span class="hljs-keyword">return</span> value[property.node.name];<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>它主要处理在第二个 if 语句里面  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (object.isLiteral() &amp;&amp; property.isIdentifier()) &#123;......&#125;<br></code></pre></td></tr></table></figure><p>但是它只考虑了 <code>object</code> 是字面量且 <code>property</code> 必须是 <code>Idernifier</code> 的情况，也就是类似 <code>&quot;string&quot;.length</code>的表达式  </p></li></ol><p>现在把另外一种情况的代码补充进去, 代码如下:  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (object.isLiteral() &amp;&amp; property.isLiteral()) &#123;<br>      <span class="hljs-keyword">const</span> value = object.node.value;<br>      <span class="hljs-keyword">const</span> type = <span class="hljs-keyword">typeof</span> value;<br>      <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&quot;number&quot;</span> || type === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> value[property.node.value];<br>      &#125;<br>    &#125;  <br></code></pre></td></tr></table></figure><p>将代码直接添加到 <code>if</code> 语句的后面即可  </p><p>多了一种判断逻辑和对应的处理逻辑，就能处理<code>&quot;string&quot;[&quot;length&quot;]</code>类型的代码了  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>Babel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>域名-DomainName-意义-购买-解析-备案</title>
    <link href="/post/e5cd2b3/"/>
    <url>/post/e5cd2b3/</url>
    
    <content type="html"><![CDATA[<h1 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h1><h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a>基础信息</h2><p>网域名称（英语：Domain Name，简称：Domain），简称 <strong>域名</strong>、<strong>网域</strong>，是由一串用点分隔的字符组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子方位  </p><h2 id="意义、特点、限制"><a href="#意义、特点、限制" class="headerlink" title="意义、特点、限制"></a>意义、特点、限制</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a><strong>意义</strong></h3><p>域名存在的意义是为了方便记忆 <strong>IP地址</strong>  </p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h3><p>域名具有唯一性<br>在资源更改 <strong>IP地址</strong> 时，只需要进行新IP地址与恒定域名的转换，即可实现将资源移动到网络地址拓扑中的不同物理位置  </p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a><strong>限制</strong></h3><p>完整域名的所有字符加起来不得超过253个ASCII字符的总长度<br>当每一级都使用单个字符时，限制为127个级别(127个字符加上126个点的总长度为253)  </p><h2 id="发展过程"><a href="#发展过程" class="headerlink" title="发展过程"></a>发展过程</h2><ol><li><p>使用 <strong>Hosts文件</strong> 管理<br>这种方式在网络小，计算机数量也少的情况下能解决问题，但随着接入网络的计算机越来越多，频繁的更新 <strong>Hosts文件</strong> 会造成问题  </p></li><li><p>域名解析服务 与 域名 被发明<br>1983年，保罗·莫卡派乔斯发明了域名解析服务和域名系统，随后它们被引入<code>ARPANET</code><br>原始的技术规范在882号和883号因特网标准草案中发布  </p></li><li><p>修正技术规范<br>1987年发布的第1034和1035号草案修正了一些技术规范，并废除了之前的第882和883号草案<br>此之后对因特网标准草案的修改基本上没有涉及到域名系统技术规范部分的改动。</p></li></ol><h2 id="ICANN"><a href="#ICANN" class="headerlink" title="ICANN"></a>ICANN</h2><blockquote><p>维基百科：<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E7%A7%B0%E4%B8%8E%E6%95%B0%E5%AD%97%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E6%9C%BA%E6%9E%84">https://zh.wikipedia.org/wiki/%E4%BA%9……</a>  </p></blockquote><p>互联网名称与数字地址分配机构（Internet Corporation for Assigned Names and Numbers），简称 <strong>ICANN</strong>，是位于美国加利福尼亚的非营利社团<br>主要由互联网协会的成员组成，创建于1998年9月18日，目的是接管包括管理域名和IP地址的分配等与互联网相关的任务  </p><h2 id="顶级域"><a href="#顶级域" class="headerlink" title="顶级域"></a>顶级域</h2><p>顶级域（英语：Top-level domains，缩写：TLD）是域名中最高的一级，每个域名都以顶级域结尾  </p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><table><thead><tr><th>名称</th><th>缩写</th><th>信息</th></tr></thead><tbody><tr><td>国家及地区双字代码顶级域<br>Country Code Top-level domains</td><td>ccTLD</td><td>最初定义类型之一<br>基于 ISO-3166 规定的国家/地区双字缩写代码</td></tr><tr><td>通用顶级域<br>general Top-level domains</td><td>gTLD</td><td>最初定义类型之一<br>代表了一组名称和多个组织</td></tr><tr><td>新通用顶级域<br>New general Top-level domains</td><td>NewgTLD</td><td>2011年，新的TLD命名政策被 <strong>ICANN</strong> 批准<br>2012年初，开始实施<br>现在见到的那些奇怪的顶级域(比如说中文顶级域名)为此类</td></tr></tbody></table><h4 id="gTLD代表意义"><a href="#gTLD代表意义" class="headerlink" title="gTLD代表意义"></a>gTLD代表意义</h4><table><thead><tr><th>域名</th><th>信息</th></tr></thead><tbody><tr><td><code>.gov</code></td><td>政府，现被用于美国政府的网站</td></tr><tr><td><code>.edu</code></td><td>教育机构，现被用于美国各类学校的网站</td></tr><tr><td><code>.com</code></td><td>商业，现在成为全球注册量最大、最通用的域名</td></tr><tr><td><code>.mil</code></td><td>军事，现被用于美国国防部及其附属机构的网站</td></tr><tr><td><code>.org</code></td><td>非营利组织</td></tr><tr><td><code>.net</code></td><td>网络，过去时被定位为网络基础服务提供商</td></tr><tr><td><code>.int</code></td><td>国际组织</td></tr></tbody></table><h2 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h2><p>子域名将顶级域名进一步细分<br>域名层次结构中，顶级域名下面是二级域名，它位于顶级域名的左侧<br>更下级的域名也类似，从右侧到左侧，隔一个点依次下降一层  </p><h2 id="国际化域名"><a href="#国际化域名" class="headerlink" title="国际化域名"></a>国际化域名</h2><blockquote><p>传统域名系统中允许的字符集基于 <strong>ASCII</strong>，只支持英文字母(不区分大小写)、数字和连字符(-)，而不允许其他语言的文字  </p></blockquote><p>国际化域名（英语：Internationalized Domain Name，缩写：IDN）系统<br>该系统将其他语言对应的 <strong>Unicode</strong> 字符串，转换为一个名为 <strong>Punycode</strong> 的编码字符集<br>转换结果符合传统域名的规范，这使得其他语言的文字可以注册域名，并在浏览器中访问  </p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>域名解析包括正向解析和反向解析  </p><h3 id="正向解析"><a href="#正向解析" class="headerlink" title="正向解析"></a>正向解析</h3><p>正向解析是把域名转换为IP地址的过程<br>因为机器间互相只认IP地址，所以需要把域名转换为IP地址<br>这需要由专门的 <strong>域名解析服务器</strong> 来完成，整个过程自动进行  </p><p>DNS服务器可接受两种类型的解析，分别是 <strong>递归解析</strong> 和 <strong>反复解析</strong><br>两者的区别在于，前者查询失败一般直接返回失败消息，后者会继续查询一些其他的服务器  </p><h3 id="反向解析"><a href="#反向解析" class="headerlink" title="反向解析"></a>反向解析</h3><p>反向解析比较罕见，是把IP地址转换为域名的过程<br><strong>.arpa</strong> 顶级域名专门被用于这类用途  </p><h2 id="虚构域名"><a href="#虚构域名" class="headerlink" title="虚构域名"></a>虚构域名</h2><p>虚构域名是用于小说或流行文化，或用于示例、测试的域名，用于指代实际上不存在的域名<br>规范的虚构域名是 <strong>example.com</strong> 和 <strong>example.org</strong> 以及 <strong>.测试</strong> 等顶级域名  </p><h2 id="域名数据库查询-WHOIS"><a href="#域名数据库查询-WHOIS" class="headerlink" title="域名数据库查询 WHOIS"></a>域名数据库查询 WHOIS</h2><p>一个域名的所有者可以通过查询 <strong>WHOIS数据库</strong> 而被找到<br>对于大多数根域名服务器，<strong>基本的WHOIS</strong> 由 <strong>ICANN</strong> 维护，而 **WHOIS的细节 ** 则由控制那个域的域注册机构维护  </p><p>对于240多个国家代码顶级域名（<strong>ccTLDs</strong>），通常由该域名权威注册机构负责维护 <strong>WHOIS</strong>  </p><blockquote><p>例如  </p><ul><li><strong>.CN</strong> 域名的WHOIS维护<br>中国互联网络信息中心（China Internet Network Information Center）负责</li><li><strong>.HK</strong> 域名的WHOIS维护<br>香港互联网注册管理有限公司（Hong Kong Internet Registration Corporation Limited）负责  </li><li><strong>.TW</strong> 域名的WHOIS维护<br>台湾网络信息中心（Taiwan Network Information Center）负责  </li></ul></blockquote><h2 id="权力滥用"><a href="#权力滥用" class="headerlink" title="权力滥用"></a>权力滥用</h2><p>对域名的控制权本身就是一种权力<br>权力存在的地方，就必定会有滥用的情况  </p><ul><li><p><strong>VeriSign</strong> 重定向搜索事件  </p></li><li><p>*.com<strong>的域名注册管理机构 **VeriSign</strong> ，开发了<strong>VeriSign Site Finder</strong>系统<br>系统将所有未注册的 <strong>.com</strong> 和 <strong>.net</strong> 域名重定向到 <strong>VeriSign</strong>的搜索网页<br>尽管此举在社会上受到非常多的批评，但 <strong>VeriSign</strong> 无动于衷。直到 <strong>ICANN</strong> 威胁要撤销其管理 <strong>.com</strong> 域名的资格授权之后，<strong>VeriSign</strong> 才不情愿地撤下 <strong>Site Finder</strong> 系统  </p></li><li><p>美国注册的域名为何没有**.us**  </p><blockquote><p>这其实是过去美国政府操作的结果  </p></blockquote><p>20世纪80年代，互联网域名与地址的管理权一直由美国政府垄断，它自行定义了一些域名为自己所用    </p><blockquote><p>比如将 <strong>.edu</strong>、**.mil** 、**.gov** 等域名用作美国自己使用，而不用 <strong>.edu.us</strong> 二级域名）</p></blockquote><p>1998年，美国政府与 <strong>ICANN</strong> 签订合同，授权由 <strong>ICANN</strong> 负责协调管理, 但美国政府仍然拥有对域名的控制权，并有时进行干涉<br>2013年，美国曝出的“棱镜门”丑闻引发了风波。“棱镜门”丑闻曝光带来的压力，促使奥巴马政府最终决定放弃对 <strong>ICANN</strong> 的权力<br>2016年10月，美国政府机构正式将互联网域名的管理权完全移交给 <strong>ICANN</strong>，才结束了对域名管理近20年的垄断  </p></li></ul><ul><li>使你无法访问外网的 <strong>墙</strong><br>维基百科：<a href="https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E9%95%BF%E5%9F%8E">https://zh.wikipedia.org/wiki/%E9%98%……</a>  </li></ul><p><a id="DNS"></a></p><h1 id="域名服务器-DNS"><a href="#域名服务器-DNS" class="headerlink" title="域名服务器 DNS"></a>域名服务器 DNS</h1><h2 id="域名记录类型"><a href="#域名记录类型" class="headerlink" title="域名记录类型"></a>域名记录类型</h2><p>DNS系统中，常见的资源记录类型有：</p><table><thead><tr><th>记录名称</th><th>类型</th><th>定义标准</th><th>信息</th></tr></thead><tbody><tr><td>主机记录</td><td>A记录</td><td>RFC 1035定义</td><td>A记录是用于名称解析的重要记录<br>它将特定的主机名映射到对应主机的IP地址上</td></tr><tr><td>别名记录</td><td>CNAME记录</td><td>RFC 1035定义</td><td>CNAME记录用于将某个别名指向到某个A记录上<br>这样就不需要再为某个新名字另外创建一条新的A记录</td></tr><tr><td>IPv6主机记录</td><td>AAAA记录</td><td>RFC 3596定义</td><td>与A记录类似，用于将特定的主机名映射到一个主机的 IPv6 地址</td></tr><tr><td>服务位置记录</td><td>SRV记录</td><td>RFC 2782定义</td><td>用于定义提供特定服务的服务器的位置，如主机（hostname），端口（port number）等</td></tr><tr><td>域名服务器记录</td><td>NS记录</td><td></td><td>用来指定该域名由哪个 DNS服务器 来进行解析<br>注册域名时，总有默认的DNS服务器，每个注册的域名都是由一个 DNS域名服务器 来进行解析的<br>DNS服务器的NS记录地址一般以以下的形式出现： ns1.domain.com、ns2.domain.com等</td></tr><tr><td>NAPTR记录</td><td></td><td>RFC 3403定义</td><td>它提供了正则表达式方式去映射一个域名<br>NAPTR记录非常著名的一个应用是用于ENUM查询</td></tr><tr><td>邮件交换记录</td><td>MX记录</td><td>RFC 1035定义</td><td>用于指定负责处理发往收件人域名的邮件服务器<br>MX记录允许设置一个优先级，当多个邮件服务器可用时，会根据该值决定投递邮件的服务器。简单邮件传输协议（SMTP）会根据MX记录的值来决定邮件的路由过程。</td></tr></tbody></table><blockquote><p>类型大全：<a href="https://zh.wikipedia.org/wiki/DNS%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B%E5%88%97%E8%A1%A8">https://zh.wikipedia.org/wiki/DNS%E8……</a>  </p></blockquote><h2 id="最常用类型"><a href="#最常用类型" class="headerlink" title="最常用类型"></a>最常用类型</h2><p>在域名解析控制台里，最常配置的是  </p><ul><li><code>A记录</code> 主机记录  </li><li><code>CNAME记录</code> 别名记录  </li></ul><p>这里用假用百度域名<code>baidu.com</code>和假定的服务器<code>192.168.1.2</code>来举例<br><code>A记录</code> 会作为主记录存在，可以利用域名直接指定  </p><blockquote><p>即<code>baidu.com</code>-A记录解析-&gt;<code>192.168.1.2</code>  </p></blockquote><p>但<code>baidu.com</code>并不是我们最常用的访问域名，我们最常用的访问域名是<code>www.baidu.com</code>，这里实际上并不是指定一个新的<code>A记录</code>，因为如果这样做。未来服务器IP改变的话，就需要更改大量的记录<br><code>CNAME记录</code> 就是用来处理这种情况的。记录可以将子域名<code>www.baidu.com</code>指定到<code>baidu.com</code>上  </p><blockquote><p>即<code>www.baidu.com</code>-CNAME记录解析-&gt;<code>baidu.com</code>-&gt;<code>A记录解析</code>-&gt;<code>192.168.1.2</code>  </p></blockquote><h1 id="域名购买-备案-使用"><a href="#域名购买-备案-使用" class="headerlink" title="域名购买-备案-使用"></a>域名购买-备案-使用</h1><h2 id="域名购买"><a href="#域名购买" class="headerlink" title="域名购买"></a>域名购买</h2><h3 id="确认需求"><a href="#确认需求" class="headerlink" title="确认需求"></a>确认需求</h3><p>一般而言，购买域名适用于部署网站的，当然你也能用来炒<br>如果是用于部署网站，那么最好在网站部署完成前一到半个月考虑域名的事情。买早了浪费，买迟了会被备案拖累  </p><h3 id="运营商选择"><a href="#运营商选择" class="headerlink" title="运营商选择"></a>运营商选择</h3><p>在购买之前需要选择一个运营商<br>不少云服务商也经营着域名相关的业务（例如：<a href="https://buy.cloud.tencent.com/domain">腾讯云</a>，<a href="https://wanwang.aliyun.com/domain/yumingheji">阿里云</a>）<br>销售策略也多为捆绑销售（买服务器送域名之类）  </p><h3 id="查询域名"><a href="#查询域名" class="headerlink" title="查询域名"></a>查询域名</h3><p>由于域名是唯一的，在购买之前需要知道你想要的域名是否已经被注册<br>这个运营商会提供查询服务<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201208025140801.png" alt="腾讯域名查询"><br>域名是可以买卖的，好的域名老早就被人抢注了  </p><h3 id="域名价格"><a href="#域名价格" class="headerlink" title="域名价格"></a>域名价格</h3><ul><li>查询得到的结果内会包含购买的价格信息，可以在不同运营商的平台上查询，货比三家  </li><li>一次性购买时间越长越便宜  </li><li>顶级域越奇怪约便宜  </li><li>域名越长越便宜  </li></ul><h3 id="购买域名"><a href="#购买域名" class="headerlink" title="购买域名"></a>购买域名</h3><p>购买域名需要填写一些个人信息<br>并不复杂  </p><h2 id="域名备案"><a href="#域名备案" class="headerlink" title="域名备案"></a>域名备案</h2><p>在你制作好了网站项目，部署好了以后，需要对域名进行备案<br>域名运营商会提供备案的渠道，你需要在渠道中填写一些信息<br>比如：</p><ul><li>网站名称  </li><li>域名  </li><li>网站描述  </li><li>域名控制台截图  </li><li>用于联系的手机号（需要两个号码）  </li><li>……  </li></ul><p>信息最终会提交到各省的管理部门进行审核  </p><h3 id="等待备案审核完成"><a href="#等待备案审核完成" class="headerlink" title="等待备案审核完成"></a>等待备案审核完成</h3><p>这个步骤会花费不少的时间。在不同的地区，审核时间会不一样<br>我在广州，花了12天。 有网友在北京，花了一个月 </p><p>在多天以后，会收到来自 <strong>工业和信息化部网站备案系统邮件通知</strong>，说明备案成功<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201208045759316.png"><br>随后，也会收到来自服务商的通知<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201208050039061.png">  </p><p>它会提示你  </p><ul><li>30天内常住地公安机关备案  </li><li>将备案信息html插入到网站首页  </li></ul><p>去公安机关进行备案后，html信息也会给你，所以实际上只需要去公安机关备案即可  </p><h2 id="公安局备案"><a href="#公安局备案" class="headerlink" title="公安局备案"></a>公安局备案</h2><p>全国互联网安全管理服务平台：<a href="http://www.beian.gov.cn/portal/index">http://www.beian.gov.cn/portal/index</a>  </p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>访问以后需要注册<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/1.gif"><br>注册完以后，依然是点那个按钮来登录  </p><h3 id="创建主体"><a href="#创建主体" class="headerlink" title="创建主体"></a>创建主体</h3><p><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201208065102442.png"><br>需要填入很多信息  </p><h3 id="办理备案"><a href="#办理备案" class="headerlink" title="办理备案"></a>办理备案</h3><p><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201208065759604.png"><br>需要填入很多信息，注意与域名备案匹配<br>其中会有个点需要注意：域名证书  </p><blockquote><p>域名证书<br>虽然表单中域名证书并不是必填项，但你不填必定会不会通过审核<br>域名证书可以在域名控制台里下载到(一张图片)<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201209045557661.png">  </p></blockquote><p>申请提交完成后，能在首页查看到申请信息<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201208070043543.png">  </p><p>接下来就是等待审核的结果了，审核完成后（无论通过还是不通过）都会通过手机给你发短信进行通知<br>所以不必担心不知道结果  </p><h3 id="网站首页张贴指定HTML"><a href="#网站首页张贴指定HTML" class="headerlink" title="网站首页张贴指定HTML"></a>网站首页张贴指定HTML</h3><p>在通过审核后，可以在此处看到审核通过的信息<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201211040628850.png"><br>它会给你生成一小段的HTML引用信息<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201211041014061.png"><br>复制下来，将内容粘贴到网站首页就行  </p><h1 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h1><p>做了那麽多操作，但實際上還并沒有將域名用起來<br>不過設置解析并不是什麽困難的事情，也不需要花費什麽時間<br>進到域名控制台解析頁面裏<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201221080859208.png"><br>將主要需要解析的IP和端口號解析用擁有的域名進行解析就行<br><img src="/%E5%9F%9F%E5%90%8D-DomainName-%E6%84%8F%E4%B9%89-%E8%B4%AD%E4%B9%B0-%E8%A7%A3%E6%9E%90-%E5%A4%87%E6%A1%88/20201221081158804.png"><br>一般來説，域名解析用得最多的是A類型。具體可以參考上文的<a href="#DNS">解析類型</a>  </p><p>可以將更低級的域名解析到不同的 位置/端口，使得單個域名給多個服務器同時使用。他們之間并不會相互影響  </p><hr><p>参考  </p><ul><li><a href="https://zh.wikipedia.org/wiki/%E5%9F%9F%E5%90%8D">维基百科-域名</a>  </li><li><a href="https://cloud.tencent.com/document/product/243/19142?from=10680">腾讯云文档-公安局备案</a>  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>域名</tag>
      
      <tag>备案</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-Babel-AST-基础</title>
    <link href="/post/7389a59f/"/>
    <url>/post/7389a59f/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><h2 id="抽象语法树-AST"><a href="#抽象语法树-AST" class="headerlink" title="抽象语法树 AST"></a>抽象语法树 AST</h2><blockquote><p>维基百科-抽象语法树：<a href="https://zh.wikipedia.org/wiki/%E6%8A%BD%E8%B1%A1%E8%AA%9E%E6%B3%95%E6%A8%B9">https://zh.wikipedia.org/wiki/%E6%8A%……</a>  </p></blockquote><p>抽象语法树（Abstract Syntax Tree，AST）是源代码语法结构的一种抽象表示<br>它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构<br>之所以说语法是“抽象”的，是因为这里的语法并不会表示出真实语法中出现的每个细节  </p><blockquote><p>例:代码转抽象语法树  </p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus">while <span class="hljs-selector-tag">b</span> ≠ <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-selector-tag">a</span> &gt; b<br>        <span class="hljs-selector-tag">a</span> := <span class="hljs-selector-tag">a</span> − b<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-selector-tag">b</span> := <span class="hljs-selector-tag">b</span> − a<br>    return a<br></code></pre></td></tr></table></figure><p><img src="/Javascript-Babel-AST-%E5%9F%BA%E7%A1%80/20201224050050034.png">  </p><p>需要注意的是，<code>Babel</code>并非操作的基础的<code>ESTree</code>，它 修改/扩充 了一些节点类型<br>(自行记录：<a href="https://evilrecluse.top/post/77d57432/#%E8%BE%93%E5%87%BA-Output"><code>Babel parser</code>与<code>ESTree</code>的不同之处</a>）</p><h2 id="链接信息"><a href="#链接信息" class="headerlink" title="链接信息"></a>链接信息</h2><table><thead><tr><th>信息</th><th>地址</th></tr></thead><tbody><tr><td>AST在线解析</td><td><a href="https://astexplorer.net/">https://astexplorer.net/</a></td></tr><tr><td>babel中文文档</td><td><a href="https://www.babeljs.cn/docs/">https://www.babeljs.cn/docs/</a></td></tr><tr><td>babel英文文档</td><td><a href="https://babeljs.io/docs/en/">https://babeljs.io/docs/en/</a></td></tr><tr><td>Github</td><td><a href="https://github.com/babel/babel">https://github.com/babel/babel</a></td></tr><tr><td>插件手册</td><td><a href="https://blog.csdn.net/weixin_33826609/article/details/93164633#toc-visitors">https://blog.csdn.net/weixin_33826609/article/details/93164633#toc-visitors</a></td></tr></tbody></table><table><thead><tr><th>信息</th><th>地址</th></tr></thead><tbody><tr><td>babel各节点解释</td><td><a href="https://github.com/babel/babylon/blob/master/ast/spec.md">https://github.com/babel/babylon/blob/master/ast/spec.md</a></td></tr><tr><td>babel简单剖析</td><td><a href="http://www.alloyteam.com/2017/04/analysis-of-babel-babel-overview/">http://www.alloyteam.com/2017/04/analysis-of-babel-babel-overview/</a></td></tr><tr><td>淘宝前端团队写的babel相关</td><td><a href="https://fed.taobao.org/blog/taofed/do71ct/babel-plugins/">https://fed.taobao.org/blog/taofed/do71ct/babel-plugins/</a></td></tr><tr><td>babel到底将代码转换成什么</td><td><a href="http://www.alloyteam.com/2016/05/babel-code-into-a-bird-like/">http://www.alloyteam.com/2016/05/babel-code-into-a-bird-like/</a></td></tr></tbody></table><h1 id="安装-使用环境"><a href="#安装-使用环境" class="headerlink" title="安装/使用环境"></a>安装/使用环境</h1><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><h3 id="安装-Node-js-与Babel"><a href="#安装-Node-js-与Babel" class="headerlink" title="安装 Node.js 与Babel"></a>安装 Node.js 与Babel</h3><p>首先你要有<code>Node.js</code>环境  </p><a href="#">Post not found: Node.js</a><p>全局安装 <code>babel</code>的各个库  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install @babel/core -g<br>npm install @babel/parser -g<br>npm install @babel/traverse -g<br>npm install @babel/generator -g<br>npm install @babel/types -g<br></code></pre></td></tr></table></figure><p>简单描述一下刚刚安装的库的作用：   </p><ul><li><code>@babel/core</code>是 <code>Babel</code> 的核心代码  </li><li><code>@babel/parser</code>常用于解析代码语法树的模块  </li><li><code>@babel/traverse</code>常用于操作语法树的模块  </li><li><code>@babel/generator</code>常用于将语法树生成代码的模块  </li><li><code>@babel/types</code> 包含类型信息，在生成节点等与类型相关的操作会用到</li></ul><h3 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h3><p>启动 <code>Node.js</code> 环境  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node<br></code></pre></td></tr></table></figure><p>引入babel库，测试是否成功  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br></code></pre></td></tr></table></figure><p>这一步可能会出现说没有库的问题，这是由于环境变量导致的<br>一般而言，安装<code>Node.js</code>会默认配置上环境变量，但这个配置不一定有用<br>此时你可以手动设置环境变量，或者用绝对路径来引入  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;E:/Environment/Nodejs/node_global/node_modules/@babel/parser&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="在线解析网站"><a href="#在线解析网站" class="headerlink" title="在线解析网站"></a>在线解析网站</h2><p>链接： <a href="https://astexplorer.net/">https://astexplorer.net/</a><br>这个是一个解析代码语法树的网站<br>这里是需要用它的<code>Babel</code>解析语法树，所以要做对应设置<br><img src="/Javascript-Babel-AST-%E5%9F%BA%E7%A1%80/20200830085956301.png"><br>打开以后将解析方式改为<code>@babel/parser</code><br>在左边的文本框里输入一些代码，就能在右边看到对应解析出来的语法树了  </p><h1 id="认识AST"><a href="#认识AST" class="headerlink" title="认识AST"></a>认识AST</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果将代码中各类的语句都看成节点，那么整个程序的代码就像是由一个个节点组成的树状结构，代码的运行就像是不完全遍历这颗树一样  </p><p>AST解析源代码实际上就是这样干的<br>在代码解析完成后，你会得到一颗语法树，这颗语法树包含了代码中的所有内容  </p><p>你可以对它进行树（数据结构）可以进行的所有操作（从复杂的 <code>有序树转二叉树</code> 到简单的 <code>替换节点</code>，<code>计算树的深度</code>，<code>剪枝</code>，<code>拼接</code>都可以）  </p><p>最后想象一下，程序运行 就是在这棵树里进行 <code>深度优先遍历</code>  </p><blockquote><p>实际上，它的结果更接近图（数据结构），因为可能存在调用循环/递归（树中的节点不允许连接自身或有多个父级）  </p></blockquote><h2 id="常见节点信息解析"><a href="#常见节点信息解析" class="headerlink" title="常见节点信息解析"></a>常见节点信息解析</h2><table><thead><tr><th>节点属性</th><th>记录的信息</th></tr></thead><tbody><tr><td>type</td><td>当前节点的类型</td></tr><tr><td>start</td><td>当前节点的起始位</td></tr><tr><td>end</td><td>当前节点的末尾</td></tr><tr><td>loc</td><td>当前节点所在的行列位置<br>起始于结束的行列信息</td></tr><tr><td>errors</td><td>File节点所持有的特有属性，可以不用理会</td></tr><tr><td>program</td><td>包含整个源代码，不包含注释节点</td></tr><tr><td>comments</td><td>源代码中所有的注释会显示在这里</td></tr></tbody></table><p>就这么直接列出来可能还不太容易理解<br>可以利用 <a href="https://astexplorer.net/">在线解析网站</a>  解析一小段<code>javascript</code>代码来帮助理解/记忆  </p><p>输入仪式性的语句  <code>console.log(&quot;Hello World&quot;)</code>  的变种代码  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 这是一段源代码，作用就是计算，输出一些字符</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> i = [<span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-string">&#x27;W&#x27;</span>, <span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>, <span class="hljs-string">&#x27;l&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>];<br>  i = i.join(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <span class="hljs-keyword">return</span> i<br>&#125;<br><span class="hljs-built_in">console</span>.log(test())<br></code></pre></td></tr></table></figure><h3 id="最外层File节点"><a href="#最外层File节点" class="headerlink" title="最外层File节点"></a>最外层<code>File节点</code></h3><p><img src="/Javascript-Babel-AST-%E5%9F%BA%E7%A1%80/20200901023343710.png"><br>先将节点收得差不多，观察最外面的<code>File节点</code>的信息  </p><ul><li><code>type</code> <code>start</code> <code>end</code> <code>loc</code> 你能在绝大多数节点里看到  </li><li>常用的类型判断方法<code>t.is****(node)</code>就是判断当前节点type是否为某个类型  </li></ul><h3 id="层级结构分析"><a href="#层级结构分析" class="headerlink" title="层级结构分析"></a>层级结构分析</h3><p>实际上，可以通过观察 <code>type</code> 知道一些信息  </p><blockquote><p>层级分析例1:<br><img src="/Javascript-Babel-AST-%E5%9F%BA%E7%A1%80/20200901023523804.png"><br>比如说这整个文件包含了了代码块主要有两部分： <strong>一个函数声明</strong> 和 <strong>一句语句</strong>  </p></blockquote><br><blockquote><p>层级分析例2:<br><img src="/Javascript-Babel-AST-%E5%9F%BA%E7%A1%80/20200901082003100.png"><br>又比如说，这个函数里包含了三个部分：<strong>一个声明</strong>，<strong>一个语句</strong>，<strong>一个返回</strong>  </p></blockquote><h2 id="解析代码-Code→AST"><a href="#解析代码-Code→AST" class="headerlink" title="解析代码 Code→AST"></a>解析代码 Code→AST</h2><p><code>@babel/parser</code>能将<code>javascript</code>代码解析成语法树<br>这个库在前文中已经安装好了，现在用它来解析语法树吧  </p><blockquote><p>例：用babel解析语法树  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">&quot;var a = 123;&quot;</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(ast, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;\t&#x27;</span>));<br></code></pre></td></tr></table></figure><p>此处会输出和网页解析出来的内容一样的结果<br>做简单分析时，用网页解析比较快捷方便，很少写代码来解析  </p><h2 id="AST寻路"><a href="#AST寻路" class="headerlink" title="AST寻路"></a>AST寻路</h2><p>在解析出语法树后，就可以进行各类的操作了<br>但和想要对树（数据结构）进行任何操作一样，在对AST进行各类操作之前，你要先会 寻路 （到达(遍历到)指定的节点）才能进行操作  </p><blockquote><p>寻路这个词是我自己瞎编的  </p></blockquote><h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>想要约朋友来家里玩，可以向别人描述 家的附近 或者 家本身 有什么特征。比如说:</p><blockquote><p>“我家门口有一颗歪脖子树” 或者 “我家房顶有一个大洞”  </p></blockquote><p>这样子能很方便得让别人找到位置  </p><p>寻路的过程也一样。想要到达 某个/某些 特定节点上，可以根据这个节点的 <code>类型</code> 与 <code>路径</code> 给出判断依据来到达特定的 某个/某些 节点  </p><h3 id="遍历整个语法树"><a href="#遍历整个语法树" class="headerlink" title="遍历整个语法树"></a>遍历整个语法树</h3><p>绝大多数情况下，对AST进行寻路比上面描述的情况更糟糕一些  </p><blockquote><p><strong>在AST中寻路的情况更像是：</strong><br>你的朋友坐在一个城市观光车上，观光车会穿过城市里的每一个街道。你的朋友无法控制车前进的方向，你只能让车在你描述的情况下停下，用这种方式来到达你家    </p></blockquote><p>默认情况下，<code>@babel/traverse</code>能让你遍历整个AST<br>如果想要寻路到达某个节点，就需要给出你想要寻路的 那个/那些 节点的特征进行判断操作  </p><h3 id="使用-Path-进行寻路"><a href="#使用-Path-进行寻路" class="headerlink" title="使用 Path 进行寻路"></a>使用 Path 进行寻路</h3><p>在使用 <code>enter</code> 遍历所有节点的时候，参数 <code>path</code> 会传入当前的路径<br>可以根据<code>path</code>进行各种判断，继而进行各类操作  </p><h4 id="Path基本信息"><a href="#Path基本信息" class="headerlink" title="Path基本信息"></a>Path基本信息</h4><ul><li>获取 <code>Path</code>对应节点的 源代码 <code>path.toString()</code>  </li><li>获取 <code>Path</code>对应节点的 类型 <code>path.type</code>  </li></ul><blockquote><p>例: 寻找代码中包含 字符a 的节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">    var b = 123;</span><br><span class="hljs-string">    a = b + 1;</span><br><span class="hljs-string">`</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    enter(path)  <span class="hljs-comment">// 此处会遍历所有的节点，并得到对应的路径</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(path.toString().indexOf(<span class="hljs-string">&#x27;a&#x27;</span>) &gt; -<span class="hljs-number">1</span>)&#123;  <span class="hljs-comment">// 根据路径，得到对应的代码，如果其中包含 字符a 则输出信息</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径类型&#x27;</span>, path.type); <span class="hljs-comment">// 打印当前路径类型</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径源码：&#x27;</span>, path.toString()); <span class="hljs-comment">// 打印当前路径所对应的源代码</span><br>            <span class="hljs-comment">// is + 节点类型全名, 能判断当前路径节点的类型是否是声明的类型</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是一个变量声明节点:\t&#x27;</span>, path.isVariableDeclaration())<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;--------------------&#x27;</span>)<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br>traverse(ast, visitor);  <span class="hljs-comment">// traverse会遍历所有的节点</span><br></code></pre></td></tr></table></figure><p>会得到如下的结果  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">当前路径类型 Program<br>当前路径源码： var b = 123;<br>a = b + 1;<br>这是一个变量声明节点: <span class="hljs-literal">false</span><br>--------------------<br>当前路径类型 VariableDeclaration<br>当前路径源码： var b = 123;<br>这是一个变量声明节点: <span class="hljs-literal">true</span><br>--------------------<br>当前路径类型 ExpressionStatement<br>当前路径源码： a = b + 1;<br>这是一个变量声明节点: <span class="hljs-literal">false</span><br>--------------------<br>当前路径类型 AssignmentExpression<br>当前路径源码： a = b + 1<br>这是一个变量声明节点: <span class="hljs-literal">false</span><br>--------------------<br>当前路径类型 Identifier<br>当前路径源码： a<br>这是一个变量声明节点: <span class="hljs-literal">false</span><br>--------------------<br></code></pre></td></tr></table></figure><p>此处是对源代码进行判断，所以<code>var</code>这种关键词也是会被认为是包含<code>a</code>的  </p><h3 id="使用-节点-进行寻路"><a href="#使用-节点-进行寻路" class="headerlink" title="使用 节点 进行寻路"></a>使用 节点 进行寻路</h3><blockquote><p>例子：根据特点寻找语法树中的节点</p><ul><li>特点：这个节点是一个 变量声明节点  </li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> jscode = <span class="hljs-string">&quot;var a = 123;&quot;</span>;<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-comment">// 这里的 VariableDeclaration 表明 需要的是 变量声明节点 </span><br>    VariableDeclaration(path)<br>    &#123;   <span class="hljs-comment">// 获取到 路径path 后，可以根据path的信息来进一步进行判断</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 源码:\n&#x27;</span>, path.toString());<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 节点:\n&#x27;</span>, path.node.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 父级节点:\n&#x27;</span>, path.parent.toString());<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 父级路径:\n&#x27;</span>, path.parentPath.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;当前路径 类型:\n&#x27;</span>, path.type)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);  <span class="hljs-comment">// 解析语法树</span><br>traverse(ast, visitor);  <span class="hljs-comment">// 遍历以进行操作</span><br></code></pre></td></tr></table></figure><p>由于直接输出<code>Node</code>会显示非常多的信息，此处用<code>toString()</code>意思意思<br>得到的输出结果：  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">当前路径 源码:<br> var a = 123;<br>当前路径 节点:<br> [object Object]<br>当前路径 父级节点:<br> [object Object]<br>当前路径 父级路径:<br> var a = 123;<br>当前路径 类型:<br> VariableDeclaration<br></code></pre></td></tr></table></figure><p>这里用了一个 <code>VariableDeclaration</code>（变量声明节点）来表述特点，更多得节点类型可以查看 <a href="https://github.com/babel/babylon/blob/master/ast/spec.md#node-objects">Github-Babel-节点类型文档</a>  </p><p><strong>注意：所有符合你描述的特点的节点都会进行声明中的操作</strong>（此处为输出信息）<br>由于此处只有一句声明语句的代码，所以随意给出一个合适的特点就能轻松到达目标节点<br>如果代码量大，又希望只改动部分，那么最好给出更多的语句以精确修改目标  </p><h2 id="用AST生成代码-AST→Code"><a href="#用AST生成代码-AST→Code" class="headerlink" title="用AST生成代码 AST→Code"></a>用AST生成代码 AST→Code</h2><p>尽管你现在可能还并不知道如何对语法树节点进行操作<br>但根据AST生成代码的方法还是要学会的，要不然最终结果长什么样都不知道  </p><p>可以使用<code>@babel/generator</code>来实现 根据AST生成代码的这个过程  </p><blockquote><p>例：根据AST生成代码以查看修改结果  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">&#x27;function squire()&#123;var n = 3; return n*n;&#125;&#x27;</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">BinaryExpression</span>(<span class="hljs-params">path</span>)</span> &#123;  <span class="hljs-comment">// 寻找所有 二元表达式节点</span><br>    <span class="hljs-keyword">if</span> (path.node.operator == <span class="hljs-string">&#x27;*&#x27;</span>) &#123;  <span class="hljs-comment">// 并且这个表达式节点的操作是做 乘法 </span><br>      path.node.operator = <span class="hljs-string">&#x27;+&#x27;</span>;  <span class="hljs-comment">// 将操作改为 加</span><br>    &#125;<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);  <span class="hljs-comment">// 对AST进行操作</span><br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>]);  <span class="hljs-comment">// 使用 generator 利用AST生成对应的代码</span><br></code></pre></td></tr></table></figure><p>运行后会输出结果  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">squire</span></span>() &#123;<br>  var n = 3;<br>  <span class="hljs-built_in">return</span> n + n;<br>&#125;<br></code></pre></td></tr></table></figure><p>此处将所有的表达式乘法转为加法，并且将改变后的AST利用<code>@babel/generator</code>生成出新的代码  </p><h2 id="常用基础操作"><a href="#常用基础操作" class="headerlink" title="常用基础操作"></a>常用基础操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><p><code>@babel/types</code>包含了各个节点的定义<br>可以通过使用<code>@babel/types</code>的类型名，查阅<a href="https://babeljs.io/docs/en/babel-types"><code>@babel/types</code>官方文档</a>，获取对应类型的构造函数，创建对应类型的节点  </p><blockquote><p>例：利用 @babel/types 提供的类来直接创建节点，编写ast内容  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">var</span> callee = t.memberExpression(t.identifier(<span class="hljs-string">&#x27;console&#x27;</span>), t.identifier(<span class="hljs-string">&#x27;log&#x27;</span>)),<br>    args = [t.NumericLiteral(<span class="hljs-number">666</span>)],<br>    call_exp = t.callExpression(callee, args),<br>    exp_statement = t.ExpressionStatement(call_exp)<br><br><span class="hljs-built_in">console</span>.log(generator(exp_statement)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><p>输出结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">666</span>)<br></code></pre></td></tr></table></figure><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><p><code>NodePath.insertAfter()</code>方法用于在当前<code>path</code>前面插入节点<br><code>NodePath.insertBefore()</code>方法用于在当前<code>path</code>后面插入节点  </p><blockquote><p>例：向语法树中插入节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<br><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  var a = 2;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;  <span class="hljs-comment">// 找到变量声明节点，删除</span><br>    <span class="hljs-keyword">var</span> node = t.NumericLiteral(<span class="hljs-number">1</span>)  <span class="hljs-comment">// 使用 types 来生成一个数字节点</span><br>    path.insertAfter(node)  <span class="hljs-comment">// 在当前path前面插入节点</span><br>    node = t.NumericLiteral(<span class="hljs-number">3</span>)<br>    path.insertBefore(node)  <span class="hljs-comment">// 在当前path后面插入</span><br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><p>结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-number">3</span><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h3><p><code>NodePath.replaceInline</code> 方法用于替换对应path的节点  </p><blockquote><p>例：寻找计算节点，计算好了以后，生成新的数字节点，替换原本的节点  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> t = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/types&quot;</span>);<br><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  return 1 + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">BinaryExpression</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">eval</span>(path.toString())  <span class="hljs-comment">// 计算表达式结果</span><br>    <span class="hljs-keyword">var</span> node = t.NumericLiteral(result)  <span class="hljs-comment">// 使用 types 来生成一个数字节点</span><br>    path.replaceInline(node);   <span class="hljs-comment">// 用新的节点来替换表达式内容</span><br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><p>得到结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p><code>NodePath.remove()</code>用于删除路径对应的节点<br>由于是对<code>path</code>操作，所以务必注意不要误删  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  var a = 1;</span><br><span class="hljs-string">  return 1 + 1;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>  <span class="hljs-function"><span class="hljs-title">VariableDeclaration</span>(<span class="hljs-params">path</span>)</span> &#123;  <span class="hljs-comment">// 找到变量声明节点，删除</span><br>      path.remove()<br>  &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>])<br></code></pre></td></tr></table></figure><p>得到结果：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="作用域Scope-与-被绑定量Binding"><a href="#作用域Scope-与-被绑定量Binding" class="headerlink" title="作用域Scope 与 被绑定量Binding"></a>作用域Scope 与 被绑定量Binding</h1><h2 id="词汇描述"><a href="#词汇描述" class="headerlink" title="词汇描述"></a>词汇描述</h2><ul><li><p><strong>作用域scope</strong> - 有效范围<br>作用域（<code>scope</code>，或译作有效范围）是名字（<code>name</code>）与实体（<code>entity</code>）的绑定（<code>binding</code>）保持有效的那部分计算机程序<br>不同的编程语言可能有不同的作用域和名字解析。而同一语言内也可能存在多种作用域，随实体的类型变化而不同<br>作用域类别影响变量的绑定方式，根据语言使用静态作用域还是动态作用域变量的取值可能会有不同的结果  </p><blockquote><p>摘自：<a href="https://zh.wikipedia.org/wiki/%E4%BD%9C%E7%94%A8%E5%9F%9F">维基百科-作用域</a>  </p></blockquote></li><li><p><strong>名字绑定binding</strong><br>名字绑定(简称绑定)是把实体（数据 或/且 代码）关联到标识符<br>标识符绑定到实体被称为引用该对象<br>机器语言没有内建的标识符表示方法，但程序设计语言实现了名字与对象的绑定<br>绑定最初是与作用域相关，因为作用域确定了哪个名字绑定到哪个对象——在程序代码中的哪个位置与哪条执行路径  </p><blockquote><p>摘自：<a href="https://zh.wikipedia.org/wiki/%E5%90%8D%E5%AD%97%E7%BB%91%E5%AE%9A">维基百科-名字与绑定</a>  </p></blockquote></li></ul><p><strong>最简易理解</strong>  </p><p>对于复杂程度不高的代码，可以可简单的理解为：</p><ul><li>一个<strong>函数</strong>就是一个<strong>作用域</strong>  </li><li>一个<strong>变量</strong>就是一个<strong>绑定</strong>，依附在<strong>作用域</strong>上  </li></ul><p>这对于复杂的代码可能并不会成立，但用于学习最基本的内容已经足够  </p><h2 id="作用域-Scope"><a href="#作用域-Scope" class="headerlink" title="作用域 Scope"></a>作用域 Scope</h2><p><code>@Babel</code>解析出来的语法树节点对象会包含作用域信息，这个信息会作为节点<code>Node</code>对象的一个属性保存<br>这个属性本身是一个<code>Scope</code>对象，其定义位于<code>node_modules/@babel/traverse/lib/scope/index.js</code>中  </p><blockquote><p>例: 查看基本的 作用域与绑定 信息  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function squire(i)&#123;</span><br><span class="hljs-string">    return i * i * i;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">function i()</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    var i = 123;</span><br><span class="hljs-string">    i += 2;</span><br><span class="hljs-string">    return 123;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-string">&quot;FunctionDeclaration&quot;</span>(path)&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n\n这里是函数 &quot;</span>, path.node.id.name + <span class="hljs-string">&#x27;()&#x27;</span>)<br>        path.scope.dump();<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br></code></pre></td></tr></table></figure><p>执行 <code>Scope.dump()</code>，会得到自底向上的 作用域与变量信息<br>得到结果：  </p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">这里是函数  squire()<br>------------------------------------------------------------<br># FunctionDeclaration<br><span class="hljs-code"> - i &#123; constant: true, references: 3, violations: 0, kind: &#x27;param&#x27; &#125;</span><br># Program<br><span class="hljs-code"> - squire &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br><span class="hljs-code"> - i &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br>------------------------------------------------------------<br><br><br>这里是函数  i()<br>------------------------------------------------------------<br># FunctionDeclaration<br><span class="hljs-code"> - i &#123; constant: false, references: 0, violations: 1, kind: &#x27;var&#x27; &#125;</span><br># Program<br><span class="hljs-code"> - squire &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br><span class="hljs-code"> - i &#123; constant: true, references: 0, violations: 0, kind: &#x27;hoisted&#x27; &#125;</span><br>------------------------------------------------------------<br></code></pre></td></tr></table></figure><p><strong>输出查看方法</strong>    </p><ul><li><p>每一个作用域都以<code>#</code>标识输出  </p></li><li><p>每一个绑定都以<code>-</code>标识输出  </p></li><li><p>对于单次输出，都是自底向上的<br>先输出当前作用域，再输出父级作用域，再输出父级的父级作用域……</p></li><li><p>对于单个绑定<code>Binding</code>，会输出4种信息  </p><ul><li>constant 声明后，是否会被修改  </li><li>references  被引用次数  </li><li>violations  被重新定义的次数  </li><li>kind  函数声明类型。param 参数, hoisted 提升，var 变量， local 内部  </li></ul><p>后续会单独说明<code>Binding</code>对象，此处留个印象即可  </p></li></ul><p><strong>描述</strong><br>此处从两个函数节点输出了其作用域的信息  </p><ul><li>这两个函数都是定义在同一级下的，所以都会输出相同的父级作用域<code>Program</code>的信息  </li><li>你会发现，代码中有非常多个<code>i</code>，有的是函数定义，有的是参数，有的是变量。仔细观察它们的不同之处<br>解释器就是通过 不同层级的作用域 与 绑定定义信息 来区分不同的名称的量的  </li></ul><h2 id="绑定-Binding"><a href="#绑定-Binding" class="headerlink" title="绑定 Binding"></a>绑定 Binding</h2><p><code>Binding</code> 对象用于存储 绑定 的信息<br>这个对象会作为<code>Scope</code>对象的一个属性存在<br>同一个作用域可以包含多个 <code>Binding</code>  </p><p>你可以在 <code>@babel/traverse/lib/scope/binding.js</code> 中查看到它的定义  </p><blockquote><p>显示 Binding 的信息  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">function a()&#123;</span><br><span class="hljs-string">    var a = 1;</span><br><span class="hljs-string">    a = a + 1;</span><br><span class="hljs-string">    return a;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">function b()&#123;</span><br><span class="hljs-string">    var b = 1;</span><br><span class="hljs-string">    var c = 2;</span><br><span class="hljs-string">    b = b - c;</span><br><span class="hljs-string">    return b;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    <span class="hljs-function"><span class="hljs-title">BlockStatement</span>(<span class="hljs-params">path</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;\n此块节点源码：\n&quot;</span>, path.toString())<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;----------------------------------------&#x27;</span>)<br>        <span class="hljs-keyword">var</span> bindings = path.scope.bindings<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;作用域内 被绑定量 数量：&#x27;</span>, <span class="hljs-built_in">Object</span>.keys(bindings).length)<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> binding_ <span class="hljs-keyword">in</span> bindings)&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;名字：&#x27;</span>, binding_)<br>            binding_ = bindings[binding_];<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;类型：&#x27;</span>, binding_.kind)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;定义：&#x27;</span>, binding_.identifier)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是否会被修改：&#x27;</span>, binding_.constant)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被修改信息信息记录&#x27;</span>, binding_.constantViolations)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;是否会被引用：&#x27;</span>, binding_.referenced)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被引用次数&#x27;</span>, binding_.references)<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;被引用信息NodePath记录&#x27;</span>, binding_.referencePaths)<br>        &#125;<br>    &#125;<br>&#125;<br><br>traverse(ast, visitor);<br><br></code></pre></td></tr></table></figure><p>会输出一大堆信息。其对应的意义已经写在代码中，可以自行查看  </p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在解混淆中，作用域与绑定 主要用来处理边界的问题<br>即：某个量哪里引用了，在哪里定义  </p><blockquote><p>例：删除所有定义了, 却从未使用的变量  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> parser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>);<br><span class="hljs-keyword">const</span> traverse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/traverse&quot;</span>).default;<br><span class="hljs-keyword">const</span> generator = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/generator&quot;</span>).default;<br><br><span class="hljs-keyword">const</span> jscode = <span class="hljs-string">`</span><br><span class="hljs-string">var a = 1;</span><br><span class="hljs-string">var b = 2;</span><br><span class="hljs-string">function squire()&#123;</span><br><span class="hljs-string">  var c = 3;</span><br><span class="hljs-string">  var d = 4;</span><br><span class="hljs-string">  return a * d;</span><br><span class="hljs-string">  var e = 5;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">var f = 6;</span><br><span class="hljs-string">`</span>;<br><span class="hljs-keyword">let</span> ast = parser.parse(jscode);<br><span class="hljs-keyword">const</span> visitor = &#123;<br>    VariableDeclarator(path)<br>    &#123;<br>        <span class="hljs-keyword">const</span> func_name = path.node.id.name;<br>        <span class="hljs-keyword">const</span> binding = path.scope.getBinding(func_name);<br>        <span class="hljs-comment">// 如果变量没有被引用过，那么删除也没关系</span><br>        <span class="hljs-comment">//   此处不能用有无修改过进行判断，因为没有被修改过并不意味着没用</span><br>        <span class="hljs-keyword">if</span>(binding &amp;&amp; !binding.referenced)&#123;<br>            path.remove();<br>        &#125;<br>    &#125;,<br>&#125;<br><br><br>traverse(ast, visitor);<br><span class="hljs-built_in">console</span>.log(generator(ast)[<span class="hljs-string">&#x27;code&#x27;</span>]);<br><br></code></pre></td></tr></table></figure><p>得到输出  </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">squire</span><span class="hljs-params">()</span> </span>&#123;<br>  <span class="hljs-keyword">var</span> d = <span class="hljs-number">4</span>;<br>  <span class="hljs-keyword">return</span> a * d;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里使用了<code>Scope.getBinding()</code>方法来获取<code>Binding</code>对象, 判断其引用情况来对语法树进行修改  </p><hr><p><strong>相关链接</strong></p><ul><li>蔡老板的教程：<a href="https://wx.zsxq.com/dweb2/index/group/48415254524248">https://wx.zsxq.com/dweb2/index/group/48415254524248</a>  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>Babel</tag>
      
      <tag>AST</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Https-TLS-SSL</title>
    <link href="/post/ff374aa2/"/>
    <url>/post/ff374aa2/</url>
    
    <content type="html"><![CDATA[<p><strong>前置知识</strong><br><a href="https://evilrecluse.top/post/3b5ddb7/#%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95">对称加密与非对称加密</a>    </p><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>超文本传输安全协议（英语：<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol <strong>S</strong>ecure，缩写：<strong>HTTPS</strong>)  </p><p><code>HTTPS</code> 并非是应用层的一种新协议。 只是 <code>HTTP</code> 通信接口部分用<code>SSL</code>（Secure Socket Layer） 和 <code>TLS</code>（Transport Layer Security） 协议代替而已  </p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h3 id="HTTP的不安全性"><a href="#HTTP的不安全性" class="headerlink" title="HTTP的不安全性"></a>HTTP的不安全性</h3><p><code>Http</code>是明文传输的，由于这个原因，可能出现的风险非常多<br>主要可以分为  <code>窃听风险</code>、<code>篡改风险</code>、<code>冒充风险</code>    </p><blockquote><p>安全通信的四大原则</p></blockquote><ul><li>机密性：即对数据加密，解决了窃听风险  </li><li>完整性：指数据在传输过程中没有被篡改，不多不少，保持原样，中途如果哪怕改了一个标点符号，接收方也能识别出来，从来判定接收报文不合法  </li><li>身份认证：确认对方的真实身份，解决了冒充风险，用户不用担心访问的是某宝结果却在和钓鱼网站通信的问题  </li><li>不可否认: 即不可否认已发生的行为，比如小明向小红借了 1000 元，但没打借条，或者打了借条但没有签名，就会造成小红的资金损失  </li></ul><h3 id="HTTPS的作用"><a href="#HTTPS的作用" class="headerlink" title="HTTPS的作用"></a>HTTPS的作用</h3><p>为了让传输过程中的数据更加安全，需要对传输的信息进行加密<br>为了通信双方能正确 解密对方加密的数据，通信的双方必须约定加密算法<br><code>SSL</code>/<code>TLS</code>主要负责事情：让双方 <strong>安全地</strong> 约定加密算法 </p><blockquote><p>加密策略<br>为了兼顾速度与安全性。通常采用的策略：<br>对称加密算法加密数据，非对称加密算法加密 对称加密的密钥的方式进行加密  </p></blockquote><br><blockquote><p><code>HTTPS</code> 的主要作用是在不安全的网络上创建一个安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的防护<br><a href="https://zh.wikipedia.org/wiki/%E5%82%B3%E8%BC%B8%E5%B1%A4%E5%AE%89%E5%85%A8%E6%80%A7%E5%8D%94%E5%AE%9A">维基百科</a>  </p></blockquote><h2 id="SSL与TLS"><a href="#SSL与TLS" class="headerlink" title="SSL与TLS"></a>SSL与TLS</h2><p>传输层安全性协议（英语：<strong>T</strong>ransport <strong>L</strong>ayer <strong>S</strong>ecurity，缩写：TLS）<br>安全套接层（英语：<strong>S</strong>ecure <strong>S</strong>ockets <strong>L</strong>ayer，缩写：SSL）  </p><p><code>TLS</code>实际上是<code>SSL</code>进行标准化后得到的产物，<code>TLS</code>几乎可以理解为是<code>SSL</code>的别称<br><code>SSL</code>已被弃用，现在使用的基本都为<code>TLS</code>  </p><table><thead><tr><th>协议</th><th>发布时间</th><th>状态</th></tr></thead><tbody><tr><td>SSL 1.0</td><td>未公布</td><td>未公布</td></tr><tr><td>SSL 2.0</td><td>1995年</td><td>已于2011年弃用</td></tr><tr><td>SSL 3.0</td><td>1996年</td><td>已于2015年弃用</td></tr><tr><td>TLS 1.0</td><td>1999年</td><td></td></tr><tr><td>TLS 1.1</td><td>2006年</td><td></td></tr><tr><td>TLS 1.2</td><td>2008年</td><td></td></tr><tr><td>TLS 1.3</td><td>2018年</td><td></td></tr></tbody></table><h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>讲述升级思路  </p><h2 id="一、全数据对称加密"><a href="#一、全数据对称加密" class="headerlink" title="一、全数据对称加密"></a>一、全数据对称加密</h2><p>在认识到<code>HTTP</code>不安全后，双方决定对数据进行加密<br><strong>情景</strong>  </p><ol><li>一方决定<code>对称加密密钥</code>  </li><li>发送<code>对称加密密钥</code>给对方  </li><li>利用<code>对称加密密钥</code>建立通信，传输<code>被对称加密的数据</code>  </li></ol><p><strong>网络上暴露的内容</strong><br>这个过程，双方交换了：<code>对称加密密钥</code>、<code>被对称加密的数据</code>  </p><p><strong>结果</strong><br>显然这个加密就跟没有一样，用<code>对称加密密钥</code>解开<code>被对称加密的数据</code>就能拿到明文了  </p><h2 id="二、非对称-对称加密"><a href="#二、非对称-对称加密" class="headerlink" title="二、非对称+对称加密"></a>二、非对称+对称加密</h2><p>在认识到直接交换 <code>对称加密密钥</code> 不安全, <code>非对称加密</code>计算速度很慢后<br>进行了折中的处理  </p><p><strong>情景</strong>  </p><ol><li>双方都各自根据<code>对称加密算法</code>生成 公钥 与 私钥  </li><li>（交换）双方交换<code>对称加密公钥</code>  </li><li>服务器使用<code>对称加密算法</code>对数据进行加密，得到了 <code>被对称加密的数据</code> 与 <code>对称加密密钥</code>  </li><li>用 <code>客户端的非对称加密公钥</code> 加密 <code>对称加密密钥</code>，得到 <code>被客户端公钥加密的&quot;对称加密密钥&quot;</code>  </li><li>（交换）传输 <code>被客户端公钥加密的 对称加密公钥</code> 给客户端  </li><li>客户端收到服务器的数据。使用客户端私钥解开 <code>被客户端公钥加密的 &quot;对称加密公钥&quot;</code> 的加密，得到 <code>对称加密密钥</code>  </li><li>利用<code>对称加密密钥</code>建立通信，传输<code>被对称加密的数据</code>  </li></ol><p><strong>网络上暴露的内容</strong><br><code>服务器对称加密公钥</code>、<code>客户端对称加密公钥</code>、<code>被客户端公钥加密的 对称加密公钥</code>  </p><p><strong>结果</strong><br>中间人攻击的可能<br><img src="/Https-TLS-SSL/20210115095213018.png"></p><h2 id="三、数字证书，数字签名"><a href="#三、数字证书，数字签名" class="headerlink" title="三、数字证书，数字签名"></a>三、数字证书，数字签名</h2><p>现实生活中，员工入职时，企业一般会要求提供学历证明。这个学历必须由第三方权威机构（<code>Certificate Authority</code>，简称 <code>CA</code>）即教育部颁发  </p><p>服务端 也可以向 <code>CA</code> 申请证书，在证书中附上公钥，然后将证书传给 客户端  </p><p><strong>证书基本的信息</strong><br><img src="/Https-TLS-SSL/20210118095916986.png"><br>证书由站点管理者向 <code>CA</code> 申请，申请的时候会提交 <code>DNS</code> 主机名等信息，<code>CA</code> 会根据这些信息生成证书  </p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>本质：被<code>CA</code>私钥加密过的证书主要内容的摘要信息<br>作用：验证证书的真实性，防止证书被篡改  </p><p><strong>数字证书（含数字签名）的生成过程</strong>  </p><ol><li>服务端 向CA发出申请，提交自己服务器的信息，交钱，请求生成证书  </li><li>CA根据服务端提供的信息，生成证书的主要内容  </li><li>将证书的主要内容整合，用摘要算法计算出 证书摘要值  </li><li>用<code>CA</code>私钥对 证书摘要值 进行加密，得到 <code>被CA私钥加密的 CA计算的证书摘要值</code> 即 <code>数字签名</code>  </li><li><code>CA</code>将数字签名写入证书之中   </li><li><code>CA</code>返回 <code>数字证书</code> 给服务端  </li></ol><p><img src="/Https-TLS-SSL/20210118101412498.png">  </p><p><strong>数字证书的使用</strong><br><img src="/Https-TLS-SSL/20210118111039145.png">  </p><ol><li>在客户端，服务端交换密钥时，服务端返回 <code>数字证书</code> 给客户端，而不是单纯的服务器公钥  </li><li>客户端收到 <code>数字证书</code>。使用操作系统自带的 <code>CA</code>公钥 对 <code>被CA私钥加密的 证书摘要值</code>进行解密，得到 <code>CA计算的证书摘要值</code>  </li><li>客户端根据证书内容计算摘要 得到 <code>客户端计算的证书摘要值</code>  </li><li>客户端使用 <code>客户端计算的证书摘要值</code> 与  <code>CA计算的证书摘要值</code>进行对比。如果摘要值一致，说明内容未被篡改  </li></ol><p>其中第2、3、4步被称为<code>验签</code>  </p><blockquote><p><strong>为何只是对摘要进行加密？</strong><br>非对称加密算法效率低下，速度过慢  </p></blockquote><p><span></span></p><blockquote><p><strong>客户端操作系统自带<code>CA公钥</code>？</strong><br>如果<code>CA</code>公钥通过网络传输，那么依然存在被攻击的可能，情况与前面说明的中间人攻击类似 <img src="/Https-TLS-SSL/20210118113727467.png"><br>为了解决这个套娃问题，<code>CA</code>公司 与 操作系统公司 达成了PY交易，使它们的证书内置在了操作系统里面   </p></blockquote><p><span></span></p><blockquote><p><strong>那么抓包工具如何工作</strong><br>在用 <code>charles</code> 抓 HTTPS 的包之前我们先要安装 charles 的证书<br>这个证书里有 <code>charles</code> 的公钥，这样的话 <code>charles</code> 就可以将 server 传给 client 的证书调包成自己的证书<br>client 拿到后就可以用你安装的 <code>charles</code> 证书来验签等，验证通过之后就会用 <code>charles</code> 证书中的公钥来加密对称密钥了<br><img src="/Https-TLS-SSL/20210118114203571.png">  </p></blockquote><h3 id="证书信任链"><a href="#证书信任链" class="headerlink" title="证书信任链"></a>证书信任链</h3><p>全世界的顶级 <code>CA</code>（Root CA） 就只有那几个。但它可以向下一级<code>CA</code>，下下级 <code>CA</code> 授权。所以一个 一级/二级/三级 <code>CA</code> 也是可以申请证书的  </p><blockquote><p><strong>怎么证明这些 下级<code>CA</code>证书被 <code>Root CA</code> 授权过了?</strong><br>下一级 <code>CA</code> 可以让上一级 <code>CA</code> 来签名认证，比如一级 <code>CA</code> 让 <code>Root CA</code> 来签名认证，二级 <code>CA</code> 让一级 <code>CA</code> 来签名认证  </p></blockquote><blockquote><p><code>Root CA</code> 没有人给他签名认证，只能自己证明自己了，这个证书就叫「自签名证书」或者「根证书」，我们必须信任它，不然证书信任链是走不下去的  </p></blockquote><blockquote><p>「根证书」就是那些内置在操作系统中的证书  </p></blockquote><p><strong>客户端认证</strong><br>如果站点申请的是二级 <code>CA</code> 颁发的证书，<code>服务端</code> 传了传给二级 <code>CA</code> 的证书外，还会把证书信任链也一起传给客户端<br>这样客户端会逐级验签进行验证：  </p><ol><li>浏览器使用信任的根证书（根公钥）解析证书链的根证书得到一级 证书的公钥 + 摘要验签  </li><li>拿一级证书的公钥解密一级证书，拿到二级证书的公钥和摘要验签  </li><li>拿二级证书的公钥解密 服务端 传过来的二级证书<br>……<br>直到得到服务器的公钥和摘要验签，验证过程就结束了  </li></ol><h1 id="SSL流程-四次握手"><a href="#SSL流程-四次握手" class="headerlink" title="SSL流程-四次握手"></a>SSL流程-四次握手</h1><p><img src="/Https-TLS-SSL/20210111041424432.png">  </p><h2 id="一次握手"><a href="#一次握手" class="headerlink" title="一次握手"></a>一次握手</h2><h3 id="1-客户端通过发送-Client-Hello-报文-开始-SSL通信"><a href="#1-客户端通过发送-Client-Hello-报文-开始-SSL通信" class="headerlink" title="1. 客户端通过发送 Client Hello 报文 开始 SSL通信"></a>1. 客户端通过发送 <code>Client Hello 报文</code> 开始 SSL通信</h3><p>报文中包含客户端支持的 <code>SSL版本</code>、 加密组件（CipherSuite） 列表（客户端支持的加密算法 及 密钥长度等）  </p><blockquote><p>维基百科-加密组件-CipherSuite：<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%A5%97%E4%BB%B6">链接</a>  </p></blockquote><h2 id="二次握手"><a href="#二次握手" class="headerlink" title="二次握手"></a>二次握手</h2><h3 id="2-服务器可进行-SSL通信-时，会以-Server-Hello-报文-作为应答"><a href="#2-服务器可进行-SSL通信-时，会以-Server-Hello-报文-作为应答" class="headerlink" title="2. 服务器可进行 SSL通信 时，会以 Server Hello 报文 作为应答"></a>2. 服务器可进行 SSL通信 时，会以 <code>Server Hello 报文</code> 作为应答</h3><p>和客户端一样, 在报文中包含 <code>SSL</code>版本 以及 <code>加密组件</code><br>服务器的加密组件内容 是 从接收到的客户端加密组件内 筛选出来的  </p><ul><li>因为是要进行通信的，所以加密组件必须是双方都有的  </li><li>服务器也可以根据客户端的加密组件拒绝相应  </li></ul><h3 id="3-之后服务器发送-Certificate-报文"><a href="#3-之后服务器发送-Certificate-报文" class="headerlink" title="3. 之后服务器发送 Certificate 报文"></a>3. 之后服务器发送 <code>Certificate 报文</code></h3><p>报文中包含公开密钥证书  </p><h3 id="4-最后服务器发送-Server-Hello-Done-报文-通知客户端"><a href="#4-最后服务器发送-Server-Hello-Done-报文-通知客户端" class="headerlink" title="4. 最后服务器发送 Server Hello Done 报文 通知客户端"></a>4. 最后服务器发送 <code>Server Hello Done 报文</code> 通知客户端</h3><p>至此，最初阶段的 SSL握手协商部分结束  </p><h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><h3 id="5-客户端以-Client-Key-Exchange-报文作为回应"><a href="#5-客户端以-Client-Key-Exchange-报文作为回应" class="headerlink" title="5. 客户端以 Client Key Exchange 报文作为回应"></a>5. 客户端以 <code>Client Key Exchange 报文</code>作为回应</h3><p>报文中包含通信加密中使用的一种被称为 <code>Pre-mastersecret</code> 的随机密码串<br>该报文已用步骤 3 中的公开密钥进行加密  </p><h3 id="6-接着客户端继续发送-Change-Cipher-Spec-报文"><a href="#6-接着客户端继续发送-Change-Cipher-Spec-报文" class="headerlink" title="6. 接着客户端继续发送 Change Cipher Spec 报文"></a>6. 接着客户端继续发送 <code>Change Cipher Spec 报文</code></h3><p>该报文会提示服务器，在此报文之后的通信会采用<code>Pre-master secret</code> 密钥加密  </p><h3 id="7-客户端发送-Finished-报文"><a href="#7-客户端发送-Finished-报文" class="headerlink" title="7. 客户端发送 Finished 报文"></a>7. 客户端发送 <code>Finished 报文</code></h3><p>该报文包含连接至今全部报文的整体校验值<br>这次握手协商是否能够成功， 要以服务器是否能够正确解密该报文作为判定标准  </p><h2 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h2><h3 id="8-服务器同样发送-Change-Cipher-Spec-报文"><a href="#8-服务器同样发送-Change-Cipher-Spec-报文" class="headerlink" title="8. 服务器同样发送 Change Cipher Spec 报文"></a>8. 服务器同样发送 <code>Change Cipher Spec 报文</code></h3><h3 id="9-服务器同样发送-Finished-报文"><a href="#9-服务器同样发送-Finished-报文" class="headerlink" title="9. 服务器同样发送 Finished 报文"></a>9. 服务器同样发送 <code>Finished 报文</code></h3><p>总的来说，SSL会话的建立完成了以下几个工作：<br>交换协议版本号，选择一个通信双方都支持的加密方式；对两端实现身份验证；密钥交换<br>服务器和客户端的 <code>Finished</code> 报文交换完毕之后， <code>SSL</code>连接就算建立完成，通信会受到 <code>SSL</code>的保护。 从此处开始进行应用层协议的通信， 即发送 <code>HTTP</code> 请求  </p><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="可否修改443端口"><a href="#可否修改443端口" class="headerlink" title="可否修改443端口"></a>可否修改443端口</h2><p><code>Https</code>传输数据，需要服务器开启两个端口<code>80</code>与<code>443</code><br>其中，<code>443</code>端口仅用来建立连接，并不传输真正的数据 </p><p><code>443</code>端口是约定的<code>Https</code>端口，被写入到了浏览器中<br>浏览器在域名中识别到<code>https</code>，就默认请求<code>443</code>  </p><p>如果你修改了<code>https</code>端口，又没有特别指定访问端口。那么用户会无法用浏览器访问（浏览器访问<code>443</code>发现无响应）  </p><h1 id="HTTPS的缺点"><a href="#HTTPS的缺点" class="headerlink" title="HTTPS的缺点"></a>HTTPS的缺点</h1><ul><li>变慢  <ul><li>网络<br>和使用 HTTP 相比， 网络负载可能会变慢 2 到 100 倍。进行 SSL通信 使得整体上处理通信量不可避免会增加  </li><li>处理速度<br>加密/解密 要大量消耗CPU 及内存等资源，导致处理速度变慢  </li></ul></li><li>证书购买花销<br>证书并不是免费的，是需要向 认证机构（CA） 购买的  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Https</tag>
      
      <tag>TLS</tag>
      
      <tag>SSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>部署高匿代理-Squid</title>
    <link href="/post/b9157208/"/>
    <url>/post/b9157208/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>用<code>Squid</code>来部署一个高匿代理服务到服务器  </p><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="安装-Squid-与-Httpd"><a href="#安装-Squid-与-Httpd" class="headerlink" title="安装 Squid 与 Httpd"></a>安装 Squid 与 Httpd</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y openssl squid<br>yum install httpd<br></code></pre></td></tr></table></figure><p><code>Squid</code>自然是服务器主体<br><code>Httpd</code>是用于生成密码文件的  </p><blockquote><p>网上为什么那么多的免费代理，有一部分原因就是因为服务器转发没有设置密码，被黑客扫端口扫出来直接用了  </p></blockquote><h2 id="创建密码文件"><a href="#创建密码文件" class="headerlink" title="创建密码文件"></a>创建密码文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">htpasswd -c /etc/squid/passwd EvilRecluse<br></code></pre></td></tr></table></figure><blockquote><p>命令说明：  </p></blockquote><ul><li>htpasswd<br><code>htpasswd</code> 用来创建和更新用于基本认证的用户认证密码文件  </li><li>-c<br>创建参数。创建密码文件，如果文件存在，那么内容被清空重写</li><li>/etc/squid/passwd<br>密码文件路径，此处生成文件在<code>squid</code>目录下<code>passwd</code>文件中  </li><li>EvilRecluse<br>用户名，随便填，但要记住  </li></ul><blockquote><p><a href="#%E9%99%84%E5%BD%95">附录：关于htpasswd命令</a></p></blockquote><p>命令输入后会让你输入密码，输入完密码文件就生成了<br>此处生成的密码文件会被用于代理访问，以防端口被扫后就随便访问  </p><h2 id="配置-Squid"><a href="#配置-Squid" class="headerlink" title="配置 Squid"></a>配置 Squid</h2><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs vim"># localnet 网络ip配置<br>acl localnet src <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">0</span>    # <span class="hljs-keyword">all</span> network<br>acl localnet src <span class="hljs-number">10.0</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">8</span>    # RFC1918 possible internal network<br>acl localnet src <span class="hljs-number">172.16</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">12</span>    # RFC1918 possible internal network<br>acl localnet src <span class="hljs-number">192.168</span>.<span class="hljs-number">0.0</span>/<span class="hljs-number">16</span>    # RFC1918 possible internal network<br>acl localnet src fc00::/<span class="hljs-number">7</span>       # RFC <span class="hljs-number">4193</span> local private network <span class="hljs-built_in">range</span><br>acl localnet src fe80::/<span class="hljs-number">10</span>      # RFC <span class="hljs-number">4291</span> link-local (directly plugged) machines<br><br># SSL_ports SSL端口配置<br>acl SSL_ports port <span class="hljs-number">443</span><br><br># Safe_ports 端口配置<br>acl Safe_ports port <span class="hljs-number">80</span>        # http<br>acl Safe_ports port <span class="hljs-number">21</span>        # ftp<br>acl Safe_ports port <span class="hljs-number">443</span>        # https<br>acl Safe_ports port <span class="hljs-number">70</span>        # gopher<br>acl Safe_ports port <span class="hljs-number">210</span>        # wais<br>acl Safe_ports port <span class="hljs-number">1025</span>-<span class="hljs-number">65535</span>    # unregistered ports<br>acl Safe_ports port <span class="hljs-number">280</span>        # http-mgmt<br>acl Safe_ports port <span class="hljs-number">488</span>        # gss-http<br>acl Safe_ports port <span class="hljs-number">591</span>        # filemaker<br>acl Safe_ports port <span class="hljs-number">777</span>        # multiling http<br><br># CONNECT 连接方法<br>acl CONNECT method CONNECT<br><br># 拒绝所有 非Safe_ports 端口的访问<br>http_access deny !Safe_ports<br># 拒绝所有 非SSL_ports 的连接方法<br>http_access deny CONNECT !SSL_ports<br># 允许<br>http_access allow localhost manager<br>http_access deny manager<br><br># http访问端口为 <span class="hljs-number">65000</span> 注意！！！<br># 以后要用代理就靠这个端口了<br>http_port <span class="hljs-number">65000</span><br><br># squid启动目录<br>coredump_dir /var/spool/squid<br><br># 缓存新旧刷新相关配置<br>refresh_pattern ^ftp:        <span class="hljs-number">1440</span>    <span class="hljs-number">20</span>%    <span class="hljs-number">10080</span><br>refresh_pattern ^gopher:    <span class="hljs-number">1440</span>    <span class="hljs-number">0</span>%    <span class="hljs-number">1440</span><br>refresh_pattern -i (/cgi-bin/|\?) <span class="hljs-number">0</span>    <span class="hljs-number">0</span>%    <span class="hljs-number">0</span><br>refresh_pattern .        <span class="hljs-number">0</span>    <span class="hljs-number">20</span>%    <span class="hljs-number">4320</span><br><br># via 用于检测转发循环，设置禁止则可以避免循环<br>via off<br><br># 转发头部标识删除<br>forwarded_for <span class="hljs-keyword">delete</span><br>forwarded_for off<br><br># 包含特定头部的请求禁止访问<br>request_header_access From deny <span class="hljs-keyword">all</span><br>request_header_access Server deny <span class="hljs-keyword">all</span><br>request_header_access WWW-Authenticate deny <span class="hljs-keyword">all</span><br>request_header_access Link deny <span class="hljs-keyword">all</span><br>request_header_access Cache-Control deny <span class="hljs-keyword">all</span><br>request_header_access Proxy-Connection deny <span class="hljs-keyword">all</span><br>request_header_access <span class="hljs-keyword">X</span>-Cache deny <span class="hljs-keyword">all</span><br>request_header_access <span class="hljs-keyword">X</span>-Cache-Lookup deny <span class="hljs-keyword">all</span><br>request_header_access Via deny <span class="hljs-keyword">all</span><br>request_header_access <span class="hljs-keyword">X</span>-Forwarded-For deny <span class="hljs-keyword">all</span><br>request_header_access Pragma deny <span class="hljs-keyword">all</span><br>request_header_access Keep-Alive deny <span class="hljs-keyword">all</span><br><br># 关闭squid的缓存功能<br>acl NCACHE method GET<br>no_cache deny NCACHE<br><br># 用户认证<br>auth_param basic program /usr/lib64/squid/basic_ncsa_auth /etc/squid/passwd<br>acl EvilRecluse proxy_auth REQUIRED<br>http_access allow EvilRecluse<br></code></pre></td></tr></table></figure><h1 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h1><p><a id="附录"></a></p><ul><li><a href="https://www.cnblogs.com/wj78080458/p/10847976.html">htpasswd命令详细</a>  </li><li><a href="https://blog.csdn.net/wangpengqi/article/details/9224841">关于Squild via</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>Squid</tag>
      
      <tag>代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>特殊想法-奇思妙想</title>
    <link href="/post/a7b96945/"/>
    <url>/post/a7b96945/</url>
    
    <content type="html"><![CDATA[<ul><li><p>浏览器xpath插件不支持基于指定节点 </p></li><li><p>Babel抽象语法树函数内无法分辨 外部参数 是可变量还是不可变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">z</span>(<span class="hljs-params">x</span>)</span>&#123;x=x+<span class="hljs-number">1</span>&#125;<br>z(a);<br><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-comment">// -------------------------------------</span><br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">z</span>(<span class="hljs-params">x</span>)</span>&#123;x.push(<span class="hljs-number">4</span>)&#125;<br>z(a);<br><span class="hljs-built_in">console</span>.log(a);<br></code></pre></td></tr></table></figure><p>你无法判断可以不可删除z函数，因为它的计算可能会影响a</p></li><li><p>Babel, 在调用<code>path.evaluate</code> 方法时，它只处理了<code>string&quot;.length</code>这种方式的表达式，而 <code>&quot;string&quot;[&quot;length&quot;]</code>并未直接处理</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>奇思妙想</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MessagePack</title>
    <link href="/post/d52eeddc/"/>
    <url>/post/d52eeddc/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>MessagePack</code>是一种有效的二进制序列化格式<br>相比与于JSON，它处理起来更快，生成的文件也更小<br>小整数被编码为一个字节，典型的短字符串除字符串本身外仅需要一个额外的字节<br><img src="/MessagePack/20201130085302466.png">  </p><p>但是这东西的问题其实也很多  </p><ul><li>兼容性问题。不同语言的客户端的不同版本经常发生兼容性  </li><li>对于二进制安全需求，json有base64方案。事实上，浏览器就对base64友好  </li><li>对于rpc序列化需求，高性能有protobuf，后面有json，并没有很大的优势  </li></ul><p>官网：<a href="https://msgpack.org/">https://msgpack.org/</a>  </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install msgpack<br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="pack-amp-unpack-打包与解包"><a href="#pack-amp-unpack-打包与解包" class="headerlink" title="pack &amp; unpack 打包与解包"></a>pack &amp; unpack 打包与解包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> msgpack<br><span class="hljs-comment"># 打包函数packb，类似于json.dumps</span><br>msgpack.packb([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], use_bin_type=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 此处得到结果：&#x27;\x93\x01\x02\x03&#x27;</span><br><br><span class="hljs-comment"># 解包函数unpackb，类似于json.loads</span><br>msgpack.unpackb(_, raw=<span class="hljs-literal">False</span>)<br><span class="hljs-comment"># 此处得到结果：[1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>此处的解包函数得到的结果是一个<code>List</code>，如果希望得到的是<code>tunple</code>可以添加参数  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">msgpack.unpackb(<span class="hljs-string">b&#x27;\x93\x01\x02\x03&#x27;</span>, use_list=<span class="hljs-literal">False</span>, raw=<span class="hljs-literal">False</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure><h2 id="Streaming-unpacking-流解包"><a href="#Streaming-unpacking-流解包" class="headerlink" title="Streaming unpacking  流解包"></a>Streaming unpacking  流解包</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> msgpack<br><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIO<br><br><span class="hljs-comment"># 向流中写入一些内容以用作试验</span><br>buf = BytesIO()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    buf.write(msgpack.packb(i, use_bin_type=<span class="hljs-literal">True</span>))<br><br>buf.seek(<span class="hljs-number">0</span>)<br><br>unpacker = msgpack.Unpacker(buf, raw=<span class="hljs-literal">False</span>)<br><span class="hljs-keyword">for</span> unpacked <span class="hljs-keyword">in</span> unpacker:<br>    print(unpacked)<br></code></pre></td></tr></table></figure><p>解包函数可以从流（或从通过其feed方法提供的字节）中解出多个对象  </p><h2 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h2><p>使用<code>ext</code>能够扩充打包/解包的类型  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> msgpack<br><span class="hljs-keyword">import</span> array<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">default</span>(<span class="hljs-params">obj</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(obj, array.array) <span class="hljs-keyword">and</span> obj.typecode == <span class="hljs-string">&#x27;d&#x27;</span>:<br>        <span class="hljs-keyword">return</span> msgpack.ExtType(<span class="hljs-number">42</span>, obj.tostring())<br>    <span class="hljs-keyword">raise</span> TypeError(<span class="hljs-string">&quot;Unknown type: %r&quot;</span> % (obj,))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ext_hook</span>(<span class="hljs-params">code, data</span>):</span><br>    <span class="hljs-keyword">if</span> code == <span class="hljs-number">42</span>:<br>        a = array.array(<span class="hljs-string">&#x27;d&#x27;</span>)<br>        a.fromstring(data)<br>        <span class="hljs-keyword">return</span> a<br>    <span class="hljs-keyword">return</span> ExtType(code, data)<br><br>data = array.array(<span class="hljs-string">&#x27;d&#x27;</span>, [<span class="hljs-number">1.2</span>, <span class="hljs-number">3.4</span>])<br>packed = msgpack.packb(data, default=default, use_bin_type=<span class="hljs-literal">True</span>)<br>unpacked = msgpack.unpackb(packed, ext_hook=ext_hook, raw=<span class="hljs-literal">False</span>)<br>print(data == unpacked)<br><span class="hljs-comment"># True</span><br></code></pre></td></tr></table></figure><h2 id="解包控制"><a href="#解包控制" class="headerlink" title="解包控制"></a>解包控制</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> io <span class="hljs-keyword">import</span> BytesIO<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">distribute</span>(<span class="hljs-params">unpacker, get_worker</span>):</span><br>    nelems = unpacker.read_map_header()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(nelems):<br>        <span class="hljs-comment"># Select a worker for the given key</span><br>        key = unpacker.unpack()<br>        worker = get_worker(key)<br><br>        <span class="hljs-comment"># Send the value as a packed message to worker</span><br>        bytestream = BytesIO()<br>        unpacker.skip(bytestream.write)<br>        worker.send(bytestream.getvalue())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>MessagePack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-UUID</title>
    <link href="/post/7db30d0/"/>
    <url>/post/7db30d0/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>UUID（Universally Unique Identifier）是通用唯一识别码，在许多领域用作标识<br>常用的数据库也可以用它来作为主键，原理上它是可以对任何东西进行唯一的编码  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>如果你想要的只是一个唯一的ID，你应该用 <code>uuid1()</code>或<code>uuid4()</code>，但是要注意，<code>uuid1()</code>可能会危害隐私.  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> uuid<br> <br><span class="hljs-built_in">print</span> uuid.uuid1()<br><span class="hljs-comment"># bf1dfacf-67d8-11e8-9a23-408d5c985711</span><br><span class="hljs-built_in">print</span> uuid.uuid3(uuid.NAMESPACE_DNS, <span class="hljs-string">&#x27;yuanlin&#x27;</span>)<br><span class="hljs-comment"># ddb366f5-d4bc-3a20-ac68-e13c0560058f</span><br><span class="hljs-built_in">print</span> uuid.uuid4()<br><span class="hljs-comment"># 144d622b-e83a-40ea-8ca1-66af8a86261c</span><br><span class="hljs-built_in">print</span> uuid.uuid5(uuid.NAMESPACE_DNS, <span class="hljs-string">&#x27;yuanlin&#x27;</span>)<br><span class="hljs-comment"># 4a47c18d-037a-5df6-9e12-20b643c334d3</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>生成方法</th><th>信息</th></tr></thead><tbody><tr><td>uuid1()</td><td>根据当前的时间戳和MAC地址生成</td><td>最后的12个字符408d5c985711对应的就是MAC地址。暴露MAC地址，可能造成安全隐患</td></tr><tr><td>uuid3()</td><td>根据指定的 <code>namespace</code> 和 具体的字符串 通过MD5生成</td><td><code>namespace</code>内唯一</td></tr><tr><td>uuid4()</td><td>基于随机数</td><td>存在相同的可能性</td></tr><tr><td>uuid5()</td><td>根据指定的 <code>namespace</code> 和 具体的字符串 通过SHA1生成</td><td><code>namespace</code>内唯一</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>uuid</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-Redlock-锁-Redis分布式锁</title>
    <link href="/post/d84e1cb8/"/>
    <url>/post/d84e1cb8/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>官方算法文章：<a href="https://redis.io/topics/distlock">https://redis.io/topics/distlock</a><br>redlock-py pypi: <a href="https://pypi.org/project/redlock-py/">https://pypi.org/project/redlock-py/</a><br>redlock-py github: <a href="https://github.com/SPSCommerce/redlock-py">https://github.com/SPSCommerce/redlock-py</a>  </p><h1 id="安全和可靠性保证"><a href="#安全和可靠性保证" class="headerlink" title="安全和可靠性保证"></a>安全和可靠性保证</h1><p>实现高效分布式锁的基础  </p><ul><li>一致性<br>互斥。不管任何时候，只有一个客户端能持有同一个锁  </li><li>分区可容忍性<br>不会死锁，最终一定会得到锁，就算一个持有锁的客户端宕掉或者发生网络分区  </li><li>可用性<br>只要大多数<code>Redis</code>节点正常工作，客户端应该都能获取和释放锁  </li></ul><h1 id="锁的基础"><a href="#锁的基础" class="headerlink" title="锁的基础"></a>锁的基础</h1><p><code>Redis</code>中本身包含一些命令可以用来实现锁的功能，比如<code>SETNX</code><br>思路:<br>如果 <code>key</code> 不存在，将 <code>key</code> 设置为 <code>value</code><br>如果 <code>key</code> 已存在，则 <code>SETNX</code> 不做任何动作  </p><ol><li>客户端A请求服务器设置key的值，如果设置成功就表示加锁成功  </li><li>客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败  </li><li>客户端A执行代码完成，删除锁  </li><li>客户端B在等待一段时间后在去请求设置key的值，设置成功  </li><li>客户端B执行代码完成，删除锁  </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$redis</span>-&gt;setNX(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$value</span>);<br><span class="hljs-variable">$redis</span>-&gt;expire(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$ttl</span>);<br></code></pre></td></tr></table></figure><blockquote><h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><p>如果请求执行因为某些原因意外退出了，导致创建了锁但是没有删除锁，那么这个锁将一直存在，以至于以后缓存再也得不到更新。<br>为 <code>key</code> 设置过期时间能够确保锁最终能够得到释放    </p></blockquote><blockquote><h3 id="请求与等待-的循环"><a href="#请求与等待-的循环" class="headerlink" title="请求与等待 的循环"></a>请求与等待 的循环</h3><p>程序不能因为发现资源被锁上了就直接停止<br>过于频繁的请求会让服务器压力变大<br>等待的时间应该为一个合理的随机数，因为如果多个客户端同时重试，那么可能会导致谁都无法拿到锁的情况出现  </p></blockquote><p>但是用来设置过期时间的 <code>Expire</code>命令 并不是原子性操作了, 所以需要设置<code>事务</code>来确保原子性  </p><ol><li>客户端A请求服务器设置key的值，如果设置成功就表示加锁成功</li><li>客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败</li><li>客户端A执行代码完成，删除锁</li><li>客户端B在等待一段时间后在去请求设置key的值，设置成功</li><li>客户端B执行代码完成，删除锁</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$redis</span>-&gt;<span class="hljs-built_in">set</span>(<span class="hljs-variable">$key</span>, <span class="hljs-variable">$value</span>, array(<span class="hljs-string">&#x27;nx&#x27;</span>, <span class="hljs-string">&#x27;ex&#x27;</span> =&gt; <span class="hljs-variable">$ttl</span>));  //ex表示秒<br></code></pre></td></tr></table></figure><h2 id="关于键的值"><a href="#关于键的值" class="headerlink" title="关于键的值"></a>关于键的值</h2><p>值会被填入一个随机数，且必须在所有获取锁请求的客户端里保持唯一<br>键值是用来保证能安全地释放锁的，删除前需要做对比。单纯的用<code>DEL</code>指令有可能造成一个客户端删除了其他客户端的锁  </p><blockquote><p>例: 为什么要设置一个特殊的值  </p><ol><li>A客户端拿到了锁，被某个操作阻塞了很长时间，过了超时时间后自动释放了这个锁  </li><li>B客户端来了，申请，拿到了这个锁  </li><li>A客户端操作结束，尝试删除这个其实已经被其他客户端拿到的锁  <blockquote><p>如果此时没有设置随机数作校对，那么会删掉B的锁  </p></blockquote></li></ol></blockquote><h1 id="Redlock算法"><a href="#Redlock算法" class="headerlink" title="Redlock算法"></a>Redlock算法</h1><p>假设有<code>N</code>个<code>Redis master</code>节点  </p><blockquote><p><strong><code>N</code>是个奇数</strong><br>因为流程中有 <strong>过半数</strong> 这种判断，如果是偶数，那么将无法完成判断<br>节点越多，越能避免部分节点宕机造成的影响，但也越浪费资源    </p></blockquote><ol><li><p>获取当前时间（单位是毫秒）  </p></li><li><p>用 相同的<code>key</code>和随机值 在<code>N</code>个节点上逐一请求锁<br>客户端在每个<code>master</code>上请求锁时，会有一个比总的 <code>锁释放时间</code> 小很多的 <code>连接超时时间</code>  </p><blockquote><p>比如:如果锁自动释放时间是10秒钟，那每个节点锁请求的超时时间可能是5-50毫秒的范围  </p></blockquote><p>设置<strong>连接超时时间</strong> 可以防止一个客户端在某个宕掉的<code>master</code>节点上阻塞过长时间（避免<strong>总连接时间</strong>接近/超过<strong>锁释放时间</strong>）  </p></li><li><p>客户端计算第二步中获取锁所花的总时间  </p></li><li><p>进行判断<br>只有当客户端在过半数<code>master</code>节点上成功获取了锁，而且 <code>总共消耗的时间</code> 不超过 <code>锁释放时间</code>，这个锁才会被认为是获取成功  </p></li></ol><ul><li>如果锁获取成功了<br>那现在锁自动释放时间就是最初的锁释放时间减去之前获取锁所消耗的时间  </li><li>如果锁获取失败了<br>客户端会到每个<code>master</code>节点上释放锁，即便是那些他认为没有获取成功的锁  </li></ul><p>客户端如果没有在多数节点获取到锁，一定要尽快在获取锁成功的节点上释放锁，这样就没必要等到<code>key</code>超时后才能重新获取这个锁（但是如果网络分区的情况发生而且客户端无法连接到<code>Redis</code>节点时，会损失等待key超时这段时间的系统可用性）  </p><h1 id="扩展锁"><a href="#扩展锁" class="headerlink" title="扩展锁"></a>扩展锁</h1><p>如果客户端做的工作都是由一些小的步骤组成，那么就有可能使用更小的默认锁有效时间，而且扩展这个算法来实现一个锁扩展机制<br>客户端如果在执行计算期间发现锁快要超时了，客户端可以给所有服务实例发送一个命令，让<code>master</code>端延长锁的时间<br>只要这个锁的 <code>key</code> 还存在而且值还等于客户端获取时的那个值。 客户端应当只有在 失效时间内无法延长锁时 再去重新获取锁（基本上这个和获取锁的算法是差不多的）  </p><h1 id="安全性的论证"><a href="#安全性的论证" class="headerlink" title="安全性的论证"></a>安全性的论证</h1><p>可以观察不同场景下的情况来理解这个算法为什么是安全的。 </p><p>假设客户端可以在大多数节点都获取到锁，这样所有的节点都会包含一个有相同存活时间的<code>key</code>。需要注意的是，这个<code>key</code>是在不同时间点设置的，所以这些key也会在不同的时间超时  </p><p>假设最坏情况下：  </p><ul><li>第一个<code>key</code>是在<code>T1</code>时间设置的（客户端连接到第一个服务器时的时间）  </li><li>最后一个<code>key</code>是在<code>T2</code>时间设置的（客户端收到最后一个服务器返回结果的时间）  </li></ul><p>从<code>T2</code>时间开始，确认最早超时的<code>key</code>至少也会存在的时间为  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">MIN_VALIDITY</span> = TTL - (T<span class="hljs-number">2</span>-T<span class="hljs-number">1</span>) - CLOCK_DRIFT<br></code></pre></td></tr></table></figure><ul><li>TTL: 锁超时时间  </li><li>（T2-T1）: 最晚获取到的锁的耗时  </li><li>CLOCK_DRIFT: 是不同进程间时钟差异，这个是用来补偿前面的(T2-T1）  </li></ul><p>其他的<code>key</code>都会在这个时间点之后才会超时，所以我们可以确定这些<code>key</code>在这个时间点之前至少都是同时存在的  </p><ul><li><p>无法抢占<br>在过半数<code>master</code>节点的<code>key</code>都<code>set</code>了的时间段内，其他客户端无法抢占这个锁<br>因为在 <code>(N/2)+1</code> 个 <code>master</code> 端的 <code>key</code> 已经存在的情况下不可能再在<code>(N/2)+1</code>个<code>master</code>端上获取锁成功，所以如果一个锁获取成功了，就不可能同时重新获取这个锁成功（不然就违反了分布式锁互斥原则）</p></li><li><p>多个客户端同时尝试获取锁时不会都同时成功<br>如果一个 <strong>客户端获取过半数节点锁的耗时</strong> 接近甚至超过 <strong>锁的最大有效时间</strong>，那么系统会认为这个锁是无效的同时会释放这些节点上的锁，所以仅仅需要考虑获取 <strong>过半数节点所的耗时</strong> 小于 <strong>锁有效时间</strong> 的情况，而在这种情况下，根据我们前面的证明，在<code>MIN_VALIDITY</code>时间内，没有客户端能重新获取锁成功  </p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>分布式</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式-断言-预查</title>
    <link href="/post/2cccdedc/"/>
    <url>/post/2cccdedc/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>文章默认以从左向右，从前到后描述方向<br>有些翻译会将 <strong>assert</strong> 翻译作预查，有些则翻译为断言  </p><blockquote><p>我更喜欢断言这种翻译，所以后文我都用这个词  </p></blockquote><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>断言是正则表达式的一种用法<br>主要是在表达式的某个位置发出向某个方向的声明断言判断<br>如果不符合断言所描述的场景，那么就认为匹配失败  </p><blockquote><p>仅作理解用的举例：  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">为什么不问问这个神奇的海螺呢？<br></code></pre></td></tr></table></figure><blockquote><blockquote><p>例1：”海螺”这个词前面是”神奇的”这个词<br>那么这个断言是符合句子中的场景的，因为“海螺”前面确实是”神奇的”这个词  </p></blockquote></blockquote><blockquote><p><span></span></p><blockquote><p>例2：”神奇的”后面是”烤肉”这个词<br>那么这个断言是不符合句子中的场景的，因为”神奇的”后面不是“烤肉”，而是“海螺”  </p></blockquote></blockquote><h2 id="断言肯否-肯定positive-否定negative"><a href="#断言肯否-肯定positive-否定negative" class="headerlink" title="断言肯否 - 肯定positive/否定negative"></a>断言肯否 - 肯定positive/否定negative</h2><blockquote><p>断言肯定与否定举例  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plain">接招吧DIO！半径30米的绿宝石飞溅！！！<br></code></pre></td></tr></table></figure><blockquote><p>肯定断言：“绿宝石飞溅”前面是”半径30米”<br>否定断言：“绿宝石飞溅”前面不是”半径30米”  </p></blockquote><h2 id="断言方向-正向look-ahead-反向look-behind"><a href="#断言方向-正向look-ahead-反向look-behind" class="headerlink" title="断言方向 - 正向look ahead/反向look behind"></a>断言方向 - 正向look ahead/反向look behind</h2><p>断言只有两个场景场景，即：断言在描述场景前/后<br>这对应着正则表达式的两种类型的断言  </p><ul><li>正向断言<br>对前文的断言。断言当前文本前面(没)有什么  </li><li>反向断言<br>对后文的断言。断言当前文本后面(没)有什么  </li></ul><blockquote><p>不知为什么有些文章会将这个方向说成与肯否弄反，此处采用维基百科的说法  </p></blockquote><h2 id="非获取匹配-零宽"><a href="#非获取匹配-零宽" class="headerlink" title="非获取匹配 - 零宽"></a>非获取匹配 - 零宽</h2><p>指匹配pattern但不获取匹配的子字符串（shy groups），也就是说这是一个非获取匹配，不存储匹配的子字符串用于向后引用<br>简单来说就是，断言的内容只用作判断，最终返回的内容不会包含断言的内容  </p><h2 id="语言限制"><a href="#语言限制" class="headerlink" title="语言限制"></a>语言限制</h2><p>不同语言不同库可能对正则表达式的断言声明有着不同的限制<br>比如：</p><ul><li><code>JavaScript</code>中并不支持后行断言  </li><li><code>Python</code>中并不支持变长后行断言  </li></ul><blockquote><p>也许未来会支持也不一定，不过现在的情况是这样的  </p></blockquote><h1 id="正则表达式断言"><a href="#正则表达式断言" class="headerlink" title="正则表达式断言"></a>正则表达式断言</h1><table><thead><tr><th>表达式</th><th>方向</th><th>肯否</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td>(?=pattern)</td><td>正向</td><td>肯定</td><td>零宽度正先行断言<br>仅当子表达式 pattern 在 此位置的右侧匹配时才继续匹配。</td><td>\w+(?=\d) <br>与后跟数字的单词匹配，而不与该数字匹配。</td></tr><tr><td>(?!pattern)</td><td>正向</td><td>否定</td><td>零宽度负先行断言<br>仅当子表达式 pattern 不在 此位置的右侧匹配时才继续匹配。</td><td>/w+(?!/d) <br>与后不跟数字的单词匹配，而不与该数字匹配 。</td></tr><tr><td>(?&lt;=pattern)</td><td>反向</td><td>肯定</td><td>零宽度正后发断言<br>仅当子表达式 pattern 在 此位置的左侧匹配时才继续匹配。</td><td>(?&lt;=19)99 <br>与跟在 19 后面的 99 的实例匹配。</td></tr><tr><td>(?&lt;!pattern)</td><td>反向</td><td>否定</td><td>零宽度负后发断言<br>仅当子表达式 pattern 不在此位置的左侧匹配时才继续匹配。</td><td>(?&lt;!19)99 <br>与不跟在 19 后面的 99 的实例匹配</td></tr></tbody></table><hr><p>参考<br>维基百科-正则表达式: <a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F</a>  </p>]]></content>
    
    
    
    <tags>
      
      <tag>正则</tag>
      
      <tag>断言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue-前端</title>
    <link href="/post/8c57192e/"/>
    <url>/post/8c57192e/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Vue</code> (读音 <code>/vjuː/</code>) 是一套用于构建用户界面的渐进式框架<br>与其它大型框架不同的是，<code>Vue</code> 被设计为可以自底向上逐层应用<br><code>Vue</code> 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合  </p><blockquote><ul><li>渐进式<br>指你可以让已有的项目，一点一点的用来<code>Vue</code>取代实现，不用担心<code>Vue</code>框架的排它性<br>一些框架可能会强制你使用它的一些东西，使得这个框架与其它框架难以集成到一起  </li><li>组件化应用<br>组件系统是 <code>Vue</code> 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用<br><img src="/Vue-%E5%89%8D%E7%AB%AF/20201118041814431.png">  </li></ul></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p>Vue 不支持 IE8 及以下版本，因为 Vue 使用了 IE8 无法模拟的 ECMAScript 5 特性  </p></blockquote><h2 id="直接用-lt-script-gt-CDN引入"><a href="#直接用-lt-script-gt-CDN引入" class="headerlink" title="直接用 &lt;script&gt;CDN引入"></a>直接用 <code>&lt;script&gt;</code>CDN引入</h2><p>对于制作原型或学习，你可以这样使用最新版本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于生产环境，我们推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.12&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="NPM"><a href="#NPM" class="headerlink" title="NPM"></a>NPM</h2><p>在用 <code>Vue</code> 构建大型应用时推荐使用 <code>NPM</code> 安装。<code>NPM</code> 能很好地和<code>webpack</code>打包器配合使用  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install vue<br></code></pre></td></tr></table></figure><h3 id="对不同构建版本的解释"><a href="#对不同构建版本的解释" class="headerlink" title="对不同构建版本的解释"></a>对不同构建版本的解释</h3><p>在 <code>NPM</code> 包的 <code>dist/</code> 目录会找到很多不同的 <code>Vue.js</code> 构建版本  </p><table><thead><tr><th></th><th>UMD</th><th>CommonJS</th><th>ES Module <br>(基于构建工具使用)</th><th>ES Module <br>(直接用于浏览器)</th></tr></thead><tbody><tr><td>完整版</td><td>vue.js</td><td>vue.common.js</td><td>vue.esm.js</td><td>vue.esm.browser.js</td></tr><tr><td>只包含运行时版</td><td>vue.runtime.js</td><td>vue.runtime.common.js</td><td>vue.runtime.esm.js</td><td></td></tr><tr><td>完整版 (生产环境)</td><td>vue.min.js</td><td></td><td></td><td>vue.esm.browser.min.js</td></tr><tr><td>只包含运行时版 (生产环境)</td><td>vue.runtime.min.js</td><td></td><td></td><td></td></tr></tbody></table><ul><li>完整版：同时包含编译器和运行时的版本。</li><li>编译器：用来将模板字符串编译成为 JavaScript 渲染函数的代码。</li><li>运行时：用来创建 Vue 实例、渲染并处理虚拟 DOM 等的代码。基本上就是除去编译器的其它一切。</li></ul><blockquote><p>版本类型说明</p><ul><li>UMD：UMD 版本可以通过 <code>&lt;script&gt;</code> 标签直接用在浏览器中  </li><li>CommonJS：CommonJS 版本用来配合老的打包工具<code>webpack 1</code>  </li><li>ES Module：为打包工具提供的 ESM  <ul><li>为诸如 <code>webpack 2</code> 提供的现代打包工具<br>ESM 格式被设计为可以被静态分析，所以打包工具可以利用这一点来进行“tree-shaking”并将用不到的代码排除出最终的包。<br>为这些打包工具提供的默认文件 (<code>pkg.module</code>) 是只有运行时的 ES Module 构建 (<code>vue.runtime.esm.js</code>)  </li><li>为浏览器提供的 ESM (2.6+)<br>用于在现代浏览器中通过 <code>&lt;script type=&quot;module&quot;&gt;</code> 直接导入  </li></ul></li></ul></blockquote><h2 id="浏览器调试插件Vue-Devtools"><a href="#浏览器调试插件Vue-Devtools" class="headerlink" title="浏览器调试插件Vue Devtools"></a>浏览器调试插件Vue Devtools</h2><p>Github: <a href="https://github.com/vuejs/vue-devtools#vue-devtools">https://github.com/vuejs/vue-devtools#vue-devtools</a><br>寻找对应自己浏览器版本的调试插件安装即可  </p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h1><p>创建一个<code>HTML</code>文件，在文件中引入<code>Vue</code>的CDN来使用<code>Vue</code>  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>HTML中设置一个标签用于显示数据</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span></span><br><span class="xml">    </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">message</span>&#125;&#125;</span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>编写模板代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el:<span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>        data:&#123;<br><span class="javascript">            message:<span class="hljs-string">&quot;Hello World&quot;</span></span><br>        &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><code>Vue.js</code> 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统  </p></blockquote><p>这样就已经成功创建了第一个 <code>Vue</code> 应用！看起来这跟渲染一个字符串模板非常类似，但是 <code>Vue</code> 在背后做了大量工作<br>现在数据和 <code>DOM</code> 已经被建立了关联，所有东西都是响应式的。  </p><blockquote><p>要怎么确认呢？打开你的浏览器的控制台 (就在这个页面打开)，并修改 app.message 的值<br><img src="/Vue-%E5%89%8D%E7%AB%AF/1.gif"><br>你将看到上例相应地更新  </p></blockquote><p>注意我们不再和 <code>HTML</code> 直接交互了<br>一个 <code>Vue</code> 应用会将其挂载到一个 <code>DOM</code> 元素上 (对于这个例子是 <code>#app</code>) 然后对其进行完全控制。那个 <code>HTML</code> 是我们的入口，但其余都会发生在新创建的 <code>Vue</code> 实例内部  </p><h2 id="其它的绑定"><a href="#其它的绑定" class="headerlink" title="其它的绑定"></a>其它的绑定</h2><p>除了文本插值，我们还可以像这样来绑定元素 attribute  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-2&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-bind:title</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br>    鼠标悬停几秒钟查看此处动态绑定的提示信息！<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app2 = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#app-2&#x27;</span>,</span><br>      data: &#123;<br><span class="javascript">        message: <span class="hljs-string">&#x27;页面加载于 &#x27;</span> + <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toLocaleString()</span><br>      &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里我们遇到了一点新东西。你看到的 <code>v-bind attribute</code> 被称为指令。指令带有前缀 <code>v-</code>，以表示它们是 <code>Vue</code> 提供的特殊 <code>attribute</code>。它们会在渲染的 DOM 上应用特殊的响应式行为<br>在这里，该指令的意思是：“将这个元素节点的 <code>title attribute</code> 和 <code>Vue</code> 实例的 <code>message property</code> 保持一致”  </p><blockquote><p>类似的，这个内容也是响应式的<br><img src="/Vue-%E5%89%8D%E7%AB%AF/2.gif">  </p></blockquote><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>控制切换一个元素是否显示  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-3&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;seen&quot;</span>&gt;</span>现在你看到我了<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app3 = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#app-3&#x27;</span>,</span><br>      data: &#123;<br><span class="javascript">        seen: <span class="hljs-literal">true</span></span><br>      &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/Vue-%E5%89%8D%E7%AB%AF/3.gif"><br>在控制台输入 <code>app3.seen = false</code>，你会发现之前显示的消息消失了。</p><p>这个例子演示了我们不仅可以把数据绑定到 <code>DOM</code> 文本或 <code>attribute</code>，还可以绑定到 <code>DOM</code> 结构  </p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p><code>v-for</code> 指令可以绑定数组的数据来渲染一个项目列表  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-4&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;todo in todos&quot;</span>&gt;</span><br>      &#123;&#123; todo.text &#125;&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app4 = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#app-4&#x27;</span>,</span><br>      data: &#123;<br>        todos: [<br><span class="javascript">          &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;学习 JavaScript&#x27;</span> &#125;,</span><br><span class="javascript">          &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;学习 Vue&#x27;</span> &#125;,</span><br><span class="javascript">          &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;整个牛项目&#x27;</span> &#125;</span><br>        ]<br>      &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/Vue-%E5%89%8D%E7%AB%AF/4.gif">  </p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><h3 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h3><p>可以用 <code>v-on</code> 指令添加一个事件监听器，通过它调用在 <code>Vue</code> 实例中定义的方法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-5&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;reverseMessage&quot;</span>&gt;</span>反转消息<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app5 = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#app-5&#x27;</span>,</span><br>      data: &#123;<br><span class="javascript">        message: <span class="hljs-string">&#x27;Hello Vue.js!&#x27;</span></span><br>      &#125;,<br>      methods: &#123;<br><span class="javascript">        reverseMessage: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.message = <span class="hljs-built_in">this</span>.message.split(<span class="hljs-string">&#x27;&#x27;</span>)</span><br>          <br><span class="javascript">          .reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)</span><br>        &#125;<br>      &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/Vue-%E5%89%8D%E7%AB%AF/5.gif"><br>注意在 <code>reverseMessage</code> 方法中，我们更新了应用的状态，但没有触碰 <code>DOM</code><br>所有的 <code>DOM</code> 操作都由 <code>Vue</code> 来处理，你编写的代码只需要关注逻辑层面即可  </p><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p><code>Vue</code> 提供了 <code>v-model</code> 指令，它能轻松实现表单输入和应用状态之间的双向绑定  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-6&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> app6 = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#app-6&#x27;</span>,</span><br>      data: &#123;<br><span class="javascript">        message: <span class="hljs-string">&#x27;Hello Vue!&#x27;</span></span><br>      &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件系统是 <code>Vue</code> 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用<br><img src="/Vue-%E5%89%8D%E7%AB%AF/20201118041814431.png"><br>在 <code>Vue</code> 里，一个组件本质上是一个拥有预定义选项的一个 <code>Vue</code> 实例。在 <code>Vue</code> 中注册组件很简单：  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app-7&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>      <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        现在我们为每个 todo-item 提供 todo 对象</span><br><span class="hljs-comment">        todo 对象是变量，即其内容可以是动态的。</span><br><span class="hljs-comment">        我们也需要为每个组件提供一个“key”，稍后再作详细解释。</span><br><span class="hljs-comment">      --&gt;</span><br>      <span class="hljs-comment">&lt;!-- 使用 v-bind 指令将待办项传到循环输出的每个组件中 --&gt;</span><br>      &lt;todo-item<br>        v-for=&quot;item in groceryList&quot;<br>        v-bind:todo=&quot;item&quot;<br>        v-bind:key=&quot;item.id&quot; <br>      &gt;<span class="hljs-tag">&lt;/<span class="hljs-name">todo-item</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-comment">// 定义名为 todo-item 的新组件</span></span><br><span class="javascript">    Vue.component(<span class="hljs-string">&#x27;todo-item&#x27;</span>, &#123;</span><br><span class="javascript">        <span class="hljs-comment">// todo-item 组件接受一个&quot;prop&quot;，类似于一个自定义 attribute。</span></span><br><span class="javascript">        <span class="hljs-comment">// 这个 prop 名为 todo。</span></span><br><span class="javascript">        props: [<span class="hljs-string">&#x27;todo&#x27;</span>],</span><br><span class="handlebars"><span class="xml">        template: &#x27;<span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">todo.text</span> &#125;&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>&#x27;</span></span><br>    &#125;)<br><br><span class="javascript">    <span class="hljs-keyword">var</span> app7 = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el: <span class="hljs-string">&#x27;#app-7&#x27;</span>,</span><br>        data: &#123;<br>            groceryList: [<br><span class="javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;蔬菜&#x27;</span> &#125;,</span><br><span class="javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;奶酪&#x27;</span> &#125;,</span><br><span class="javascript">                &#123; <span class="hljs-attr">id</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;随便其它什么人吃的东西&#x27;</span> &#125;</span><br>            ]<br>        &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>附带的观察整个流程（并非是运行流程），便于理解  </p><ol><li><code>&lt;script&gt;</code>初始化  <ol><li>声明自定义的组件<code>&lt;todo-item&gt;</code>  </li><li>初始化数据 <code>groceryList</code>  </li></ol></li><li><code>HTML</code>里的<code>&lt;todo-item&gt;</code>  <ol><li><code>v-for</code>遍历<code>groceryList</code>中拿到数据,命名为<code>item</code>  </li><li>``v-bind:todo=”item”相当于 <code>组件.todo = item</code>  </li><li><code>todo-item</code>根据定义的<code>template</code>计算出内容回填  </li></ol></li></ol></blockquote><p>尽管这只是一个刻意设计的例子，但是我们已经设法将应用分割成了两个更小的单元。<br>子单元通过<code>prop</code>接口与父单元进行了良好的解耦<br>现在可以进一步改进 <code>&lt;todo-item&gt;</code> 组件，提供更为复杂的模板和逻辑，而不会影响到父单元  </p><h1 id="Vue实例"><a href="#Vue实例" class="headerlink" title="Vue实例"></a>Vue实例</h1><p>每个 <code>Vue</code> 应用都是通过用 <code>Vue</code> 函数创建一个新的 <code>Vue</code> 实例开始的  </p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-type">Vue</span>(&#123;<br>  <span class="hljs-comment">// 选项</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>虽然没有完全遵循 <a href="https://zh.wikipedia.org/wiki/MVVM">MVVM</a> 模型，但是 <code>Vue</code> 的设计也受到了它的启发。因此在文档中经常会使用 <code>vm</code> (<code>ViewModel</code> 的缩写) 这个变量名表示 <code>Vue</code> 实例<br>当创建一个 <code>Vue</code> 实例时，你可以传入一个选项对象。这个篇章主要描述的就是如何使用这些选项来创建你想要的行为。作为参考，你也可以在 <a href="https://cn.vuejs.org/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE">API 文档</a> 中浏览完整的选项列表  </p><p>一个 <code>Vue</code> 应用由一个通过 <code>new Vue</code> 创建的根 <code>Vue</code> 实例，以及可选的嵌套的、可复用的组件树组成  </p><blockquote><p>举个例子，一个 todo 应用的组件树可以是这样的：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plain">根实例<br>└─ TodoList<br>   ├─ TodoItem<br>   │  ├─ TodoButtonDelete<br>   │  └─ TodoButtonEdit<br>   └─ TodoListFooter<br>      ├─ TodosButtonClear<br>      └─ TodoListStatistics<br></code></pre></td></tr></table></figure><p>所有的 Vue 组件都是 Vue 实例，并且接受相同的选项对象 (一些根实例特有的选项除外)  </p><h2 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h2><p>当一个 <code>Vue</code> 实例被创建时，它将 <code>data</code> 对象中的所有的 <code>property</code> 加入到 <code>Vue</code> 的响应式系统中<br>当这些 <code>property</code> 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 我们的数据对象</span><br><span class="hljs-keyword">var</span> data = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;<br><br><span class="hljs-comment">// 该对象被加入到一个 Vue 实例中</span><br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  data: data<br>&#125;)<br><br><span class="hljs-comment">// 获得这个实例上的 property</span><br><span class="hljs-comment">// 返回源数据中对应的字段</span><br>vm.a == data.a <span class="hljs-comment">// =&gt; true</span><br><br><span class="hljs-comment">// 设置 property 也会影响到原始数据</span><br>vm.a = <span class="hljs-number">2</span><br>data.a <span class="hljs-comment">// =&gt; 2</span><br><br><span class="hljs-comment">// ……反之亦然</span><br>data.a = <span class="hljs-number">3</span><br>vm.a <span class="hljs-comment">// =&gt; 3</span><br></code></pre></td></tr></table></figure><p>当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 <code>data</code> 中的 <code>property</code> 才是响应式的  </p><blockquote><p>也就是说如果你在创建以后再去添加一个新的 <code>property</code>，比如：  </p></blockquote><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">vm.b</span> = <span class="hljs-string">&#x27;hi&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>那么对 <code>b</code> 的改动将不会触发任何视图的更新  </p></blockquote><p>如果你知道你会在晚些时候需要一个 <code>property</code>，但是一开始它为空或不存在，那么你需要设置一些初始值，以确保它是响应式的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">data: &#123;<br>  newTodoText: <span class="hljs-string">&#x27;&#x27;</span>,<br>  visitCount: <span class="hljs-number">0</span>,<br>  hideCompletedTodos: <span class="hljs-literal">false</span>,<br>  todos: [],<br>  error: <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="冻结"><a href="#冻结" class="headerlink" title="冻结"></a>冻结</h3><p><code>Object.freeze()</code>会阻止修改现有的 <code>property</code>，也意味着响应系统无法再追踪变化  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 这里的 `foo` 不会更新！ --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;</span>Change it<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> obj = &#123;</span><br><span class="javascript">      foo: <span class="hljs-string">&#x27;bar&#x27;</span></span><br>    &#125;<br><br><span class="javascript">    <span class="hljs-built_in">Object</span>.freeze(obj)</span><br><br><span class="javascript">    <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br>      data: obj<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀$"></a>前缀<code>$</code></h3><p>除了数据 <code>property</code>，<code>Vue</code> 实例还暴露了一些有用的实例 <code>property</code> 与方法。它们都有前缀 <code>$</code>，以便与用户定义的 <code>property</code> 区分开来  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> data = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;<br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#example&#x27;</span>,<br>  data: data<br>&#125;)<br><br>vm.$data === data <span class="hljs-comment">// =&gt; true</span><br>vm.$el === <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;example&#x27;</span>) <span class="hljs-comment">// =&gt; true</span><br><br><span class="hljs-comment">// $watch 是一个实例方法</span><br>vm.$watch(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newValue, oldValue</span>) </span>&#123;<br>  <span class="hljs-comment">// 这个回调将在 `vm.a` 改变后调用</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>可以在 <a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B-property">API</a> 中查阅到完整的实例 <code>property</code> 和方法的列表  </p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><h4 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h4><p>每个<code>Vue</code>实例在被创建时都要经过一系列的初始化过程  </p><blockquote><p>例如，需要设置数据监听、编译模板、将实例挂载到 <code>DOM</code> 并在数据变化时更新 <code>DOM</code> 等  </p></blockquote><p>同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会  </p><p>比如 <code>created</code> 钩子可以用来在一个实例被创建之后执行代码：  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> Vue(&#123;<br>  data: &#123;<br>    a: <span class="hljs-number">1</span><br>  &#125;,<br>  created: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// `this` 指向 vm 实例</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a is: &#x27;</span> + <span class="hljs-built_in">this</span>.a)<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// =&gt; &quot;a is: 1&quot;</span><br></code></pre></td></tr></table></figure><p>也有一些其它的钩子，在实例生命周期的不同阶段被调用。如 <code>mounted</code>、<code>updated</code> 和 <code>destroyed</code><br>生命周期钩子的 <code>this</code> 上下文指向调用它的 <code>Vue</code> 实例  </p><blockquote><h4 id="不要在选项-property-或回调上使用箭头函数"><a href="#不要在选项-property-或回调上使用箭头函数" class="headerlink" title="不要在选项 property 或回调上使用箭头函数"></a>不要在选项 <code>property</code> 或回调上使用箭头函数</h4><blockquote><p>比如<br>created: () =&gt; console.log(this.a)<br>vm.$watch(‘a’, newValue =&gt; this.myMethod())。</p></blockquote><p>因为箭头函数并没有 <code>this</code>，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止<br>这经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code> 或 <code>Uncaught TypeError: this.myMethod is not a function</code> 之类的错误  </p></blockquote><h4 id="生命周期图例"><a href="#生命周期图例" class="headerlink" title="生命周期图例"></a>生命周期图例</h4><p><img src="/Vue-%E5%89%8D%E7%AB%AF/lifecycle.png"><br>图例上说明了可以使用的钩子函数（红框红字）与生命周期过程<br>以后遇到问题可以作为参考  </p><h1 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h1><p><code>Vue.js</code> 使用了基于 <code>HTML</code> 的模板语法，允许开发者声明式地将 <code>DOM</code> 绑定至底层 <code>Vue</code> 实例的数据。所有 <code>Vue.js</code> 的模板都是合法的 <code>HTML</code>，所以能被遵循规范的浏览器和 <code>HTML</code> 解析器解析  </p><p>在底层的实现上，<code>Vue</code> 将模板编译成虚拟 <code>DOM</code> 渲染函数。结合响应系统，<code>Vue</code> 能够智能地计算出最少需要重新渲染多少组件，并把 <code>DOM</code> 操作次数减到最少  </p><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><p>顾名思义，就是往<code>HTML</code>中插入一些内容，以填充页面    </p><h3 id="普通文本"><a href="#普通文本" class="headerlink" title="普通文本"></a>普通文本</h3><blockquote><h5 id="“Mustache”语法-双大括号"><a href="#“Mustache”语法-双大括号" class="headerlink" title="“Mustache”语法 (双大括号)"></a>“Mustache”语法 (双大括号)</h5><p>向HTML中插入变量的值  </p></blockquote><p>数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值  </p><ul><li>无法对元素属性使用  </li><li>插入的HTML内容不会被当做元素，只会当做普通字符串  </li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Message: &#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>Mustache</code> 标签将会被替代为对应数据对象上 <code>msg property</code> 的值。无论何时，绑定的数据对象上 <code>msg property</code> 发生了改变，插值处的内容都会更新  </p><h3 id="插值固定"><a href="#插值固定" class="headerlink" title="插值固定"></a>插值固定</h3><blockquote><h5 id="v-once-指令"><a href="#v-once-指令" class="headerlink" title="v-once 指令"></a><a href="https://cn.vuejs.org/v2/api/#v-once">v-once 指令</a></h5><p>用于影响插值，在此指令范围内的文本插值后不会因其原本变量值改变而改变  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-once</span>&gt;</span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="HTML内容"><a href="#HTML内容" class="headerlink" title="HTML内容"></a>HTML内容</h3><blockquote><h5 id="v-html-指令"><a href="#v-html-指令" class="headerlink" title="v-html 指令"></a><a href="https://cn.vuejs.org/v2/api/#v-html">v-html 指令</a></h5><p>用于插入HTML内容  </p></blockquote><p>双大括号会将数据解释为普通文本，要插入HTML内容，需要用这个<code>v-html 指令</code>  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Using mustaches: &#123;&#123; rawHtml &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Using v-html directive: <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;rawHtml&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个 <code>span</code> 的内容将会被替换成为 <code>property</code> 值 <code>rawHtml</code>，直接作为 HTML——会忽略解析 <code>property</code> 值中的数据绑定  </p><p>注意，你不能使用 <code>v-html</code> 来复合局部模板，因为 <code>Vue</code> 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位  </p><blockquote><p>你的站点上动态渲染的任意 <code>HTML</code> 可能会非常危险，因为它很容易导致 <code>XSS 攻击</code>。请只对可信内容使用 <code>HTML</code> 插值，绝不要对用户提供的内容使用插值  </p></blockquote><h3 id="元素属性插值"><a href="#元素属性插值" class="headerlink" title="元素属性插值"></a>元素属性插值</h3><blockquote><h5 id="v-bind-指令"><a href="#v-bind-指令" class="headerlink" title="v-bind 指令"></a>v-bind 指令</h5><p>用于绑定内容与目标元素的属性  </p></blockquote><p><code>Mustache 语法</code>不能作用在 <code>HTML attribute</code> 上，遇到这种情况应该使用 <code>v-bind 指令</code>  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;dynamicId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于布尔 <code>attribute</code> (它们只要存在就意味着值为 <code>true</code>)，<code>v-bind</code> 工作起来略有不同  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-bind:disabled</span>=<span class="hljs-string">&quot;isButtonDisabled&quot;</span>&gt;</span>Button<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果<code>isButtonDisabled</code> 的值是 <code>null</code>、<code>undefined</code> 或 <code>false</code>，则 <code>disabled attribute</code> 甚至不会被包含在渲染出来的 <code>&lt;button&gt;</code> 元素中  </p><h3 id="JavaScript-表达式"><a href="#JavaScript-表达式" class="headerlink" title="JavaScript 表达式"></a>JavaScript 表达式</h3><p>实际上，对于所有的数据绑定，<code>Vue.js</code> 都提供了完全的 <code>JavaScript</code> 表达式支持  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123; number + 1 &#125;&#125;<br>&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;<br>&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这些表达式会在所属 <code>Vue</code> 实例的数据作用域下作为 <code>JavaScript</code> 被解析。有个限制就是，每个绑定都只能包含单个表达式  </p><blockquote><h4 id="下面的例子都不会生效"><a href="#下面的例子都不会生效" class="headerlink" title="下面的例子都不会生效"></a>下面的例子都不会生效</h4><p>这是语句，不是表达式 </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123; var a = 1 &#125;&#125;<br></code></pre></td></tr></table></figure><blockquote><p>流控制也不会生效，请使用三元表达式</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;<br></code></pre></td></tr></table></figure><p>模板表达式都被放在沙盒中，只能访问一些<a href="https://github.com/vuejs/vue/blob/v2.6.10/src/core/instance/proxy.js#L9">特定的全局变量</a>，如 <code>Math</code> 和 <code>Date</code><br>你不应该在模板表达式中访问用户定义的全局变量  </p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊 <code>attribute</code><br>指令 <code>attribute</code> 的值预期是单个 <code>JavaScript</code> 表达式 (v-for 是例外情况，稍后我们再讨论)。<br>指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 <code>DOM</code>  </p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>一些指令能够接收一个“参数”，在指令名称之后以冒号表示  </p><blockquote><p>例: <code>v-bind</code> 指令可以用于响应式地更新 <code>HTML attribute</code>  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这里 <code>href</code> 是参数，告知 <code>v-bind</code> 指令将该元素的 <code>href attribute</code> 与表达式 <code>url</code> 的值绑定  </p><blockquote><p>例:  <code>v-on</code> 指令，它用于监听 `DOM 事件  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>在这里参数是监听的事件名  </p></blockquote><h3 id="动态参数"><a href="#动态参数" class="headerlink" title="动态参数"></a>动态参数</h3><p>可以用方括号括起来的 <code>JavaScript</code> 表达式作为一个指令的参数  </p><blockquote><p>例：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">注意，参数表达式的写法存在一些约束，如之后的“对动态参数表达式的约束”章节所述。</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">attributeName</span>]=<span class="hljs-string">&quot;url&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果你的 Vue 实例有一个 data property attributeName，其值为 “href”，那么这个绑定将等价于 v-bind:href  </p></blockquote><p>这里的 <code>attributeName</code> 会被作为一个 <code>JavaScript</code> 表达式进行动态求值，求得的值将会作为最终的参数来使用  </p><p>同样地，你可以使用动态参数为一个动态的事件名绑定处理函数：</p><blockquote><p>例：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:</span>[<span class="hljs-attr">eventName</span>]=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当 <code>eventName</code> 的值为 “focus” 时，<code>v-on:[eventName]</code> 将等价于 <code>v-on:focus</code>  </p><h4 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h4><h5 id="对动态参数的值的约束"><a href="#对动态参数的值的约束" class="headerlink" title="对动态参数的值的约束"></a>对动态参数的值的约束</h5><ul><li>null<br>动态参数预期会求出一个字符串，异常情况下值为 <code>null</code><br>这个特殊的 <code>null</code> 值可以被显性地用于移除绑定。任何其它非字符串类型的值都将会触发一个警告。</li></ul><h5 id="对动态参数表达式的约束"><a href="#对动态参数表达式的约束" class="headerlink" title="对动态参数表达式的约束"></a>对动态参数表达式的约束</h5><ul><li><p>特殊符号约束<br>动态参数表达式有一些语法约束，因为某些字符，如空格和引号，放在 <code>HTML attribute</code> 名里是无效的  </p><blockquote><p>例：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 这会触发一个编译警告 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[&#x27;<span class="hljs-attr">foo</span>&#x27; + <span class="hljs-attr">bar</span>]=<span class="hljs-string">&quot;value&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  变通的办法是使用没有空格或引号的表达式，或用计算属性替代这种复杂表达式  </p></li><li><p>大小写约束<br>在 <code>DOM</code> 中使用模板时 (直接在一个 <code>HTML</code> 文件里撰写模板)，还需要避免使用大写字符来命名键名，因为浏览器会把 <code>attribute</code> 名全部强制转为小写  </p><blockquote><p>例：</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">在 DOM 中使用模板时这段代码会被转换为 `v-bind:[someattr]`。</span><br><span class="hljs-comment">除非在实例中有一个名为“someattr”的 property，否则代码不会工作。</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">someAttr</span>]=<span class="hljs-string">&quot;value&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符 (modifier) 是以半角句号 <code>.</code> 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。</p><blockquote><p>例如，.prevent 修饰符告诉 v-on 指令对于触发的事件调用 <code>event.preventDefault()</code>  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>=<span class="hljs-string">&quot;onSubmit&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><p><code>v-</code> 前缀作为一种视觉提示，用来识别模板中 <code>Vue</code> 特定的 <code>attribute</code><br><code>Vue</code> 为 <code>v-bind</code> 和 <code>v-on</code> 这两个最常用的指令，提供了特定简写  </p></li></ul><h4 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a>v-bind 缩写</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 完整语法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">:</span>[<span class="hljs-attr">key</span>]=<span class="hljs-string">&quot;url&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a>v-on 缩写</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 完整语法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 动态参数的缩写 (2.6.0+) --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> @[<span class="hljs-attr">event</span>]=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span> ... <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>它们看起来可能与普通的 <code>HTML</code> 略有不同，但 <code>:</code> 与 <code>@</code> 对于 <code>attribute</code> 名来说都是合法字符，在所有支持 <code>Vue</code> 的浏览器都能被正确地解析<br>它们不会出现在最终渲染的标记中  </p><h1 id="计算属性和侦听器"><a href="#计算属性和侦听器" class="headerlink" title="计算属性和侦听器"></a>计算属性和侦听器</h1><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><h3 id="模板表达式-与-计算属性"><a href="#模板表达式-与-计算属性" class="headerlink" title="模板表达式 与 计算属性"></a>模板表达式 与 计算属性</h3><p>模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的  </p><blockquote><p>在模板中放入太多的逻辑会让模板过重且难以维护  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>在这个地方，模板不再是简单的声明式逻辑。你必须看一段时间才能意识到，这里是想要显示变量 <code>message</code> 的翻转字符串<br>当你想要在模板中多包含此处的翻转字符串时，就会更加难以处理  </p></blockquote><p>对于任何复杂逻辑，你都应当使用计算属性  </p><h3 id="计算属性-1"><a href="#计算属性-1" class="headerlink" title="计算属性"></a>计算属性</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Original message: &quot;&#123;&#123; message &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>      data: &#123;<br><span class="javascript">        message: <span class="hljs-string">&#x27;Hello&#x27;</span></span><br>      &#125;,<br>      computed: &#123;<br><span class="javascript">        <span class="hljs-comment">// 声明了一个计算属性 reversedMessage</span></span><br><span class="javascript">        <span class="hljs-comment">// 计算属性的 getter</span></span><br><span class="javascript">        reversedMessage: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-comment">// `this` 指向 vm 实例</span></span><br><span class="javascript">          <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.message.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)</span><br>        &#125;<br>      &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里声明了一个 “计算反转的<code>vm.message</code>字符串的函数” 传入到 计算属性 <code>reversedMessage</code><br>提供的函数将用作 <code>property</code> <code>vm.reversedMessage</code> 的 <code>getter</code> 函数<br>计算属性 <code>reversedMessage</code> 的结果是响应式的  </p><blockquote><p><code>reversedMessage</code> 的值始终取决于 <code>vm.message</code> 的值<br><img src="/Vue-%E5%89%8D%E7%AB%AF/6.gif">  </p></blockquote><p>你可以像绑定普通 <code>property</code> 一样在模板中绑定计算属性<br><code>Vue</code> 知道 <code>vm.reversedMessage</code> 依赖于 <code>vm.message</code>，因此当 <code>vm.message</code> 发生改变时，所有依赖 <code>vm.reversedMessage</code> 的绑定也会更新<br>而且最妙的是我们已经以声明的方式创建了这种依赖关系：<code>计算属性</code>的 <code>getter</code> 函数是没有副作用 (<code>side effect</code>) 的，这使它更易于测试和理解  </p><h4 id="计算属性的-setter"><a href="#计算属性的-setter" class="headerlink" title="计算属性的 setter"></a>计算属性的 setter</h4><p>计算属性默认只有 <code>getter</code>，不过在需要时你也可以提供一个 <code>setter</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">computed: &#123;<br>  fullName: &#123;<br>    <span class="hljs-comment">// getter</span><br>    get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">this</span>.lastName<br>    &#125;,<br>    <span class="hljs-comment">// setter</span><br>    set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newValue</span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> names = newValue.split(<span class="hljs-string">&#x27; &#x27;</span>)<br>      <span class="hljs-built_in">this</span>.firstName = names[<span class="hljs-number">0</span>]<br>      <span class="hljs-built_in">this</span>.lastName = names[names.length - <span class="hljs-number">1</span>]<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，<code>setter</code> 会被调用<br>因此<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p><h4 id="计算属性缓存-与-方法"><a href="#计算属性缓存-与-方法" class="headerlink" title="计算属性缓存 与 方法"></a>计算属性缓存 与 方法</h4><p>你可能会想到：通过 在表达式中调用方法 来达到和 计算属性 同样的效果  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Reversed message: &quot;&#123;&#123; reversedMessage() &#125;&#125;&quot;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在组件中</span><br>methods: &#123;<br>  reversedMessage: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.message.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两种方式的最终结果确实是完全相同的<br>不同的是 <code>计算属性</code> 是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值  </p><p>只要 <code>message</code> 还没有发生改变，多次访问 <code>reversedMessage</code> 计算属性会立即返回之前的计算结果，而会再次执行函数  </p><blockquote><h4 id="可能造成的问题"><a href="#可能造成的问题" class="headerlink" title="可能造成的问题"></a>可能造成的问题</h4><p>下面的 <code>计算属性</code> 将不再更新，因为 <code>Date.now()</code> 不是响应式依赖  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">computed: &#123;<br>  now: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Date</span>.now()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th>计算属性</th><th>方法</th></tr></thead><tbody><tr><td>更新结果</td><td>依赖更新时更新<br>否则从缓存中得到上次的计算结果</td><td>每次运行都更新</td></tr><tr><td>资源消耗</td><td>小</td><td>大</td></tr><tr><td>速度</td><td>较快</td><td>较慢</td></tr></tbody></table><h4 id="计算属性-vs-侦听属性"><a href="#计算属性-vs-侦听属性" class="headerlink" title="计算属性 vs 侦听属性"></a>计算属性 vs 侦听属性</h4><p><code>Vue</code> 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性(<code>watch</code>)<br>但通常<code>计算属性</code> 能够取代 命令式的 <code>watch</code>回调，并且让代码更优美  </p><blockquote><p>例：姓更变 或 名更变 时 自动计算全名  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span>&#123;&#123; fullName &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><blockquote><p>此处用<code>watch</code>实现  </p></blockquote></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#demo&#x27;</span>,</span><br>      data: &#123;<br><span class="javascript">        firstName: <span class="hljs-string">&#x27;Foo&#x27;</span>,</span><br><span class="javascript">        lastName: <span class="hljs-string">&#x27;Bar&#x27;</span>,</span><br><span class="javascript">        fullName: <span class="hljs-string">&#x27;Foo Bar&#x27;</span></span><br>      &#125;,<br>      watch: &#123;<br><span class="javascript">        <span class="hljs-comment">// 因为要监听两个变量，所以定义了两个</span></span><br><span class="javascript">        firstName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.fullName = val + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">this</span>.lastName</span><br>        &#125;,<br><span class="javascript">        lastName: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.fullName = <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + val</span><br>        &#125;<br>      &#125;<br>    &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><span></span></p><blockquote><p>此处用 <code>计算属性</code>实现  </p></blockquote></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#demo&#x27;</span>,<br>  data: &#123;<br>    firstName: <span class="hljs-string">&#x27;Foo&#x27;</span>,<br>    lastName: <span class="hljs-string">&#x27;Bar&#x27;</span><br>  &#125;,<br>  computed: &#123;<br>    fullName: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.firstName + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-keyword">this</span>.lastName<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>对比而言，<code>计算属性</code> 的代码就优美很多  </p></blockquote><h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p><code>Vue</code> 通过 <code>watch</code> 选项提供了一个更通用的方法，来响应数据的变化<br>当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。  </p><blockquote><p>例：异步<code>Ajax</code>请求</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;watch-example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span><br>    Ask a yes/no question:<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;question&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; answer &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>使用 <code>watch</code> 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 因为 AJAX 库和通用工具的生态已经相当丰富，Vue 核心代码没有重复 --&gt;</span><br><span class="hljs-comment">&lt;!-- 提供这些功能以保持精简。这也可以让你自由选择自己更熟悉的工具。 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/axios@0.12.0/dist/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/lodash@4.13.1/lodash.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> watchExampleVM = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">  el: <span class="hljs-string">&#x27;#watch-example&#x27;</span>,</span><br>  data: &#123;<br><span class="javascript">    question: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="javascript">    answer: <span class="hljs-string">&#x27;I cannot give you an answer until you ask a question!&#x27;</span></span><br>  &#125;,<br>  watch: &#123;<br><span class="javascript">    <span class="hljs-comment">// 如果 `question` 发生改变，这个函数就会运行</span></span><br><span class="javascript">    question: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newQuestion, oldQuestion</span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.answer = <span class="hljs-string">&#x27;Waiting for you to stop typing...&#x27;</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.debouncedGetAnswer()</span><br>    &#125;<br>  &#125;,<br><span class="javascript">  created: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">    <span class="hljs-comment">// `_.debounce` 是一个通过 Lodash 限制操作频率的函数。</span></span><br><span class="javascript">    <span class="hljs-comment">// 在这个例子中，我们希望限制访问 yesno.wtf/api 的频率</span></span><br><span class="javascript">    <span class="hljs-comment">// AJAX 请求直到用户输入完毕才会发出。想要了解更多关于</span></span><br><span class="javascript">    <span class="hljs-comment">// `_.debounce` 函数 (及其近亲 `_.throttle`) 的知识，</span></span><br><span class="javascript">    <span class="hljs-comment">// 请参考：https://lodash.com/docs#debounce</span></span><br><span class="javascript">    <span class="hljs-built_in">this</span>.debouncedGetAnswer = _.debounce(<span class="hljs-built_in">this</span>.getAnswer, <span class="hljs-number">500</span>)</span><br>  &#125;,<br>  methods: &#123;<br><span class="javascript">    getAnswer: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.question.indexOf(<span class="hljs-string">&#x27;?&#x27;</span>) === -<span class="hljs-number">1</span>) &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.answer = <span class="hljs-string">&#x27;Questions usually contain a question mark. ;-)&#x27;</span></span><br><span class="javascript">        <span class="hljs-keyword">return</span></span><br>      &#125;<br><span class="javascript">      <span class="hljs-built_in">this</span>.answer = <span class="hljs-string">&#x27;Thinking...&#x27;</span></span><br><span class="javascript">      <span class="hljs-keyword">var</span> vm = <span class="hljs-built_in">this</span></span><br><span class="javascript">      axios.get(<span class="hljs-string">&#x27;https://yesno.wtf/api&#x27;</span>)</span><br><span class="javascript">        .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">response</span>) </span>&#123;</span><br>          vm.answer = _.capitalize(response.data.answer)<br>        &#125;)<br><span class="javascript">        .catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;</span><br><span class="javascript">          vm.answer = <span class="hljs-string">&#x27;Error! Could not reach the API. &#x27;</span> + error</span><br>        &#125;)<br>    &#125;<br>  &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>除了 <code>watch</code> 选项之外，还可以使用命令式的 <a href="https://cn.vuejs.org/v2/api/#vm-watch"><code>vm.$watch</code> API</a>  </p><h1 id="Class-与-Style绑定"><a href="#Class-与-Style绑定" class="headerlink" title="Class 与 Style绑定"></a>Class 与 Style绑定</h1><p>操作元素的 <code>class</code> 列表和内联样式是数据绑定的一个常见需求。它们都是 <code>attribute</code>，所以可以用 <code>v-bind</code> 处理它们<br>在将 <code>v-bind</code> 用于 <code>class</code> 和 <code>style</code> 时，<code>Vue.js</code> 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组  </p><h2 id="绑定-HTML-Class"><a href="#绑定-HTML-Class" class="headerlink" title="绑定 HTML Class"></a>绑定 HTML Class</h2><h3 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h3><h4 id="多字段设置"><a href="#多字段设置" class="headerlink" title="多字段设置"></a>多字段设置</h4><p>可以传给 <code>v-bind:class</code> 多个字段，以动态地切换 <code>class</code>  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;static&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;&#123; active: isActive &#125;&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>v-bind:class</code> 指令也可以与普通的 <code>class</code> <code>attribute</code> 共存，最终得到的结果会是它们拼接在一起的样子    </p><blockquote><p>多字段来动态切换Class  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;div<br>    id=&quot;example&quot;<br>    class=&quot;static&quot;<br>    v-bind:class=&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;<br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">        el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br><span class="javascript">        isActive: <span class="hljs-literal">true</span>,</span><br><span class="javascript">        hasError: <span class="hljs-literal">false</span></span><br>    &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>会得到这样的渲染结果 <code>static activate</code><br><img src="/Vue-%E5%89%8D%E7%AB%AF/20201124085448963.png"><br>类似的，这样设置的样式是响应式的，如果修改<code>isActive</code>与<code>hasError</code>设置的内容也会相应的做出改变  </p></blockquote><h4 id="单对象"><a href="#单对象" class="headerlink" title="单对象"></a>单对象</h4><p>与上面的多个字段类似，可以在一个对象中设置多个属性（作为字段），来进行<code>class</code>的切换  </p><blockquote><p>单个对象来动态切换class</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;div<br>    id=&quot;example&quot;<br>    class=&quot;static&quot;<br>    v-bind:class=&quot;classObject&quot;<br>&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br>        classObject: &#123;<br><span class="javascript">            active: <span class="hljs-literal">true</span>,</span><br><span class="javascript">            <span class="hljs-string">&#x27;text-danger&#x27;</span>: <span class="hljs-literal">false</span></span><br>        &#125;<br>    &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>会得到和上面的例子一样的的结果  </p></blockquote><h2 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h2><p>可以把一个数组传给 <code>v-bind:class</code>，以应用一个 <code>class</code> 列表  </p><blockquote><p>数组来动态切换class</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-bind:class</span>=<span class="hljs-string">&quot;[activeClass, errorClass]&quot;</span></span><br><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br><span class="javascript">        activeClass: <span class="hljs-string">&#x27;active&#x27;</span>,</span><br><span class="javascript">        errorClass: <span class="hljs-string">&#x27;text-danger&#x27;</span></span><br>    &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>最终渲染结果为<code>class=&quot;active text-danger&quot;</code><br><img src="/Vue-%E5%89%8D%E7%AB%AF/20201124092827386.png">  </p></blockquote><p>你可以在数组中填入表达式，但这会造成内容的不美观，不建议那样做  </p><h2 id="绑定内联样式-style"><a href="#绑定内联样式-style" class="headerlink" title="绑定内联样式 style"></a>绑定内联样式 style</h2><p><code>v-bind:style</code> 的对象语法十分直观——看着非常像 <code>CSS</code>，但其实是一个 <code>JavaScript</code> 对象<br><code>CSS property</code> 名可以用驼峰式 (camelCase) 或短横线分隔 (kebab-case，记得用引号括起来) 来命名  </p><h3 id="多字段设置style"><a href="#多字段设置style" class="headerlink" title="多字段设置style"></a>多字段设置style</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27; &#125;&quot;</span>&gt;</span>Hello<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br><span class="javascript">        activeColor: <span class="hljs-string">&#x27;red&#x27;</span>,</span><br>        fontSize: 30<br>    &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>最终得到的<code>style=&quot;color: red; font-size: 30px;&quot;</code><br><img src="/Vue-%E5%89%8D%E7%AB%AF/20201124094841954.png">  </p></blockquote><h3 id="对象设置Style"><a href="#对象设置Style" class="headerlink" title="对象设置Style"></a>对象设置Style</h3><p>类似的，<code>v-bind:style</code>可以在一个或多个对象中设置属性（作为字段），来进行<code>style</code>的设置  </p><blockquote><p>单个对象设置 style</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">&quot;styleObject&quot;</span>&gt;</span>Hello<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br>        styleObject: &#123;<br><span class="javascript">            color: <span class="hljs-string">&#x27;red&#x27;</span>,</span><br><span class="javascript">            fontSize: <span class="hljs-string">&#x27;30px&#x27;</span></span><br>        &#125;<br>    &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>得到的结果与上个例子一致: <code>style=&quot;color: red; font-size: 30px;&quot;</code>  </p></blockquote><p>对于希望设置多个对象到元素上时，需要用数组括起来  </p><blockquote><p>多个对象设置 style  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> </span><br><span class="hljs-tag">    <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">&quot;[colorStyleObject, fontStyleObject]&quot;</span>&gt;</span>Hello<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br>        colorStyleObject: &#123;<br><span class="javascript">            color: <span class="hljs-string">&#x27;red&#x27;</span></span><br>        &#125;,<br>        fontStyleObject:&#123;<br><span class="javascript">            fontSize: <span class="hljs-string">&#x27;30px&#x27;</span></span><br>        &#125;<br>    &#125;<br>&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>得到的结果与上个例子一致: <code>style=&quot;color: red; font-size: 30px;&quot;</code>  </p></blockquote><h3 id="自动添加前缀"><a href="#自动添加前缀" class="headerlink" title="自动添加前缀"></a>自动添加前缀</h3><p>当 <code>v-bind:style</code> 使用需要添加浏览器引擎前缀的 <code>CSS property</code> 时，如 <code>transform</code>，<code>Vue.js</code> 会自动侦测并添加相应的前缀  </p><h3 id="多重值"><a href="#多重值" class="headerlink" title="多重值"></a>多重值</h3><p>可以为 <code>style</code> 绑定中的 <code>property</code> 提供一个包含多个值的数组，常用于提供多个带前缀的值，这样写只会渲染数组中最后一个被浏览器支持的值  </p><blockquote><p>包含多个值的 preoperty 数组</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>如果此处浏览器支持不带浏览器前缀的 flexbox，那么就只会渲染 display: flex  </p></blockquote><h1 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h1><h2 id="v-if-与-v-else"><a href="#v-if-与-v-else" class="headerlink" title="v-if 与 v-else"></a>v-if 与 v-else</h2><p><code>v-if</code> 指令用于条件性地渲染一块内容<br>这块内容只会在指令的表达式返回 <code>truthy</code> 值的时候被渲染  </p><p><code>v-else</code> 指令来表示 <code>v-if</code> 的 “else 块”<br><code>v-else</code> 元素必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素的后面，否则它将不会被识别  </p><blockquote><p><code>v-if</code>与<code>v-else</code>的基本使用方式  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;is_awesome&quot;</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-else</span>&gt;</span>Oh no 😢<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br><span class="javascript">      is_awesome: <span class="hljs-literal">true</span></span><br>    &#125;<br>  &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><img src="/Vue-%E5%89%8D%E7%AB%AF/7.gif"><br>依旧，这个渲染是响应式的，而且在状态发生改变之前，页面上不会有多余的元素（并不是hide，而是完全没有）  </p></blockquote><h3 id="v-if-与-v-for-一起使用"><a href="#v-if-与-v-for-一起使用" class="headerlink" title="v-if 与 v-for 一起使用"></a>v-if 与 v-for 一起使用</h3><p>不推荐同时使用 <code>v-if</code> 和 <code>v-for</code>。请查阅<a href="https://cn.vuejs.org/v2/style-guide/#%E9%81%BF%E5%85%8D-v-if-%E5%92%8C-v-for-%E7%94%A8%E5%9C%A8%E4%B8%80%E8%B5%B7-%E5%BF%85%E8%A6%81">风格指南</a>以获取更多信息<br>当 <code>v-if</code> 与 <code>v-for</code> 一起使用时，<code>v-for</code> 具有比 <code>v-if</code> 更高的优先级。请查阅<a href="https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if">列表渲染指南</a>以获取详细信息。</p><h2 id="v-else-if"><a href="#v-else-if" class="headerlink" title="v-else-if"></a>v-else-if</h2><p><code>v-else-if</code>，顾名思义，其作用就相当于马上在<code>else</code>后接一个<code>if</code>判断<br>类似于 <code>v-else</code>，<code>v-else-if</code> 也必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素之后  </p><blockquote><p><code>v-else-if</code>的使用方式  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>Not A/B/C<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br><span class="javascript">      type: <span class="hljs-string">&#x27;A&#x27;</span></span><br>    &#125;<br>  &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><img src="/Vue-%E5%89%8D%E7%AB%AF/8.gif">  </p></blockquote><h2 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 key 管理可复用的元素</h2><p><code>Vue</code> 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染  这么做除了使 <code>Vue</code> 变得非常快之外，还有其它一些现象    </p><blockquote><p>尽可能复用：用户在不同的登录方式之间切换    </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your username&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your email address&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br><span class="javascript">      loginType: <span class="hljs-string">&#x27;username&#x27;</span></span><br>    &#125;<br>  &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><img src="/Vue-%E5%89%8D%E7%AB%AF/9.gif"><br>切换 <code>loginType</code> 将不会清除用户已经输入的内容<br>两个模板都使用了相同的元素<code>&lt;input&gt;</code>。因为<code>vue</code>总是希望尽可能复用，这个元素不会被替换掉(此处仅替换了它的 <code>placeholder</code>属性)<br>这会造成一些问题，一般切换输入类型都需要将已输入内容清空，而这里没清<br>如果不希望<code>vue</code>最大程度复用，那么可以为元素添加<code>key</code>属性<br>需要注意，<code>key</code>属性需要一个唯一值  </p></blockquote><blockquote><p>独立的key：用户在不同的登录方式之间切换    </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Username<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your username&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;username-input&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-else</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>Email<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your email address&quot;</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;email-input&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">      el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>      data: &#123;<br><span class="javascript">        loginType: <span class="hljs-string">&#x27;username&#x27;</span></span><br>      &#125;<br>    &#125;)<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><img src="/Vue-%E5%89%8D%E7%AB%AF/10.gif"><br>在设置了<code>key</code>后，模板内容会被重新渲染后才放到页面上。所以输入的内容消失了    </p></blockquote><h2 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h2><p>另一个用于根据条件展示元素的选项是 <code>v-show</code> 指令<br>用法与 <code>v-if</code> 类似，都是表达式返回 <code>truthy</code> 值的时候被渲染<br>不同的是带有 <code>v-show</code> 的元素始终会被渲染并保留在 <code>DOM</code> 中<br><code>v-show</code> 只是简单地切换元素的 <code>CSS property display</code>  </p><p><strong>注意，<code>v-show</code> 不支持 <code>&lt;template&gt;</code> 元素，也不支持 <code>v-else</code></strong>  </p><blockquote><p><code>v-show</code>的使用  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;is_awesome&quot;</span>&gt;</span>Vue is awesome!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example&#x27;</span>,</span><br>    data: &#123;<br><span class="javascript">      is_awesome: <span class="hljs-literal">true</span></span><br>    &#125;<br>  &#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p><img src="/Vue-%E5%89%8D%E7%AB%AF/11.gif">  </p></blockquote><h2 id="v-if-对比-v-show"><a href="#v-if-对比-v-show" class="headerlink" title="v-if 对比 v-show"></a>v-if 对比 v-show</h2><p><code>v-if</code> 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p><p><code>v-if</code> 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p><p>相比之下，<code>v-show</code> 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 <code>CSS</code> 进行切换。</p><p>一般来说，<code>v-if</code> 有更高的切换开销，而 <code>v-show</code> 有更高的初始渲染开销  因此，如果需要非常频繁地切换，则使用 <code>v-show</code> 较好；如果在运行时条件很少改变，则使用 <code>v-if</code> 较好  </p><h1 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h1><h2 id="v-for-对应数组"><a href="#v-for-对应数组" class="headerlink" title="v-for 对应数组"></a>v-for 对应数组</h2><p>可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表<br><code>v-for</code> 指令需要使用 <code>item in items</code> 形式的特殊语法，其中 <code>items</code> 是源数据数组，而 <code>item</code> 则是被迭代的数组元素的别名  </p><blockquote><p><code>v-for</code>对应数组到元素  </p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;example-1&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.message&quot;</span>&gt;</span><br>    &#123;&#123; item.message &#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="javascript">  <span class="hljs-keyword">var</span> example1 = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    el: <span class="hljs-string">&#x27;#example-1&#x27;</span>,</span><br>    data: &#123;<br>      items: [<br><span class="javascript">        &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Foo&#x27;</span> &#125;,</span><br><span class="javascript">        &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Bar&#x27;</span> &#125;</span><br>      ]<br>    &#125;<br>  &#125;)<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode-json文件注释报错</title>
    <link href="/post/f31007a7/"/>
    <url>/post/f31007a7/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>默认的情况下，用<code>VSCode</code>打开有注释的<code>JSON</code>文件的话，会显示不允许有注释的错误<br><img src="/VSCode-json%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A%E6%8A%A5%E9%94%99/20201111105657326.png"></p><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><p>实际上这是标准的问题<br>标准的<code>JSON</code>并不允许注释的存在，所以报错是理所当然的<br><code>JSONC</code>(JSON with Comments)才是允许写注释的标准  </p><blockquote><p>注释方法与C一样  </p></blockquote><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><h2 id="对单文件"><a href="#对单文件" class="headerlink" title="对单文件"></a>对单文件</h2><p>更改<code>JSON</code>标准为<code>JSONC</code>  </p><ol><li>打开标准选择<br><img src="/VSCode-json%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A%E6%8A%A5%E9%94%99/20201111110252392.png">  </li><li>设置标准为 JSONC<br><img src="/VSCode-json%E6%96%87%E4%BB%B6%E6%B3%A8%E9%87%8A%E6%8A%A5%E9%94%99/20201111110339930.png">  </li></ol><h2 id="对所有-json文件"><a href="#对所有-json文件" class="headerlink" title="对所有.json文件"></a>对所有.json文件</h2><p>在用户设置中设置JSONC为默认  </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;files.associations&quot;: &#123;<br>    &quot;*.json&quot;: &quot;jsonc&quot;<br>&#125;,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JSON</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-大JSON文件读取-ijson</title>
    <link href="/post/aaf3dbde/"/>
    <url>/post/aaf3dbde/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>在学过一些<code>Python</code>的日常使用方法以后，你应该已经知道了<code>Python</code>自带的<code>json</code>库，它能处理一些<code>json</code>数据  </p><blockquote><p>例如：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">json.loads()  <span class="hljs-comment"># str读取</span><br>json.dumps()  <span class="hljs-comment"># 转为str</span><br></code></pre></td></tr></table></figure><p>但在面对一个体量很大的 <code>JSON</code> 文件时，无论是写还是读都会非常吃力<br>专门用于处理大 <code>JSON</code> 的库是 <code>ijson</code>  </p><h2 id="ijson"><a href="#ijson" class="headerlink" title="ijson"></a>ijson</h2><p><code>Ijson</code>是具有标准<code>Python</code>迭代器接口的迭代<code>JSON</code>解析器  </p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>pypi: <a href="https://pypi.org/project/ijson/">https://pypi.org/project/ijson/</a>  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install ijson<br></code></pre></td></tr></table></figure><p>版本需求：3.5+</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><figure class="highlight"><figcaption><span>说明中使用的json文件.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JSON">&#123;<br>  <span class="hljs-attr">&quot;earth&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;europe&quot;</span>: [<br>      &#123;&quot;name&quot;: &quot;Paris&quot;, &quot;type&quot;: &quot;city&quot;, &quot;info&quot;: &#123; ... &#125;&#125;,<br>      &#123;&quot;name&quot;: &quot;Thames&quot;, &quot;type&quot;: &quot;river&quot;, &quot;info&quot;: &#123; ... &#125;&#125;,<br>      <span class="hljs-comment">// ...</span><br>    ],<br>    &quot;america&quot;: [<br>      &#123;&quot;name&quot;: &quot;Texas&quot;, &quot;type&quot;: &quot;state&quot;, &quot;info&quot;: &#123; ... &#125;&#125;,<br>      <span class="hljs-comment">// ...</span><br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常用用法-ijson-items"><a href="#常用用法-ijson-items" class="headerlink" title="常用用法 ijson.items"></a>常用用法 ijson.items</h3><p>最常见的用法：让<code>ijson</code>从<code>JSON</code>流中 获取前缀下的内容。并转换为<code>Python</code>对象  </p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs prolog">import ijson<br><br>f = open(<span class="hljs-string">&#x27;file.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<br># 相当于获取json[<span class="hljs-string">&#x27;earth&#x27;</span>][<span class="hljs-string">&#x27;europe&#x27;</span>]下的内容<br>objects = ijson.items(f, <span class="hljs-string">&#x27;earth.europe.item&#x27;</span>)<br>cities = (o for o in objects if o[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;city&#x27;</span>)<br>for city in cities:<br>    do_something_with(city)<br></code></pre></td></tr></table></figure><h3 id="只获取值-ijson-kvitems"><a href="#只获取值-ijson-kvitems" class="headerlink" title="只获取值 ijson.kvitems"></a>只获取值 ijson.kvitems</h3><p>如果你只需要values，而不需要key，可以用<code>ijson.kvitems</code><br>这个函数的处理效率比<code>ijson.items</code>要高  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> ijson<br><br>f = urlopen(<span class="hljs-string">&#x27;http://.../&#x27;</span>)<br>european_places = ijson.kvitems(f, <span class="hljs-string">&#x27;earth.europe.item&#x27;</span>)<br>names = (v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> european_places <span class="hljs-keyword">if</span> k == <span class="hljs-string">&#x27;name&#x27;</span>)<br><span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> names:<br>    do_something_with(name)<br></code></pre></td></tr></table></figure><h3 id="asyncio支持"><a href="#asyncio支持" class="headerlink" title="asyncio支持"></a><code>asyncio</code>支持</h3><p>方法也可以异步进行  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> ijson<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>():</span><br>    f = <span class="hljs-keyword">await</span> async_urlopen(<span class="hljs-string">&#x27;http://..../&#x27;</span>)<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> <span class="hljs-built_in">object</span> <span class="hljs-keyword">in</span> ijson.items(f, <span class="hljs-string">&#x27;earth.europe.item&#x27;</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">object</span>[<span class="hljs-string">&#x27;type&#x27;</span>] == <span class="hljs-string">&#x27;city&#x27;</span>:<br>            do_something_with(city)<br>asyncio.run(run())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>ijson</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-asyncio-协程</title>
    <link href="/post/2d2478f5/"/>
    <url>/post/2d2478f5/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>asyncio</code>是用来编写 <code>并发</code> 代码的库，使用 <code>async/await</code> 语法<br><code>asyncio</code> 被用作多个提供高性能 <code>Python</code> 异步框架的基础，包括网络和网站服务，数据库连接库，分布式任务队列等等  </p><blockquote><p><code>asyncio</code> 往往是构建 <code>IO密集型</code> 和高层级 <code>结构化</code> 网络代码的最佳选择  </p></blockquote><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><code>asyncio</code>官网：<a href="https://docs.python.org/zh-cn/3/library/asyncio.html">https://docs.python.org/zh-cn/3/library/asyncio.html</a>  </p><p><code>asyncio</code>提供一组 <code>高层级</code>API 用于:<br>并发地 运行 <code>Python 协程</code> 并对其执行过程实现完全控制;  </p><ul><li>执行 <code>网络 IO 和 IPC</code>;  </li><li>控制 <code>子进程</code>;  </li><li>通过 <code>队列</code> 实现分布式任务;  </li><li><code>同步</code> 并发代码;  </li></ul><p>此外，还有一些 <code>低层级</code> API 以支持 库和框架的开发者 实现:  </p><ul><li>创建和管理 <code>事件循环</code>，以提供异步 API 用于 <code>网络化</code>, 运行 <code>子进程</code>，处理 <code>OS 信号</code> 等等;  </li><li>使用 <code>transports</code> 实现高效率协议;  </li><li>通过 async/await 语法 <code>桥接</code> 基于回调的库和代码  </li></ul><h1 id="协程与任务"><a href="#协程与任务" class="headerlink" title="协程与任务"></a>协程与任务</h1><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p><code>协程</code> 通过 <code>async/await</code> 语法进行声明，是编写 <code>asyncio</code> 应用的推荐方式  </p><blockquote><p>协程基础</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    print(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">&#x27;world&#x27;</span>)<br><br>    asyncio.run(main())<br></code></pre></td></tr></table></figure><blockquote><p>结果</p></blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hello</span><br><span class="hljs-attribute">world</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：简单地调用一个协程并不会将其加入执行日程  </p></blockquote><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>协程函数: 定义形式为 <code>async def</code> 的函数  </li><li>协程对象: 调用 <code>协程函数</code> 所返回的对象  </li></ul><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>要真正运行一个协程，<code>asyncio</code> 提供了三种主要机制:  </p><ul><li><a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.run"><code>asyncio.run()</code></a> 函数直接运行<br><code>asyncio.run()</code>是用来运行协程的最高层级的入口，案例见上</li><li>串行运行<br>没有特别设置的情况下，连续 <code>await</code> 一个或多个协程能让它串行运行，<a id="BackExampleJustAwait" href="#ExampleJustAwait">案例</a>  </li><li>并发运行<br><code>asyncio.create_task()</code> 函数用来作为 <code>asyncio</code> 任务 的多个协程，<a id="BackExampleCreateTaskMostBasing" href="#ExampleCreateTaskMostBasing">案例</a>  </li></ul><h2 id="可等待对象"><a href="#可等待对象" class="headerlink" title="可等待对象"></a>可等待对象</h2><p>如果一个对象可以在 <code>await</code> 语句中使用，那么它就是 可等待对象<br>许多 <code>asyncio API</code> 都被设计为接受可等待对象  </p><p>可等待 对象有三种主要类型：协程、任务、Future  </p><h3 id="可等待对象-协程"><a href="#可等待对象-协程" class="headerlink" title="可等待对象 - 协程"></a>可等待对象 - 协程</h3><p><code>Python</code> <code>协程</code>属于 <code>可等待</code> 对象，因此可以在其他协程中被等待  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nested</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 如果一个协程创建出来，但是没有被 await ,那么它根本就不会被执行</span><br>    nested()<br>    <span class="hljs-comment"># await 以后才会被执行</span><br>    print(<span class="hljs-keyword">await</span> nested())  <span class="hljs-comment"># 将会输出42</span><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h3 id="可等待对象-Task-任务"><a href="#可等待对象-Task-任务" class="headerlink" title="可等待对象 - Task 任务"></a>可等待对象 - Task 任务</h3><p><code>Task</code> 被用来设置日程以便 <code>并发</code> 执行协程。</p><p>当一个协程通过 <a href="https://docs.python.org/zh-cn/3/library/asyncio-task.html#asyncio.create_task"><code>asyncio.create_task()</code></a> 等函数被打包为一个 <code>Task</code>，该协程将自动排入日程准备立即运行:  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nested</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 利用 协程函数 nested() 创建了一个 Task</span><br>    <span class="hljs-comment"># 这个 Task 会被 协程 main() 立即执行</span><br>    task = asyncio.create_task(nested())<br>    <span class="hljs-keyword">await</span> task<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h4 id="名字-与-计算结果"><a href="#名字-与-计算结果" class="headerlink" title="名字 与 计算结果"></a>名字 与 计算结果</h4><ul><li>名字<br>可以为<code>Task</code>对象设置一个名字，用来辨识不同的对象<br>名字可以在创建的时候通过参数设置, 也可以通过<code>set_name()</code>方法进行设置  </li><li>获取计算结果<br>可以通过<code>result()</code>方法来获取<code>Task</code>运行完毕以后得到的计算结果  </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nested</span>():</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">42</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    task = asyncio.create_task(nested())<br>    <span class="hljs-comment"># 设置 Task 的名字。其实也可以在创建的时候传参来设置</span><br>    task.set_name(<span class="hljs-string">&#x27;My_name_is_Task&#x27;</span>)<br>    <span class="hljs-keyword">await</span> task<br>    print(<span class="hljs-string">&#x27;Task 的名字为:&#x27;</span>, task.get_name())<br>    print(<span class="hljs-string">&#x27;Task 的计算结果为:&#x27;</span>, task.result())<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h4 id="运行完毕-与-取消"><a href="#运行完毕-与-取消" class="headerlink" title="运行完毕 与 取消"></a>运行完毕 与 取消</h4><ul><li>是否运行完毕<br>查看 <code>Task</code> 是否运行完毕可以用<code>done()</code>方法<br>如果 <code>Task</code> 对象 <strong>已完成</strong> 则返回 <code>True</code><br>当 <code>Task</code> 所封包的协程返回一个值、引发一个异常或 <code>Task</code> 本身被取消时，会被认为 <strong>已完成</strong>  </li><li>取消<br>要取消一个正在运行的 <code>Task</code> 对象可使用 <code>cancel()</code> 方法<br>调用此方法将使该 <code>Task</code> 对象抛出一个 <code>CancelledError</code> 异常给打包的协程  </li><li>查看是否被取消<br>使用<code>cancelled()</code>方法可以查看<code>Task</code>是否已经被取消运行  </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nested</span>():</span><br>    a = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">4</span>):<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>        a += randint(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)<br>        print(<span class="hljs-string">&#x27;nested -&gt; &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(a))<br>    <span class="hljs-keyword">return</span> a<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">using_cancel</span>():</span><br>    _task = asyncio.create_task(nested())<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 等待,以验证真的是运行以后再取消</span><br>    _task.cancel()<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> _task<br>    <span class="hljs-keyword">except</span> asyncio.CancelledError:<br>        <span class="hljs-keyword">if</span> _task.cancelled():  <span class="hljs-comment"># cancelled() 可被用来检测 Task 对象是否被取消。</span><br>            print(<span class="hljs-string">&quot;task 已经被取消了&quot;</span>)<br><br>        <span class="hljs-keyword">if</span> _task.done():  <span class="hljs-comment"># done()方法 返回 Task 是否已经完成  </span><br>            print(<span class="hljs-string">&#x27;task 已经完成&#x27;</span>)<br>            <br></code></pre></td></tr></table></figure><h3 id="可等待对象-Future-对象"><a href="#可等待对象-Future-对象" class="headerlink" title="可等待对象 - Future 对象"></a>可等待对象 - Future 对象</h3><p><a href="https://docs.python.org/zh-cn/3/library/asyncio-future.html#asyncio.Future"><code>Future</code></a> 是一种特殊的 <code>低层级</code> 可等待对象，表示一个异步操作的 <code>最终结果</code>  </p><p>当一个 <code>Future 对象</code> 被等待，这意味着协程将保持等待直到该 <code>Future</code> 对象在其他地方操作完毕  </p><p>在 <code>asyncio</code> 中需要 <code>Future</code> 对象以便允许通过 <code>async/await</code> 使用基于回调的代码  </p><p>通常情况下 没有必要 在应用层级的代码中创建 <code>Future 对象</code>  </p><h2 id="运行-asyncio-程序"><a href="#运行-asyncio-程序" class="headerlink" title="运行 asyncio 程序"></a>运行 asyncio 程序</h2><p><code>asyncio.run(coro, *, debug=False)</code><br>执行 <code>coroutine</code> coro 并返回结果。</p><p>此函数会运行传入的协程，负责管理 <code>asyncio</code> 事件循环，终结异步生成器，并关闭线程池。</p><p>当有其他 <code>asyncio</code> 事件循环在同一线程中运行时，此函数不能被调用。</p><p>如果 <code>debug</code> 为 <code>True</code>，事件循环将以调试模式运行。</p><p>此函数总是会创建一个新的事件循环并在结束时关闭之。它应当被用作 <code>asyncio</code> 程序的主入口点，理想情况下应当只被调用一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h2 id="创建任务"><a href="#创建任务" class="headerlink" title="创建任务"></a>创建任务</h2><p><code>asyncio.create_task(coro, *, name=None)</code><br>将 <code>协程函数coro</code> 打包为一个 <code>Task</code> 排入日程准备执行，函数执行后，会返回一个 <code>Task</code> 对象  </p><p>如果 参数<code>name</code> 不为 <code>None</code>，它将使用 <code>Task.set_name()</code> 来设为任务的名称  </p><p>该任务会在 <code>get_running_loop()</code> 返回的循环中执行，如果当前线程没有在运行的循环则会引发 <code>RuntimeError</code>  </p><blockquote><p>此函数 在 <code>Python 3.7</code> 中被加入。在 <code>Python 3.7</code> 之前，可以改用低层级的 <code>asyncio.ensure_future()</code> 函数。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">coro</span>():</span><br>    ...<br><br><span class="hljs-comment"># In Python 3.7+</span><br>task = asyncio.create_task(coro())<br>...<br><br><span class="hljs-comment"># This works in all Python versions but is less readable</span><br>task = asyncio.ensure_future(coro())<br></code></pre></td></tr></table></figure><h2 id="休眠"><a href="#休眠" class="headerlink" title="休眠"></a>休眠</h2><p><code>coroutine asyncio.sleep(delay, result=None, *)</code><br>阻塞 <code>delay</code> 指定的秒数<br>如果指定了 <code>result</code>，则当协程完成时将其返回给调用者。<br><code>sleep()</code> 总是会挂起当前任务，以允许其他任务运行。  </p><blockquote><p>以下协程示例运行 5 秒，每秒显示一次当前日期:  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> datetime<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">display_date</span>():</span><br>    loop = asyncio.get_running_loop()<br>    end_time = loop.time() + <span class="hljs-number">5.0</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        print(datetime.datetime.now())<br>        <span class="hljs-keyword">if</span> (loop.time() + <span class="hljs-number">1.0</span>) &gt;= end_time:<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br><br>asyncio.run(display_date())<br></code></pre></td></tr></table></figure><h2 id="并发运行"><a href="#并发运行" class="headerlink" title="并发运行"></a>并发运行</h2><p><code>awaitable asyncio.gather(*aws,  return_exceptions=False)</code><br>并发 运行<code>aws</code> 序列中的 可等待对象  </p><p>如果 <code>aws</code> 中的某个可等待对象为协程，它将自动作为一个<code>Task</code>加入日程  </p><p>如果所有可等待对象都成功完成，结果将是一个由所有返回值聚合而成的列表。结果值的顺序与 <code>aws</code> 中可等待对象的顺序一致  </p><ul><li>return_exceptions<ul><li>如果 <code>return_exceptions</code> 为 <code>False</code> (默认)，所引发的首个异常会立即传播给等待 <code>gather()</code> 的任务<br><code>aws</code> 序列中的其他可等待对象 不会被取消 并将继续运行  </li><li>如果 <code>return_exceptions</code> 为 <code>True</code>，异常会和成功的结果一样处理，并聚合至结果列表。</li></ul></li></ul><p>如果 <code>gather()</code> 被取消，所有被提交 (尚未完成) 的可等待对象也会 被取消。</p><p>如果 <code>aws</code> 序列中的任一 <code>Task</code> 或 <code>Future</code> 对象 被取消，它将被当作引发了 <code>CancelledError</code> 一样处理 – 在此情况下 <code>gather()</code> 调用 不会 被取消。这是为了防止一个已提交的 <code>Task/Future</code> 被取消导致其他 <code>Tasks/Future</code> 也被取消  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span>(<span class="hljs-params">name, number</span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    计算阶乘</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    f = <span class="hljs-number">1</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, number + <span class="hljs-number">1</span>):<br>        print(<span class="hljs-string">f&quot;Task <span class="hljs-subst">&#123;name&#125;</span>: Compute factorial(<span class="hljs-subst">&#123;i&#125;</span>)...&quot;</span>)<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">1</span>)<br>        f *= i<br>    print(<span class="hljs-string">f&quot;Task <span class="hljs-subst">&#123;name&#125;</span>: <span class="hljs-subst">&#123;number&#125;</span>的阶乘 = <span class="hljs-subst">&#123;f&#125;</span>&quot;</span>)<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># Schedule three calls *concurrently*:</span><br>    <span class="hljs-keyword">await</span> asyncio.gather(<br>        factorial(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">2</span>),<br>        factorial(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">3</span>),<br>        factorial(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">4</span>),<br>    )<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h2 id="屏蔽取消操作"><a href="#屏蔽取消操作" class="headerlink" title="屏蔽取消操作"></a>屏蔽取消操作</h2><p><code>awaitable asyncio.shield(aw, *, loop=None)</code><br>保护一个 <code>可等待对象</code> 防止其被 <code>取消</code><br>如果 <code>aw</code> 是一个协程，它将自动作为任务加入日程  </p><p>以下语句:<br><code>res = await shield(something())</code><br>相当于:<br><code>res = await something()</code><br>不同之处 在于如果包含它的协程被取消，在 something() 中运行的任务不会被取消<br>从<code>something()</code> 的角度看来，取消操作并没有发生。然而其调用者已被取消，因此 “await” 表达式仍然会引发 <code>CancelledError</code>  </p><p>如果通过其他方式取消 <code>something()</code> (例如在其内部操作) 则 <code>shield()</code> 也会取消。</p><p>如果希望完全忽略取消操作 (不推荐) 则 <code>shield()</code> 函数需要配合一个 <code>try/except</code> 代码段  </p><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p><code>coroutine asyncio.wait_for(aw, timeout, *, loop=None)</code><br>等待 <code>aw</code> 可等待对象 完成，指定 <code>timeout</code> 秒数后超时  <a id="asyncio_wait_for"></a><br>如果 <code>aw</code> 是一个协程，它将自动作为任务加入日程<br><code>timeout</code> 可以为 <code>None</code>，也可以为 <code>float</code> 或 <code>int</code> 型数值表示的等待秒数。如果 <code>timeout</code> 为 <code>None</code>，则等待直到完成<br>如果发生超时，任务将取消并引发 <code>asyncio</code>.<code>TimeoutError</code><br>要避免任务 取消，可以加上 <code>shield()</code>  </p><p>此函数将等待直到 <code>Future</code> 确实被取消，所以总等待时间可能超过 <code>timeout</code>。 如果在取消期间发生了异常，异常将会被传播  </p><p>如果等待被取消，则 <code>aw</code> 指定的对象也会被取消  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eternity</span>():</span><br>    <span class="hljs-comment"># Sleep for one hour</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3600</span>)<br>    print(<span class="hljs-string">&#x27;yay!&#x27;</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># Wait for at most 1 second</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">await</span> asyncio.wait_for(eternity(), timeout=<span class="hljs-number">1.0</span>)<br>    <span class="hljs-keyword">except</span> asyncio.TimeoutError:<br>        print(<span class="hljs-string">&#x27;timeout!&#x27;</span>)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h2 id="简单等待"><a href="#简单等待" class="headerlink" title="简单等待"></a>简单等待</h2><h3 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h3><p><code>coroutine asyncio.wait(aws, *, loop=None, timeout=None, return_when=ALL_COMPLETED)</code><br>运行 <code>aws</code> 的可等待对象。阻塞直到触发<code>return_when</code>设置的条件<br>返回两个 <code>Task/Future</code> 集合: (done, pending)  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">done, pending = <span class="hljs-keyword">await</span> asyncio.wait(aws)<br></code></pre></td></tr></table></figure><p>如指定 <code>timeout (float 或 int 类型)</code> 则它将被用于控制返回之前等待的最长秒数  </p><p>请注意此函数不会引发 <code>asyncio.TimeoutError</code><br>当超时发生时，未完成的 <code>Future</code> 或 <code>Task</code> 将在指定秒数后被返回  </p><p><code>return_when</code> 指定此函数应在何时返回。它必须为以下常数之一  </p><table><thead><tr><th>常数</th><th>描述</th></tr></thead><tbody><tr><td>FIRST_COMPLETED</td><td>函数将在任意可等待对象结束或取消时返回</td></tr><tr><td>FIRST_EXCEPTION</td><td>函数将在任意可等待对象因引发异常而结束时返回。当没有引发任何异常时它就相当于 <code>ALL_COMPLETED</code></td></tr><tr><td>ALL_COMPLETED</td><td>函数将在所有可等待对象结束或取消时返回</td></tr></tbody></table><p>与 <code>wait_for()</code> 不同，<code>wait()</code> 在超时发生时不会取消可等待对象  </p><h3 id="as-completed"><a href="#as-completed" class="headerlink" title="as_completed"></a>as_completed</h3><p><code>asyncio.as_completed(aws, *, loop=None, timeout=None)</code><br>运行 <code>aws</code> 的可等待对象。返回可迭代的协程<br>如果在所有 <code>Future</code> 对象完成前发生超时则将引发 <code>asyncio.TimeoutError</code>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> random <span class="hljs-keyword">import</span> randint<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span><br>    <span class="hljs-keyword">return</span> randint(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    the_futures = []<br>    the_futures.append(asyncio.ensure_future(foo()))<br>    the_futures.append(asyncio.ensure_future(foo()))<br>    the_futures.append(asyncio.ensure_future(foo()))<br>    the_futures.append(asyncio.ensure_future(foo()))<br>    <br>    <span class="hljs-keyword">for</span> coro <span class="hljs-keyword">in</span> asyncio.as_completed(the_futures):<br>        earliest_result = <span class="hljs-keyword">await</span> coro<br>        print(earliest_result)<br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h1 id="同步原语"><a href="#同步原语" class="headerlink" title="同步原语"></a>同步原语</h1><p>章节官方文档: <a href="https://docs.python.org/zh-cn/3/library/asyncio-sync.html">https://docs.python.org/zh-cn/3/library/asyncio-sync.html</a>  </p><blockquote><p>原语<br>所谓原语，一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断<br>在操作系统中，某些被进程调用的操作，如队列操作、对信号量的操作、检查启动外设操作等，一旦开始执行，就不能被中断，否则就会出现操作错误，造成系统混乱  </p></blockquote><p><code>asyncio</code> 同步原语被设计为与 <code>threading</code> 模块的类似，但有两个关键注意事项:</p><ul><li><strong><code>asyncio</code> 原语不是线程安全的</strong>，因此它们不应被用于 <code>OS</code> 线程同步 (而应当使用 <code>threading</code>)；</li><li>这些同步原语的方法不接受 <code>timeout</code> 参数；请使用 <a href="#asyncio_wait_for"><code>asyncio.wait_for()</code></a> 函数来执行带有超时的操作  </li></ul><h2 id="Lock-锁"><a href="#Lock-锁" class="headerlink" title="Lock 锁"></a>Lock 锁</h2><p><code>class asyncio.Lock(*)</code><br>实现一个用于 <code>asyncio</code> 任务的互斥锁。 非线程安全<br><code>asyncio</code> 锁可被用来保证对共享资源的独占访问<br>推荐<a href="#ExampleAsyncWithRunLock">通过 <code>async with</code> 语句来使用 <code>Lock</code></a><a id="AsyncWithRunLock"></a>  </p><table><thead><tr><th>方法</th><th>信息</th><th>特殊</th></tr></thead><tbody><tr><td>coroutine acquire()</td><td>获取锁<br>此方法会等待直至锁为 <code>unlocked</code>，将其设为 <code>locked</code> 并返回 <code>True</code><br>当有一个以上的协程在 <code>acquire()</code> 中被阻塞则会等待解锁，最终只有一个协程会被执行</td><td><strong>公平的</strong>的获取: <br>等待的协程服从先等先服务原则</td></tr><tr><td>release()</td><td>释放锁<br>当锁为 <code>locked</code> 时，将其设为 <code>unlocked</code> 并返回</td><td>如果锁为 <code>unlocked</code>，则会引发 <code>RuntimeError</code></td></tr><tr><td>locked()</td><td>如果锁为 <code>locked</code> 则返回 <code>True</code></td><td></td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">using_toilet</span>(<span class="hljs-params">toilet_lock, name:<span class="hljs-built_in">str</span></span>):</span><br>    print(<span class="hljs-string">&#x27;&#123;&#125; 尝试获取厕所使用权&#x27;</span>.<span class="hljs-built_in">format</span>(name))<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> toilet_lock:<br>        print(<span class="hljs-string">&#x27;&#123;&#125; 正在使用厕所&#x27;</span>.<span class="hljs-built_in">format</span>(name))<br>        <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">4</span>)<br>    print(<span class="hljs-string">&#x27;&#123;&#125; 厕所使用完毕&#x27;</span>.<span class="hljs-built_in">format</span>(name))<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">using_toilet_without_lock</span>(<span class="hljs-params">name:<span class="hljs-built_in">str</span></span>):</span><br>    print(<span class="hljs-string">&#x27;&#123;&#125; 尝试获取厕所使用权&#x27;</span>.<span class="hljs-built_in">format</span>(name))<br>    print(<span class="hljs-string">&#x27;&#123;&#125; 正在使用厕所&#x27;</span>.<span class="hljs-built_in">format</span>(name))<br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">4</span>)<br>    print(<span class="hljs-string">&#x27;&#123;&#125; 厕所使用完毕&#x27;</span>.<span class="hljs-built_in">format</span>(name))<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    print(<span class="hljs-string">&#x27;\n并行无锁&#x27;</span>)<br>    futures = asyncio.wait([<br>        using_toilet_without_lock(name)<br>        <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;DIO&#x27;</span>, <span class="hljs-string">&#x27;JOJO&#x27;</span>, <span class="hljs-string">&#x27;XISA&#x27;</span>]<br>    ])<br>    <span class="hljs-keyword">await</span> asyncio.ensure_future(futures)<br><br>    print(<span class="hljs-string">&#x27;\n并行有锁&#x27;</span>)<br>    toilet_lock = asyncio.Lock()<br>    futures = asyncio.wait([<br>        using_toilet(toilet_lock, name)<br>        <span class="hljs-keyword">for</span> name <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;DIO&#x27;</span>, <span class="hljs-string">&#x27;JOJO&#x27;</span>, <span class="hljs-string">&#x27;XISA&#x27;</span>]<br>    ])<br>    <span class="hljs-keyword">await</span> asyncio.ensure_future(futures)<br><br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h2 id="Event-事件"><a href="#Event-事件" class="headerlink" title="Event 事件"></a>Event 事件</h2><p><code>class asyncio.Event(*)</code><br>事件对象。 该对象不是线程安全的。</p><p><code>asyncio</code> 事件可被用来通知多个 <code>asyncio</code> 任务已经有事件发生。</p><p><code>Event</code> 对象会管理一个内部旗标，该旗标初始时将被设为 <code>false</code>  </p><ul><li><code>set()</code> 方法将其设为 <code>true</code>  </li><li><code>clear()</code> 方法将其设为 <code>false</code>  </li><li><code>wait()</code> 方法会阻塞直至该旗标被设为 <code>true</code>  </li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">waiter</span>(<span class="hljs-params">event</span>):</span><br>    print(<span class="hljs-string">&#x27;意大利炮已上膛，等待发射命令中......&#x27;</span>)<br>    <span class="hljs-keyword">await</span> event.wait()<br>    print(<span class="hljs-string">&#x27;开炮！！！开炮！！！开炮！！！&#x27;</span>)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    event = asyncio.Event()  <span class="hljs-comment"># 创建一个Event对象</span><br>    <span class="hljs-comment"># create_task 生成一个 Task，这个 Task 立即执行</span><br>    <span class="hljs-comment"># 然后碰到event.wait()会一直等待，直到 Event 被 set</span><br>    waiter_task = asyncio.create_task(waiter(event))<br><br>    <span class="hljs-comment"># 等待3秒后，set Event</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(<span class="hljs-number">3</span>)<br>    event.<span class="hljs-built_in">set</span>()<br><br>    <span class="hljs-comment"># 虽然说在Event set了以后，Task会运行进行直到运行完毕  </span><br>    <span class="hljs-comment"># 但加个等待以确保100% 完成是个好习惯</span><br>    <span class="hljs-keyword">await</span> waiter_task<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><h2 id="Condition-条件"><a href="#Condition-条件" class="headerlink" title="Condition 条件"></a>Condition 条件</h2><p><code>asyncio</code> 条件原语可被任务用于等待某个事件发生，然后获取对共享资源的独占访问  </p><p>在本质上，<code>Condition</code> 对象合并了 <code>Event</code> 和 <code>Lock</code> 的功能<br>多个 <code>Condition</code> 对象有可能共享一个 <code>Lock</code>，这允许关注于共享资源的特定状态的不同任务实现对共享资源的协同独占访问  </p><p>可选的 <code>lock</code> 参数必须为 <code>Lock</code> 对象或 <code>None</code>。 在后一种情况下会自动创建一个新的 <code>Lock</code> 对象。</p><p>推荐<a href="#ExampleAsyncWithRunCondition">通过 <code>async with</code> 语句来使用 <code>Condition</code></a><a id="AsyncWithRunCondition"></a>  </p><p>|方法|信息|特殊|<br>|–|–|<br>|coroutine acquire()|获取下层的锁<br>此方法会等待直至下层的锁为 <code>unlocked</code>，将其设为 <code>locked</code> 并返回 <code>True</code>|<br>|notify(n=1)|唤醒最多 <code>n</code> 个正在等待此条件的任务（默认为 1 个）<br>如果没有任务正在等待则此方法为空操作。<br>锁必须在此方法被调用前被获取并在随后被快速释放<br>|如果通过一个 <code>unlocked</code> 锁调用则会引发 <code>RuntimeError</code>|<br>|locked()|如果下层的锁已被获取则返回 <code>True</code>||<br>|notify_all()|唤醒所有正在等待此条件的任务。此方法的行为类似于 <code>notify()</code>，但会唤醒所有正在等待的任务。锁必须在此方法被调用前被获取并在随后被快速释放| 如果通过一个 <code>unlocked</code> 锁调用则会引发 <code>RuntimeError</code>|<br>|release()|释放下层的锁|当在未锁定的锁上发起调用时，会引发 <code>RuntimeError</code>|<br>|coroutine wait()|等待直至收到通知<br>这个方法会释放下层的锁，然后保持阻塞直到被 <code>notify()</code> 或 <code>notify_all()</code> 调用所唤醒。 <br>一旦被唤醒，<code>Condition</code> 会重新获取它的锁并且此方法将返回 <code>True</code>|当此方法被调用时如果调用方任务未获得锁，则会引发 <code>RuntimeError</code>|<br>|coroutine wait_for(predicate)|等待直到目标值变为 <code>true</code><br>目标必须为一个可调用对象，其结果将被解读为一个布尔值。 最终的值将为返回值。|</p><h2 id="Semaphore-信号量"><a href="#Semaphore-信号量" class="headerlink" title="Semaphore 信号量"></a>Semaphore 信号量</h2><p>信号量会管理一个内部计数器，该计数器会随每次 <code>acquire()</code> 调用递减并随每次 <code>release()</code> 调用递增。计数器的值永远不会降到零以下<br>当 <code>acquire()</code> 发现其值为零时，它将保持阻塞直到有某个任务调用了 <code>release()</code>  </p><p>可选的 <code>value</code> 参数用来为内部计数器赋初始值 (默认值为 1)。 如果给定的值小于 <code>0</code> 则会引发 <code>ValueError</code>  </p><table><thead><tr><th>方法</th><th>信息</th></tr></thead><tbody><tr><td>coroutine acquire()</td><td>获取一个信号量。<br>如果内部计数器的值大于零，则将其减一并立即返回 <code>True</code><br> 如果其值为零，则会等待直到 <code>release()</code> 并调用并返回 <code>True</code></td></tr><tr><td>locked()</td><td>如果信号量对象无法被立即获取则返回 <code>True</code></td></tr><tr><td>release()</td><td>释放一个信号量对象，将内部计数器的值加1<br>可以唤醒一个正在等待获取信号量对象的任务。<br>不同于 <code>BoundedSemaphore</code>，<code>Semaphore</code> 允许执行的 <code>release()</code> 调用多于 <code>acquire()</code> 调用</td></tr></tbody></table><h2 id="BoundedSemaphore"><a href="#BoundedSemaphore" class="headerlink" title="BoundedSemaphore"></a>BoundedSemaphore</h2><p><code>class asyncio.BoundedSemaphore(value=1, *)</code><br>绑定的信号量对象<br><code>BoundedSemaphore</code> 是特殊版本的 <code>Semaphore</code>，如果在 <code>release()</code> 中内部计数器值增加到初始 <code>value</code> 以上它将引发一个 <code>ValueError</code>  </p><h1 id="未完成"><a href="#未完成" class="headerlink" title="未完成"></a>未完成</h1><p>位置：<a href="https://docs.python.org/zh-cn/3/library/asyncio-subprocess.html">https://docs.python.org/zh-cn/3/library/asyncio-subprocess.html</a>  </p><hr><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><h2 id="串行等待运行"><a href="#串行等待运行" class="headerlink" title="串行等待运行"></a>串行等待运行</h2><p><a id="ExampleJustAwait"></a></p><blockquote><p>以下代码段会在等待 1 秒后打印 “hello”，然后 再次 等待 2 秒后打印 “world  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_after</span>(<span class="hljs-params">delay, what</span>):</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(delay)<br>    print(what)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    print(<span class="hljs-string">f&quot;started at <span class="hljs-subst">&#123;time.strftime(<span class="hljs-string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 直接运行并等待执行完毕（简单来说就是串行执行的协程）</span><br>    <span class="hljs-keyword">await</span> say_after(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;hello&#x27;</span>)<br>    <span class="hljs-keyword">await</span> say_after(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;world&#x27;</span>)<br>    print(<span class="hljs-string">f&quot;finished at <span class="hljs-subst">&#123;time.strftime(<span class="hljs-string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><pre><code>&gt;预期的输出:  </code></pre><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">started</span> at <span class="hljs-number">17</span>:<span class="hljs-number">13</span>:<span class="hljs-number">52</span><br><span class="hljs-attribute">hello</span><br><span class="hljs-attribute">world</span><br><span class="hljs-attribute">finished</span> at <span class="hljs-number">17</span>:<span class="hljs-number">13</span>:<span class="hljs-number">55</span><br></code></pre></td></tr></table></figure><center>[Back](#BackExampleJustAwait)</center><h2 id="asyncio-create-task-基础并行运行"><a href="#asyncio-create-task-基础并行运行" class="headerlink" title="asyncio.create_task 基础并行运行"></a>asyncio.create_task 基础并行运行</h2><p><a id="ExampleCreateTaskMostBasing"></a></p><blockquote><p>等待到两个协程都执行完毕，因为是并行的，预计会用两秒钟  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">say_after</span>(<span class="hljs-params">delay, what</span>):</span><br>    <span class="hljs-keyword">await</span> asyncio.sleep(delay)<br>    print(what)<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    task1 = asyncio.create_task(say_after(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;world&#x27;</span>))<br>    task2 = asyncio.create_task(say_after(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;hello&#x27;</span>))<br>    print(<span class="hljs-string">f&quot;started at <span class="hljs-subst">&#123;time.strftime(<span class="hljs-string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 等待到两个协程都执行完毕，因为是并行的，预计会用两秒钟</span><br>    <span class="hljs-keyword">await</span> task1<br>    <span class="hljs-keyword">await</span> task2<br>    print(<span class="hljs-string">f&quot;finished at <span class="hljs-subst">&#123;time.strftime(<span class="hljs-string">&#x27;%X&#x27;</span>)&#125;</span>&quot;</span>)<br><br>asyncio.run(main())<br></code></pre></td></tr></table></figure><center>[Back](#BackExampleCreateTaskMostBasing)</center><h2 id="async-with-运行Lock"><a href="#async-with-运行Lock" class="headerlink" title="async with 运行Lock"></a><code>async with</code> 运行<code>Lock</code></h2><p><a id="ExampleAsyncWithRunLock"></a>通过<code>async with</code>来运行<code>Lock</code>能够能够让代码更加美观  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">lock = asyncio.Lock()<br><br><span class="hljs-comment"># ... later</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> lock:<br>    <span class="hljs-comment"># access shared state</span><br></code></pre></td></tr></table></figure><p>这等价于:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">lock = asyncio.Lock()<br><br><span class="hljs-comment"># ... later</span><br><span class="hljs-keyword">await</span> lock.acquire()<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># access shared state</span><br><span class="hljs-keyword">finally</span>:<br>    lock.release()<br><br>lock = asyncio.Lock()<br></code></pre></td></tr></table></figure><center>[Back](#AsyncWithRunLock)</center><h2 id="async-with-运行Condition"><a href="#async-with-运行Condition" class="headerlink" title="async with 运行Condition"></a><code>async with</code> 运行<code>Condition</code></h2><p><a id="ExampleAsyncWithRunCondition"></a>通过<code>async with</code>来运行<code>Lock</code>能够能够让代码更加美观  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">cond = asyncio.Condition()<br><br><span class="hljs-comment"># ... later</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> cond:<br>    <span class="hljs-keyword">await</span> cond.wait()<br></code></pre></td></tr></table></figure><p>这等价于:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">cond = asyncio.Condition()<br><br><span class="hljs-comment"># ... later</span><br><span class="hljs-keyword">await</span> cond.acquire()<br><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">await</span> cond.wait()<br><span class="hljs-keyword">finally</span>:<br>    cond.release()<br></code></pre></td></tr></table></figure><center>[Back](#AsyncWithRunCondition)</center>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>协程</tag>
      
      <tag>asyncio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-DownloaderMiddleware-下载中间件</title>
    <link href="/post/7e3517c0/"/>
    <url>/post/7e3517c0/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>下载器中间件是介于<code>Scrapy</code>的<code>request</code>/<code>response</code>处理的钩子框架<br>是用于全局修改<code>request</code>和<code>rsponse</code>的一个轻量、底层的系统  </p><h1 id="激活下载器中间件"><a href="#激活下载器中间件" class="headerlink" title="激活下载器中间件"></a>激活下载器中间件</h1><p>要激活下载器中间件组件，将其加入到setting.py的 <code>DOWNLOADER_MIDDLEWARES</code>设置中<br>这个设置是一个<code>dict</code>，键为中间件类的路径，值为其中间件的处理顺序  </p><h1 id="编写下载器中间件"><a href="#编写下载器中间件" class="headerlink" title="编写下载器中间件"></a>编写下载器中间件</h1><p>编写下载器中间件十分简单<br>每个中间件组件是一个定义了以下一个或多个方法的<code>Python类</code>  </p><h2 id="process-request-request-spider"><a href="#process-request-request-spider" class="headerlink" title="process_request(request, spider)"></a>process_request(request, spider)</h2><p>当每个<code>request</code>通过下载中间件时，该方法被调用  </p><p>此函数必须返回/抛出其中之一: </p><ul><li>返回 None  </li><li>返回一个 Response </li><li>返回一个 Request </li><li>抛出 IgnoreRequest</li></ul><h3 id="返回-None"><a href="#返回-None" class="headerlink" title="返回 None"></a>返回 None</h3><p><code>Scrapy</code>将继续处理该<code>request</code>，执行其他的中间件的相应方法，直到合适的下载器处理函数(download handler)被调用， 该<code>request</code>被执行(其response被下载)  </p><h3 id="返回一个-Response"><a href="#返回一个-Response" class="headerlink" title="返回一个 Response"></a>返回一个 Response</h3><p>这个<code>Response</code>将作为最终的<code>Response</code>返回。不会再将它传给其他的中间件的<code>process_request()</code><br>这个<code>Response</code>，会像普通的<code>Response</code>一样。传给每一个中间件的<code>process_response()</code>方法进行处理  </p><h3 id="返回一个-Request"><a href="#返回一个-Request" class="headerlink" title="返回一个 Request"></a>返回一个 Request</h3><p><code>Scrapy</code>停止调用 <code>process_request</code>方法并重新调度返回的<code>request</code>。当新返回的<code>request</code>被执行后， 相应地中间件链将会根据下载的<code>response</code>被调用  </p><h3 id="抛出-IgnoreRequest"><a href="#抛出-IgnoreRequest" class="headerlink" title="抛出 IgnoreRequest"></a>抛出 IgnoreRequest</h3><p>中间件的<code>process_exception()</code>方法会被调用<br>如果没有任何一个方法处理该异常， 则<code>request</code>的<code>errback(Request.errback)</code>方法会被调用<br>如果没有代码处理抛出的异常， 则该异常被忽略且不记录  </p><h2 id="process-response-request-response-spider"><a href="#process-response-request-response-spider" class="headerlink" title="process_response(request, response, spider)"></a>process_response(request, response, spider)</h2><p>此函数必须返回以下之一:   </p><ul><li>返回一个<code>Response</code>对象  </li><li>返回一个 Request 对象  </li><li>抛 IgnoreRequest 异常  </li></ul><h3 id="返回一个-Response-1"><a href="#返回一个-Response-1" class="headerlink" title="返回一个 Response"></a>返回一个 Response</h3><p>(可以与传入的response相同，也可以是全新的对象)<br>该<code>response</code>会被在链中的其他中间件的 <code>process_response()</code>方法处理，直到所有中间件处理完就返回  </p><p>需要注意的是，虽然是需要返回<code>scrapy.http.Response</code>对象，但这个类并不能直接返回<br>如果想要返回，需要用继承这个类的对象的实例来返回<br>官方有一些预设的继承类，如：<code>scrapy.http.TextResponse</code>、<code>scrapy.http.HtmlResponse</code>  </p><h3 id="返回一个-Request-对象"><a href="#返回一个-Request-对象" class="headerlink" title="返回一个 Request 对象"></a>返回一个 Request 对象</h3><p>中间件链停止，返回的request会被重新调度下载  </p><h3 id="抛出一个-IgnoreRequest-异常"><a href="#抛出一个-IgnoreRequest-异常" class="headerlink" title="抛出一个 IgnoreRequest 异常"></a>抛出一个 IgnoreRequest 异常</h3><p>调用<code>request</code>的<code>errback(Request.errback)</code><br>如果没有代码处理抛出的异常，则该异常被忽略且不记录(不同于其他异常那样)   </p><h2 id="process-exception-request-exception-spider"><a href="#process-exception-request-exception-spider" class="headerlink" title="process_exception(request, exception, spider)"></a>process_exception(request, exception, spider)</h2><p>当 下载处理器 或 下载中间件 抛出异常(包括<code>IgnoreRequest</code>异常)时，会调用<code>process_exception()</code>  </p><p><code>process_exception()</code> 应该返回以下之一:  </p><ul><li>返回 None  </li><li>一个 Response 对象  </li><li>一个 Request 对象  </li></ul><h3 id="返回-None-1"><a href="#返回-None-1" class="headerlink" title="返回 None"></a>返回 None</h3><p><code>Scrapy</code>将会继续处理该异常，接着调用已安装的其他中间件的 <code>process_exception()</code>方法，直到所有中间件都被调用完毕，则调用默认的异常处理。</p><h3 id="返回一个-Response-对象"><a href="#返回一个-Response-对象" class="headerlink" title="返回一个 Response 对象"></a>返回一个 Response 对象</h3><p>已安装的中间件链的<code>process_response()</code>方法被调用。<code>Scrapy</code>将不会调用任何其他中间件的<code>process_exception()</code> 方法  </p><h3 id="返回一个-Request-对象-1"><a href="#返回一个-Request-对象-1" class="headerlink" title="返回一个 Request 对象"></a>返回一个 Request 对象</h3><p>返回的<code>request</code>将会被重新调用下载。这将停止中间件的 <code>process_exception()</code>方法执行，就如返回一个<code>response</code>的那样  </p><h1 id="简单样例"><a href="#简单样例" class="headerlink" title="简单样例"></a>简单样例</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResponseHtmlBackupDownloaderMiddleware</span>:</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    对响应html进行备份，下次请求相同的路径，则直接读文件，不进行爬虫</span><br><span class="hljs-string">    request.meta[&#x27;BackupHTML&#x27;]=Ture时启用</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_request</span>(<span class="hljs-params">self, request, spider</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> request.meta.get(<span class="hljs-string">&#x27;BackupHTML&#x27;</span>):<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span><br>        <br>        file_path = <span class="hljs-string">&#x27;resources/response/&#123;&#125;.html&#x27;</span>.<span class="hljs-built_in">format</span>(get_string_md5(request.url))<br>        <span class="hljs-keyword">if</span> exists(file_path):<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<span class="hljs-keyword">as</span> f:<br>                html = f.read()<br>            <span class="hljs-keyword">return</span> TextResponse(url=request.url, body=html.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>), encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>, request=request)<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_response</span>(<span class="hljs-params">self, request, response, spider</span>):</span><br>        <span class="hljs-keyword">if</span> request.meta.get(<span class="hljs-string">&#x27;BackupHTML&#x27;</span>):<br>            file_path = <span class="hljs-string">&#x27;resources/response/&#123;&#125;.html&#x27;</span>.<span class="hljs-built_in">format</span>(get_string_md5(request.url))<br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<span class="hljs-keyword">as</span> f:<br>                f.write(response.text)<br>        <span class="hljs-keyword">return</span> response<br></code></pre></td></tr></table></figure><p>这个是我自己写的非常简单的中间件<br><code>process_request</code>方法对请求进行判断。如果记录的<code>Html</code>已经保存在本地，那么从本地读取文件，不进行爬虫<br><code>process_response</code>方法对响应进行判断。如果需要备份则保存<code>Html</code>到本地<br>因为所有 请求/响应 都会经过中间件，但并非所有的 请求/响应 都需要进行备份。所以在开头添加<code>request.meta</code>判断  </p><h1 id="官方中间件下载"><a href="#官方中间件下载" class="headerlink" title="官方中间件下载"></a>官方中间件下载</h1><p>Github地址：<a href="https://github.com/scrapy/scrapy/tree/master/scrapy/downloadermiddlewares">https://github.com/scrapy/scrapy/tree/master/scrapy/downloadermiddlewares</a><br>你能够在这里查看到官方给出的一些下载中间件<br>中间件包括失败重试，代理等一些实用的功能  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode-用户代码片段</title>
    <link href="/post/ad65409c/"/>
    <url>/post/ad65409c/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>在编写代码的过程中使用用户代码片段能使得代码编写速度更快<br><img src="https://i.loli.net/2020/11/05/bS1ApLRPkV8o76e.gif" alt="ajax-snippet.gif"><br>VSCode文档-用户代码片段：<a href="https://code.visualstudio.com/docs/editor/userdefinedsnippets">https://code.visualstudio.com/docs/editor/userdefinedsnippets</a>  </p><h1 id="创建用户代码片段"><a href="#创建用户代码片段" class="headerlink" title="创建用户代码片段"></a>创建用户代码片段</h1><h2 id="创建代码片段文件"><a href="#创建代码片段文件" class="headerlink" title="创建代码片段文件"></a>创建代码片段文件</h2><p>文件-&gt;首选项-&gt;用户片段<br><img src="/VSCode-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/open_user_snippets.gif"><br>点击以后会出现一些选项，可以打开以前的代码片段文件进行修改，或者新建一个代码片段文件  </p><h2 id="代码片段文件"><a href="#代码片段文件" class="headerlink" title="代码片段文件"></a>代码片段文件</h2><p>代码片段的编写语法就和<code>JSON</code>一样<br>支持编写C语言类型的注释（也就是”//“注释）<br>一个代码片段文件可以编写任意个代码片段  </p><h2 id="编写代码片段"><a href="#编写代码片段" class="headerlink" title="编写代码片段"></a>编写代码片段</h2><p>在代码片段文件中写入用户代码片段<br>此处我以Python头举例  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;Python-Commom&quot;</span>: &#123;<br><span class="hljs-attr">&quot;scope&quot;</span>: <span class="hljs-string">&quot;python&quot;</span>,<br><span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;Python声明头部，包含编码，解释器指定，文件信息&quot;</span>,<br><span class="hljs-attr">&quot;prefix&quot;</span>: [<span class="hljs-string">&quot;header&quot;</span>],<br><span class="hljs-attr">&quot;body&quot;</span>: [<br><span class="hljs-string">&quot;#!/usr/bin/env python&quot;</span>,<br><span class="hljs-string">&quot;# -*- encoding: utf-8 -*-&quot;</span>,<br><span class="hljs-string">&quot;&#x27;&#x27;&#x27;&quot;</span>,<br><span class="hljs-string">&quot;@File    :   $TM_FILENAME&quot;</span>,<br><span class="hljs-string">&quot;@Time    :   $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE&quot;</span>,<br><span class="hljs-string">&quot;@Contact :   https://github.com/RecluseXU&quot;</span>,<br><span class="hljs-string">&quot;@Desc    :   $1&quot;</span>,<br><span class="hljs-string">&quot;&#x27;&#x27;&#x27;&quot;</span>,<br><span class="hljs-string">&quot;&quot;</span>,<br><span class="hljs-string">&quot;# here put the import lib&quot;</span>,<br><span class="hljs-string">&quot;$0&quot;</span>,<br>],<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>内容</th><th>值</th><th>说明</th></tr></thead><tbody><tr><td>代码片段名</td><td>“Python-Commom”</td><td>仅仅是一个名字</td></tr><tr><td>“scope”</td><td>“python”</td><td>代码段使用的语言名称列表<br>例如 “python,c”</td></tr><tr><td>“description”</td><td>“Python声明……定，文件信息”</td><td>代码片段的描述，在使用时能够看到它，方便理解代码片段作用</td></tr><tr><td>“prefix”</td><td>[“header”]</td><td>匹配关键词，可以填入多个<br>在你编写代码时填入部分匹配关键词时，会提示出用户代码片段</td></tr><tr><td>“body”</td><td>[“#!/usr/bin/env py……put the import lib”,”$0”,]</td><td>代码片段内容，插入到原本代码中的代码片段<br>以list的形式记录，一个元素为一行内容<br>可以使用一些已经定义好了的变量来填充内容。例如：<br><code>$1</code>代表每一次按<code>Tab</code>后光标跳跃到的位置<br><code>$0</code>表示光标最终位置<br><code>$TM_FILENAME</code>代表当前文件名</td></tr></tbody></table><h2 id="测试使用"><a href="#测试使用" class="headerlink" title="测试使用"></a>测试使用</h2><p><img src="/VSCode-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/use_user_snippets.gif"></p><h1 id="代码片段语法"><a href="#代码片段语法" class="headerlink" title="代码片段语法"></a>代码片段语法</h1><h2 id="制表符-Tabstops"><a href="#制表符-Tabstops" class="headerlink" title="制表符 Tabstops"></a>制表符 Tabstops</h2><p><code>$0</code>, <code>$1</code>, <code>$2</code>……<br>使用制表符能够在代码片段中用<code>Tab</code>键快速移动  </p><p><img src="/VSCode-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/tabstops.gif">  </p><ul><li>在数字大于0时，按照从小到大移动，既 <code>$1</code>-<code>Tab</code>-&gt;<code>$2</code>-<code>Tab</code>-&gt;<code>$3</code></li><li>最终，光标会<code>Tab</code>到<code>$0</code>的位置，既最后的位置  </li><li>如果设置多个一样的制表符（比如在多个位置输入<code>$1</code>）,那么会同时在多个地方输入  </li></ul><h2 id="占位符-Placeholders"><a href="#占位符-Placeholders" class="headerlink" title="占位符 Placeholders"></a>占位符 Placeholders</h2><p><code>$&#123;1:foo&#125;</code>，<code>$&#123;2:what&#125;</code>……<br>存在默认值的制表符。如果你什么都不输入，直接<code>Tab</code>会使用占位符的值设置这个位置<br><img src="/VSCode-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/placeholder.gif">  </p><h2 id="选项-Choice"><a href="#选项-Choice" class="headerlink" title="选项 Choice"></a>选项 Choice</h2><p><code>$&#123;1|one,two,three|&#125;</code>, <code>$&#123;2|op1,op2|&#125;</code>……<br>存在默认值的制表符。你可以选择，设定的值来填入<br><img src="/VSCode-%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/choice.gif">  </p><h2 id="变量-Variables"><a href="#变量-Variables" class="headerlink" title="变量 Variables"></a>变量 Variables</h2><h3 id="编辑相关"><a href="#编辑相关" class="headerlink" title="编辑相关"></a>编辑相关</h3><table><thead><tr><th>变量</th><th>信息</th></tr></thead><tbody><tr><td>TM_SELECTED_TEXT</td><td>当前选择的字符（没有则为空）</td></tr><tr><td>TM_CURRENT_LINE</td><td>当前行的内容</td></tr><tr><td>TM_CURRENT_WORD</td><td>当前光标下的单词（没有则为空）</td></tr><tr><td>TM_LINE_INDEX</td><td>从0开始的行序号</td></tr><tr><td>TM_LINE_NUMBER</td><td>从1开始的行号</td></tr><tr><td>TM_FILENAME</td><td>当前文档的文件名</td></tr><tr><td>TM_FILENAME_BASE</td><td>当前文档的文件名，不带扩展名</td></tr><tr><td>TM_DIRECTORY</td><td>当前文档的相对路径</td></tr><tr><td>TM_FILEPATH</td><td>当前文档的绝对路径</td></tr><tr><td>CLIPBOARD</td><td>剪贴板中的内容</td></tr><tr><td>WORKSPACE_NAME</td><td>工作路径名称</td></tr></tbody></table><h3 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h3><table><thead><tr><th>变量</th><th>信息</th></tr></thead><tbody><tr><td>CURRENT_YEAR</td><td>当前年份</td></tr><tr><td>CURRENT_YEAR_SHORT</td><td>当前年份（只包含后两位）</td></tr><tr><td>CURRENT_MONTH</td><td>当前月份，用两个数字表示<br>例如：02</td></tr><tr><td>CURRENT_MONTH_NAME</td><td>当前月份的完整英文名<br>例如：July</td></tr><tr><td>CURRENT_MONTH_NAME_SHORT</td><td>当前月份的简写英文名<br>例如：Jul</td></tr><tr><td>CURRENT_DATE</td><td>日期，这个月的第几天</td></tr><tr><td>CURRENT_DAY_NAME</td><td>当前日期星期数完整英文<br>例如：Monday)</td></tr><tr><td>CURRENT_DAY_NAME_SHORT</td><td>当前日期星期数简写英文<br>例如：Mon)</td></tr><tr><td>CURRENT_HOUR</td><td>当前小时数，24小时制</td></tr><tr><td>CURRENT_MINUTE</td><td>当前分钟数</td></tr><tr><td>CURRENT_SECOND</td><td>当前秒数</td></tr><tr><td>CURRENT_SECONDS_UNIX</td><td>时间戳</td></tr></tbody></table><h3 id="变量转换-Variable-transforms"><a href="#变量转换-Variable-transforms" class="headerlink" title="变量转换 Variable transforms"></a>变量转换 Variable transforms</h3><p>在代码片段正式插入到代码之中前，你可以对其中的变量的值，通过正则表达式进行一些替换处理  </p><blockquote><p>案例：去除文件名的扩展名  </p></blockquote><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">$&#123;TM_FILENAME/(.<span class="hljs-symbol">*</span>)\\..+$/$1/&#125;<br>  |<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  </span>|<br>  |<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">  </span>|<span class="hljs-string">-&gt; 替换内容为&quot;&quot;</span><br><span class="hljs-string">  </span>|<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<br>  |<span class="hljs-string">           </span>|<span class="hljs-string">         </span>|<span class="hljs-string">-&gt; 选择第一个被正则表达式匹配的内容</span><br><span class="hljs-string">  </span>|<span class="hljs-string">           </span>|<span class="hljs-string">            </span><br><span class="hljs-string">  </span>|<span class="hljs-string">           </span>|<span class="hljs-string">-&gt; 正则表达式匹配(.*)</span><br><span class="hljs-string">  </span>|<span class="hljs-string">             </span><br><span class="hljs-string">  </span>|<span class="hljs-string">-&gt; 通过变量得到文件名</span><br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：用<code>_</code>取代<code>.</code>  </p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$&#123;TM_FILENAME<span class="hljs-regexp">/[\\.]/</span>_/&#125;<br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：用<code>_</code>取代<code>.</code>和<code>-</code></p></blockquote><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$&#123;TM_FILENAME<span class="hljs-regexp">/[\\.-]/</span>_/g&#125;<br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：将文件名改为大写字母  </p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$&#123;</span>TM_FILENAME/(.*)/<span class="hljs-variable">$&#123;</span><span class="hljs-number">1</span><span class="hljs-symbol">:/upcase</span>&#125;/&#125;<br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：只保留数字与字母 </p></blockquote><figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs parser3"><span class="hljs-variable">$&#123;TM_FILENAME</span><span class="xml">/[</span><span class="hljs-keyword">^0-9</span><span class="hljs-keyword">^a-z</span><span class="xml">]//gi&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-ConfigParser-ini配置文件</title>
    <link href="/post/810bbcb7/"/>
    <url>/post/810bbcb7/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>这是一个用来管理配置文件的库<br>一般用来管理<code>.ini</code>配置文件（<code>Windows</code>下的配置文件）  </p><blockquote><p>不太推荐用这个东西，问题较多，感觉还不如直接<code>json</code></p></blockquote><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>官方文档：<a href="https://docs.python.org/3/library/configparser.html">https://docs.python.org/3/library/configparser.html</a>  </p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>.ini</code>和<code>.conf</code>配置文件,他们大概长这样：  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[db]</span><br><span class="hljs-attr">db_host</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">db_port</span> = <span class="hljs-number">69</span><br><span class="hljs-attr">db_user</span> = root<br><span class="hljs-attr">db_pass</span> = root<br><span class="hljs-attr">host_port</span> = <span class="hljs-number">69</span><br><span class="hljs-attr">is_ok</span> = <span class="hljs-literal">True</span><br> <br><span class="hljs-section">[concurrent]</span><br><span class="hljs-attr">thread</span> = <span class="hljs-number">10</span><br><span class="hljs-attr">processor</span> = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><h3 id="Section"><a href="#Section" class="headerlink" title="Section"></a>Section</h3><p>上面的<code>[db]</code>,<code>[concurrent]</code>之类的就是<code>section</code><br>内容一般用<code>[]</code>来包裹，表示一块相对独立的配置块  </p><h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h3><p>上面的<code>db_host = 127.0.0.1</code>，<code>db_port = 69</code>之类的就是<code>Options</code><br>这是配置的本体，以<code>Key-Value</code>的形式保存着  </p><h1 id="使用入门"><a href="#使用入门" class="headerlink" title="使用入门"></a>使用入门</h1><p>这个东西的用法很像<code>dict</code><br>如果遇到什么想要进行的<code>dict</code>本身又提供函数的操作，可以试试看能不能用  </p><h2 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h2><h3 id="初始化ConfigParser对象"><a href="#初始化ConfigParser对象" class="headerlink" title="初始化ConfigParser对象"></a>初始化ConfigParser对象</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;<span class="hljs-keyword">import</span> configparser<br>&gt;&gt;&gt;config = configparser.ConfigParser()<br>&gt;&gt;&gt;config.read(<span class="hljs-string">&quot;ini&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="获取Section节点"><a href="#获取Section节点" class="headerlink" title="获取Section节点"></a>获取Section节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;print(config.sections())<br>[<span class="hljs-string">&#x27;db&#x27;</span>, <span class="hljs-string">&#x27;concurrent&#x27;</span>]<br>&gt;&gt;&gt;print(config[<span class="hljs-string">&#x27;db&#x27;</span>])<br>[<span class="hljs-string">&#x27;db&#x27;</span>, <span class="hljs-string">&#x27;concurrent&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="从Section中获取Options"><a href="#从Section中获取Options" class="headerlink" title="从Section中获取Options"></a>从Section中获取Options</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;config.options(<span class="hljs-string">&quot;db&quot;</span>)<br>[<span class="hljs-string">&#x27;db_host&#x27;</span>, <span class="hljs-string">&#x27;db_port&#x27;</span>, <span class="hljs-string">&#x27;db_user&#x27;</span>, <span class="hljs-string">&#x27;db_pass&#x27;</span>, <span class="hljs-string">&#x27;host_port&#x27;</span>]<br>&gt;&gt;&gt;<span class="hljs-built_in">list</span>(config[<span class="hljs-string">&#x27;db&#x27;</span>].keys())<br>[<span class="hljs-string">&#x27;db_host&#x27;</span>, <span class="hljs-string">&#x27;db_port&#x27;</span>, <span class="hljs-string">&#x27;db_user&#x27;</span>, <span class="hljs-string">&#x27;db_pass&#x27;</span>, <span class="hljs-string">&#x27;host_port&#x27;</span>]<br></code></pre></td></tr></table></figure><h3 id="获取Option的值"><a href="#获取Option的值" class="headerlink" title="获取Option的值"></a>获取Option的值</h3><h4 id="获取指定Option的值"><a href="#获取指定Option的值" class="headerlink" title="获取指定Option的值"></a>获取指定Option的值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;r = config.get(<span class="hljs-string">&quot;db&quot;</span>, <span class="hljs-string">&quot;db_host&quot;</span>)<br><span class="hljs-string">&quot;127.0.0.1&quot;</span><br>&gt;&gt;&gt;r0 = config[<span class="hljs-string">&#x27;db&#x27;</span>][<span class="hljs-string">&#x27;db_host&#x27;</span>]<br><span class="hljs-string">&quot;127.0.0.1&quot;</span><br>&gt;&gt;&gt;r1 = config.getint(<span class="hljs-string">&quot;db&quot;</span>, <span class="hljs-string">&quot;db_port&quot;</span>)  <span class="hljs-comment"># 将获取到值转换为int型</span><br><span class="hljs-number">69</span><br>&gt;&gt;&gt;r2 = config.getboolean(<span class="hljs-string">&quot;db&quot;</span>, <span class="hljs-string">&quot;is_ok&quot;</span> )  <span class="hljs-comment"># 将获取到值转换为bool型</span><br><span class="hljs-literal">True</span><br>&gt;&gt;&gt;r3 = config.getfloat(<span class="hljs-string">&quot;db&quot;</span>, <span class="hljs-string">&quot;host_port&quot;</span> ) <span class="hljs-comment">#将获取到值转换为浮点型</span><br><span class="hljs-number">69.0</span><br></code></pre></td></tr></table></figure><h4 id="获取所有Option的值"><a href="#获取所有Option的值" class="headerlink" title="获取所有Option的值"></a>获取所有Option的值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;config.items(<span class="hljs-string">&quot;db&quot;</span>)<br>[(<span class="hljs-string">&#x27;db_host&#x27;</span>, <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>), (<span class="hljs-string">&#x27;db_port&#x27;</span>, <span class="hljs-string">&#x27;69&#x27;</span>), (<span class="hljs-string">&#x27;db_user&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>), (<span class="hljs-string">&#x27;db_pass&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>), (<span class="hljs-string">&#x27;host_port&#x27;</span>, <span class="hljs-string">&#x27;69&#x27;</span>)]<br>&gt;&gt;&gt;<span class="hljs-built_in">list</span>(config[<span class="hljs-string">&#x27;database-mongo&#x27;</span>].items())<br>[(<span class="hljs-string">&#x27;db_host&#x27;</span>, <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>), (<span class="hljs-string">&#x27;db_port&#x27;</span>, <span class="hljs-string">&#x27;69&#x27;</span>), (<span class="hljs-string">&#x27;db_user&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>), (<span class="hljs-string">&#x27;db_pass&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>), (<span class="hljs-string">&#x27;host_port&#x27;</span>, <span class="hljs-string">&#x27;69&#x27;</span>)]<br></code></pre></td></tr></table></figure><h2 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h2><h3 id="检测是否有Section"><a href="#检测是否有Section" class="headerlink" title="检测是否有Section"></a>检测是否有Section</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;config.has_section(<span class="hljs-string">&quot;db&quot;</span>)  <span class="hljs-comment"># 是否存在该section</span><br><span class="hljs-literal">True</span><br>&gt;&gt;&gt;<span class="hljs-string">&#x27;db&#x27;</span> <span class="hljs-keyword">in</span> config<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h3 id="检测是否有Option"><a href="#检测是否有Option" class="headerlink" title="检测是否有Option"></a>检测是否有Option</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;config.has_option(<span class="hljs-string">&quot;section&quot;</span>, <span class="hljs-string">&quot;option&quot;</span>)<br><span class="hljs-literal">False</span><br>&gt;&gt;&gt;<span class="hljs-string">&quot;db_host&quot;</span> <span class="hljs-keyword">in</span> config[<span class="hljs-string">&quot;db&quot;</span>]<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="修改-创建"><a href="#修改-创建" class="headerlink" title="修改/创建"></a>修改/创建</h2><h3 id="创建Section"><a href="#创建Section" class="headerlink" title="创建Section"></a>创建Section</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;config.add_section(<span class="hljs-string">&quot;new:section&quot;</span>)<br>&gt;&gt;&gt;config[<span class="hljs-string">&#x27;new:section&#x27;</span>] = &#123;&#125;<br><span class="hljs-comment"># 可以顺便赋值option</span><br>&gt;&gt;&gt;config[<span class="hljs-string">&#x27;new:section&#x27;</span>] = &#123;<span class="hljs-string">&#x27;o1&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;o2&#x27;</span>: <span class="hljs-string">&#x27;2&#x27;</span>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改-创建Option"><a href="#修改-创建Option" class="headerlink" title="修改/创建Option"></a>修改/创建Option</h3><p>修改某个<code>option</code>的值，如果不存在该<code>option</code>则会被创建  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># db Section 的 db_port Option 的值为69</span><br>&gt;&gt;&gt;config.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;db&quot;</span>, <span class="hljs-string">&quot;db_port&quot;</span>, <span class="hljs-string">&quot;69&quot;</span>)<br>&gt;&gt;&gt;config[<span class="hljs-string">&#x27;db&#x27;</span>][<span class="hljs-string">&quot;db_port&quot;</span>] = <span class="hljs-string">&#x27;69&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="删除Section"><a href="#删除Section" class="headerlink" title="删除Section"></a>删除Section</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;config.pop(<span class="hljs-string">&#x27;db&#x27;</span>)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;config[<span class="hljs-string">&#x27;db&#x27;</span>] = &#123;&#125;  <span class="hljs-comment"># 重新创建以供删除</span><br>&gt;&gt;&gt;config.remove_section(<span class="hljs-string">&quot;default&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="删除Option"><a href="#删除Option" class="headerlink" title="删除Option"></a>删除Option</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;config.pop(<span class="hljs-string">&#x27;db&#x27;</span>)<br>&gt;&gt;&gt;<br>&gt;&gt;&gt;config[<span class="hljs-string">&#x27;db&#x27;</span>] = &#123;&#125;  <span class="hljs-comment"># 重新创建以供删除</span><br>&gt;&gt;&gt;config.remove_section(<span class="hljs-string">&quot;default&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;example.ini&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    config.write(f)<br></code></pre></td></tr></table></figure><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="关键词无法使用"><a href="#关键词无法使用" class="headerlink" title="关键词无法使用"></a>关键词无法使用</h2><p>有一些词在文件里是无法使用的，只要一访问带有这个词的Option就会报错<br>比如说 <code>asctime</code><br>解决办法：</p><ol><li>使用<code>RawConfigParser</code>而不是<code>ConfigParser</code>  </li><li>把关键词删除  </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>ConfigParser</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack-前端</title>
    <link href="/post/80b1cc67/"/>
    <url>/post/80b1cc67/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>分析项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss,TypeScript等），将其打包为合适的格式以供浏览器使用<br><img src="/Webpack-%E5%89%8D%E7%AB%AF/20201028105124538.png">  </p><ul><li>代码转换<br>ES6-&gt;ES5之类  </li><li>文件优化<br>代码压缩，合并文件  </li><li>代码分割<br>公共模块抽离  </li><li>模块合并  </li><li>自动刷新<br>代码变更，更新页面  </li><li>代码校验  </li><li>自动发布  </li></ul><h2 id="学习条件"><a href="#学习条件" class="headerlink" title="学习条件"></a>学习条件</h2><ul><li>Node基础  </li><li>npm使用  </li><li>ES6语法  </li></ul><h1 id="文档-链接"><a href="#文档-链接" class="headerlink" title="文档/链接"></a>文档/链接</h1><p>官网：<a href="https://www.webpackjs.com/">https://www.webpackjs.com/</a><br>文档：<a href="https://www.webpackjs.com/concepts/">https://www.webpackjs.com/concepts/</a>  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Django-后端-Python</title>
    <link href="/post/63485ee6/"/>
    <url>/post/63485ee6/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>一个<code>python</code> <code>web框架</code>，相较于<code>flask</code>而言体量更大更重 </p><h1 id="文档-网站"><a href="#文档-网站" class="headerlink" title="文档/网站"></a>文档/网站</h1><p>官网：<a href="https://www.djangoproject.com/">https://www.djangoproject.com/</a><br>文档：<a href="https://docs.djangoproject.com/zh-hans/3.1/intro/install/">https://docs.djangoproject.com/zh-hans/3.1/intro/install/</a>  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>使用<code>pip</code>进行安装即可  </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> Django<br></code></pre></td></tr></table></figure><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>对应环境启动后，输出<code>django</code>版本号以测试是否安装成功</p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-keyword">import</span> django</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">print(django.get_version())</span><br></code></pre></td></tr></table></figure><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h3><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h4><p>在<code>cmd</code>中<code>cd</code>到一个建立项目的位置<br>使用<code>startproject命令</code>创建项目  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">django-admin startproject 项目名<br></code></pre></td></tr></table></figure><blockquote><p>注意：不要使用python内部字段来命名项目，这会引起冲突  </p></blockquote><p>在运行<code>startproject</code>生成项目后，会生成以下这些文件  </p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs 1c">项目名/  <span class="hljs-meta"># 项目根目录。名字可以随改</span><br>    manage.py  <span class="hljs-meta"># Django项目的命令行工具</span><br>    项目名/  <span class="hljs-meta"># 项目所需python包</span><br>        __init__.py  <span class="hljs-meta"># 包标识</span><br>        settings.py  <span class="hljs-meta"># 项目的配置文件</span><br>        urls.py  <span class="hljs-meta"># 项目的URL声明，就像你网站的“目录”</span><br>        asgi.py <span class="hljs-meta"># 项目的运行在ASGI兼容的Web服务器上的入口</span><br>        wsgi.py  <span class="hljs-meta"># 项目的运行在 WSGI 兼容的Web服务器上的入口</span><br></code></pre></td></tr></table></figure><p>更多细节 - 链接：  </p><ul><li>manage.py - <a href="https://docs.djangoproject.com/zh-hans/3.1/ref/django-admin/">Django项目的命令行工具</a>  </li><li>mysite/settings.py - <a href="https://docs.djangoproject.com/zh-hans/3.1/topics/settings/">Django项目配置</a>  </li><li>mysite/urls.py - <a href="https://docs.djangoproject.com/zh-hans/3.1/topics/http/urls/">URL声明</a>  </li><li>mysite/asgi.py - <a href="https://docs.djangoproject.com/zh-hans/3.1/howto/deployment/asgi/">ASGI-Web服务器入口</a>  </li><li>mysite/wsgi.py - <a href="https://docs.djangoproject.com/zh-hans/3.1/howto/deployment/wsgi/">WSGI-Web服务器入口</a>  </li></ul><h4 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h4><p>在<code>Django</code>中，每一个应用都是一个<code>Python</code>包，并且遵循着相同的约定<br><code>Django</code>自带一个工具，可以帮你生成应用的基础目录结构  </p><blockquote><p>项目和应用有什么区别？<br>应用：一个专门做某件事的网络应用程序——比如博客系统，或者公共记录的数据库，或者小型的投票程序<br>项目：则是一个网站使用的配置和应用的集合<br>项目可以包含很多个应用。应用可以被很多个项目使用  </p></blockquote><p>你的应用可以存放在任何<code>Python path</code>中定义的路径<br>可以在<code>manage.py</code>同级目录下创建应用。这样它就可以作为顶级模块导入。也可以在<code>mysite</code>中创建，作为一个子模块  </p><p>创建一个应用（注意路径问题）  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python manage.py startapp 应用名<br></code></pre></td></tr></table></figure><p>这样以后，会创建一个以应用名命名的文件夹  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">应用名/<br>    __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">admin</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">apps</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">migrations</span>/<br>        __<span class="hljs-selector-tag">init__</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">models</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">tests</span><span class="hljs-selector-class">.py</span><br>    <span class="hljs-selector-tag">views</span><span class="hljs-selector-class">.py</span><br></code></pre></td></tr></table></figure><p>这个目录包含了这个应用的全部内容  </p><h5 id="添加创建的应用到配置文件中"><a href="#添加创建的应用到配置文件中" class="headerlink" title="添加创建的应用到配置文件中"></a>添加创建的应用到配置文件中</h5><p>然后在<code>项目名/项目名/settings.py</code>中的<code>INSTALLED_APPS</code>中将自己创建的应用添加进去  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">INSTALLED_APPS</span> = [<br>    ......<br>    <span class="hljs-string">&#x27;应用名&#x27;</span><br>]<br></code></pre></td></tr></table></figure><p>这样做能更好的利用<code>Django</code>自带的配置，比如说自动加载模板<br>不添加也不会出什么问题  </p><h4 id="编辑视图"><a href="#编辑视图" class="headerlink" title="编辑视图"></a>编辑视图</h4><p>打开<code>polls/views.py</code>，把下面这些<code>Python</code>代码写入：  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>(<span class="hljs-params">request</span>):</span><br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;Hello, world.&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="编辑URL映射"><a href="#编辑URL映射" class="headerlink" title="编辑URL映射"></a>编辑URL映射</h4><h5 id="编辑应用URL映射"><a href="#编辑应用URL映射" class="headerlink" title="编辑应用URL映射"></a>编辑应用URL映射</h5><p>将一个URL映射到视图上，才能显示一个视图<br>在 应用的目录（不是项目） 中创建一个<code>urls.py</code>文件，并写入以下代码：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> <span class="hljs-type">path</span><br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;&#x27;</span>, views.<span class="hljs-keyword">index</span>, <span class="hljs-type">name</span>=<span class="hljs-string">&#x27;index&#x27;</span>),<br>]<br></code></pre></td></tr></table></figure><blockquote><p><a href="https://docs.djangoproject.com/zh-hans/3.1/ref/urls/#django.urls.path">path函数</a>具有四个参数，两个必传：<code>route</code> 和 <code>view</code>，两个可选参数：<code>kwargs</code> 和 <code>name</code>    </p><ul><li><p><code>route</code><br><code>route</code>是一个匹配<code>URL</code>的准则（类似正则表达式）<br>当 Django 响应一个请求时，它会从<code>urlpatterns</code>的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。</p><blockquote><p>注意：这些准则不会匹配<code>GET</code>和<code>POST</code>参数或域名   </p></blockquote></li><li><p><code>view</code><br>当<code>Django</code>找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 <code>HttpRequest</code>对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入  </p></li><li><p><code>kwargs</code><br>任意个关键字参数可以作为一个字典传递给目标视图函数  </p></li><li><p><code>name</code><br>为<code>URL</code>取名能使你在<code>Django</code>的任意地方唯一地引用它，尤其是在模板中<br>这个有用的特性允许你只改一个文件就能全局地修改某个<code>URL</code>模式  </p></li></ul></blockquote><h5 id="编辑项目URL映射"><a href="#编辑项目URL映射" class="headerlink" title="编辑项目URL映射"></a>编辑项目URL映射</h5><p>应用是依托于项目运行的，应用的URL映射关系应与项目URL映射绑定  </p><p>在根<code>URLconf文件</code>中指定我们创建的<code>应用名.urls</code>模块<br>在<code>mysite/urls.py</code>文件的<code>urlpatterns</code>列表里插入一个 <code>include()</code>， 如下：  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> <span class="hljs-keyword">admin</span><br><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> <span class="hljs-keyword">include</span>, <span class="hljs-type">path</span><br><br>urlpatterns = [<br>    path(<span class="hljs-string">&#x27;应用名/&#x27;</span>, <span class="hljs-keyword">include</span>(<span class="hljs-string">&#x27;应用名.urls&#x27;</span>)),<br>    path(<span class="hljs-string">&#x27;admin/&#x27;</span>, <span class="hljs-keyword">admin</span>.site.urls),<br>]<br></code></pre></td></tr></table></figure><p>函数<code>include()</code>允许引用其它<code>URLconfs</code><br>每当<code>Django</code>遇到<code>include()</code>时，它会截断与此项匹配的<code>URL</code>的部分，并将剩余的字符串发送到<code>URLconf</code>以供进一步处理  </p><blockquote><p><code>include()</code>的理念是可以即插即用<br>因为应用有它自己的<code>URLconf( polls/urls.py )</code>，他们能够被放在 “/polls/“ ， “/fun_polls/“ ，”/content/polls/“，或者其他任何路径下，这个应用都能够正常工作  </p></blockquote><h4 id="用于开发的简易服务器"><a href="#用于开发的简易服务器" class="headerlink" title="用于开发的简易服务器"></a>用于开发的简易服务器</h4><p>在<code>cmd</code>中输入命令以使用开发服务器  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">&gt;&gt;&gt;python manager.py runserver<br></code></pre></td></tr></table></figure><p>启动后你会看到一些输出  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sql">Watching for file changes <span class="hljs-keyword">with</span> StatReloader<br>Performing <span class="hljs-keyword">system</span> checks...<br><br><span class="hljs-keyword">System</span> <span class="hljs-keyword">check</span> <span class="hljs-keyword">identified</span> <span class="hljs-keyword">no</span> issues (<span class="hljs-number">0</span> silenced).<br><br>You have <span class="hljs-number">18</span> unapplied <span class="hljs-keyword">migration</span>(s). Your <span class="hljs-keyword">project</span> may <span class="hljs-keyword">not</span> <span class="hljs-keyword">work</span> properly <span class="hljs-keyword">until</span> you <span class="hljs-keyword">apply</span> the migrations <span class="hljs-keyword">for</span> app(s): <span class="hljs-keyword">admin</span>, auth, contenttypes, sessions.<br>Run <span class="hljs-string">&#x27;python manage.py migrate&#x27;</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">apply</span> them.<br>October <span class="hljs-number">26</span>, <span class="hljs-number">2020</span> - <span class="hljs-number">16</span>:<span class="hljs-number">25</span>:<span class="hljs-number">10</span><br>Django <span class="hljs-keyword">version</span> <span class="hljs-number">3.1</span><span class="hljs-number">.2</span>, <span class="hljs-keyword">using</span> <span class="hljs-keyword">settings</span> <span class="hljs-string">&#x27;SXB_BaiduSEO_Web.settings&#x27;</span><br><span class="hljs-keyword">Starting</span> development <span class="hljs-keyword">server</span> <span class="hljs-keyword">at</span> <span class="hljs-keyword">http</span>://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8000</span>/<br>Quit the <span class="hljs-keyword">server</span> <span class="hljs-keyword">with</span> CTRL-BREAK.<br></code></pre></td></tr></table></figure><p>这个命令启动的是<code>Django</code>自带的用于开发的简易服务器，一个用纯<code>Python</code>写的轻量级的<code>Web服务器</code><br>这个服务器内置在<code>Django</code>中是为了让你能快速的开发出想要的东西  (不需要进行配置生产级别的服务器（比如 Apache）方面的工作）</p><p><strong>千万不要！！！ 千万不要！！！ 千万不要！！！</strong>将这个服务器用于和生产环境相关的任何地方  </p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="更多视图"><a href="#更多视图" class="headerlink" title="更多视图"></a>更多视图</h3><p>向<code>应用名/views.py</code> 里添加更多视图  </p><h4 id="带参数视图"><a href="#带参数视图" class="headerlink" title="带参数视图"></a>带参数视图</h4><figure class="highlight python"><figcaption><span>应用名/urls.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br>urlpatterns = [<br>    ......<br>    <span class="hljs-comment"># 新的url映射，映射到detail中</span><br>    <span class="hljs-comment"># url的一部分作为参数 _id 传入</span><br>    path(<span class="hljs-string">&#x27;&lt;int:_id&gt;/&#x27;</span>, views.detail, name=<span class="hljs-string">&#x27;detail&#x27;</span>),<br>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><figcaption><span>应用名/views.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">detail</span>(<span class="hljs-params">request, _id</span>):</span><br>    <span class="hljs-comment"># 获取url作为参数传入的_id</span><br>    <span class="hljs-keyword">return</span> HttpResponse(<span class="hljs-string">&quot;ID=&quot;</span> + _id)<br></code></pre></td></tr></table></figure><h4 id="HTML模板视图"><a href="#HTML模板视图" class="headerlink" title="HTML模板视图"></a>HTML模板视图</h4><ol><li>首先，在应用目录中创建一个模板目录（文件夹）<code>templates</code><br><code>Django</code>将会在这个目录里查找模板文件  </li><li>在刚创建的<code>templates</code>目录里，再创建一个目录<code>polls</code>  </li><li>然后在其中新建一个文件 <code>index.html</code><br>在完成上面的操作以后，你的模板文件的路径应该是 <code>应用名/templates/应用名/index.html</code></li><li>写入<code>index.html</code>的模板代码  <figure class="highlight html"><figcaption><span>应用名/templates/应用名/index.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>        &#123;% for question in questions %&#125;<br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>&#123;&#123; question &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        &#123;% endfor %&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>视图引用HTML模板  <figure class="highlight python"><figcaption><span>polls/views.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> HttpResponse<br><span class="hljs-keyword">from</span> django.template <span class="hljs-keyword">import</span> loader<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">questions</span>(<span class="hljs-params">request</span>):</span><br>    questions = [<span class="hljs-string">&#x27;是什么&#x27;</span>,<span class="hljs-string">&#x27;为什么&#x27;</span>, <span class="hljs-string">&#x27;怎么做&#x27;</span>]<br>    template = loader.get_template(<span class="hljs-string">&#x27;BaiduSEO/index.html&#x27;</span>)<br>    context = &#123;<span class="hljs-string">&#x27;questions&#x27;</span>: questions&#125;<br>    <span class="hljs-keyword">return</span> HttpResponse(template.render(context, request))<br></code></pre></td></tr></table></figure></li><li>创建对应url映射  <figure class="highlight python"><figcaption><span>应用名/urls.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">urlpatterns = [<br>    ......<br>    path(<span class="hljs-string">&#x27;questions/&#x27;</span>, views.questions, name=<span class="hljs-string">&#x27;questions&#x27;</span>)<br>]<br></code></pre></td></tr></table></figure></li><li>部署、访问、验证效果  </li></ol><blockquote><h5 id="为什么能够找到模板？"><a href="#为什么能够找到模板？" class="headerlink" title="为什么能够找到模板？"></a>为什么能够找到模板？</h5><p>你项目的<a href="https://docs.djangoproject.com/zh-hans/3.1/ref/settings/#std:setting-TEMPLATES"><code>TEMPLATES</code></a> 配置项描述了<code>Django</code>如何载入和渲染模板。<br>默认的设置文件设置了 <code>DjangoTemplates</code> 后端，并将 <a href="https://docs.djangoproject.com/zh-hans/3.1/ref/settings/#std:setting-TEMPLATES-APP_DIRS"><code>APP_DIRS</code></a> 设置成了 <code>True</code>。这一选项将会让 <code>DjangoTemplates</code> 在每个 <a href="https://docs.djangoproject.com/zh-hans/3.1/ref/settings/#std:setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> 文件夹中寻找 <code>&quot;templates&quot;</code> 子目录。这就是<code>Django</code>能正确找到应用模板位置的原因。</p></blockquote><p><span></span></p><blockquote><h5 id="模板命名空间"><a href="#模板命名空间" class="headerlink" title="模板命名空间"></a>模板命名空间</h5><p>虽然可以将模板文件直接放在<code>应用名/templates</code>文件夹中（而不是再建立一个<code>应用名</code>子文件夹），但是这样做不太好<br><code>Django</code>会选择第一个匹配的模板文件，如果你有一个模板文件正好和另一个应用中的某个模板文件重名，<code>Django</code>没有办法区分它们<br>为了让<code>Django</code>选择正确的模板，最好的方法就是把他们放入各自的<code>命名空间</code> 中，也就是把这些模板放入一个和 <strong>自身</strong> 应用重名的子文件夹里  </p></blockquote><h3 id="快捷函数render"><a href="#快捷函数render" class="headerlink" title="快捷函数render()"></a>快捷函数render()</h3><p>「载入模板，填充上下文，再返回由它生成的 HttpResponse 对象」是一个非常常用的操作流程<br>于是<code>Django</code>提供了一个快捷函数，来让代码变得更优美  </p><figure class="highlight python"><figcaption><span>应用名/views.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index</span>(<span class="hljs-params">request</span>):</span><br>    questions = [<span class="hljs-string">&#x27;是什么&#x27;</span>,<span class="hljs-string">&#x27;为什么&#x27;</span>, <span class="hljs-string">&#x27;怎么做&#x27;</span>]<br>    context = &#123;<span class="hljs-string">&#x27;questions&#x27;</span>: questions&#125;<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;应用名/index.html&#x27;</span>, context)<br></code></pre></td></tr></table></figure><p>这样做就不再需要导入<code>loader</code>和<code>HttpResponse</code>  </p><h3 id="抛出404错误"><a href="#抛出404错误" class="headerlink" title="抛出404错误"></a>抛出404错误</h3><p>写一个可能会报错的代码，在抓到异常后返回<code>404</code>  </p><figure class="highlight python"><figcaption><span>应用名/views.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.http <span class="hljs-keyword">import</span> Http404<br><span class="hljs-keyword">from</span> django.shortcuts <span class="hljs-keyword">import</span> render<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">detail</span>(<span class="hljs-params">request, question_id</span>):</span><br>    <span class="hljs-keyword">try</span>:<br>    <span class="hljs-comment"># 如果传入的数是0，那么会报错返回`404`  </span><br>        a = <span class="hljs-number">10</span>/question_id<br>    <span class="hljs-keyword">except</span> Exception:<br>        <span class="hljs-keyword">raise</span> Http404(<span class="hljs-string">&quot;Question does not exist&quot;</span>)<br>    <span class="hljs-keyword">return</span> render(request, <span class="hljs-string">&#x27;应用名/id_zero.html&#x27;</span>, &#123;<span class="hljs-string">&#x27;question&#x27;</span>: a&#125;)<br></code></pre></td></tr></table></figure><p>配套的<code>html</code>和<code>url</code>映射写好了以后就能查看情况了  </p><h3 id="去除模板中的硬编码URL"><a href="#去除模板中的硬编码URL" class="headerlink" title="去除模板中的硬编码URL"></a>去除模板中的硬编码URL</h3><figure class="highlight html"><figcaption><span>应用名/template/应用名/free_url.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/polls/&#123;&#123; question.id &#125;&#125;/&quot;</span>&gt;</span>点我<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>硬编码和强耦合的链接，对于一个包含很多应用的项目来说，修改起来是十分困难的。<br>然而，因为你在<code>polls.urls</code>的<code>url()</code>函数中通过<code>name</code>参数为<code>URL</code>定义了名字，你可以使用 <code>&#123;% url %&#125;</code> 标签代替它  </p><figure class="highlight html"><figcaption><span>应用名/template/应用名/free_url.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;detail&#x27; question.id %&#125;&quot;</span>&gt;</span>&#123;&#123; question.question_text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个标签的工作方式是在<code>应用名/urls.py</code>的<code>URL</code>定义中寻具有指定名字的条目 </p><figure class="highlight python"><figcaption><span>应用名/urls.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">path(<span class="hljs-string">&#x27;&lt;int:question_id&gt;/&#x27;</span>, views.detail, name=<span class="hljs-string">&#x27;detail&#x27;</span>)<br></code></pre></td></tr></table></figure><p>这个<code>name</code>参数，就是<code>&#123;% url %&#125;</code>用来引用的<code>key</code>，最终得到的值是前面的路由信息</p><p>如果你想改变投票详情视图的<code>URL</code>，比如想改成<code>应用名/specifics/12/</code>，你不用在模板里修改任何东西（包括其它模板），只要在<code>polls/urls.py</code>里稍微修改一下就行  </p><figure class="highlight python"><figcaption><span>应用名/urls.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># added the word &#x27;specifics&#x27;</span><br>path(<span class="hljs-string">&#x27;specifics/&lt;int:question_id&gt;/&#x27;</span>, views.detail, name=<span class="hljs-string">&#x27;detail&#x27;</span>),<br></code></pre></td></tr></table></figure><h3 id="URL命名空间"><a href="#URL命名空间" class="headerlink" title="URL命名空间"></a>URL命名空间</h3><p>在一个真实的<code>Django</code>项目中，可能会有五个，十个，二十个，甚至更多应用<br><code>Django</code>如何分辨重名的<code>URL</code>呢？<br>答案是：在根<code>URLconf</code>中添加命名空间。在 <code>应用名/urls.py</code> 文件中稍作修改，加上 <code>app_name</code> 设置命名空间  </p><figure class="highlight python"><figcaption><span>应用名/urls.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<br><span class="hljs-keyword">from</span> . <span class="hljs-keyword">import</span> views<br><br><br>app_name = <span class="hljs-string">&#x27;well&#x27;</span>  <span class="hljs-comment"># 添加命名空间</span><br>urlpatterns = [<br>    ......<br>]<br></code></pre></td></tr></table></figure><p>在模板需要使用<code>&#123;% url %&#125;</code>时，带上命名空间  </p><figure class="highlight html"><figcaption><span>应用名/template/应用名/free_url.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;&#123;% url &#x27;well:detail question.id&#x27;%&#125;&quot;</span>&gt;</span>&#123;&#123; question &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h3><p>视图中的<code>request</code>参数（<code>HttpRequest</code>对象）可供使用的内容  </p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>path</td><td>请求页面的全路径,不包括域名</td></tr><tr><td>method</td><td>请求中使用的HTTP方法的字符串表示。全大写表示。</td></tr><tr><td>GET</td><td>包含所有HTTP GET参数的类字典对象</td></tr><tr><td>POST</td><td>包含所有HTTP POST参数的类字典对象</td></tr><tr><td>REQUEST</td><td>为了方便，该属性是POST和GET属性的集合体<br>有特殊性，先查找POST属性，然后再查找GET属性。<br>强烈建议使用GET and POST,因为这两个属性更加显式化，写出的代码也更易理解。</td></tr><tr><td>COOKIES</td><td>包含所有cookies的标准Python字典对象。Keys和values都是字符串。</td></tr><tr><td>FILES</td><td>包含所有上传文件的类字典对象。<br>FILES中的每个Key都是<code>&lt;input type=&quot;file&quot; name=&quot;&quot; /&gt;</code>标签中name属性的值. <br>FILES中的每个value 同时也是一个标准Python字典对象，包含下面三个Keys:<br>&ensp;&ensp;&ensp;&ensp;filename: 上传文件名,用Python字符串表示<br>&ensp;&ensp;&ensp;&ensp;content-type: 上传文件的Content type<br>&ensp;&ensp;&ensp;&ensp;content: 上传文件的原始内容<br>注意：只有在请求方法是POST，并且请求页面中<code>&lt;form&gt;</code>有<code>enctype=&quot;multipart/form-data&quot;</code>属性时FILES才拥有数据。否则，FILES 是一个空字典。</td></tr><tr><td>META</td><td>包含所有可用HTTP头部信息的字典<br>&ensp;&ensp;&ensp;&ensp;CONTENT_LENGTH<br>&ensp;&ensp;&ensp;&ensp;CONTENT_TYPE<br>&ensp;&ensp;&ensp;&ensp;QUERY_STRING: 未解析的原始查询字符串<br>&ensp;&ensp;&ensp;&ensp;REMOTE_ADDR: 客户端IP地址<br>&ensp;&ensp;&ensp;&ensp;REMOTE_HOST: 客户端主机名<br>&ensp;&ensp;&ensp;&ensp;SERVER_NAME: 服务器主机名<br>&ensp;&ensp;&ensp;&ensp;SERVER_PORT: 服务器端口<br>META 中这些头加上前缀 HTTP_ 为 Key, 冒号(:)后面的为 Value， 例如:<br>&ensp;&ensp;&ensp;&ensp;HTTP_ACCEPT_ENCODING<br>&ensp;&ensp;&ensp;&ensp;HTTP_ACCEPT_LANGUAGE<br>&ensp;&ensp;&ensp;&ensp;HTTP_HOST: 客户发送的HTTP主机头信息<br>&ensp;&ensp;&ensp;&ensp;HTTP_REFERER: referring页<br>&ensp;&ensp;&ensp;&ensp;HTTP_USER_AGENT: 客户端的user-agent字符串<br>&ensp;&ensp;&ensp;&ensp;HTTP_X_BENDER: X-Bender头信息</td></tr><tr><td>session</td><td>唯一可读写的属性，代表当前会话的字典对象。只有激活Django中的session支持时该属性才可用。</td></tr><tr><td>raw_post_data</td><td>原始HTTP POST数据，未解析过。 高级处理时会有用处。</td></tr></tbody></table><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>__getitem__(key)</code></td><td>返回GET/POST的键值,先取POST,后取GET。<br>如果键不存在抛出<code>KeyError</code>。<br>这是我们可以使用字典语法访问HttpRequest对象。<br>例如:<code>request[&quot;foo&quot;]</code>等同于先request.POST<code>[&quot;foo&quot;]</code>然后 <code>request.GET[&quot;foo&quot;]</code>的操作。</td></tr><tr><td><code>has_key()</code></td><td>检查<code>request.GET</code>或<code>request.POST</code>中是否包含参数指定的Key。</td></tr><tr><td><code>get_full_path()</code></td><td>返回包含查询字符串的请求路径</td></tr><tr><td><code>is_secure()</code></td><td>如果请求是安全的，返回True，就是说，发出的是HTTPS请求。</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Django</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>xpath-XML-数据解析</title>
    <link href="/post/7f566256/"/>
    <url>/post/7f566256/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>XPath</code>是一门在<code>XML</code>档中查找信息的语言<br><code>XPath</code>在<code>XML</code>文档中通过元素和属性进行导航<br>其速度比<code>Beautifulsoup</code>要快，比<code>正则表达式</code>要慢  </p><blockquote><p>正则，永远的神  </p></blockquote><h1 id="词汇描述"><a href="#词汇描述" class="headerlink" title="词汇描述"></a>词汇描述</h1><p>在使用<code>xpath</code>前，先要知道一些<code>DOM</code>描述词汇的意义  </p><blockquote><p>其描述与数据结构中树的描述有很多相似的地方  </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>J K. Rowling<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span> <br>      <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2005<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>29.99<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li><p>节点 Node<br>从标签开头到标签结束都是节点内容  </p><blockquote><p>比如  </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">author</span>&gt;</span>J K. Rowling<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span> <br></code></pre></td></tr></table></figure></li><li><p>值 Atomic value</p><blockquote><p>比如  </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">29.99<br></code></pre></td></tr></table></figure></li><li><p>项 Item<br>值或节点  </p></li><li><p>父级 Parent 与 子级 Children<br>直接父级指上级节点，直接子级指下级节点  </p><blockquote><p>比如：title节点的父级是book节点<br>比如：book节点有子节点title</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      ......<br><span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>比如：book节点有子节点title</p></blockquote></li><li><p>祖先 Ancestor 与 后代 Descendant<br>多级父级关系与多级子级关系  </p><blockquote><p>比如：bookstore有后代节点title节点<br>比如：title有祖先bookstore节点  </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      ......<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>同胞 Sibling<br>拥有相同父节点的节点  </p><blockquote><p>比如：title节点与year节点是同胞</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">year</span>&gt;</span>2005<span class="hljs-tag">&lt;/<span class="hljs-name">year</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><blockquote><p>然而我还是喜欢叫兄弟节点多一点</p></blockquote></blockquote></li><li><p>属性<br>指节点标签内部声明的内容  </p><blockquote><p>比如：title节点有lang属性，其值为en  </p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="轴描述语法"><a href="#轴描述语法" class="headerlink" title="轴描述语法"></a>轴描述语法</h1><p>语法本身是比较的冗长<br>缩写的语法虽然简易，但是无法做到一些比较复杂的事情  </p><table><thead><tr><th>坐标</th><th>名称</th><th>说明</th><th>缩写语法</th></tr></thead><tbody><tr><td>child</td><td>子节点</td><td>比自身节点深度大的一层的节点，且被包含在自身之内</td><td>默认，不需要</td></tr><tr><td>attribute</td><td>属性</td><td></td><td>@</td></tr><tr><td>descendant</td><td>子孙节点</td><td>比自身节点深度大的节点，且被包含在自身之内</td><td>不提供</td></tr><tr><td>descendant-or-self</td><td>自身引用及子孙节点</td><td></td><td>//</td></tr><tr><td>parent</td><td>父节点</td><td>比自身节点深度小一层的节点，且包含自身</td><td>..</td></tr><tr><td>ancestor</td><td>祖先节点</td><td>比自身节点深度小的节点，且包含自身</td><td>不提供</td></tr><tr><td>ancestor-or-self</td><td>自身引用及祖先节点</td><td></td><td>不提供</td></tr><tr><td>following</td><td>下文节点</td><td>按纵轴视图，在此节点后的所有完整节点，即不包含其祖先节点</td><td>不提供</td></tr><tr><td>preceding</td><td>前文节点</td><td>按纵轴视图，在此节点前的所有完整节点，即不包含其子孙节点</td><td>不提供</td></tr><tr><td>following-sibling</td><td>下一个同级节点</td><td></td><td>不提供</td></tr><tr><td>preceding-sibling</td><td>上一个同级节点</td><td></td><td>不提供</td></tr><tr><td>self</td><td>自己</td><td></td><td>.</td></tr><tr><td>namespace</td><td>名称空间</td><td></td><td>不提供</td></tr></tbody></table><blockquote></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;eng&quot;</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>29.99<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;eng&quot;</span>&gt;</span>Learning XML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>39.95<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;cn&quot;</span>&gt;</span>Learning XPath<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>23.33<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span><br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：原轴描述语法 获取title节点  </p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">/child::bookstore/child::book/child::title<br></code></pre></td></tr></table></figure><blockquote><p>案例：缩写语法 获取title节点  </p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/bookstore/</span>book/title<br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：原轴描述语法 获取price节点</p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">/descendant-<span class="hljs-keyword">or</span>-<span class="hljs-keyword">self</span>::price<br></code></pre></td></tr></table></figure><blockquote><p>案例：缩写语法 获取price节点</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>price<br></code></pre></td></tr></table></figure><h1 id="节点测试"><a href="#节点测试" class="headerlink" title="节点测试"></a>节点测试</h1><table><thead><tr><th>格式</th><th>信息</th><th>例子</th><th>简写</th></tr></thead><tbody><tr><td>comment()</td><td>寻找XML注释节点</td><td>获取<code>&lt;!-- 注释 --&gt;</code>中的<code>注释</code></td><td></td></tr><tr><td>text()</td><td>寻找某点的文字型别</td><td>获取<code>&lt;k&gt;hello&lt;/k&gt;</code>中的<code>hello</code></td><td></td></tr><tr><td>processing-instruction()</td><td>寻找XML处理指令</td><td><code>&lt;?php echo $a; ?&gt;</code>在这个例子里，将符合processing-instruction(‘php’)会传回值</td><td></td></tr><tr><td>node()</td><td>寻找所有点</td><td><code>//node()[@lang=&quot;cn&quot;]</code>寻找属性<code>lang</code>为<code>cn</code>的节点</td><td><code>*</code></td></tr></tbody></table><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th><th>返回值</th></tr></thead><tbody><tr><td><code>+</code>,<code>-</code>,<code>*</code>,<code>div</code></td><td>加,减,乘,除</td><td><code>6 + 4</code></td><td>返回对应计算结果</td></tr><tr><td><code>=</code>,<code>!=</code></td><td>等于, 不等于</td><td><code>price=9.80</code></td><td>根据比较返回<code>true</code>或<code>false</code></td></tr><tr><td><code>&lt;</code>,<code>&gt;</code>,<code>&lt;=</code>,<code>&gt;=</code></td><td>小于，大于，小于等于，大于等于</td><td><code>price&lt;=9.80</code></td><td>根据比较结果返回<code>true</code>或<code>false</code></td></tr><tr><td>or</td><td>或</td><td><code>price=9.80 or price=9.70</code></td><td>如果 price 是 9.80，则返回 true，否则返回 false</td></tr><tr><td>and</td><td>与</td><td><code>price&gt;9.00 and price&lt;9.90</code></td><td>如果 price 是 9.80，则返回 true，否则返回 false</td></tr><tr><td>mod</td><td>计算除法的余数</td><td><code>5 mod 2</code></td><td>1</td></tr></tbody></table><h1 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bookstore</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;eng&quot;</span>&gt;</span>Harry Potter<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>29.99<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;eng&quot;</span>&gt;</span>Learning XML<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>39.95<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">book</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">title</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;cn&quot;</span>&gt;</span>Learning XPath<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">price</span>&gt;</span>23.33<span class="hljs-tag">&lt;/<span class="hljs-name">price</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">book</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ticket</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spend</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">spend</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ticket</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bookstore</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h2><p>string()，number()，boolean()  </p><h2 id="字符串运算函数"><a href="#字符串运算函数" class="headerlink" title="字符串运算函数"></a>字符串运算函数</h2><table><thead><tr><th>函数</th><th>作用描述</th><th>例子</th></tr></thead><tbody><tr><td>concat()</td><td>拼接字符串</td><td><code>concat(/bookstore/book[1]/price/text(), &quot;元&quot;)</code><br>结果：29.99元</td></tr><tr><td>string-join((str1,str2,…),sep)</td><td>用指定分割字符拼接多个字符串</td><td><code>string-join(/bookstore/book/title/text(), &#39;,&#39;)</code><br>结果：Harry Potter,Learning XML,Learning XPath</td></tr><tr><td>substring(str,start,length)</td><td>返回指定区间子字符串<br>若不传入长度参数则返回后续全部字符</td><td><code>substring(/bookstore/book[1]/title/text(), 2, 2)</code><br>结果：ar</td></tr><tr><td>substring-before(str, after_str)</td><td>返回在特定字串前的字符串</td><td><code>substring-before(/bookstore/book[1]/title/text(), &quot;ry&quot;)</code><br>结果：Har</td></tr><tr><td>substring-after(str, before_str)</td><td>返回在特定字串后的字符串</td><td><code>substring-after(/bookstore/book[1]/title/text(), &quot;ry &quot;)</code><br>结果：Potter</td></tr><tr><td>translate(str,origin_str,replace_str)</td><td>用指定字符串替换目标字符串</td><td><code>translate(/bookstore/book[1]/title/text(), &quot;Potter&quot;, &quot;After&quot;)</code><br>结果：Harry After</td></tr><tr><td>normalize-space(str)</td><td>删除开头结尾空白字符</td><td><code>normalize-space(&#39; The XML &#39;)</code><br>结果：The XML</td></tr><tr><td>string-length(str)</td><td>得到字符串长度</td><td><code>string-length(&#39;Beatles&#39;)</code><br>结果：7</td></tr><tr><td>contains(str,sub_str)</td><td>检查字符串中是否包含子字符串</td><td><code>contains(/bookstore/book[1]/title/text(), &#39;Harry&#39;)</code><br>结果:True</td></tr></tbody></table><h2 id="数学运算函数"><a href="#数学运算函数" class="headerlink" title="数学运算函数"></a>数学运算函数</h2><table><thead><tr><th>函数</th><th>作用描述</th><th>例子</th></tr></thead><tbody><tr><td>sum()</td><td>求和</td><td><code>sum(/bookstore/book[position()&gt;1]/price/text())</code><br>结果：63.28</td></tr><tr><td>ceiling()</td><td>向上取整</td><td><code>ceiling(/bookstore/book[1]/price/text())</code><br>结果：30</td></tr><tr><td>floor()</td><td>向下取整</td><td><code>floor(/bookstore/book[1]/price/text())</code><br>结果：29</td></tr><tr><td>round()</td><td>取最接近整数<br>并非四舍五入，处中间则向下取整入</td><td><code>round(/bookstore/book[1]/price/text())</code><br>结果：30</td></tr></tbody></table><h2 id="节点属性取得函数"><a href="#节点属性取得函数" class="headerlink" title="节点属性取得函数"></a>节点属性取得函数</h2><p>name(), local-name(), namespace-uri()  </p><h2 id="处理上下文数据取得函数"><a href="#处理上下文数据取得函数" class="headerlink" title="处理上下文数据取得函数"></a>处理上下文数据取得函数</h2><p>position(), last()  </p>]]></content>
    
    
    
    <tags>
      
      <tag>xpath</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-tqdm-进度条</title>
    <link href="/post/3162fa98/"/>
    <url>/post/3162fa98/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>python</code>可以使用的一个进度条<br>github/文档：<a href="https://github.com/tqdm/tqdm">https://github.com/tqdm/tqdm</a>  </p><h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><h2 id="tqdm-tqdm"><a href="#tqdm-tqdm" class="headerlink" title="tqdm.tqdm"></a>tqdm.tqdm</h2><p>使用之前先将<code>tqdm</code>导入进来  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br></code></pre></td></tr></table></figure><h3 id="基于可迭代对象使用"><a href="#基于可迭代对象使用" class="headerlink" title="基于可迭代对象使用"></a>基于可迭代对象使用</h3><blockquote><p>案例 1  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm(<span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>)):<br>    ...<br></code></pre></td></tr></table></figure><blockquote><p>显示结果</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">76%</span><span class="bash">|████████████████████████        | 7568/10000 [00:33&lt;00:10, 229.00it/s]</span><br></code></pre></td></tr></table></figure><br>>案例 2  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> tqdm <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">from</span> time <span class="hljs-keyword">import</span> sleep<br><br>text = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> tqdm([<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;d&quot;</span>]):<br>    sleep(<span class="hljs-number">0.25</span>)<br>    text = text + char<br></code></pre></td></tr></table></figure>`tqdm.tqdm()`会接收一个可迭代的对象，通过`len()`计算它的长度来实现进度条的效果  只要满足这两个条件，就能塞东西进去显示进度条  <h3 id="基于数值使用"><a href="#基于数值使用" class="headerlink" title="基于数值使用"></a>基于数值使用</h3><p>并非所有对象都可以进行迭代<br>在遇到不能迭代的内容时，可以使用预先设置数值来进行进度条的计算  </p><blockquote><p>案例 1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">pbar = tqdm(total=<span class="hljs-number">100</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>    sleep(<span class="hljs-number">0.1</span>)<br>    pbar.update(<span class="hljs-number">10</span>)<br>pbar.close()<br></code></pre></td></tr></table></figure><blockquote><p>案例 2</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> tqdm(total=<span class="hljs-number">100</span>) <span class="hljs-keyword">as</span> pbar:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>):<br>        sleep(<span class="hljs-number">0.1</span>)<br>        pbar.update(<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure><h1 id="tqdm详细"><a href="#tqdm详细" class="headerlink" title="tqdm详细"></a>tqdm详细</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">class tqdm():<br>  <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">  装饰一个可迭代的对象，返回一个迭代器。迭代器返回的对象与原本一致，但是会更新进度条信息  </span><br><span class="hljs-string">  &quot;</span><span class="hljs-string">&quot;&quot;</span><br><br>  def __init__(self, <span class="hljs-attribute">iterable</span>=None, <span class="hljs-attribute">desc</span>=None, <span class="hljs-attribute">total</span>=None, <span class="hljs-attribute">leave</span>=<span class="hljs-literal">True</span>,<br>               <span class="hljs-attribute">file</span>=None, <span class="hljs-attribute">ncols</span>=None, <span class="hljs-attribute">mininterval</span>=0.1,<br>               <span class="hljs-attribute">maxinterval</span>=10.0, <span class="hljs-attribute">miniters</span>=None, <span class="hljs-attribute">ascii</span>=None, <span class="hljs-attribute">disable</span>=<span class="hljs-literal">False</span>,<br>               <span class="hljs-attribute">unit</span>=<span class="hljs-string">&#x27;it&#x27;</span>, <span class="hljs-attribute">unit_scale</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">dynamic_ncols</span>=<span class="hljs-literal">False</span>,<br>               <span class="hljs-attribute">smoothing</span>=0.3, <span class="hljs-attribute">bar_format</span>=None, <span class="hljs-attribute">initial</span>=0, <span class="hljs-attribute">position</span>=None,<br>               <span class="hljs-attribute">postfix</span>=None, <span class="hljs-attribute">unit_divisor</span>=1000):<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数名</th><th>值类型</th><th>参数类型</th><th>描述</th></tr></thead><tbody><tr><td>iterable</td><td>iterable</td><td>可选</td><td>一个被装饰的可迭代对象</td></tr><tr><td>desc</td><td>str</td><td>可选</td><td>进度条前缀描述</td></tr><tr><td>total</td><td>int / float</td><td>可选</td><td>预期的迭代次数。<br>如未指定，则使用len(iterable)获取</td></tr><tr><td>leave</td><td>bool</td><td>可选</td><td>默认为True<br>是否不在迭代迭代结束后将进度条消除掉</td></tr><tr><td>file</td><td><code>io.TextIOWrapper</code>/<code>io.StringIO</code></td><td>可选</td><td>指定输出流，使用<code>file.write(str)</code>和<code>file.flush()</code>实现</td></tr><tr><td>ncols</td><td>int</td><td>可选</td><td>进度条宽度</td></tr><tr><td>mininterval</td><td>float</td><td>可选</td><td>进度条最小进度更新时间间隔，默认值：0.1秒</td></tr><tr><td>maxinterval</td><td>float</td><td>可选</td><td>进度条最大进度更新时间间隔，默认10秒</td></tr><tr><td>miniters</td><td>int / float</td><td>可选</td><td>最小进度显示更新值</td></tr><tr><td>ascii</td><td>bool / str</td><td>可选</td><td>如果未指定或为<code>False</code>，则会用<code>unicode</code>平滑块符号 填充仪表</td></tr><tr><td>disable</td><td>bool</td><td>可选</td><td>是否禁用</td></tr><tr><td>unit</td><td>str</td><td>可选</td><td>进度条单位</td></tr><tr><td>unit_scale</td><td>bool / int / float</td><td>可选</td><td>如果为1或True，则迭代次数将自动减少/缩放。比如<code>bit</code>转<code>kb</code>。默认值：False</td></tr><tr><td>dynamic_ncols</td><td>bool</td><td>可选</td><td>进度条长度动态适应窗口大小。默认值：False</td></tr><tr><td>smoothing</td><td>float</td><td>可选</td><td>速度估计的平滑因子<br>范围从0（平均速度）到1（当前/瞬时速度）。默认值：0.3</td></tr><tr><td>bar_format</td><td>str</td><td>可选</td><td>进度条显示形式，由于是不断刷新的，会影响机器性能<br>默认值：’{l_bar} {bar} {r_bar}’</td></tr><tr><td>initial</td><td>int / float</td><td>可选</td><td>进度条初始值</td></tr><tr><td>position</td><td>int</td><td>可选</td><td>指定进度条显示偏移量（从0开始）。如果未指定，则为自动设置。<br>在你想要显示多个进度条的时候，它会帮到你的</td></tr><tr><td>postfix</td><td>dict / <code>*</code></td><td>可选</td><td>指定显示在进度条末尾的其他统计信息</td></tr><tr><td>unit_divisor</td><td>float</td><td>可选</td><td></td></tr><tr><td>write_bytes</td><td>bool</td><td>可选</td><td></td></tr><tr><td>lock_args</td><td>tuple</td><td>可选</td><td></td></tr><tr><td>nrows</td><td>int</td><td>可选</td><td>如果指定，则在此边界之外隐藏嵌套的条。 如果未指定，请尝试使用环境高度。</td></tr><tr><td>colour</td><td>str</td><td>可选项</td><td>进度条颜色</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>tqdm</tag>
      
      <tag>进度条</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-進程查看</title>
    <link href="/post/b5bd8d04/"/>
    <url>/post/b5bd8d04/</url>
    
    <content type="html"><![CDATA[<h1 id="ps-命令"><a href="#ps-命令" class="headerlink" title="ps 命令"></a>ps 命令</h1><p>ps(process status) 命令是 Linux 下最常用的进程查看工具，使用该命令可以确定哪些进程正在运行和运行的状态、</p><p>进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等等  </p><blockquote><p>注意：ps 命令工具显示的是进程的瞬间状态，并不是动态连续显示，如果想对进程状态进行实时监控应该用 top 命令  </p></blockquote><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>不添加任何參數时，只显示当前用户会话中打开的进程  </p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps<br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011050930863.png">  </p></blockquote><ul><li>PID：表示该进程的唯一 ID 号  </li><li>TTY 或 TT：启动进程的终端名。表示该进程在哪个终端上运行  </li><li>TIME：该进程使用 CPU 的累计时间  </li><li>CMD：该进程所运行的命令  </li></ul><h2 id="e显示全部进程的信息"><a href="#e显示全部进程的信息" class="headerlink" title="e显示全部进程的信息"></a><code>e</code>显示全部进程的信息</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps e<br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011081257947.png"></p></blockquote><p>结果和上面的类似，但是显示的进程会多一些  </p><ul><li>COMMAND：执行原因（命令）  </li><li>STAT：表示进程的当前状态  <ul><li>R：running，运行或可运行状态（在运行队列中）。正在运行或准备运行的进程。</li><li>S：interruptable sleeping，可中断睡眠（等待事件完成）。正在睡眠的进程。</li><li>D：uninterruptable sleeping，不可中断的睡眠进程（通常为IO）。</li><li>T：stopped，停止或被追踪的进程。由作业控制信号停止。</li><li>Z：zombie，失败终止的（“僵死”）进程。</li><li>s：session leader，会话层状态。代表的父进程</li><li>N：低优先级进程</li><li>&lt;：高优先级进程</li><li>+：前台进程。在前台进程组中</li><li>l：多线程进程。</li></ul></li></ul><h2 id="f显示完整信息"><a href="#f显示完整信息" class="headerlink" title="f显示完整信息"></a><code>f</code>显示完整信息</h2><blockquote><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ps f</span><br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011081444591.png"></p></blockquote><p>除了基本命令本身就有的信息项以外，还会显示更多的信息  </p><ul><li>UID：启动该进程的用户的 ID 号  </li><li>PPID：代表该进程的父进程的 ID 号  </li><li>C：进程的 CPU 处理器利用率  </li><li>STIME/START：表示进程的启动时间  </li></ul><h2 id="a显示当前终端所有进程信息"><a href="#a显示当前终端所有进程信息" class="headerlink" title="a显示当前终端所有进程信息"></a><code>a</code>显示当前终端所有进程信息</h2><p>显示当前终端下的所有进程信息，包含其他用户的进程信息  </p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps a<br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011083539734.png">  </p></blockquote><h2 id="x显示当前用户在所有终端下的进程信息"><a href="#x显示当前用户在所有终端下的进程信息" class="headerlink" title="x显示当前用户在所有终端下的进程信息"></a><code>x</code>显示当前用户在所有终端下的进程信息</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps x<br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011084553974.png">  </p></blockquote><h2 id="u以面向用户的格式显示当前终端下的所有信息"><a href="#u以面向用户的格式显示当前终端下的所有信息" class="headerlink" title="u以面向用户的格式显示当前终端下的所有信息"></a><code>u</code>以面向用户的格式显示当前终端下的所有信息</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ps u<br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011084827077.png">  </p></blockquote><ul><li>USER：启动该进程的用户帐号名称  </li><li>%CPU：表示进程的 CPU 占用率  </li><li>%MEM：表示进程的内存占用率  </li><li>VSZ：表示进程虚拟内存的大小，以 KB 为单位  </li></ul><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><ul><li><code>ps -ef</code><br>查看所有进程  </li><li><code>ps aux</code><br>以面向用户的格式显示当前终端下的所有信息  </li></ul><h1 id="更多操作"><a href="#更多操作" class="headerlink" title="更多操作"></a>更多操作</h1><h2 id="sort排序"><a href="#sort排序" class="headerlink" title="--sort排序"></a><code>--sort</code>排序</h2><p>对指定的项目输入即可得到根据项目排序后得到的结果  </p><blockquote><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">ps <span class="hljs-built_in">aux</span> --<span class="hljs-built_in">sort</span>=%mem<br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011090057738.png">  </p></blockquote><h2 id="grep过滤"><a href="#grep过滤" class="headerlink" title="grep过滤"></a><code>grep</code>过滤</h2><p>过滤调不符合条件的内容，只显示指定的内容  </p><blockquote><p>只显示SSH的进程  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -ef |<span class="hljs-keyword">grep</span> sshd<br></code></pre></td></tr></table></figure><p><img src="/Linux-%E9%80%B2%E7%A8%8B%E6%9F%A5%E7%9C%8B/20201011090803012.png">  </p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-logging-日志</title>
    <link href="/post/6c246ae5/"/>
    <url>/post/6c246ae5/</url>
    
    <content type="html"><![CDATA[<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>日志是跟踪软件运行时所发生的事件的一种方法<br>软件开发者在代码中调用日志函数，表明发生了特定的事件  </p><p><code>logging</code>可以很好的代替<code>print</code>功能，并且更加方便管理  </p><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><p><code>logging</code>是<code>python</code>自带的日志模块，一般不需要额外安装<br>需要使用日志前<code>import</code>即可  </p><blockquote><p>案例：Hello World</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br>logging.info(<span class="hljs-string">&#x27;Hello World&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>这是一个简单的<code>logging</code>使用的例子<br>这里用<code>logging</code>记录了<code>Hello World</code>这个信息  </p></blockquote><p>如果没有特别设置，这个信息默认会输出到控制台上。并且附带一些诸如时间之类的额外的信息  </p><h2 id="日志等级"><a href="#日志等级" class="headerlink" title="日志等级"></a>日志等级</h2><p><code>logging</code>的日志有六个等级  </p><table><thead><tr><th>等级</th><th>NOTSET</th><th>DEBUG</th><th>INFO</th><th>WARNING(默认)</th><th>ERROR</th><th>CRITICAL</th></tr></thead><tbody><tr><td>数值</td><td>0</td><td>10</td><td>20</td><td>30</td><td>40</td><td>50</td></tr><tr><td>信息</td><td>提示</td><td>调试信息<br>只在调试问题时使用</td><td>信息<br>事情按预期工作</td><td>警告<br>没有预料到的事件提示</td><td>错误<br>软件不能执行一些功能</td><td>严重错误<br>软件已不能继续运行</td></tr></tbody></table><p>你可以在代码需要的位置记录不同等级的日志  </p><blockquote><p>案例：记录不同级别的日志  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br>logging.debug(<span class="hljs-string">&#x27;debug 信息&#x27;</span>)<br>logging.info(<span class="hljs-string">&#x27;info 信息&#x27;</span>)<br>logging.warning(<span class="hljs-string">&#x27;warning 信息&#x27;</span>)<br>logging.error(<span class="hljs-string">&#x27;error 信息&#x27;</span>)<br>logging.critical(<span class="hljs-string">&#x27;critial 信息&#x27;</span>)<br></code></pre></td></tr></table></figure><p>可以在使用前,用<code>logging.basicConfig</code>规定日志的输出等级(上面说过的等级都有)<br>低于规定等级的日志，在程序运行过程中不会记录  </p><blockquote><p>案例：指定输出日志等级  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> logging<br>logging.basicConfig(level=logging.INFO)<br>logging.debug(<span class="hljs-string">&#x27;debug 信息&#x27;</span>)<br>logging.error(<span class="hljs-string">&#x27;error 信息&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="文件日志"><a href="#文件日志" class="headerlink" title="文件日志"></a>文件日志</h2><p>可以在使用前,用<code>logging.basicConfig</code>规定日志的输出文件与输出方式  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.basicConfig(<br>    filename=<span class="hljs-string">&#x27;new.log&#x27;</span>,  <span class="hljs-comment"># 日志文件文件路径</span><br>    filemode=<span class="hljs-string">&#x27;a&#x27;</span>  <span class="hljs-comment"># 记录模式，可填入&#x27;a&#x27;或&#x27;w&#x27;,与`open`函数的对应参数效果一致</span><br>)<br></code></pre></td></tr></table></figure><ul><li>filename<br>日志文件文件路径  </li><li>filemode<br>记录模式，可填入’a’或’w’,与<code>open</code>函数的对应参数效果一致  (即’w’为覆盖，’a’为增量)</li></ul><h2 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h2><p>日志中的信息除了基本写在程序中的信息以外，还包括了一些附属的信息（时间，级别，模块名……）<br>设置日志记录的格式结构，可以让记录更加精简或更加详细  </p><p>可以在使用前,用<code>logging.basicConfig</code>规定日志格式  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">logging.basicConfig(<br>    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(pathname)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span><br>)<br></code></pre></td></tr></table></figure><h3 id="格式参数参考"><a href="#格式参数参考" class="headerlink" title="格式参数参考"></a>格式参数参考</h3><table><thead><tr><th>日志内容</th><th>信息</th></tr></thead><tbody><tr><td>%(name)s</td><td>Logger的名字</td></tr><tr><td>%(levelno)s</td><td>数字形式的日志级别</td></tr><tr><td>%(levelname)s</td><td>文本形式的日志级别</td></tr><tr><td>%(pathname)s</td><td>调用日志输出函数的模块的完整路径名，可能没有</td></tr><tr><td>%(filename)s</td><td>调用日志输出函数的模块的文件名</td></tr><tr><td>%(module)s</td><td>调用日志输出函数的模块名</td></tr><tr><td>%(funcName)s</td><td>调用日志输出函数的函数名</td></tr><tr><td>%(lineno)d</td><td>调用日志输出函数的语句所在的代码行</td></tr><tr><td>%(created)f</td><td>当前时间，用UNIX标准的表示时间的浮 点数表示</td></tr><tr><td>%(relativeCreated)d</td><td>输出日志信息时的，自Logger创建以 来的毫秒数</td></tr><tr><td>%(asctime)s</td><td>字符串形式的当前时间。默认格式：”%Y-%m-%d %H:%M:%S”<br>效果：“2003-07-08 16:49:45,896”。逗号后面的是毫秒</td></tr><tr><td>%(thread)d</td><td>线程ID。可能没有</td></tr><tr><td>%(threadName)s</td><td>线程名。可能没有</td></tr><tr><td>%(process)d</td><td>进程ID。可能没有</td></tr><tr><td>%(message)s</td><td>用户输出的消息</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>logging</tag>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-基础-url拼接</title>
    <link href="/post/296cbee9/"/>
    <url>/post/296cbee9/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>爬虫过程中，url拼接的问题几乎是100%会碰到的<br>你当然可以使用字符串并接的方式删删拼拼达到目的，但那样做显得很麻瓜。而且，由于<code>&lt;a&gt;</code>的<code>@href</code>和<code>&lt;img&gt;</code>的<code>@src</code>呈现出来的内容的不同，可能每一个url都要区别对待<br>实际上，倒是有一些函数能帮忙做这些事情  </p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="基本字符串拼接"><a href="#基本字符串拼接" class="headerlink" title="基本字符串拼接"></a>基本字符串拼接</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">url</span> = <span class="hljs-string">&#x27;https://www.a.com&#x27;</span> + <span class="hljs-string">&#x27;/index.html&#x27;</span><br><span class="hljs-attr">url</span> = <span class="hljs-string">&#x27;https://www.a.com/index.html&#x27;</span>[:<span class="hljs-number">11</span>] + <span class="hljs-string">&#x27;/1_1.html&#x27;</span><br></code></pre></td></tr></table></figure><p>最多最多就是把<code>host</code>拿来用一下减轻一些观感上的压力，但实际上就是很麻烦  </p><h2 id="response-joinurl"><a href="#response-joinurl" class="headerlink" title="response.joinurl"></a>response.joinurl</h2><p><code>scrapy</code>的解析函数参数<code>response</code>的函数<code>joinurl</code>能够很轻松的处理<code>url</code>拼接问题  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a_href = <span class="hljs-string">&#x27;/a/1.html&#x27;</span><br>url = response.urljoin(a_href)<br></code></pre></td></tr></table></figure><h2 id="response-follow"><a href="#response-follow" class="headerlink" title="response.follow"></a>response.follow</h2><p>此函数用于直接对新的<code>url</code>发起请求，它会计算新的<code>url</code>来访问  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a_href = <span class="hljs-string">&#x27;/a/1.html&#x27;</span><br><span class="hljs-keyword">yield</span> response.follow(a_href, callback=self.parse)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-单例模式</title>
    <link href="/post/c7d0c491/"/>
    <url>/post/c7d0c491/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><p>单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在<br>当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场  </p><blockquote><p>在那些需要“创建连接”的内容中使用能节约很多资源  </p></blockquote><h1 id="Python实现方式"><a href="#Python实现方式" class="headerlink" title="Python实现方式"></a>Python实现方式</h1><h2 id="模块方式"><a href="#模块方式" class="headerlink" title="模块方式"></a>模块方式</h2><p>其实，<code>Python</code> 的模块就是天然的单例模式<br>因为模块在第一次导入时，会生成<code>.pyc</code>文件，当第二次导入时，就会直接加载<code>.pyc</code>文件，而不会再次执行模块代码<br>因此，只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了  </p><blockquote><p>例：</p></blockquote><figure class="highlight python"><figcaption><span>single.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br>single = Singleton()<br></code></pre></td></tr></table></figure><blockquote><p>直接在其他文件中导入此文件中的对象<code>single</code>，这个对象即是单例模式的对象  </p></blockquote><figure class="highlight python"><figcaption><span>a.py</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> demo.my_singleton <span class="hljs-keyword">import</span> single<br> <br>single.foo()<br></code></pre></td></tr></table></figure><h2 id="装饰器方式"><a href="#装饰器方式" class="headerlink" title="装饰器方式"></a>装饰器方式</h2><h3 id="函数装饰器"><a href="#函数装饰器" class="headerlink" title="函数装饰器"></a>函数装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleton</span>(<span class="hljs-params">cls</span>):</span><br>    _instance = &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span>():</span><br>        <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _instance:<br>            _instance[cls] = cls()<br>        <span class="hljs-keyword">return</span> _instance[cls]<br>    <span class="hljs-keyword">return</span> inner<br>    <br><span class="hljs-meta">@singleton</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cls</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">pass</span><br><br>cls1, cls2 = Cls(), Cls()<br>print(<span class="hljs-built_in">id</span>(cls1) == <span class="hljs-built_in">id</span>(cls2))<br></code></pre></td></tr></table></figure><blockquote><ul><li>id函数可以查看对象在内存中的位置  </li><li>使用这个方式创建对象时，会访问singleton函数<br>实际上，由于装饰器的应用，<code>Cls</code>返回的结果也变成了函数  </li></ul></blockquote><p>函数会查看想要创建实例的类是否在字典中已经有记录，要是有记录就直接返回记录中的对象  </p><h3 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    _INSTANCE = &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, cls</span>):</span><br>        self.cls = cls   <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span><br>        instance = self._INSTANCE.get(self.cls, <span class="hljs-literal">None</span>)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> instance:<br>            instance = self.cls(*args, **kwargs)<br>            self._INSTANCE[self.cls] = instance<br>        <span class="hljs-keyword">return</span> instance  <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getattr__</span>(<span class="hljs-params">self, key</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getattr</span>(self.cls, key, <span class="hljs-literal">None</span>)<br><span class="hljs-meta">@Singleton</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">my_cls</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-keyword">pass</span><br><br>cls1, cls2 = Cls2(), Cls2()<br>print(<span class="hljs-built_in">id</span>(cls1) == <span class="hljs-built_in">id</span>(cls2))<br></code></pre></td></tr></table></figure><p>虽然和函数装饰器看上去并不一样，但实际上原理是一样的  </p><h2 id="类方式"><a href="#类方式" class="headerlink" title="类方式"></a>类方式</h2><h3 id="使用属性（不要在多线程环境使用）"><a href="#使用属性（不要在多线程环境使用）" class="headerlink" title="使用属性（不要在多线程环境使用）"></a>使用属性（不要在多线程环境使用）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    __instance = <span class="hljs-literal">None</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.x = x<br>        print(x)<br>        time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 加入干扰元素，造成多线程出现问题</span><br> <br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_singleton</span>(<span class="hljs-params">cls, *args, **kwargs</span>):</span><br>        <span class="hljs-keyword">with</span> cls.__instance_lock:  <span class="hljs-comment"># 加锁</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> cls.__instance:<br>                cls.__instance = cls(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> cls.__instance<br></code></pre></td></tr></table></figure><p>这种方式如果不加锁，在多线程环境使用的时候会出现失效的情况  </p><blockquote><p>过程很容易想象，假设现在有A，B两个线程  </p></blockquote><ol><li>A <code>if not cls.__instance:</code>判断为真  </li><li>B <code>if not cls.__instance:</code>判断为真  </li><li>B <code>cls.__instance = cls(*args, **kwargs)</code>初始化了一遍实例  </li><li>A <code>cls.__instance = cls(*args, **kwargs)</code>初始化了两遍实例  </li></ol><p>这种方式仅在单线程情况下推荐使用<br>多线程模式中不推荐使用，加锁会明显的降低性能  </p><h3 id="使用-new"><a href="#使用-new" class="headerlink" title="使用__new__"></a>使用<code>__new__</code></h3><p>当我们实例化一个对象时，是先执行了类的<code>__new__</code>方法实例化对象；然后再执行类的<code>__init__</code>方法，对这个对象进行初始化  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<br> <br> <br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    _instance_lock = threading.Lock()<br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x</span>):</span><br>        self.x = x<br>        <span class="hljs-keyword">import</span> time<br>        time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 加入干扰元素，造成多线程出现问题</span><br> <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(cls, <span class="hljs-string">&#x27;_instance&#x27;</span>):<br>            <span class="hljs-keyword">with</span> cls._instance_lock:  <span class="hljs-comment"># 加锁</span><br>                cls._instance = <span class="hljs-built_in">super</span>(Singleton, cls).__new__(cls)<br>        <span class="hljs-keyword">return</span> cls._instance<br></code></pre></td></tr></table></figure><h3 id="元类方式"><a href="#元类方式" class="headerlink" title="元类方式"></a>元类方式</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">class</span> <span class="hljs-constructor">Singleton(<span class="hljs-params">type</span>)</span>:<br>    def <span class="hljs-constructor">__init__(<span class="hljs-params">cls</span>, <span class="hljs-params">name</span>, <span class="hljs-params">bases</span>, <span class="hljs-params">dic</span>)</span>:<br>        super(Singleton, cls).<span class="hljs-constructor">__init__(<span class="hljs-params">name</span>, <span class="hljs-params">bases</span>, <span class="hljs-params">dic</span>)</span><br>        cls._instance = None<br>    def <span class="hljs-constructor">__call__(<span class="hljs-params">cls</span>, <span class="hljs-operator">*</span><span class="hljs-params">args</span>, <span class="hljs-operator">**</span><span class="hljs-params">kwargs</span>)</span>:<br>        <span class="hljs-keyword">if</span> cls._instance is None:<br>            cls._instance = super(Singleton, cls).<span class="hljs-constructor">__call__(<span class="hljs-operator">*</span><span class="hljs-params">args</span>, <span class="hljs-operator">**</span><span class="hljs-params">kwargs</span>)</span><br>            # cls._instance = cls(*args, **kwargs)  # Error! Lead <span class="hljs-keyword">to</span> call this <span class="hljs-keyword">function</span> recursively<br>        return cls._instance<br> <br><span class="hljs-keyword">class</span> my<span class="hljs-constructor">_cls(<span class="hljs-params">object</span>)</span>:<br>    __metaclass__ = Singleton<br></code></pre></td></tr></table></figure><p>这个例子中我们使用元类<code>Singleton</code>替代默认使用<code>type</code>方式创建类<code>my_cls</code><br>可以将类<code>my_cls</code>看做是元类<code>Singleton</code>的一个对象，当我们使用<code>my_cls(...)</code>的方式创建类<code>my_cls</code>的对象时，实际上是在调用元类<code>Singleton</code>的对象<code>my_cls</code>  </p><p>对象可以以函数的方式被调用，那么要求类中定义<code>__call__</code>函数。不过此处被调用的是类，因此我们在元类中定义函数<code>__call__</code>来控制类<code>my_cls</code>对象创建的唯一性  </p><p>这种方式的弊端之一就是类唯一的对象被存放在类的一个静态数据成员中，外部可以通过<code>class_name._instance</code>的方式修改甚至删除这个实例(该例中<code>my_cls._instance = None</code>完全合法)  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>设计模式</tag>
      
      <tag>单例模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-.gitignore-忽略指定文件的版本控制</title>
    <link href="/post/f44b67ee/"/>
    <url>/post/f44b67ee/</url>
    
    <content type="html"><![CDATA[<h1 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h1><p>并不是所有的文件都需要版本控制，程序运行产生的编译的中间文件，日志文件，等等都是不需要版本控制的  </p><p>编写在git的目录创建一个<code>.ignore</code>文件，编写指定的忽略规则就能让git忽略指定的文件或者文件夹，让管理更方便  </p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>创建.gitignore文件<br>如果此文件是在项目<code>push</code>之后创建，那么需要进行一些操作才能让这个文件正常工作  <blockquote><p>注意！！！<br>在代码提交以后再进行此操作，要不然会丢失进度<br><span></span></p></blockquote></li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git rm -r --cached .<br>git <span class="hljs-keyword">add</span><span class="bash"> .</span><br></code></pre></td></tr></table></figure><pre><code>stackoverflow：[如何在push后创建.gitignore并使它生效](https://stackoverflow.com/questions/1139762/ignore-files-that-have-already-been-committed-to-a-git-repository)</code></pre><ol start="2"><li>编写忽略规则  </li></ol><table><thead><tr><th>规则案例</th><th>说明</th></tr></thead><tbody><tr><td><code>.a</code></td><td>忽略所有 <code>.a</code> 结尾的文件</td></tr><tr><td><code>/TODO</code></td><td>仅仅忽略项目根目录下的 <code>TODO</code> 文件</td></tr><tr><td><code>build/</code></td><td>忽略 <code>build/</code> 目录下的所有文件</td></tr><tr><td><code>doc/\*.txt</code></td><td>忽略 <code>doc</code>文件夹下的<code>txt</code>文件</td></tr><tr><td><code>*.class</code></td><td>忽略所有后缀为<code>.class</code>的文件</td></tr><tr><td><code>**/__pycache__</code></td><td>忽略所有<code>__pycache__</code>子文件夹</td></tr></tbody></table><blockquote><p>案例：我的VScode python项目的.ignore案例  </p><p>~~~<br>.vscode/<br>models/<strong>pycache</strong><br>old/~~~<br>忽略了根目录下的.vscode配置文件夹<br>忽略了models/__pycache__文件夹<br>忽略了根目录下的old文件夹</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-Hook-脚本</title>
    <link href="/post/a88eb1a7/"/>
    <url>/post/a88eb1a7/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>自行编写或者收集到的<code>Hook</code>脚本代码  </p><h1 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h1><h2 id="webpack-hook-半自动扣"><a href="#webpack-hook-半自动扣" class="headerlink" title="webpack hook 半自动扣"></a>webpack hook 半自动扣</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 在加载器后面下断点  执行下面代码</span><br><span class="hljs-comment">// 这里的f 替换成需要导出的函数名</span><br><span class="hljs-built_in">window</span>.zhiyuan = f;<br><span class="hljs-built_in">window</span>.wbpk_ = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-built_in">window</span>.isz = <span class="hljs-literal">false</span>;<br>f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">window</span>.isz)<br>&#123;<br>                <span class="hljs-comment">// e[r]里的e 是加载器里的call那里</span><br><span class="hljs-built_in">window</span>.wbpk_ = <span class="hljs-built_in">window</span>.wbpk_ + r.toString()+<span class="hljs-string">&quot;:&quot;</span>+(e[r]+<span class="hljs-string">&quot;&quot;</span>)+ <span class="hljs-string">&quot;,&quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.zhiyuan(r);<br>&#125;<br></code></pre></td></tr></table></figure><p>在你要的方法加载前下断点 执行<code>window.isz=true</code><br>在你要的方法运行后代码处下断点  执行<code>window.wbpk_</code> 拿到所有代码  注意后面有个逗号</p><h2 id="请求hook"><a href="#请求hook" class="headerlink" title="请求hook"></a>请求hook</h2><p>当请求的url里包含<code>MmEwMD</code>时，则插入断点  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> code = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">var</span> open = <span class="hljs-built_in">window</span>.XMLHttpRequest.prototype.open;<br><span class="hljs-built_in">window</span>.XMLHttpRequest.prototype.open = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method, url, <span class="hljs-keyword">async</span></span>)</span>&#123;<br>    <span class="hljs-keyword">if</span> (url.indexOf(<span class="hljs-string">&quot;MmEwMD&quot;</span>)&gt;-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">debugger</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> open.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>&#125;;<br>&#125;<br><span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.textContent = <span class="hljs-string">&#x27;(&#x27;</span> + code + <span class="hljs-string">&#x27;)()&#x27;</span>;<br>(<span class="hljs-built_in">document</span>.head||<span class="hljs-built_in">document</span>.documentElement).appendChild(script);<br>script.parentNode.removeChild(script);<br></code></pre></td></tr></table></figure><h2 id="docuemnt-getElementById-以及value属性的hook"><a href="#docuemnt-getElementById-以及value属性的hook" class="headerlink" title="docuemnt.getElementById 以及value属性的hook"></a>docuemnt.getElementById 以及value属性的hook</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// docuemnt.getElementById 以及value属性的hook,可以参考完成innerHTML的hook</span><br><span class="hljs-built_in">document</span>.getElementById = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">id</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> value = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#&#x27;</span> + id).value;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;DOM操作 id: &#x27;</span>, id)<br>    <span class="hljs-keyword">try</span> &#123;<br><br>        <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#&#x27;</span>+ id), <span class="hljs-string">&#x27;value&#x27;</span>, &#123;<br>            get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;getting -&#x27;</span>, id, <span class="hljs-string">&#x27;value -&#x27;</span>, value);<br>                <span class="hljs-keyword">return</span> value;<br>            &#125;,<br>            set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setting -&#x27;</span>, id, <span class="hljs-string">&#x27;value -&#x27;</span>, val)<br>                value = val;<br>            &#125;<br>        &#125;)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;---------华丽的分割线--------&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#&#x27;</span> + id);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="过debugger"><a href="#过debugger" class="headerlink" title="过debugger"></a>过debugger</h1><h2 id="Type1"><a href="#Type1" class="headerlink" title="Type1:"></a>Type1:</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Closure</span>(<span class="hljs-params">injectFunction</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">arguments</span>.length)<br>                    <span class="hljs-keyword">return</span> injectFunction.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)<br>                    <span class="hljs-built_in">arguments</span>[<span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>] = <span class="hljs-built_in">arguments</span>[<span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>].replace(<span class="hljs-regexp">/debugger/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>                <span class="hljs-keyword">return</span> injectFunction.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">var</span> oldFunctionConstructor = <span class="hljs-built_in">window</span>.Function.prototype.constructor;<br>        <span class="hljs-built_in">window</span>.Function.prototype.constructor = Closure(oldFunctionConstructor)<br>            <span class="hljs-comment">//fix native function</span><br>            <span class="hljs-built_in">window</span>.Function.prototype.constructor.toString = oldFunctionConstructor.toString.bind(oldFunctionConstructor);<br><br>        <span class="hljs-keyword">var</span> oldFunction = <span class="hljs-built_in">Function</span>;<br>        <span class="hljs-built_in">window</span>.Function = Closure(oldFunction)<br>            <span class="hljs-comment">//fix native function</span><br>            <span class="hljs-built_in">window</span>.Function.toString = oldFunction.toString.bind(oldFunction);<br><br>        <span class="hljs-keyword">var</span> oldEval = <span class="hljs-built_in">eval</span>;<br>        <span class="hljs-built_in">window</span>.eval = Closure(oldEval)<br>            <span class="hljs-comment">//fix native function</span><br>            <span class="hljs-built_in">window</span>.eval.toString = oldEval.toString.bind(oldEval);<br><br>        <span class="hljs-comment">// hook GeneratorFunction</span><br>        <span class="hljs-keyword">var</span> oldGeneratorFunctionConstructor = <span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-function"><span class="hljs-keyword">function</span>  * (<span class="hljs-params"></span>) </span>&#123;&#125;).constructor<br>            <span class="hljs-keyword">var</span> newGeneratorFunctionConstructor = Closure(oldGeneratorFunctionConstructor)<br>            newGeneratorFunctionConstructor.toString = oldGeneratorFunctionConstructor.toString.bind(oldGeneratorFunctionConstructor);<br>        <span class="hljs-built_in">Object</span>.defineProperty(oldGeneratorFunctionConstructor.prototype, <span class="hljs-string">&quot;constructor&quot;</span>, &#123;<br>            value: newGeneratorFunctionConstructor,<br>            writable: <span class="hljs-literal">false</span>,<br>            configurable: <span class="hljs-literal">true</span><br>        &#125;)<br><br>        <span class="hljs-comment">// hook Async Function</span><br>        <span class="hljs-keyword">var</span> oldAsyncFunctionConstructor = <span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;).constructor<br>            <span class="hljs-keyword">var</span> newAsyncFunctionConstructor = Closure(oldAsyncFunctionConstructor)<br>            newAsyncFunctionConstructor.toString = oldAsyncFunctionConstructor.toString.bind(oldAsyncFunctionConstructor);<br>        <span class="hljs-built_in">Object</span>.defineProperty(oldAsyncFunctionConstructor.prototype, <span class="hljs-string">&quot;constructor&quot;</span>, &#123;<br>            value: newAsyncFunctionConstructor,<br>            writable: <span class="hljs-literal">false</span>,<br>            configurable: <span class="hljs-literal">true</span><br>        &#125;)<br><br>        <span class="hljs-comment">// hook dom</span><br>        <span class="hljs-keyword">var</span> oldSetAttribute = <span class="hljs-built_in">window</span>.Element.prototype.setAttribute;<br>        <span class="hljs-built_in">window</span>.Element.prototype.setAttribute = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, value</span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value == <span class="hljs-string">&quot;string&quot;</span>)<br>                value = value.replace(<span class="hljs-regexp">/debugger/g</span>, <span class="hljs-string">&quot;&quot;</span>)<br>                    <span class="hljs-comment">// 向上调用</span><br>                    oldSetAttribute.call(<span class="hljs-built_in">this</span>, name, value)<br>        &#125;;<br>        <span class="hljs-keyword">var</span> oldContentWindow = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(HTMLIFrameElement.prototype, <span class="hljs-string">&quot;contentWindow&quot;</span>).get<br>            <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>.HTMLIFrameElement.prototype, <span class="hljs-string">&quot;contentWindow&quot;</span>, &#123;<br>            <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>                <span class="hljs-keyword">var</span> newV = oldContentWindow.call(<span class="hljs-built_in">this</span>)<br>                    <span class="hljs-keyword">if</span> (!newV.inject) &#123;<br>                        newV.inject = <span class="hljs-literal">true</span>;<br>                        core.call(newV, globalConfig, newV);<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> newV<br>            &#125;<br>        &#125;)<br></code></pre></td></tr></table></figure><h2 id="Type2-constructor构造器构造出来的debugger"><a href="#Type2-constructor构造器构造出来的debugger" class="headerlink" title="Type2: constructor构造器构造出来的debugger"></a>Type2: constructor构造器构造出来的debugger</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _constructor = <span class="hljs-title">constructor</span>;<br><span class="hljs-built_in">Function</span>.prototype.constructor = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (s == <span class="hljs-string">&quot;debugger&quot;</span>)&#123;<br>                    <span class="hljs-built_in">console</span>.log(s);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> _constructor(s);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Type3-eval构造的debugger"><a href="#Type3-eval构造的debugger" class="headerlink" title="Type3: eval构造的debugger"></a>Type3: eval构造的debugger</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <br><span class="hljs-meta">    &#x27;use strict&#x27;</span>;<br>    <span class="hljs-keyword">var</span> eval_ = <span class="hljs-built_in">window</span>.eval;<br>    <span class="hljs-built_in">window</span>.eval = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<br>    eval_(x.replace(<span class="hljs-string">&quot;debugger;&quot;</span>,<span class="hljs-string">&quot;  ; &quot;</span>));<br>    &#125;;<br>    <span class="hljs-built_in">window</span>.eval.toString = eval_.toString;<br>&#125;)();<br></code></pre></td></tr></table></figure><h1 id="json-hook"><a href="#json-hook" class="headerlink" title="json hook"></a>json hook</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> my_stringify = <span class="hljs-built_in">JSON</span>.stringify;<br><span class="hljs-built_in">JSON</span>.stringify = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>&#123;<br>    <span class="hljs-comment">//这里可以添加其他逻辑比如 debugger</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;json_stringify params:&quot;</span>,params);<br>    <span class="hljs-keyword">return</span> my_stringify(params);<br>&#125;;<br><br><span class="hljs-keyword">var</span> my_parse = <span class="hljs-built_in">JSON</span>.parse;<br><span class="hljs-built_in">JSON</span>.parse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>&#123;<br>    <span class="hljs-comment">//这里可以添加其他逻辑比如 debugger</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;json_parse params:&quot;</span>,params);<br>    <span class="hljs-keyword">return</span> my_parse(params);<br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="对象属性hook-属性自定义"><a href="#对象属性hook-属性自定义" class="headerlink" title="对象属性hook 属性自定义"></a>对象属性hook 属性自定义</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-meta">    &#x27;use strict&#x27;</span>  <span class="hljs-comment">// 严格模式，检查所有错误</span><br>    <span class="hljs-comment">// document 为要hook的对象 ,属性是cookie</span><br>    <span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>,<span class="hljs-string">&#x27;cookie&#x27;</span>,&#123;<br>        <span class="hljs-comment">// hook set方法也就是赋值的方法，get就是获取的方法</span><br>        set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;<br>            <span class="hljs-comment">// 这样就可以快速给下面这个代码行下断点，从而快速定位设置cookie的代码</span><br>            <span class="hljs-keyword">debugger</span>;  <span class="hljs-comment">// 在此处自动断下</span><br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hook捕获到set-cookie -&gt;&#x27;</span>,val);<br>            <span class="hljs-keyword">return</span> val;<br>        &#125;<br>    &#125;)<br>&#125;)();<br></code></pre></td></tr></table></figure><h1 id="cookies"><a href="#cookies" class="headerlink" title="cookies"></a>cookies</h1><h2 id="Type1-1"><a href="#Type1-1" class="headerlink" title="Type1:"></a>Type1:</h2><p>（不是万能的 有些时候hook不到 自己插入debugger）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> cookie_cache = <span class="hljs-built_in">document</span>.cookie;<br><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>, <span class="hljs-string">&#x27;cookie&#x27;</span>, &#123;<br>    get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Getting cookie&#x27;</span>);<br>        <span class="hljs-keyword">return</span> cookie_cache;<br>    &#125;,<br>    set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Seting cookie&quot;</span>,val);<br>        <span class="hljs-keyword">var</span> cookie = val.split(<span class="hljs-string">&quot;;&quot;</span>)[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">var</span> ncookie = cookie.split(<span class="hljs-string">&quot;=&quot;</span>);<br>        <span class="hljs-keyword">var</span> flag = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">var</span> cache = cookie_cache.split(<span class="hljs-string">&quot;; &quot;</span>);<br>        cache = cache.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)</span>&#123;<br>            <span class="hljs-keyword">if</span> (a.split(<span class="hljs-string">&quot;=&quot;</span>)[<span class="hljs-number">0</span>] === ncookie[<span class="hljs-number">0</span>])&#123;<br>                flag = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span> cookie;<br>            &#125;<br>            <span class="hljs-keyword">return</span> a;<br>        &#125;)<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Type2"><a href="#Type2" class="headerlink" title="Type2:"></a>Type2:</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> code = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> org = <span class="hljs-built_in">document</span>.cookie.__lookupSetter__(<span class="hljs-string">&#x27;cookie&#x27;</span>);<br>    <span class="hljs-built_in">document</span>.__defineSetter__(<span class="hljs-string">&quot;cookie&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">cookie</span>)</span>&#123;<br>        <span class="hljs-keyword">if</span>(cookie.indexOf(<span class="hljs-string">&#x27;TSdc75a61a&#x27;</span>)&gt;-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">debugger</span>;<br>        &#125;<br>        org = cookie;<br>    &#125;);<br>    <span class="hljs-built_in">document</span>.__defineGetter__(<span class="hljs-string">&quot;cookie&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> org;&#125;);<br>&#125;<br><span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.textContent = <span class="hljs-string">&#x27;(&#x27;</span> + code + <span class="hljs-string">&#x27;)()&#x27;</span>;<br>(<span class="hljs-built_in">document</span>.head||<span class="hljs-built_in">document</span>.documentElement).appendChild(script);<br>script.parentNode.removeChild(script);<br><br><span class="hljs-comment">// 当cookie中匹配到了 TSdc75a61a， 则插入断点。</span><br></code></pre></td></tr></table></figure><h1 id="window-attr"><a href="#window-attr" class="headerlink" title="window attr"></a>window attr</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义hook属性</span><br><span class="hljs-keyword">var</span> window_flag_1 = <span class="hljs-string">&quot;_t&quot;</span>;<br><span class="hljs-keyword">var</span> window_flag_2 = <span class="hljs-string">&quot;ccc&quot;</span>;<br><br><span class="hljs-keyword">var</span> key_value_map = &#123;&#125;;<br><span class="hljs-keyword">var</span> window_value = <span class="hljs-built_in">window</span>[window_flag_1];<br><br><span class="hljs-comment">// hook</span><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>, window_flag_1, &#123;<br>    get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Getting&quot;</span>,<span class="hljs-built_in">window</span>,window_flag_1,<span class="hljs-string">&quot;=&quot;</span>,window_value);<br>        <span class="hljs-comment">//debugger</span><br>        <span class="hljs-keyword">return</span> window_value<br>    &#125;,<br>    set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Setting&quot;</span>,<span class="hljs-built_in">window</span>, window_flag_1, <span class="hljs-string">&quot;=&quot;</span>,val);<br>        <span class="hljs-comment">//debugger</span><br>        window_value = val;<br>        key_value_map[<span class="hljs-built_in">window</span>[window_flag_1]] = window_flag_1;<br>        set_obj_attr(<span class="hljs-built_in">window</span>[window_flag_1],window_flag_2);<br>    &#125;,<br><br>&#125;);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">set_obj_attr</span>(<span class="hljs-params">obj,attr</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> obj_attr_value = obj[attr];<br>    <span class="hljs-built_in">Object</span>.defineProperty(obj,attr, &#123;<br>        get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Getting&quot;</span>, key_value_map[obj],attr, <span class="hljs-string">&quot;=&quot;</span>, obj_attr_value);<br>            <span class="hljs-comment">//debugger</span><br>            <span class="hljs-keyword">return</span> obj_attr_value;<br>        &#125;,<br>        set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Setting&quot;</span>, key_value_map[obj], attr, <span class="hljs-string">&quot;=&quot;</span>, val);<br>            <span class="hljs-comment">//debugger</span><br>            obj_attr_value = val;<br>        &#125;,<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="eval-Function"><a href="#eval-Function" class="headerlink" title="eval/Function"></a>eval/Function</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.__cr_eval = <span class="hljs-built_in">window</span>.eval;<br><span class="hljs-keyword">var</span> myeval = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">src</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(src);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;========= eval end ===========&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.__cr_eval;<br>&#125;<br><br><span class="hljs-keyword">var</span> _myeval = myeval.bind(<span class="hljs-literal">null</span>);<br>_myeval.toString = <span class="hljs-built_in">window</span>.__cr_eval.toString;<br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>, <span class="hljs-string">&#x27;eval&#x27;</span>,&#123;<span class="hljs-attr">value</span>: _myeval&#125;);<br><br><span class="hljs-built_in">window</span>._cr_fun = <span class="hljs-built_in">window</span>.Function<br><span class="hljs-keyword">var</span> myfun = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>).join(<span class="hljs-string">&quot;,&quot;</span>), src = <span class="hljs-built_in">arguments</span>[<span class="hljs-built_in">arguments</span>.lenght -<span class="hljs-number">1</span>];<br>    <span class="hljs-built_in">console</span>.log(src);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;======== Function end =============&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>._cr_fun.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)<br>&#125;<br><br>myfun.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>._cr_fun + <span class="hljs-string">&quot;&quot;</span>&#125; <span class="hljs-comment">//小花招，这里防止代码里检测原生函数</span><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>, <span class="hljs-string">&quot;Function&quot;</span>,&#123;<span class="hljs-attr">value</span>: myfun&#125;)<br></code></pre></td></tr></table></figure><h1 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Function</span>.prototype.__defineGetter__(<span class="hljs-string">&#x27;constructor&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;code:&#x27;</span>, ...args);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Function</span>(...args);<br>    &#125;<br>    ;<br>&#125;);<br></code></pre></td></tr></table></figure><h1 id="websocket-hook"><a href="#websocket-hook" class="headerlink" title="websocket hook"></a>websocket hook</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 1、webcoket 一般都是json数据格式传输，那么发生之前需要JSON.stringify  </span><br><span class="hljs-keyword">var</span> my_stringify = <span class="hljs-built_in">JSON</span>.stringify;<br><span class="hljs-built_in">JSON</span>.stringify = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>&#123;<br>    <span class="hljs-comment">//这里可以添加其他逻辑比如 debugger</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;json_stringify params:&quot;</span>,params);<br>    <span class="hljs-keyword">return</span> my_stringify(params);<br>&#125;;<br><br><span class="hljs-keyword">var</span> my_parse = <span class="hljs-built_in">JSON</span>.parse;<br><span class="hljs-built_in">JSON</span>.parse = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">params</span>) </span>&#123;<br>    <span class="hljs-comment">//这里可以添加其他逻辑比如 debugger</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;json_parse params:&quot;</span>,params);<br>    <span class="hljs-keyword">return</span> my_parse(params);<br>&#125;;<br><br><span class="hljs-comment">// 2  webScoket 绑定在windows对象，上，根据浏览器的不同，websokcet名字可能不一样 </span><br><span class="hljs-comment">//chrome window.WebSocket  firfox window.MozWebSocket;</span><br><span class="hljs-built_in">window</span>._WebSocket = <span class="hljs-built_in">window</span>.WebSocket;<br><br><span class="hljs-comment">// hook send</span><br><span class="hljs-built_in">window</span>._WebSocket.prototype.send = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&quot;Hook WebSocket&quot;</span>, data);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.send(data)<br>&#125;<br><br><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">window</span>, <span class="hljs-string">&quot;WebSocket&quot;</span>,&#123;<span class="hljs-attr">value</span>: WebSocket&#125;)<br></code></pre></td></tr></table></figure><h1 id="Hook-正则"><a href="#Hook-正则" class="headerlink" title="Hook 正则"></a>Hook 正则</h1><h2 id="Type1-2"><a href="#Type1-2" class="headerlink" title="Type1"></a>Type1</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> _RegExp = <span class="hljs-built_in">RegExp</span>;<br>    <span class="hljs-built_in">RegExp</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern, modifiers</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Some codes are setting regexp&quot;</span>);<br>        <span class="hljs-keyword">debugger</span>;<br>        <span class="hljs-keyword">if</span> (modifiers) &#123;<br>            <span class="hljs-keyword">return</span> _RegExp(pattern, modifiers);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> _RegExp(pattern);<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">RegExp</span>.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;function setInterval() &#123; [native code] &#125;&quot;</span><br>    &#125;;<br>&#125;)();<br></code></pre></td></tr></table></figure><h2 id="Type2-加在sojson头部过字符串格式化检测"><a href="#Type2-加在sojson头部过字符串格式化检测" class="headerlink" title="Type2: 加在sojson头部过字符串格式化检测"></a>Type2: 加在sojson头部过字符串格式化检测</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">var</span> _RegExp = <span class="hljs-built_in">RegExp</span>;<br>            <span class="hljs-built_in">RegExp</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pattern, modifiers</span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (pattern == <span class="hljs-built_in">decodeURIComponent</span>(<span class="hljs-string">&quot;%5Cw%2B%20*%5C(%5C)%20*%7B%5Cw%2B%20*%5B&#x27;%7C%22%5D.%2B%5B&#x27;%7C%22%5D%3B%3F%20*%7D&quot;</span>) || pattern == <span class="hljs-built_in">decodeURIComponent</span>(<span class="hljs-string">&quot;function%20*%5C(%20*%5C)&quot;</span>)<br>                     || pattern == <span class="hljs-built_in">decodeURIComponent</span>(<span class="hljs-string">&quot;%5C%2B%5C%2B%20*(%3F%3A_0x(%3F%3A%5Ba-f0-9%5D)%7B4%2C6%7D%7C(%3F%3A%5Cb%7C%5Cd)%5Ba-z0-9%5D%7B1%2C4%7D(%3F%3A%5Cb%7C%5Cd))&quot;</span>) || pattern == <span class="hljs-built_in">decodeURIComponent</span>(<span class="hljs-string">&quot;(%5C%5C%5Bx%7Cu%5D(%5Cw)%7B2%2C4%7D)%2B&quot;</span>)) &#123;<br>                    pattern = <span class="hljs-string">&#x27;.*?&#x27;</span>;<br>                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;发现sojson检测特征，已帮您处理。&quot;</span>)<br>                &#125;<br>                <span class="hljs-keyword">if</span> (modifiers) &#123;<br>                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;疑似最后一个检测...已帮您处理。&quot;</span>)<br>                    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;已通过全部检测，请手动处理debugger后尽情调试吧！&quot;</span>)<br>                    <span class="hljs-keyword">return</span> _RegExp(pattern, modifiers);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> _RegExp(pattern);<br>                &#125;<br>            &#125;;<br>            <span class="hljs-built_in">RegExp</span>.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-keyword">return</span> _RegExp.toString();<br>            &#125;;<br>        &#125;)();<br></code></pre></td></tr></table></figure><h1 id="hook-canvas-定位图片生成的地方"><a href="#hook-canvas-定位图片生成的地方" class="headerlink" title="hook canvas (定位图片生成的地方)"></a>hook canvas (定位图片生成的地方)</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">    &#x27;use strict&#x27;</span>;<br>    <span class="hljs-keyword">let</span> create_element = <span class="hljs-built_in">document</span>.createElement.bind(doument);<br><br>    <span class="hljs-built_in">document</span>.createElement = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_element</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;create_element:&quot;</span>,_element);<br>        <span class="hljs-keyword">if</span> (_element === <span class="hljs-string">&quot;canvas&quot;</span>) &#123;<br>            <span class="hljs-keyword">debugger</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> create_element(_element);<br>    &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure><h1 id="setInterval-定时器"><a href="#setInterval-定时器" class="headerlink" title="setInterval 定时器"></a>setInterval 定时器</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            setInterval_ = <span class="hljs-built_in">setInterval</span>;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;原函数已被重命名为setInterval_&quot;</span>)<br>            <span class="hljs-built_in">setInterval</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>            <span class="hljs-built_in">setInterval</span>.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;有函数正在检测setInterval是否被hook&quot;</span>);<br>                <span class="hljs-keyword">return</span> setInterval_.toString();<br>            &#125;;<br>        &#125;)();<br></code></pre></td></tr></table></figure><h1 id="console-log-检测例子-（不让你输出调试）"><a href="#console-log-检测例子-（不让你输出调试）" class="headerlink" title="console.log 检测例子 （不让你输出调试）"></a>console.log 检测例子 （不让你输出调试）</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> oldConsole = [<span class="hljs-string">&quot;debug&quot;</span>, <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-string">&quot;info&quot;</span>, <span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;warn&quot;</span>, <span class="hljs-string">&quot;dir&quot;</span>, <span class="hljs-string">&quot;dirxml&quot;</span>, <span class="hljs-string">&quot;table&quot;</span>, <span class="hljs-string">&quot;trace&quot;</span>, <span class="hljs-string">&quot;group&quot;</span>, <span class="hljs-string">&quot;groupCollapsed&quot;</span>, <span class="hljs-string">&quot;groupEnd&quot;</span>, <span class="hljs-string">&quot;clear&quot;</span>, <span class="hljs-string">&quot;count&quot;</span>, <span class="hljs-string">&quot;countReset&quot;</span>, <span class="hljs-string">&quot;assert&quot;</span>, <span class="hljs-string">&quot;profile&quot;</span>, <span class="hljs-string">&quot;profileEnd&quot;</span>, <span class="hljs-string">&quot;time&quot;</span>, <span class="hljs-string">&quot;timeLog&quot;</span>, <span class="hljs-string">&quot;timeEnd&quot;</span>, <span class="hljs-string">&quot;timeStamp&quot;</span>, <span class="hljs-string">&quot;context&quot;</span>, <span class="hljs-string">&quot;memory&quot;</span>].map(<span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">var</span> old = <span class="hljs-built_in">console</span>[key];<br>            <span class="hljs-built_in">console</span>[key] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>            <span class="hljs-built_in">console</span>[key].toString = old.toString.bind(old)<br>                <span class="hljs-keyword">return</span> old;<br>        &#125;)<br></code></pre></td></tr></table></figure><h1 id="检测函数是否被hook例子"><a href="#检测函数是否被hook例子" class="headerlink" title="检测函数是否被hook例子"></a>检测函数是否被hook例子</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.eval == <span class="hljs-string">&#x27;native code&#x27;</span>)&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;发现eval函数被hook了 开始死循环&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>Hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux-Shell-后台运行脚本</title>
    <link href="/post/141cf4a2/"/>
    <url>/post/141cf4a2/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>前台运行脚本会占住你的控制台，控制台关闭以后，脚本也会跟着停下。后台运行会让你感到舒服/干净  </p><blockquote><p>虽然存在忘了脚本在运行和分不清是什么脚本的可能性  </p></blockquote><h1 id="amp-后台运行脚本"><a href="#amp-后台运行脚本" class="headerlink" title="&amp;后台运行脚本"></a><code>&amp;</code>后台运行脚本</h1><p>直接在运行的脚本后家<code>&amp;</code>即可实现  </p><blockquote><p>例：后台运行<code>test.sh</code>脚本  </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">. test.sh &amp;<br></code></pre></td></tr></table></figure><p>虽然这样已经是后台运行了，但这样做会有一个问题<br>关闭终端连接后，脚本会停止运行  </p><h1 id="nohup不挂断的运行"><a href="#nohup不挂断的运行" class="headerlink" title="nohup不挂断的运行"></a><code>nohup</code>不挂断的运行</h1><blockquote><p>nohup 是 no hang up 的缩写，就是不挂断的意思  </p></blockquote><p>不挂断的运行，指用nohup运行命令可以使命令永久的执行下去。命令可以在你退出帐户/关闭终端之后继续运行相应的进程<br>断开SSH连接/关闭终端 都不会影响他的运行  </p><blockquote><p>例：后台不挂断运行<code>test.sh</code>脚本  </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">. test.sh &amp;<br></code></pre></td></tr></table></figure><p>注意：用这个命令运行的脚本的所有输出都被重定向到一个名为nohup.out的文件中  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署-SSH</title>
    <link href="/post/5ca1c756/"/>
    <url>/post/5ca1c756/</url>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Centos7.2 腾讯云服务器  </li></ul><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>SSH</code>全称是<code>Secure Shell</code>，<code>SSH</code>协议是基于应用层的协议，为远程登录会话和其他网络服务提供安全性的协议。</p><blockquote><p><code>SSH</code>使用最多的是远程登录和传输文件，实现此功能的传统协议都不安全（<code>ftp</code>，<code>telnet</code>等），因为它们使用明文传输数据。而SSH在传输过程中的数据是加密的，安全性更高。</p></blockquote><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>SSH协议传输是基于(非对称加密方法的)[<a href="https://zh.wikipedia.org/zh-cn/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86]">https://zh.wikipedia.org/zh-cn/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86]</a>  </p><h3 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h3><ul><li><p>服务端<br>若远程服务器是新系统，会在<code>/etc/ssh</code>目录下生成一个名为<code>ssh_host_ecdsa_key.pub</code>的公钥，同时生成一个名为<code>ssh_host_ecdsa_key</code>的私钥，这一对就是远程服务器的公钥与私钥<br>之后每次启动sshd服务的时候，系统会自动在此路径下查找公钥  </p></li><li><p>客户端<br>客户端将服务器传来的公钥记录在<code>~/.ssh/known_hosts</code>中，若是已经记录有该服务器公钥，则比对是否一致，一致后就计算客户端自己的公私钥。发送自己的公钥给服务器  </p></li></ul><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>实际上这个过程比上面描述的要复杂很多<br>比如说<code>DH秘钥交换的密钥交换算法</code>就是一种多种加密算法混合的算法    </p><h2 id="认证方式"><a href="#认证方式" class="headerlink" title="认证方式"></a>认证方式</h2><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><ul><li>连接服务器的各类型密码不应低于8位（建议20位）  </li><li>密码字符涵盖类型越多越好。数字、英文大写、小写、特殊字符  </li></ul><p>如果没有什么特殊需求，建议使用密钥  </p><h2 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h2><p>作为密码的更好的替代品存在的东西存在<br>载体是一个文件，认证以后就不用频繁的输入密码了  </p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="SSH配置文件修改"><a href="#SSH配置文件修改" class="headerlink" title="SSH配置文件修改"></a>SSH配置文件修改</h2><p>由于很多操作其实都是编辑<code>SSH</code>的配置文件，这里先给出打开方式  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure><p>在进行完修改以后，重新启动SSH服务以应用设置  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service sshd restart<br></code></pre></td></tr></table></figure><h2 id="SSH禁止使用root用户直接登录"><a href="#SSH禁止使用root用户直接登录" class="headerlink" title="SSH禁止使用root用户直接登录"></a>SSH禁止使用root用户直接登录</h2><p>想要获取root权限？先用普通用户登录再切换用户  </p><blockquote><p>注意，要是没有其它用户又禁用了root用户就会很麻烦  </p></blockquote><ol><li><p>打开SSH配置文件</p></li><li><p>找到对应项并设置为no</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PermitRootLogin no<br></code></pre></td></tr></table></figure><h2 id="修改SSH端口"><a href="#修改SSH端口" class="headerlink" title="修改SSH端口"></a>修改SSH端口</h2><p>如果<code>SSH端口</code>不是22，那就不能直接暴力破解了，需要扫描很多的端口才能发现真的<code>SSH端口</code>，浪费黑客的时间  </p><blockquote><p>注意防火墙的问题，连不上就麻烦了  </p></blockquote></li><li><p>打开SSH配置文件  </p></li><li><p>找到 #Port 22<br>这东西本身就被注释了，找到这个东西只是为了将一类设置写一起  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Port 22</span><br>Port 51369 <span class="hljs-comment"># 设置自定义的端口51369</span><br></code></pre></td></tr></table></figure><h2 id="创建SSH密钥来登录"><a href="#创建SSH密钥来登录" class="headerlink" title="创建SSH密钥来登录"></a>创建SSH密钥来登录</h2><p>虽然理论中说了要双方公钥交换，但实际上只要有一对连接上了，另一个会被自动创建<br>因此有两种方式来创建密钥  </p></li></ol><ul><li>客户端创建密钥，将公钥给服务器  </li><li>服务器创建密钥，将私钥给客户端，自己将公钥注册下来  </li></ul><p>以下方式为第二种  </p><ol><li>SSH设置允许密钥登录  <ol><li>打开SSH配置文件  </li><li>编辑配置  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">RSAAuthentication</span> <span class="hljs-literal">yes</span><br><span class="hljs-string">PubkeyAuthentication</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure></li></ol></li><li>切换到希望创建密钥的用户，创建密钥对  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen<br></code></pre></td></tr></table></figure> 过程中会需要你输入一些东西，要是不知道是什么，可以直接回车不管   <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">Enter file <span class="hljs-keyword">in</span> which to save the key (<span class="hljs-regexp">/home/</span>用户名<span class="hljs-regexp">/.ssh/i</span>d_rsa):  <span class="hljs-comment"># 设置密钥文件保存路径</span><br>Enter passphrase (empty <span class="hljs-keyword">for</span> no passphrase):  <span class="hljs-comment"># 设置密钥锁码</span><br>Enter same passphrase again:  <span class="hljs-comment"># 密钥锁码确认</span><br></code></pre></td></tr></table></figure> 最后会有一些提示  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 你的私钥保存在这里</span><br>Your identification has been saved <span class="hljs-keyword">in</span> <span class="hljs-regexp">/home/m</span>anager<span class="hljs-regexp">/.ssh/i</span>d_rsa.<br><span class="hljs-comment"># 你的公钥保存在这里</span><br>Your public key has been saved <span class="hljs-keyword">in</span> <span class="hljs-regexp">/home/m</span>anager<span class="hljs-regexp">/.ssh/i</span>d_rsa.pub.<br></code></pre></td></tr></table></figure></li><li>服务器公钥注册  <ol><li>来到.ssh目录 <figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<br><span class="hljs-keyword">cd</span> <span class="hljs-string">.ssh</span><br></code></pre></td></tr></table></figure></li><li>注册公钥  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">cat</span> <span class="hljs-selector-tag">id_rsa</span><span class="hljs-selector-class">.pub</span> &gt;&gt; <span class="hljs-selector-tag">authorized_keys</span><br></code></pre></td></tr></table></figure><blockquote><p>有些时候会遇到权限的问题，把权限设置得高一些就可以解决  </p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">600</span> authorized_keys<br></code></pre></td></tr></table></figure></li></ol></li><li>重启SSH以应用设置  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">service sshd restart</span><br></code></pre></td></tr></table></figure></li><li>客户端获取密钥私钥文件<br>使用<a href="/post/8649b4ed/" title="scp命令">scp命令</a>即可，这里是从服务器把私钥下载下来，放到E盘  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.1</span>.<span class="hljs-number">2</span><span class="hljs-symbol">:/home/manager/</span>.ssh/id_rsa <span class="hljs-symbol">E:</span>/ <br></code></pre></td></tr></table></figure></li><li>客户端使用私钥<br>这里以<code>putty</code>为例  <ol><li>将密钥转为<code>putty</code>能使用的类型的密钥文件<br><img src="/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-SSH/convert_key.gif">  </li><li>在登录时应用密钥<br><img src="/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-SSH/use_key.gif">  </li></ol></li></ol><h2 id="禁用密码登录"><a href="#禁用密码登录" class="headerlink" title="禁用密码登录"></a>禁用密码登录</h2><ol><li>打开SSH配置文件  </li><li>修改配置  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">PasswordAuthentication</span> <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>SSH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-abbrlink</title>
    <link href="/post/Infinity/"/>
    <url>/post/Infinity/</url>
    
    <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p><code>Hexo</code>文章链接默认的生成规则是：:year/:month/:day/:title。即按照年、月、日、标题来生成<br>如果文章标题是中文的话，URL链接是也会是中文，但链接不能是中文原文，需要转译，于是就变成了非常非常长的一串<br>如果你需要弄博客内跳转的话，文件名一改，url会跟着改，想要正确跳转又要手动跟着改，非常麻烦  </p><h1 id="Hexo-abbrlink"><a href="#Hexo-abbrlink" class="headerlink" title="Hexo-abbrlink"></a>Hexo-abbrlink</h1><p>为了应对url又长又臭，文件更改又会更改的问题，有人作出了插件让文章生成唯一不变的url的插件<code>Hexo-abbrlink</code><br>Github: <a href="https://github.com/Rozbo/hexo-abbrlink">https://github.com/Rozbo/hexo-abbrlink</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>博客目录下npm安装，如果提示缺少前置，那就把前置装上就行    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-abbrlink <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2><p>打开博客目录的配置文件<code>_config.yml</code>，修改<code>permalink</code>设置(只能在原本的位置进行更改)  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">permalink: posts<span class="hljs-regexp">/:abbrlink/</span><br></code></pre></td></tr></table></figure><p><code>:abbrlink</code>是生成的文章标识<br>你可以像我一样完全只用这个生成后不会变的id来构建路由，也可以根据自己的需要设置路由  </p><blockquote><p>最後的那個<code>/</code>不要刪除<br>web server发送错误的MIME类型，浏览器接收到非HTML的MIME，会默认进行下载</p></blockquote><p>然后在文件最后，添加生成<code>abbrlink</code>的配置  </p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">abbrlink:</span><br>    <span class="hljs-meta"># 算法： crc16(default) and crc32</span><br><span class="hljs-symbol">    alg:</span> crc32<br>    <span class="hljs-meta"># 进制： dec(default) and hex</span><br><span class="hljs-symbol">    rep:</span> hex<br></code></pre></td></tr></table></figure><p>在清理，生成文件后，文章会被添加<code>abbrlink</code>字段作为唯一标识<br><img src="/Hexo-abbrlink/20200927090958942.png"><br>发布后，此字段就会作为<code>url</code>的一部分，使得每一个文章的<code>url</code>不重复的同时很美观  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>硬件-固态硬盘</title>
    <link href="/post/b35a5996/"/>
    <url>/post/b35a5996/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>固态硬盘（SSD）主要包括主控芯片、闪存颗粒和缓存单元三大组件  </p><p>预算&gt;主控&gt;颗粒&gt;无缓存&gt;容量  </p><h2 id="主控"><a href="#主控" class="headerlink" title="主控"></a>主控</h2><p>一款主控芯片的好坏直接决定了固态硬盘的实际体验和使用寿命<br>主要分为两种：原厂和主控厂商  </p><h3 id="主控的工作"><a href="#主控的工作" class="headerlink" title="主控的工作"></a>主控的工作</h3><ul><li><p>同时连接多个闪存单元<br>这意味着能获得更高的吞吐量  </p></li><li><p>损耗均衡<br>平均分配，延长寿命<br><code>SSD</code>闪存单元写入次数有限，如果<code>SSD</code>只往同一个闪存单元理读写东西，那么这个闪存单元很快就会因为写入次数过多而报废<br>主控将东西平均分配到各个闪存单元，通过平均写次数来延长硬盘寿命  </p></li><li><p>GC 垃圾回收<br>把现存数据重新转移到其他闪存位置，并且把一些无用的数据彻底删除的过程<br>可以将块中的没用的数据打上“过期”的标签，在转移数据到其它块的时候，只转移那些没有被打标签的内容。这样能避免无意义写入，延长硬盘寿命    </p><blockquote><p>写入放大<br>当写入新数据时，如果SSD控制器找不到可以写入的page时，会执行GC过程，然后GC机制会将一些block中的有效数据合并写入其他的block中，然后将这些block的无效数据擦出，再将新数据写入到这些block中，而在整个过程中除了要写入用户的数据之外，实际上SSD还写入了一些其他block合并过来的数据，所以这就叫写入放大</p></blockquote></li><li><p>Trim<br>减少写入负担<br>当<code>Windows</code>识别到<code>SSD</code>并确认<code>SSD</code>支持<code>Trim</code>后，在删除数据时，会不向硬盘通知删除指令，只使用<code>Volume Bitmap</code>来记住这里的数据已经删除。<br><code>Volume Bitmap</code>只是一个磁盘快照，其建立速度比直接读写硬盘去标记删除区域要快得多。这一步就已经省下一大笔时间了。<br>写入数据的时候，可以直接根据<code>Volume Bitmap</code>的情况，向快照中已删除的区块写入新的数据，而不用花时间去擦除原本的数据。</p></li><li><p>控温、SMART健康度报告、坏块管理、纠错、断电保护等等  </p></li></ul><h3 id="主控的好坏"><a href="#主控的好坏" class="headerlink" title="主控的好坏"></a>主控的好坏</h3><p>各个主控厂商对主控的设计保密很厉害，实际上你很难评价主控的好坏<br>也许只有等你用久了才感受得到  </p><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><blockquote><p>缓存的标准作用<br>适配速度不同的设备。将经常使用的内容保存在其中，高速设备需要直接从缓存里拿，不必访问低速设备，进而节约在低速设备运行时间  </p></blockquote><h3 id="独立缓存"><a href="#独立缓存" class="headerlink" title="独立缓存"></a>独立缓存</h3><p>对于SSD来说，独立缓存并不是很重要。<br>SSD的反应速度很快，只有0.2毫秒，不比缓存慢。带缓存性能提升也不大，只有在小文件的读写速度上稍有优势。<br>寿命方面来说，SSD并不是看有没有缓存，而是看NAND FLASH的写入次数。打个比方说，带缓存的用10年，不带缓存的用9年10个月这种感觉，影响也很小。<br>主控不同的话，也是SSD是否带缓存的一个因素，有些主控不需要缓存，有的则需要。比如镁光M4的Marvell主控就必须要有缓存的支持才可以工作。<br>所以很多SSD都没有缓存  </p><h2 id="PCIe-与-SATA"><a href="#PCIe-与-SATA" class="headerlink" title="PCIe 与 SATA"></a>PCIe 与 SATA</h2><h3 id="SATA（串行ATA）"><a href="#SATA（串行ATA）" class="headerlink" title="SATA（串行ATA）"></a>SATA（串行ATA）</h3><p>是SSD使用的一种连接接口，用于与系统进行数据通信。它创建于2003年，这意味着它有很多时间将自己巩固为当今最广泛使用的连接类型之一  </p><h3 id="PCIe"><a href="#PCIe" class="headerlink" title="PCIe"></a>PCIe</h3><p>PCIe（Peripheral Component Interconnect Express）<br>可以视为与主板更直接的数据连接。它通常用于显卡等设备，这些设备也需要极快的数据连接  </p><h3 id="SATA-PCIe-对比"><a href="#SATA-PCIe-对比" class="headerlink" title="SATA PCIe 对比"></a>SATA PCIe 对比</h3><p>||理论通道带宽|理论传输速度|<br>|–|–|–|–|<br>|SATA 3.0|6 Gb/s|750 MB/s|<br>|PCIe 3.0|8 Gb/s/通道|985 MB/s/通道||</p><p>PCIe设备可支持1x，4x，8x或16x通道，因此潜在的传输速度可到15.76 GB/s  </p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>可以用常用的性能测试比如<code>fio</code>、<code>IOMeter</code>等工具评估一下，并且需要测试一下SSD使用率达到80%以上时SSD的性能<br>有些SSD针对常用的测试工具<code>fio</code>做了优化，所以使用<code>fio</code>是测试不出真实性能，必须上<code>IOMeter</code>  </p><h2 id="寿命"><a href="#寿命" class="headerlink" title="寿命"></a>寿命</h2><p>简易计算公式<br><img src="/%E7%A1%AC%E4%BB%B6-%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98/20200926011715037.png"></p><p>固态硬盘的寿命，是由闪存类型和写入量决定的。</p><ol><li>一般的MLC固态硬盘，最广泛了，与入量是3000次P/E，也就是累计写满3000次。假设一只128G的固态硬盘，每天平均写入40G（一般的家庭用户不可能做到），那也能使用20年以上。</li><li>TLC的寿命，是MLC的一半或三分之一。也就是上述寿命缩短三倍。</li><li>SLC的寿命，是10000次p/e，是MLC的三倍以上。</li></ol><hr><p>参考：</p><ul><li><a href="https://zhidao.baidu.com/question/524007630.html">对于SSD来说缓存很重要吗？为什么许多SSD都没有缓存？</a>  </li><li><a href="youtube.com/watch?v=qUZtXUP78sw">SSD Controllers as Fast As Possible</a>  </li><li><a href="https://blog.csdn.net/scaleqiao/article/details/50511279">SSD的工作原理、GC和TRIM、写入放大以及性能评测</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>硬件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署-CentOS-Windows-文件传输</title>
    <link href="/post/8649b4ed/"/>
    <url>/post/8649b4ed/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>上传文件总是逃不过的<br>借助第三方平台速度太慢，只能自己寻找协议/工具/代码来实现  </p><h1 id="Window端操作"><a href="#Window端操作" class="headerlink" title="Window端操作"></a>Window端操作</h1><h2 id="SCP命令"><a href="#SCP命令" class="headerlink" title="SCP命令"></a>SCP命令</h2><p><code>scp</code>是<code>secure copy</code>的简写，用于在Linux下进行远程拷贝文件的命令<br><code>scp</code>传输是加密的，速度相对于不加密的传输来说要慢（废话）<br><code>scp</code>还非常不占资源，不会提高多少系统负荷  </p><blockquote><p>在占资源这一点上，<code>rsync</code>就远远不及它了。虽然 <code>rsync</code>比<code>scp</code>会快一点，但当小文件众多的情况下，<code>rsync</code>会导致硬盘<code>I/O</code>非常高，而<code>scp</code>基本不影响系统正常使用。</p></blockquote><p><code>scp</code>是<code>linux</code>系统下基于<code>ssh</code>登陆进行安全的远程文件拷贝命令<br><code>linux</code>的<code>scp</code>命令可以在<code>linux</code>服务器之间复制文件和目录  </p><blockquote><p>注意，在cmd中要使用绝对路径  </p></blockquote><h2 id="SCP上传"><a href="#SCP上传" class="headerlink" title="SCP上传"></a>SCP上传</h2><p>将本地的文件/文件夹上传到目标服务器路径  </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">scp <span class="hljs-comment">[本地文件路径（含文件名）]</span> <span class="hljs-comment">[SSH用户名]</span>@<span class="hljs-comment">[服务器IP]</span>:<span class="hljs-comment">[服务器上文件路径（不含文件名）]</span><br></code></pre></td></tr></table></figure><blockquote><p>案例：<code>a.txt</code>通过<code>root</code>用户的<code>SSH</code>传输到<code>/home/root</code>文件夹中  </p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp a.txt root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.1</span>.<span class="hljs-number">2</span><span class="hljs-symbol">:/home/root</span><br></code></pre></td></tr></table></figure><blockquote><p>在输入以后，会提示你输入root用户的SSH密码。输入正确以后就开始传输  </p></blockquote><h2 id="SCP下载"><a href="#SCP下载" class="headerlink" title="SCP下载"></a>SCP下载</h2><p>将目标服务器文件/文件夹下载到本地  </p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">scp <span class="hljs-comment">[SSH用户名]</span>@<span class="hljs-comment">[服务器IP]</span>:<span class="hljs-comment">[服务器上文件路径（含文件名）]</span> <span class="hljs-comment">[本地文件路径（不含文件名）]</span><br></code></pre></td></tr></table></figure><blockquote><p>案例：通过<code>SSH</code>的 <code>root</code>用户 从服务器<code>/home/root/a.txt</code>下载<code>a.txt</code>到/Documents/下  </p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.1</span>.<span class="hljs-number">2</span><span class="hljs-symbol">:/home/root/a</span>.txt /Documents/ <br></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p><code>SSH</code>默认22端口。如果不是22，就需要你填入一个参数<code>-P</code>  </p><blockquote><p>案例：<code>a.txt</code>通过 11024端口 的<code>SSH</code>的 manager用户 传输到<code>/home/manager</code>文件夹中  </p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp -P <span class="hljs-number">11024</span> a.txt manager<span class="hljs-variable">@192</span>.<span class="hljs-number">168.1</span>.<span class="hljs-number">2</span><span class="hljs-symbol">:/home/manager</span><br></code></pre></td></tr></table></figure><h3 id="文件夹传输"><a href="#文件夹传输" class="headerlink" title="文件夹传输"></a>文件夹传输</h3><p>如果想要以文件夹为单位传输的话，加个<code>-r</code>参数。路径都改为文件夹路径即可  </p><blockquote><p>案例：将本地的<code>Documents</code>文件夹通过<code>root</code>用户<code>SSH</code>上传到<code>/home/root/folder</code> 下  </p></blockquote><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">scp -r /Documents  root<span class="hljs-variable">@192</span>.<span class="hljs-number">168.1</span>.<span class="hljs-number">2</span><span class="hljs-symbol">:/home/root/folder</span>  <br></code></pre></td></tr></table></figure><h3 id="其它参数"><a href="#其它参数" class="headerlink" title="其它参数"></a>其它参数</h3><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>-1</td><td>强制scp命令使用协议ssh1</td></tr><tr><td>-2</td><td>强制scp命令使用协议ssh2</td></tr><tr><td>-4</td><td>强制scp命令只使用IPv4寻址</td></tr><tr><td>-6</td><td>强制scp命令只使用IPv6寻址</td></tr><tr><td>-B</td><td>使用批处理模式（传输过程中不询问传输口令或短语）</td></tr><tr><td>-C</td><td>允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</td></tr><tr><td>-p</td><td>保留原文件的修改时间，访问时间和访问权限。</td></tr><tr><td>-q</td><td>不显示传输进度条。</td></tr><tr><td>-r</td><td>递归复制整个目录。</td></tr><tr><td>-v</td><td>详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</td></tr><tr><td>-c</td><td>cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</td></tr><tr><td>-F</td><td>ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh。</td></tr><tr><td>-i</td><td>identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</td></tr><tr><td>-l</td><td>limit 限定用户所能使用的带宽，以Kbit/s为单位。</td></tr><tr><td>-o</td><td>ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式，</td></tr><tr><td>-P</td><td>port 注意是大写的P, port是指定数据传输用到的端口号</td></tr><tr><td>-S</td><td>program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>CentOS</tag>
      
      <tag>Windows</tag>
      
      <tag>服务器部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blender-使用记录</title>
    <link href="/post/5e31e418/"/>
    <url>/post/5e31e418/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>官网下载：<a href="https://www.blender.org/download/">https://www.blender.org/download/</a><br>清华源下载：<a href="https://mirror.tuna.tsinghua.edu.cn/blender/blender-release/">https://mirror.tuna.tsinghua.edu.cn/blender/blender-release/</a></p><h1 id="个人设置"><a href="#个人设置" class="headerlink" title="个人设置"></a>个人设置</h1><h2 id="模拟maya视图操作"><a href="#模拟maya视图操作" class="headerlink" title="模拟maya视图操作"></a>模拟maya视图操作</h2><p>键位-3D视图<br>旋转视图 Alt+鼠标左键<br>平移视图 Alt+鼠标中间</p><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>Add Curve:Extra Objects<br>Add Mesh:Extra Objects<br>Object:Bool Tool<br>Node:Node Wrangler<br>Mesh:Edit Mesh Tools<br>Interface:Modifier Tools<br>Interface:Copy Attributes Menu</p><h1 id="建模方法"><a href="#建模方法" class="headerlink" title="建模方法"></a>建模方法</h1><p>此处抽象的介绍一些建模方法大致效果，具体某个功能会有更多的可选细节  </p><h2 id="挤出"><a href="#挤出" class="headerlink" title="挤出"></a>挤出</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/jichu.gif">  </p><h2 id="环切"><a href="#环切" class="headerlink" title="环切"></a>环切</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/huanqie.gif">  </p><h2 id="倒角"><a href="#倒角" class="headerlink" title="倒角"></a>倒角</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/daojiao.gif">  </p><h2 id="内插面"><a href="#内插面" class="headerlink" title="内插面"></a>内插面</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/neichamian.gif">  </p><h2 id="切刀"><a href="#切刀" class="headerlink" title="切刀"></a>切刀</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/qiedao.gif">  </p><h2 id="切分"><a href="#切分" class="headerlink" title="切分"></a>切分</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/qiefen.gif">  </p><h2 id="旋绕"><a href="#旋绕" class="headerlink" title="旋绕"></a>旋绕</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/xuanrao.gif">  </p><h2 id="旋绕复制"><a href="#旋绕复制" class="headerlink" title="旋绕复制"></a>旋绕复制</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/xuanraofuzhi.gif">  </p><h2 id="光滑"><a href="#光滑" class="headerlink" title="光滑"></a>光滑</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/guanghua.gif">  </p><h2 id="随机"><a href="#随机" class="headerlink" title="随机"></a>随机</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/suiji.gif">  </p><h2 id="滑动边线"><a href="#滑动边线" class="headerlink" title="滑动边线"></a>滑动边线</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/huadongbianxian.gif">  </p><h2 id="法线缩放"><a href="#法线缩放" class="headerlink" title="法线缩放"></a>法线缩放</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/faxiangsuofang.gif">  </p><h2 id="推拉"><a href="#推拉" class="headerlink" title="推拉"></a>推拉</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/tuila.gif">  </p><h2 id="切变"><a href="#切变" class="headerlink" title="切变"></a>切变</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/qiebian.gif">  </p><h2 id="球型化"><a href="#球型化" class="headerlink" title="球型化"></a>球型化</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/qiouxinghua.gif">  </p><h2 id="断离区域"><a href="#断离区域" class="headerlink" title="断离区域"></a>断离区域</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/duanli.gif">   </p><h2 id="断离边线"><a href="#断离边线" class="headerlink" title="断离边线"></a>断离边线</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/duanli2.gif">   </p><h2 id="融并"><a href="#融并" class="headerlink" title="融并"></a>融并</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/rongbing.gif">   </p><h2 id="桥接循环边"><a href="#桥接循环边" class="headerlink" title="桥接循环边"></a>桥接循环边</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/qiaojiexunhuanbian.gif"><br><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/qiaojiexunhuanbian2.gif">   </p><h2 id="实体化-solidify-Faces"><a href="#实体化-solidify-Faces" class="headerlink" title="实体化 solidify Faces"></a>实体化 solidify Faces</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/shitihua.gif">   </p><h2 id="线框"><a href="#线框" class="headerlink" title="线框"></a>线框</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/xiankuang.gif">   </p><h2 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/tianchong.gif">   </p><h2 id="面三角化"><a href="#面三角化" class="headerlink" title="面三角化"></a>面三角化</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/sanjiaohua.gif">   </p><h2 id="三角面-gt-四边面"><a href="#三角面-gt-四边面" class="headerlink" title="三角面-&gt;四边面"></a>三角面-&gt;四边面</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/sanjiao_sibian.gif">   </p><h2 id="交集（切割）"><a href="#交集（切割）" class="headerlink" title="交集（切割）"></a>交集（切割）</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/jiaojiqiege.gif">   </p><h2 id="交集（布尔）"><a href="#交集（布尔）" class="headerlink" title="交集（布尔）"></a>交集（布尔）</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/jiaoji_bool.gif">   </p><h1 id="物体管理"><a href="#物体管理" class="headerlink" title="物体管理"></a>物体管理</h1><h2 id="设置父级"><a href="#设置父级" class="headerlink" title="设置父级"></a>设置父级</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/shezhifuji.gif"><br>父级移动旋转也会作用于子级  </p><h2 id="合并物体"><a href="#合并物体" class="headerlink" title="合并物体"></a>合并物体</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/hebingwuti.gif">  </p><h1 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h1><h2 id="间接光照明"><a href="#间接光照明" class="headerlink" title="间接光照明"></a>间接光照明</h2><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/20210204085500410.png"><br>每当你处理好材质以后，重新烘焙用  </p><h2 id="材质四大基本属性"><a href="#材质四大基本属性" class="headerlink" title="材质四大基本属性"></a>材质四大基本属性</h2><h3 id="漫射"><a href="#漫射" class="headerlink" title="漫射"></a>漫射</h3><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/20210204091150649.png"><br>光打到物体表面时均匀散开的效果，粗糙表面的效果<br>典型例子：毛巾、石膏像    </p><h3 id="折射"><a href="#折射" class="headerlink" title="折射"></a>折射</h3><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/20210204091443984.png"><br>光打到物体表面时反射的效果<br>典型例子：金属表面、镜子    </p><h3 id="透射"><a href="#透射" class="headerlink" title="透射"></a>透射</h3><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/20210204091810068.png"><br>光打到物体时穿过去的效果<br>典型例子：玻璃  </p><p>折射率会影响表现效果<br>折射率属于物理范畴，可以在网上查到一些常见物体的折射率，以达到真实效果  </p><h3 id="发光"><a href="#发光" class="headerlink" title="发光"></a>发光</h3><p><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/20210204092244485.png"><br>物体自身发光  </p><h2 id="材质节点编辑器"><a href="#材质节点编辑器" class="headerlink" title="材质节点编辑器"></a>材质节点编辑器</h2><h3 id="前置准备"><a href="#前置准备" class="headerlink" title="前置准备"></a>前置准备</h3><ul><li><p>启用插件<br><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/20210204094344803.png"><br>Node:Node Wrangler  </p></li><li><p>设置一个着色器编辑器面板<br><img src="/Blender-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/20210204094513498.png">  </p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Blender</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pymongo-Python-MongoDB</title>
    <link href="/post/940c0ef1/"/>
    <url>/post/940c0ef1/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>PyMongo是MongoDB数据库的python模块  </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> pymongo<br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">from</span> pymongo import MongoClient<br><span class="hljs-keyword">client</span> = MongoClient(<span class="hljs-string">&quot;mongodb://mongodb0.example.net:27019&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>MongoClient(‘mongodb://用户名:用户密码@服务IP:服务端口/‘)</p></blockquote><h2 id="访问数据库-Database"><a href="#访问数据库-Database" class="headerlink" title="访问数据库 Database"></a>访问数据库 Database</h2><p>你可以使用属性访问的方式，赋值一个数据库（例如名字为primer）给本地变量db</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">db</span> = client.primer<br></code></pre></td></tr></table></figure><p>你也可以使用字典形式访问一个数据库</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">db</span> = client[<span class="hljs-string">&#x27;primer&#x27;</span>]<br></code></pre></td></tr></table></figure><blockquote><p>如果数据库不存在，那么会自动创建  </p></blockquote><h2 id="访问集合-Collection"><a href="#访问集合-Collection" class="headerlink" title="访问集合 Collection"></a>访问集合 Collection</h2><p>访问方式与访问database类似  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">coll</span> = db.dataset<br><span class="hljs-attr">coll</span> = db[<span class="hljs-string">&#x27;dataset&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="访问文档-Document"><a href="#访问文档-Document" class="headerlink" title="访问文档 Document"></a>访问文档 Document</h2><h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><blockquote><p>如果你所插入的集合在<code>MongoDB</code>中不存在，<code>MongoDB</code>将为你自动创建一个集合  </p></blockquote><h3 id="insert-one"><a href="#insert-one" class="headerlink" title="insert_one()"></a>insert_one()</h3><p>插入一条数据  </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs makefile">con = MyMongo.get_mongo_connect()<br>mydb = con[<span class="hljs-string">&quot;temp&quot;</span>]<br>mycol = mydb[<span class="hljs-string">&quot;cx_sxb_school&quot;</span>]<br>mydict = &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;EvilRecluse&quot;</span>, <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://evilrecluse.top/&quot;</span> &#125;<br>x = mycol.insert_one(mydict) <br>print(result.inserted_id)<br></code></pre></td></tr></table></figure><p>操作会返回了一个<code>InsertOneResult</code>对象，它包括了<code>insert_id</code>属性表示被插入的文档的<code>_id</code>  </p><blockquote><p>如果你传递给<code>insert_one()</code>方法的参数不包含<code>_id</code>字段，<code>MongoClient</code>将自动添加这个字段并且生成一个<code>ObjectId</code>设置为这个字段的值。</p></blockquote><h3 id="insert-many"><a href="#insert-many" class="headerlink" title="insert_many()"></a>insert_many()</h3><p>插入多条数据  </p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile">myclient = pymongo.MongoClient(<span class="hljs-string">&quot;mongodb://localhost:27017/&quot;</span>)<br>mydb = myclient[<span class="hljs-string">&quot;runoobdb&quot;</span>][<span class="hljs-string">&quot;sites&quot;</span>]<br>mylist = [<br>  &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;知乎&quot;</span>, <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://www.zhihu.com&quot;</span> &#125;,<br>  &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Github&quot;</span>, <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://www.github.com&quot;</span> &#125;<br>]<br> <br>x = mycol.insert_many(mylist)<br>print(x.inserted_ids)<br></code></pre></td></tr></table></figure><h1 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h1><ul><li><p>find_one()<br>查询得到一个结果，通常用于看看搜索结果的样式  </p><blockquote><p>似乎并不能传进去什么参数，似乎就真的只能用来看看样式  </p></blockquote></li><li><p>find()<br>查询可以返回在集合中的所有数据或者只返回符合筛选条件<br>方法返回一个查询结果的游标，这是一个产生文档的迭代对象<br>如果不传入任何参数，则返回所有结果(如果数量庞大，当心内存炸裂)    </p><blockquote><p>查询type为1的记录，只返回它们的name</p>  <figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">_col_spider.<span class="hljs-builtin-name">find</span>(&#123;<span class="hljs-string">&#x27;type&#x27;</span>: 1&#125;, &#123;<span class="hljs-string">&#x27;_id&#x27;</span>: 0, <span class="hljs-string">&#x27;name&#x27;</span>:1&#125;)<br></code></pre></td></tr></table></figure><ul><li>参数1 dict<br>筛选条件，指定列名与指定s值，这里是指定 type为1  </li><li>参数2 dict<br>返回内容项，指定返回什么数据，值为1则返回，值为0则不返回<br>如果你只指定了0，那么剩余的都会被指定为1，反之亦然  </li></ul></blockquote><p>  需要注意的是，如果你不指定不返回’_id’，那么会默认返回这个项<br>  你可以使用比较运算符之类的操作，具体见<a href="/post/8ead567e/" title="比较逻辑">比较逻辑</a>  </p></li></ul><h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><h4 id="根据-id查询"><a href="#根据-id查询" class="headerlink" title="根据_id查询"></a>根据_id查询</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> bson.objectid <span class="hljs-keyword">import</span> ObjectId<br><br>articles.find_one(&#123;‘_id’:ObjectId(‘50f0d76347f4ec148890ef1e’)&#125;)<br></code></pre></td></tr></table></figure><h4 id="结果排序"><a href="#结果排序" class="headerlink" title="结果排序"></a>结果排序</h4><ul><li><p>sort() </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">database</span><span class="hljs-selector-class">.collect</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.sort</span>(<span class="hljs-selector-tag">key</span>, <span class="hljs-selector-tag">ind</span>)<br></code></pre></td></tr></table></figure><ul><li>key<br>用来排序的键  </li><li>ind<br>排序顺序，可以填入1或-1</li></ul><p>可以填入多个参照  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">database</span>.collect.find().sort([(key<span class="hljs-number">1</span>, ind<span class="hljs-number">1</span>), (key<span class="hljs-number">2</span>, ind<span class="hljs-number">2</span>)])<br></code></pre></td></tr></table></figure><h4 id="比较查询"><a href="#比较查询" class="headerlink" title="比较查询"></a>比较查询</h4></li></ul><table><thead><tr><th>&lt;</th><th>&lt;=</th><th>&gt;</th><th>&gt;=</th><th>!=</th></tr></thead><tbody><tr><td>$lt</td><td>$lte</td><td>$gt</td><td>$gte</td><td>$ne</td></tr></tbody></table><blockquote><p>如果你希望应对数据库中不存在的null，你可以在python中填入None来与之对应<br>案例：字段非空查询</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">col.<span class="hljs-builtin-name">find</span>(&#123;<span class="hljs-string">&quot;字段名&quot;</span>:&#123;<span class="hljs-string">&quot;<span class="hljs-variable">$ne</span>&quot;</span>:None&#125;&#125;,&#123;&#125;)<br></code></pre></td></tr></table></figure><h2 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h2><p>将某个数据记录的某系字段进行更改  </p><ul><li>update_one()<br>修改匹配的第一条记录<br>第一个参数为查询的条件，第二个参数为要修改的字段    <blockquote><p>案例：将name为DIO的记录的power项改为stander  </p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">mycol.update_one(<br>    &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;DIO&quot;</span> &#125;, &#123; <span class="hljs-string">&quot;$set&quot;</span>: &#123;<span class="hljs-symbol">&#x27;power</span><span class="hljs-string">&quot;:&quot;</span>stander<span class="hljs-string">&quot; &#125; &#125;)</span><br></code></pre></td></tr></table></figure></li><li>update_many()<br>修改匹配的所有记录<br>参数与<code>update_one</code>是一样的  <blockquote><p>案例：修改所有name是JO开头的power项值为1000000  </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mycol.update_many(&#123;<span class="hljs-string">&quot;name&quot;</span>: &#123; <span class="hljs-string">&quot;<span class="hljs-variable">$regex</span>&quot;</span>: <span class="hljs-string">&quot;^JO&quot;</span> &#125; &#125;, &#123; <span class="hljs-string">&quot;<span class="hljs-variable">$set</span>&quot;</span>: &#123; <span class="hljs-string">&quot;power&quot;</span>: <span class="hljs-string">&quot;1000000&quot;</span> &#125; &#125;)<br></code></pre></td></tr></table></figure><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2>将旧的文档丢弃，传入一个新的文档替代原本的文档  </li><li>update()<br>替代文档对应原来的文档可以有不同的字段<br>替代文档可以忽略_id字段因为它是不变的。(如果你硬是要填入那它必须和原文档的值相同)  <blockquote></blockquote><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-literal">result</span> = db.restaurants.replace_one(<br>    &#123;<span class="hljs-string">&quot;_id&quot;</span>: <span class="hljs-string">&quot;5f60b67d7c68de24d1745024&quot;</span>&#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;DIO&quot;</span>,<br>        <span class="hljs-string">&quot;power&quot;</span>: <span class="hljs-string">&quot;The World&quot;</span><br>    &#125;<br>)<br></code></pre></td></tr></table></figure></li></ul><h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul><li>delete_one()<br>删除第一个匹配的项  <blockquote><p>案例：删除找寻出来第一个name为Jax的记录  </p></blockquote><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">mycol.delete<span class="hljs-constructor">_one(&#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;Jax&quot;</span> &#125;)</span><br></code></pre></td></tr></table></figure></li><li>delete_many()<br>删除多个文档<br>如果不传入参数，则删除集合中的所有文档  <blockquote><p>案例：删除所有name以F开头的记录  </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mycol.delete_many(&#123; <span class="hljs-string">&quot;name&quot;</span>: &#123;<span class="hljs-string">&quot;<span class="hljs-variable">$regex</span>&quot;</span>: <span class="hljs-string">&quot;^F&quot;</span>&#125; &#125;)<br></code></pre></td></tr></table></figure><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3></li><li>drop()<br>删除一个集合  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">mycol</span><span class="hljs-selector-class">.drop</span>()<br></code></pre></td></tr></table></figure><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2></li><li>aggregate  <blockquote><p>案例：<br>使用$group操作符去利用一个指定的键进行分组。在$group操作中，指定需要分组的字段为_id。$group通过字段路径访问字段，该字段需要有一个美元符号$作为前缀。$group操作可以使用累加器对本次分组进行计算。下面的例子将使用borough字段对restaurants集合进行操作，并且使用$sum累加器进行文档的统计计算。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">cursor = db.restaurants.aggregate(<br>    [<br>        &#123;<span class="hljs-string">&quot;<span class="hljs-variable">$group</span>&quot;</span>: &#123;<span class="hljs-string">&quot;_id&quot;</span>: <span class="hljs-string">&quot;<span class="hljs-variable">$borough</span>&quot;</span>, <span class="hljs-string">&quot;count&quot;</span>: &#123;<span class="hljs-string">&quot;<span class="hljs-variable">$sum</span>&quot;</span>: 1&#125;&#125;&#125;<br>    ]<br>)<br></code></pre></td></tr></table></figure><h1 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h1><h2 id="保存較大的二進制文件"><a href="#保存較大的二進制文件" class="headerlink" title="保存較大的二進制文件"></a>保存較大的二進制文件</h2>将图片、文档等存入<code>mogodb</code>中，需要用到两个模块，pymongo和gridfs<br>在存入过程中必须将文件转换为二进制的格式才能存入，存入<code>mongoDB</code>中会生成两个文件 <strong>xxx.chunk</strong> 和 <strong>xxx.files</strong>  </li></ul><p><code>GridFS</code>是一种将大型文件存储在 <code>MongoDB</code> 的文件规范：数据库支持以<code>BSON</code>格式保存二进制对象<br>但是<code>MongoDB</code>中 <code>BSON</code>对象 最大不能超过 4MB  </p><p><code>GridFS</code> 规范提供了一种透明的机制，可以将一个大文件分割成为多个较小的文档  </p><p>为实现这点，该规范指定了一个将文件分块的标准<br>每个文件都将在文件集合对象中保存一个元数据对象，一个或多个块对象可被组合保存在一个块集合中  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pymongo<br><span class="hljs-keyword">import</span> gridfs<br><span class="hljs-keyword">from</span> bson <span class="hljs-keyword">import</span> ObjectId<br><br>client = pymongo.MongoClient(<span class="hljs-string">&#x27;localhost&#x27;</span>, connect=<span class="hljs-literal">False</span>)<br>db = client[<span class="hljs-string">&#x27;demo&#x27;</span>]<br><br><span class="hljs-comment"># 存储到mongodb</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_file_to_mongo</span>(<span class="hljs-params">content</span>):</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(content, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        data = f.read()<br>    fs = gridfs.GridFS(db, <span class="hljs-string">&#x27;img&#x27;</span>)<br>    <span class="hljs-keyword">return</span> fs.put(data)<br><br><span class="hljs-comment"># 从mongodb取出文件</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_file_from_mongo</span>(<span class="hljs-params"><span class="hljs-built_in">id</span></span>):</span><br>    fs = gridfs.GridFS(db, <span class="hljs-string">&#x27;img&#x27;</span>)<br>    gf = fs.get(ObjectId(<span class="hljs-built_in">id</span>))<br>    content = gf.read()<br>    <span class="hljs-comment"># 将文件写入硬盘</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.jpg&#x27;</span>, <span class="hljs-string">&#x27;wb&#x27;</span> ) <span class="hljs-keyword">as</span> f:<br>        f.write(content)<br><br><span class="hljs-built_in">id</span> = save_file_to_mongo(<span class="hljs-string">&#x27;test2.jpg&#x27;</span>)<br>write_to_disk(get_file_from_mongo(<span class="hljs-built_in">id</span>))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>MongoDB</tag>
      
      <tag>Pymongo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-基础-Shell</title>
    <link href="/post/f1278502/"/>
    <url>/post/f1278502/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>Scrapy``shell</code> 是一个快速debug交互<code>shell</code>，一般被用于做数据抽取代码的测试工作，它得到的结果会和你在Python中跑出来的一样  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="命令行启动"><a href="#命令行启动" class="headerlink" title="命令行启动"></a>命令行启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scrapy shell <span class="hljs-string">&quot;url&quot;</span><br></code></pre></td></tr></table></figure><p>这是最基本的启动方式  </p><blockquote><p>注意:双引号不要去除，也不要用单引号来替代</p></blockquote><p>你也以用<code>shell</code>来加载本地文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scrapy shell /path/file.html<br></code></pre></td></tr></table></figure><blockquote><ul><li>如果使用相对路径，使用./或../开头  </li><li><code>scrapy shell index.html</code>并不会工作<blockquote><p><code>scrapy shell index.html</code>并不会工作原因<br>这并不是一个bug，<code>shell</code>会将<code>index.html</code>当成一个域名来处理，将它丢给DNS来解析，结果自然是没有正确的解析的  </p></blockquote></li></ul></blockquote><p>你也可以设置请求头来访问  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scrapy shell -s USER_AGENT=<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0&quot;</span> <span class="hljs-string">&quot;https://www.jianshu.com/recommendations/users?page=1&quot;</span><br></code></pre></td></tr></table></figure><h2 id="代码启动"><a href="#代码启动" class="headerlink" title="代码启动"></a>代码启动</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">inspect_response(response, self)<br></code></pre></td></tr></table></figure><p><code>response</code>参数是<code>parse</code>方法中的参数，<code>self</code>是<code>Spider</code>类的参数<br>在适当的地方启用shell能达到很好的目的（比如说使用<code>catch.....except</code>捕获错误以后，看看为什么解析错误报错之类）  </p><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><h2 id="捷径"><a href="#捷径" class="headerlink" title="捷径"></a>捷径</h2><p><img src="/Scrapy-%E5%9F%BA%E7%A1%80-Shell/20200916075633932.png"><br>在你打开<code>shell</code>之后，会显示一些捷径提示，你可以在<code>shell</code>中使用这些捷径来快速做事  </p><h2 id="可用的Scrapy对象"><a href="#可用的Scrapy对象" class="headerlink" title="可用的Scrapy对象"></a>可用的Scrapy对象</h2><p>Shell中有一些自动创建的对象  </p><ul><li><p><code>crawler</code> - 当前<code>crawler</code>对象  </p></li><li><p><code>spider</code> - 当前url的spider对象  </p></li><li><p><code>request</code> - 最后请求的页面对象的<code>Request</code>对象. 你可以使用<code>replace()</code>来更改这个对象.你也可以用<code>fetch</code>捷径来接收一个新的<code>request</code></p></li><li><p><code>response</code> - 装则响应的<code>Response</code>对象  </p></li><li><p><code>settings</code> - Scrapy设置</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB</title>
    <link href="/post/8ead567e/"/>
    <url>/post/8ead567e/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>MongoDB</code> 是一个由<code>C++</code>编的 写基于分布式文件存储的数据库。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案<br><code>MongoDB</code> 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的  </p><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><p><code>MongoDB</code> 将数据存储为一个文档，数据结构由键值对组成<br><code>MongoDB</code> 文档类似于 <code>JSON</code> 对象。字段值可以包含其他文档，数组及文档数组  </p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><code>MongoDB</code> 是一个面向文档存储的数据库，操作起来比较简单和容易  </li><li>MongoDB记录中设置任何属性的索引来实现更快的排序  </li><li>可以通过本地或者网络创建数据镜像，这使得MongoDB有更强的扩展性  </li><li>如果负载的增加 ，它可以分布在计算机网络中的其他节点上这就是所谓的分片  </li><li>Mongo支持丰富的查询表达式。查询指令使用JSON形式的标记，可轻易查询文档中内嵌的对象及数组  </li><li>使用update()命令可以实现替换完成的文档（数据）或者一些指定的数据字段  </li><li>Map和Reduce。Map函数调用emit(key,value)遍历集合中所有的记录，将key与value传给Reduce函数进行处理  </li><li>Map函数和Reduce函数是使用Javascript编写的，并可以通过db.runCommand或mapreduce命令来执行MapReduce操作  </li><li>GridFS是MongoDB中的一个内置功能，可以用于存放大量小文件  </li><li>MongoDB允许在服务端执行脚本，可以用Javascript编写某个函数，直接在服务端执行，也可以把函数的定义存储在服务端，下次直接调用  </li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>官网：<a href="https://www.mongodb.com/">https://www.mongodb.com/</a>  </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><h3 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull mongo</span><br></code></pre></td></tr></table></figure><p>如果想要安装非最新版，可以查询<a href="https://hub.docker.com/_/mongo?tab=tags&page=1">Docker镜像信息</a>信息<br>或者使用<code>docker search mongo</code>来查看可用版本    </p><p>在拉取完毕后，可以使用<code>docker images</code>来查看镜像信息</p><h3 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -itd --name mongo -p <span class="hljs-number">27018</span>:<span class="hljs-number">27017</span> mongo --auth<br></code></pre></td></tr></table></figure><p>參數説明：  </p><ul><li>-p 27018:27017<br>映射容器服务的<code>27017</code>端口到宿主机的<code>27018</code>端口。外部可以直接通过<code>ip:27018</code> 访问到<code>mongo</code>的服务</li><li>–auth<br>需要密码才能访问容器服务  </li><li>-itd<br>实际上是<code>-i</code> <code>-t</code> <code>-d</code>的简写  <ul><li><code>-i</code> 以交互模式运行容器，通常与 <code>-t</code> 同时使用  </li><li><code>-t</code>    为容器重新分配一个伪输入终端，通常与 <code>-i</code> 同时使用  </li><li><code>-d</code>    后台运行容器，并返回容器ID  </li></ul></li></ul><p>可以通过<code>docker ps</code>命令查看容器的运行信息  </p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="进入容器控制台"><a href="#进入容器控制台" class="headerlink" title="进入容器控制台"></a>进入容器控制台</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf">docker <span class="hljs-built_in">exec</span> -it mongo mongo <span class="hljs-built_in">admin</span><br></code></pre></td></tr></table></figure><h4 id="创建一个超级账户"><a href="#创建一个超级账户" class="headerlink" title="创建一个超级账户"></a>创建一个超级账户</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.createUser</span>(&#123; <span class="hljs-attribute">user</span>:<span class="hljs-string">&#x27;用户名&#x27;</span>,<span class="hljs-attribute">pwd</span>:<span class="hljs-string">&#x27;密码&#x27;</span>,<span class="hljs-attribute">roles</span>:[ &#123; <span class="hljs-attribute">role</span>:<span class="hljs-string">&#x27;root&#x27;</span>, <span class="hljs-attribute">db</span>: <span class="hljs-string">&#x27;admin&#x27;</span>&#125;]&#125;);<br></code></pre></td></tr></table></figure><p>在创建完用户以后尝试使用新用户进行连接  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.auth</span>(<span class="hljs-string">&#x27;用户名&#x27;</span>, <span class="hljs-string">&#x27;密码&#x27;</span>)<br></code></pre></td></tr></table></figure><p>如果正确可行的话，会返回1，这也意味着账户切换成功  </p><h1 id="MongoDB名词概念"><a href="#MongoDB名词概念" class="headerlink" title="MongoDB名词概念"></a>MongoDB名词概念</h1><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th></tr></thead><tbody><tr><td>database 数据库</td><td>database 数据库</td></tr><tr><td>table     数据库表</td><td>collection 集合</td></tr><tr><td>row     数据记录行</td><td>document 文档</td></tr><tr><td>column     数据字段</td><td>field    域</td></tr><tr><td>index   索引</td><td>index 索引</td></tr><tr><td>table joins表连接</td><td>不支持</td></tr><tr><td>primary key 主键</td><td>primary key     MongoDB自动将_id字段设置为主键</td></tr></tbody></table><p><img src="/MongoDB/20200911074758467.png">  </p><h1 id="数据库-database"><a href="#数据库-database" class="headerlink" title="数据库 database"></a>数据库 database</h1><p>一个<code>mongodb</code>中可以建立多个数据库<br><code>MongoDB</code>的默认数据库为”db”，该数据库存储在data目录中<br><code>MongoDB</code>的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也放置在不同的文件中  </p><h2 id="数据库命名"><a href="#数据库命名" class="headerlink" title="数据库命名"></a>数据库命名</h2><p>数据库名为utf-8字符串,符合以下标准：  </p><ul><li>非空  </li><li>不含（空格)、.、$、/、\和\0 (空字符)  </li><li>字母全部小写  </li><li>小于64字节  </li></ul><h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><table><thead><tr><th>命令</th><th>信息</th></tr></thead><tbody><tr><td><code>show dbs</code></td><td>查询所有含有文档的数据库信息</td></tr><tr><td><code>db</code></td><td>显示当前数据库信息</td></tr><tr><td><code>use 数据库名</code></td><td>连接到指定数据库</br>如果数据库不存在则创建数据库</td></tr><tr><td><code>db.dropDatabase()</code></td><td>删除当前数据库</td></tr></tbody></table><h2 id="保留的数据库"><a href="#保留的数据库" class="headerlink" title="保留的数据库"></a>保留的数据库</h2><p>有一些数据库名是保留的，可以直接访问这些有特殊作用的数据库。</p><table><thead><tr><th>保留数据库名</th><th>信息</th></tr></thead><tbody><tr><td>admin</td><td>从权限的角度来看，这是”root”数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器</td></tr><tr><td>local</td><td>这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合</td></tr><tr><td>config</td><td>当Mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息</td></tr></tbody></table><h1 id="集合-Collection"><a href="#集合-Collection" class="headerlink" title="集合 Collection"></a>集合 Collection</h1><h2 id="常用操作-1"><a href="#常用操作-1" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">db.create<span class="hljs-constructor">Collection(<span class="hljs-params">name</span>, <span class="hljs-params">options</span>)</span><br></code></pre></td></tr></table></figure><ul><li><p>name：集合名</p></li><li><p>option：可选参数</p><ul><li><p>capped（bool)<br> 如果为 true，则创建固定集合。为 true 时，必须指定 size 参数  </p><blockquote><p>固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档  </p></blockquote></li><li><p>size (int)<br> 为固定集合指定一个最大值，即字节数<br> 如果 capped 为 true，也需要指定该字段  </p></li><li><p>max (int)<br> 指定固定集合中包含文档的最大数量  </p></li></ul></li></ul><blockquote><p>案例: 创建集合  </p></blockquote><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">use</span> <span class="hljs-keyword">test</span><br>&gt;&gt;&gt;switched to <span class="hljs-keyword">db</span> <span class="hljs-keyword">test</span><br><span class="hljs-keyword">db</span>.createCollection(<span class="hljs-string">&quot;runoob&quot;</span>)<br>&gt;&gt;&gt;&#123; <span class="hljs-string">&quot;ok&quot;</span> : 1 &#125;<br></code></pre></td></tr></table></figure><h3 id="查看集合"><a href="#查看集合" class="headerlink" title="查看集合"></a>查看集合</h3><p>命令有两个，随便一个都可以  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">show</span> collections<br><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span><br></code></pre></td></tr></table></figure><h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.drop</span>()<br></code></pre></td></tr></table></figure><blockquote><p>案例: 删除集合  </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">use mydb<br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;switched to db mydb</span><br><br>show collections<br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;mycol</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;mycol2</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;system.indexes</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;runoob</span><br><br>show collections<br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;mycol</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;system.indexes</span><br><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt;runoob</span><br></code></pre></td></tr></table></figure><h1 id="文档-Document"><a href="#文档-Document" class="headerlink" title="文档 Document"></a>文档 Document</h1><p>文档的数据结构和 JSON 基本一样<br>所有存储在集合中的数据都是 <code>BSON</code> 格式<br><code>BSON</code> 是一种类似 JSON 的二进制形式的存储格式，是 <code>Binary JSON</code> 的简称  </p><ul><li>文档不需要设置相同的字段，相同的字段不需要相同的数据类型   </li><li>文档中的键/值对是有序的    </li><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)  </li><li>区分类型和大小写  </li><li>文档不能有重复的键  </li><li>文档的键是字符串。除了少数例外情况，键可以使用任意<code>UTF-8</code>字符  </li></ul><h2 id="文档键命名规范"><a href="#文档键命名规范" class="headerlink" title="文档键命名规范"></a>文档键命名规范</h2><ul><li>键不能含有\0 (空字符)。这个字符用来表示键的结尾  </li><li>用<code>.</code>分层  </li><li>$有特别的意义，只有在特定环境下才能使用  </li><li>以下划线<code>_</code>开头的键是保留的(不是严格要求的)  </li></ul><h2 id="常用操作-2"><a href="#常用操作-2" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="db-collection-insertOne"><a href="#db-collection-insertOne" class="headerlink" title="db.collection.insertOne"></a>db.collection.insertOne</h4><p>作用：如果主键存在则更新数据，如果不存在就插入数据  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.insertOne</span>(<br>   &lt;<span class="hljs-selector-tag">document</span>&gt;,<br>   &#123;<br>      <span class="hljs-attribute">writeConcern</span>: &lt;document&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><ul><li>document：要写入的文档  </li><li>writeConcern：写入策略，默认为 1，即要求确认写操作，0 是不要求  </li><li>ordered：指定是否按顺序写入，默认 true，按顺序写入  </li></ul><blockquote><p>案例: 插入文档   </p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.products</span><span class="hljs-selector-class">.insertOne</span>( &#123; <span class="hljs-attribute">item</span>: <span class="hljs-string">&quot;card&quot;</span>, qty: <span class="hljs-number">15</span> &#125; );<br></code></pre></td></tr></table></figure><h4 id="db-collection-insertMany"><a href="#db-collection-insertMany" class="headerlink" title="db.collection.insertMany"></a>db.collection.insertMany</h4><p>作用：向集合插入一个多个文档  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.insertMany</span>(<br>   <span class="hljs-selector-attr">[ &lt;document 1&gt; , &lt;document 2&gt;, ... ]</span>,<br>   &#123;<br>      <span class="hljs-attribute">writeConcern</span>: &lt;document&gt;,<br>      ordered: &lt;boolean&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><p>参数与<code>db.collection.insertOne</code>一致  </p><blockquote><p>案例  往 products集合 插入一些数据  </p></blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.products</span><span class="hljs-selector-class">.insertMany</span>( [<br>  &#123; <span class="hljs-attribute">item</span>: <span class="hljs-string">&quot;card&quot;</span>, <span class="hljs-attribute">qty</span>: <span class="hljs-number">15</span> &#125;,<br>  &#123; <span class="hljs-attribute">item</span>: <span class="hljs-string">&quot;envelope&quot;</span>, <span class="hljs-attribute">qty</span>: <span class="hljs-number">20</span> &#125;,<br>  &#123; <span class="hljs-attribute">item</span>: <span class="hljs-string">&quot;stamps&quot;</span> , <span class="hljs-attribute">qty</span>: <span class="hljs-number">30</span> &#125;<br>   ] );<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="db-collection-insert"><a href="#db-collection-insert" class="headerlink" title="db.collection.insert()"></a>db.collection.insert()</h4><p>若插入的数据主键已经存在，则会抛<code>org.springframework.dao.DuplicateKeyException</code> 异常，提示主键重复，不保存当前数据  </p><blockquote><p>案例：向 runoob 数据库 的 col 集合中插入数据  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.col</span><span class="hljs-selector-class">.insert</span>(&#123;<span class="hljs-attribute">title</span>: <span class="hljs-string">&#x27;MongoDB 教程&#x27;</span>, <br>   description: <span class="hljs-string">&#x27;MongoDB 是一个 Nosql 数据库&#x27;</span>,<br>   by: <span class="hljs-string">&#x27;菜鸟教程&#x27;</span>,<br>   url: <span class="hljs-string">&#x27;http://www.runoob.com&#x27;</span>,<br>   tags: [<span class="hljs-string">&#x27;mongodb&#x27;</span>, <span class="hljs-string">&#x27;database&#x27;</span>, <span class="hljs-string">&#x27;NoSQL&#x27;</span>],<br>   likes: <span class="hljs-number">100</span><br>&#125;)<br></code></pre></td></tr></table></figure></blockquote><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul><li><p><a href="https://docs.mongodb.com/manual/reference/method/db.collection.deleteOne/">db.collection.deleteOne</a><br>删除集合中的一个文档    </p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts">db.collection.deleteOne(<br>   <span class="hljs-params">&lt;filter&gt;</span>,<br>   &#123;<br><span class="hljs-symbol">      writeConcern:</span> <span class="hljs-params">&lt;document&gt;</span>,<br><span class="hljs-symbol">      collation:</span> <span class="hljs-params">&lt;document&gt;</span>,<br><span class="hljs-symbol">      hint:</span> <span class="hljs-params">&lt;document|string&gt;</span>    <span class="hljs-comment">// Available starting in MongoDB 4.4</span><br>   &#125;<br>)<br></code></pre></td></tr></table></figure><ul><li>filter<br>指定删除条件,如果设置为{}则删除第一个文档  </li><li>writeConcern<br>可选参数，写入关注，其值为一个文档  </li><li>collation<br>可选参数，指定用于操作的集合  </li><li>hint<br>可选参数，指定用于支持查询谓词的索引的文档或字符串  </li></ul><blockquote><p>假设现在有一个order集合，集合中有这么个文档  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>   <span class="hljs-attribute">_id</span>: <span class="hljs-built_in">ObjectId</span>(<span class="hljs-string">&quot;563237a41a4d68582c2509da&quot;</span>),<br>   stock: <span class="hljs-string">&quot;Brent Crude Futures&quot;</span>,<br>   qty: <span class="hljs-number">250</span>,<br>   type: <span class="hljs-string">&quot;buy-limit&quot;</span>,<br>   limit: <span class="hljs-number">48.90</span>,<br>   creationts: <span class="hljs-built_in">ISODate</span>(<span class="hljs-string">&quot;2015-11-01T12:30:15Z&quot;</span>),<br>   expiryts: <span class="hljs-built_in">ISODate</span>(<span class="hljs-string">&quot;2015-11-01T12:35:15Z&quot;</span>),<br>   client: <span class="hljs-string">&quot;Crude Traders Inc.&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>案例： 根据删除<code>_id</code>为<code>233</code>的文档  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">db.orders.deleteOne( &#123; <span class="hljs-string">&quot;_id&quot;</span> : <span class="hljs-type">ObjectId</span>(<span class="hljs-string">&quot;233&quot;</span>) &#125; );<br></code></pre></td></tr></table></figure></blockquote></li><li><p>db.collection.deleteMany<br>删除集合中所有符合<code>filter</code>的文档<br><a href="https://docs.mongodb.com/manual/reference/method/db.collection.deleteMany/">文档地址</a>  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.deleteMany</span>(<br>   &lt;<span class="hljs-selector-tag">filter</span>&gt;,<br>   &#123;<br>      <span class="hljs-attribute">writeConcern</span>: &lt;document&gt;,<br>      collation: &lt;document&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><p>  参数同<code>db.collection.deleteOne</code>  </p><blockquote><p>案例<br>假设现在有一个order集合，集合中有这么个文档  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  <span class="hljs-attribute">_id</span>: <span class="hljs-built_in">ObjectId</span>(<span class="hljs-string">&quot;563237a41a4d68582c2509da&quot;</span>),<br>  stock: <span class="hljs-string">&quot;Brent Crude Futures&quot;</span>,<br>  client: <span class="hljs-string">&quot;Crude Traders Inc.&quot;</span><br>&#125;<br>&#123;<br>  <span class="hljs-attribute">_id</span>: <span class="hljs-built_in">ObjectId</span>(<span class="hljs-string">&quot;123437a41a423423444509da&quot;</span>),<br>  stock: <span class="hljs-string">&quot;Brent Crude Futures&quot;</span>,<br>  client: <span class="hljs-string">&quot;Crude Traders Inc.&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>案例： 根据删除<code>client</code>为<code>Crude Traders Inc.</code>的文档  </p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">db.<span class="hljs-keyword">orders.deleteMany( </span>&#123; <span class="hljs-string">&quot;client&quot;</span> : <span class="hljs-string">&quot;Crude Traders Inc.&quot;</span> &#125; );<br></code></pre></td></tr></table></figure></blockquote><h3 id="更改"><a href="#更改" class="headerlink" title="更改"></a>更改</h3><h4 id="db-collection-update"><a href="#db-collection-update" class="headerlink" title="db.collection.update"></a>db.collection.update</h4><p>作用：更新已存在的文档  </p></li></ul><p>使用格式</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts">db.collection.update(<br>   <span class="hljs-params">&lt;query&gt;</span>,<br>   <span class="hljs-params">&lt;update&gt;</span>,<br>   &#123;<br><span class="hljs-symbol">     upsert:</span> <span class="hljs-params">&lt;boolean&gt;</span>,<br><span class="hljs-symbol">     multi:</span> <span class="hljs-params">&lt;boolean&gt;</span>,<br><span class="hljs-symbol">     writeConcern:</span> <span class="hljs-params">&lt;document&gt;</span><br>   &#125;<br>)<br></code></pre></td></tr></table></figure><ul><li>query : update的查询条件，类似sql update查询内where后面的  </li><li>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的  </li><li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入  </li><li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新  </li><li>writeConcern :可选，抛出异常的级别  </li></ul><blockquote><p>案例：更改<code>title</code>为<code>mysql</code>  </p></blockquote><p>假设现在有一个order集合，集合中有这么个文档  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;_id&quot;</span> : ObjectId(<span class="hljs-string">&quot;1&quot;</span>),<br>    <span class="hljs-attr">&quot;title&quot;</span> : <span class="hljs-string">&quot;MongoDB&quot;</span>,<br>    <span class="hljs-attr">&quot;description&quot;</span> : <span class="hljs-string">&quot;MongoDB 是一个 Nosql 数据库&quot;</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p>更改<code>title</code>为<code>mysql</code>  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">db.<span class="hljs-keyword">col</span>.<span class="hljs-keyword">update</span>(&#123;<span class="hljs-string">&#x27;title&#x27;</span>:<span class="hljs-string">&#x27;MongoDB&#x27;</span>&#125;,&#123;$<span class="hljs-keyword">se</span><span class="hljs-variable">t:</span>&#123;<span class="hljs-string">&#x27;title&#x27;</span>:<span class="hljs-string">&#x27;mysql&#x27;</span>&#125;&#125;)<br></code></pre></td></tr></table></figure><p>需要注意的是，这语句只会修改第一个发现的文档<br>如果想要修改多个，需要添加 <code>&#123;multi:true&#125;</code></p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">db.<span class="hljs-keyword">col</span>.<span class="hljs-keyword">update</span>(&#123;<span class="hljs-string">&#x27;title&#x27;</span>:<span class="hljs-string">&#x27;MongoDB&#x27;</span>&#125;,&#123;$<span class="hljs-keyword">se</span><span class="hljs-variable">t:</span>&#123;<span class="hljs-string">&#x27;title&#x27;</span>:<span class="hljs-string">&#x27;mysqls&#x27;</span>&#125;&#125;,&#123;multi:true&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>官方文档説明：<a href="https://docs.mongodb.com/master/reference/command/update/">https://docs.mongodb.com/master/reference/command/update/</a>  </p></blockquote><h4 id="db-collection-save"><a href="#db-collection-save" class="headerlink" title="db.collection.save"></a>db.collection.save</h4><p>作用：通过传入的文档来替换已有文档，主键存在就更新，不存在就插入  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.save</span>(<br>   &lt;<span class="hljs-selector-tag">document</span>&gt;,<br>   &#123;<br>     <span class="hljs-attribute">writeConcern</span>: &lt;document&gt;<br>   &#125;<br>)<br></code></pre></td></tr></table></figure><ul><li>document : 文档数据  </li><li>writeConcern :可选，抛出异常的级别  </li></ul><p>实际上就是用一个新的文档来覆盖旧的,关键是要让_id主键一致    </p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs maxima">db.<span class="hljs-built_in">col</span>.<span class="hljs-built_in">save</span>(&#123;<br>    <span class="hljs-string">&quot;_id&quot;</span> : ObjectId(<span class="hljs-string">&quot;1&quot;</span>),<br>    <span class="hljs-string">&quot;title&quot;</span> : <span class="hljs-string">&quot;MongoDB&quot;</span>,<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="db-collection-find"><a href="#db-collection-find" class="headerlink" title="db.collection.find"></a>db.collection.find</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.collection</span><span class="hljs-selector-class">.find</span>(<span class="hljs-selector-tag">query</span>, <span class="hljs-selector-tag">projection</span>)<br></code></pre></td></tr></table></figure><ul><li>query ：可选，使用查询操作符指定查询条件  </li><li>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）  </li></ul><p>如果你希望返回比较好看的形式，可以用<code>pretty</code>  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.col</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.pretty</span>()<br></code></pre></td></tr></table></figure><p>实际上还有一个 <code>findOne</code> 方法专门用来找单个文档    </p><h4 id="限制查询数量-Limit"><a href="#限制查询数量-Limit" class="headerlink" title="限制查询数量 Limit"></a>限制查询数量 Limit</h4><p>如果你需要在<code>MongoDB</code>中读取指定数量的数据记录，可以使用<code>MongoDB</code>的<code>Limit</code>方法<br><code>limit()</code>方法接受一个数字参数，该参数指定从MongoDB中读取的记录条数<br>未指定<code>limit</code>方法中的参数则显示集合中的所有数据  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.COLLECTION_NAME</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.limit</span>(<span class="hljs-selector-tag">NUMBER</span>)<br></code></pre></td></tr></table></figure><blockquote><p>案例：查找前两条数据</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">db</span>.col.find(&#123;&#125;,&#123;<span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-number">1</span>,_id:<span class="hljs-number">0</span>&#125;).limit(<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h4 id="跳过查询数量-Skip"><a href="#跳过查询数量-Skip" class="headerlink" title="跳过查询数量 Skip()"></a>跳过查询数量 Skip()</h4><p>除了可以使用<code>limit</code>方法来读取指定数量的数据外，还可以使用<code>skip</code>方法来跳过指定数量的数据<br>skip方法同样接受一个数字参数作为跳过的记录条数。默认参数为 0   </p><blockquote><p>案例：查找第二条数据</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.COLLECTION_NAME</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.limit</span>(<span class="hljs-selector-tag">NUMBER</span>)<span class="hljs-selector-class">.skip</span>(<span class="hljs-selector-tag">NUMBER</span>)<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">db</span>.col.find(&#123;&#125;,&#123;<span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-number">1</span>,_id:<span class="hljs-number">0</span>&#125;).limit(<span class="hljs-number">1</span>).skip(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><h4 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序 sort()"></a>排序 sort()</h4><p><code>sort</code> 方法可以通过参数指定排序的字段，并使用 1 和 -1 来指定排序的方式<br>1 为升序排列，而 -1 是用于降序排列  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.COLLECTION_NAME</span><span class="hljs-selector-class">.find</span>()<span class="hljs-selector-class">.sort</span>(&#123;<span class="hljs-attribute">KEY</span>:<span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure><h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h1><h2 id="比较逻辑"><a href="#比较逻辑" class="headerlink" title="比较逻辑"></a>比较逻辑</h2><table><thead><tr><th>操作</th><th>格式</th><th>范例</th><th>RDBMS中的类似语句</th></tr></thead><tbody><tr><td>等于</td><td>{<code>&lt;key&gt;</code>:<code>&lt;value&gt;</code>}</td><td>db.col.find({“by”:”123”}).pretty()</td><td>where by = ‘123’</td></tr><tr><td>小于</td><td>{<code>&lt;key&gt;</code>:{$lt:<code>&lt;value&gt;</code>}}</td><td>db.col.find({“likes”:{$lt:50}}).pretty()</td><td>where likes &lt; 50</td></tr><tr><td>小于或等于</td><td>{<code>&lt;key&gt;</code>:{$lte:<code>&lt;value&gt;</code>}}</td><td>db.col.find({“likes”:{$lte:50}}).pretty()</td><td>where likes &lt;= 50</td></tr><tr><td>大于</td><td>{<code>&lt;key&gt;</code>:{$gt:<code>&lt;value&gt;</code>}}</td><td>db.col.find({“likes”:{$gt:50}}).pretty()</td><td>where likes &gt; 50</td></tr><tr><td>大于或等于</td><td>{<code>&lt;key&gt;</code>:{$gte:<code>&lt;value&gt;</code>}}</td><td>db.col.find({“likes”:{$gte:50}}).pretty()</td><td>where likes &gt;= 50</td></tr><tr><td>不等于</td><td>{<code>&lt;key&gt;</code>:{$ne:<code>&lt;value&gt;</code>}}</td><td>db.col.find({“likes”:{$ne:50}}).pretty()</td><td>where likes != 50</td></tr></tbody></table><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="and-与逻辑"><a href="#and-与逻辑" class="headerlink" title="and 与逻辑"></a>and 与逻辑</h3><p>同时传入多个键即可  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">db</span>.col.find(&#123;key<span class="hljs-number">1</span>:value<span class="hljs-number">1</span>, key<span class="hljs-number">2</span>:value<span class="hljs-number">2</span>&#125;).pretty()<br></code></pre></td></tr></table></figure><h3 id="or-或逻辑"><a href="#or-或逻辑" class="headerlink" title="or 或逻辑"></a>or 或逻辑</h3><p>使用关键词<code>$or</code>  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.col</span><span class="hljs-selector-class">.find</span>(&#123;<br>    $<span class="hljs-attribute">or</span>: [&#123;<span class="hljs-attribute">key1</span>: value1&#125;, &#123;<span class="hljs-attribute">key2</span>:value2&#125;] <br>&#125;)<span class="hljs-selector-class">.pretty</span>()<br></code></pre></td></tr></table></figure><h3 id="not-非逻辑"><a href="#not-非逻辑" class="headerlink" title="not 非逻辑"></a>not 非逻辑</h3><p>使用关键词<code>$not</code>  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.col</span><span class="hljs-selector-class">.find</span>(<br>    &#123; <span class="hljs-attribute">key</span>: &#123; $not: &#123; $gt: value &#125; &#125; &#125; <br>)<br></code></pre></td></tr></table></figure><h3 id="type-操作符"><a href="#type-操作符" class="headerlink" title="$type 操作符"></a><code>$type</code> 操作符</h3><p><code>$type</code>操作符是基于<code>BSON</code>类型来检索集合中匹配的数据类型，并返回结果   </p><table><thead><tr><th>类型</th><th>数字</th><th>备注</th></tr></thead><tbody><tr><td>Double</td><td>1</td><td></td></tr><tr><td>String</td><td>2</td><td></td></tr><tr><td>Object</td><td>3</td><td></td></tr><tr><td>Array</td><td>4</td><td></td></tr><tr><td>Binary data</td><td>5</td><td></td></tr><tr><td>Undefined</td><td>6</td><td>已废弃</td></tr><tr><td>Object id</td><td>7</td><td></td></tr><tr><td>Boolean</td><td>8</td><td></td></tr><tr><td>Date</td><td>9</td><td></td></tr><tr><td>Null</td><td>10</td><td></td></tr><tr><td>Regular Expression</td><td>11</td><td></td></tr><tr><td>JavaScript</td><td>13</td><td></td></tr><tr><td>Symbol</td><td>14</td><td></td></tr><tr><td>JavaScript (with scope)</td><td>15</td><td></td></tr><tr><td>32-bit integer</td><td>16</td><td></td></tr><tr><td>Timestamp</td><td>17</td><td></td></tr><tr><td>64-bit integer</td><td>18</td><td></td></tr><tr><td>Min key</td><td>255</td><td>Query with -1</td></tr><tr><td>Max key</td><td>127</td><td></td></tr></tbody></table><blockquote><p>案例：寻找标题为字符串类型的文档  </p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">db.col.<span class="hljs-builtin-name">find</span>(&#123;<span class="hljs-string">&quot;title&quot;</span> : &#123;<span class="hljs-variable">$type</span> : 2&#125;&#125;)<br>db.col.<span class="hljs-builtin-name">find</span>(&#123;<span class="hljs-string">&quot;title&quot;</span> : &#123;<span class="hljs-variable">$type</span> : <span class="hljs-string">&#x27;string&#x27;</span>&#125;&#125;)<br></code></pre></td></tr></table></figure><h2 id="多集合查询"><a href="#多集合查询" class="headerlink" title="多集合查询"></a>多集合查询</h2><p>实际上，多集合查询是利用聚合的 <code>$lookup</code>多表关联 实现的<br>具体见后</p><h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引通常能够极大的提高查询的效率<br>索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构  </p><blockquote><p>如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的  </p></blockquote><h2 id="常用操作-3"><a href="#常用操作-3" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">db.collection.create<span class="hljs-constructor">Index(<span class="hljs-params">keys</span>, <span class="hljs-params">options</span>)</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>值类型</th><th>信息</th></tr></thead><tbody><tr><td>background</td><td>Boolean</td><td>建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为false。</td></tr><tr><td>unique</td><td>Boolean</td><td>建立的索引是否唯一。指定为true创建唯一索引。默认值为false.</td></tr><tr><td>name</td><td>string</td><td>索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。</td></tr><tr><td>dropDups</td><td>Boolean</td><td>3.0+版本已废弃。在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false.</td></tr><tr><td>sparse</td><td>Boolean</td><td>对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false.</td></tr><tr><td>expireAfterSeconds</td><td>integer</td><td>指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。</td></tr><tr><td>v</td><td>index version</td><td>索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。</td></tr><tr><td>weights</td><td>document</td><td>索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。</td></tr><tr><td>default_language</td><td>string</td><td>对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语</td></tr><tr><td>language_override</td><td>string</td><td>对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.</td></tr></tbody></table><blockquote><p>案例：以<code>title</code>键建立索引  </p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">db</span>.col.createIndex(&#123;<span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-number">1</span>&#125;)<br></code></pre></td></tr></table></figure><blockquote><p>案例：以<code>title</code>与<code>name</code>键在后台建立索引  </p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.values</span><span class="hljs-selector-class">.createIndex</span>(&#123;<span class="hljs-attribute">title</span>: <span class="hljs-number">1</span>, name: <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-attribute">background</span>: true&#125;)<br></code></pre></td></tr></table></figure><p>通过在创建索引时加 <code>background:true</code> 的选项，让创建工作在后台执行</p><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h3><ul><li>查看集合索引  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.col</span><span class="hljs-selector-class">.getIndexes</span>()<br></code></pre></td></tr></table></figure></li><li>查看集合索引大小  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.col</span><span class="hljs-selector-class">.totalIndexSize</span>()<br></code></pre></td></tr></table></figure><h3 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h3></li><li>删除集合所有索引  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.col</span><span class="hljs-selector-class">.dropIndexes</span>()<br></code></pre></td></tr></table></figure></li><li>删除集合指定索引  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.col</span><span class="hljs-selector-class">.dropIndex</span>(&quot;索引名称&quot;)<br></code></pre></td></tr></table></figure></li></ul><h2 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h2><p><code>MongoDB</code>中聚合(aggregate)主要用于处理数据(诸如统计平均值,求和等)，并返回计算后的数据结果  </p><h3 id="aggregate-方法"><a href="#aggregate-方法" class="headerlink" title="aggregate() 方法"></a>aggregate() 方法</h3><p>MongoDB中聚合的方法使用 <code>aggregate()</code>  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.COLLECTION_NAME</span><span class="hljs-selector-class">.aggregate</span>(<span class="hljs-selector-tag">AGGREGATE_OPERATION</span>)<br></code></pre></td></tr></table></figure><table><thead><tr><th>表达式</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>$sum</td><td>计算总和</td><td><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$sum : &quot;$likes&quot;&#125;&#125;&#125;])</code></td></tr><tr><td>$avg</td><td>计算平均值</td><td><code>   db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$avg : &quot;$likes&quot;&#125;&#125;&#125;])</code></td></tr><tr><td>$min</td><td>获取集合中所有文档对应值得最小值</td><td><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$min : &quot;$likes&quot;&#125;&#125;&#125;])</code></td></tr><tr><td>$max</td><td>获取集合中所有文档对应值得最大值</td><td><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, num_tutorial : &#123;$max : &quot;$likes&quot;&#125;&#125;&#125;])</code></td></tr><tr><td>$push</td><td>在结果文档中插入值到一个数组中</td><td><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, url : &#123;$push: &quot;$url&quot;&#125;&#125;&#125;])</code></td></tr><tr><td>$addToSet</td><td>在结果文档中插入值到一个数组中，但不创建副本</td><td><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, url : &#123;$addToSet : &quot;$url&quot;&#125;&#125;&#125;])</code></td></tr><tr><td>$first</td><td>根据资源文档的排序获取第一个文档数据</td><td><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, first_url : &#123;$first : &quot;$url&quot;&#125;&#125;&#125;])</code></td></tr><tr><td>$last</td><td>根据资源文档的排序获取最后一个文档数据</td><td><code>db.mycol.aggregate([&#123;$group : &#123;_id : &quot;$by_user&quot;, last_url : &#123;$last : &quot;$url&quot;&#125;&#125;&#125;])</code></td></tr></tbody></table><blockquote><p>案例：计算每个作者所写的文章数  </p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>   <span class="hljs-attribute">_id</span>: <span class="hljs-built_in">ObjectId</span>(<span class="hljs-number">7</span>df78ad8902c)<br>   title: <span class="hljs-string">&#x27;MongoDB Overview&#x27;</span>, <br>   description: <span class="hljs-string">&#x27;MongoDB is no sql database&#x27;</span>,<br>   by_user: <span class="hljs-string">&#x27;runoob.com&#x27;</span>,<br>&#125;,<br>&#123;<br>   <span class="hljs-attribute">_id</span>: <span class="hljs-built_in">ObjectId</span>(<span class="hljs-number">7</span>df78ad8902d)<br>   title: <span class="hljs-string">&#x27;NoSQL Overview&#x27;</span>, <br>   description: <span class="hljs-string">&#x27;No sql database is very fast&#x27;</span>,<br>   by_user: <span class="hljs-string">&#x27;runoob.com&#x27;</span>,<br>&#125;,<br>&#123;<br>   <span class="hljs-attribute">_id</span>: <span class="hljs-built_in">ObjectId</span>(<span class="hljs-number">7</span>df78ad8902e)<br>   title: <span class="hljs-string">&#x27;Neo4j Overview&#x27;</span>, <br>   description: <span class="hljs-string">&#x27;Neo4j is no sql database&#x27;</span>,<br>   by_user: <span class="hljs-string">&#x27;Neo4j&#x27;</span>,<br>&#125;,<br></code></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">db.mycol.aggregate([&#123;<span class="hljs-attr">$group :</span> &#123;<span class="hljs-attr">_id :</span> <span class="hljs-string">&quot;$by_user&quot;</span>, <span class="hljs-attr">num_tutorial :</span> &#123;<span class="hljs-attr">$sum :</span> <span class="hljs-number">1</span>&#125;&#125;&#125;])<br></code></pre></td></tr></table></figure><h3 id="管道的概念"><a href="#管道的概念" class="headerlink" title="管道的概念"></a>管道的概念</h3><p>管道在<code>Unix</code>和<code>Linux</code>中一般用于将当前命令的输出结果作为下一个命令的参数。  </p><p><code>MongoDB</code>的聚合管道将<code>MongoDB</code>文档在一个管道处理完毕后将结果传递给下一个管道处理。管道操作是可以重复的。  </p><blockquote><p>表达式：处理输入文档并输出。表达式是无状态的，只能用于计算当前聚合管道的文档，不能处理其它的文档。</p></blockquote><p>聚合框架中常用操作：</p><table><thead><tr><th>运算符</th><th>信息</th></tr></thead><tbody><tr><td>$project</td><td>修改输入文档的结构。可以用来重命名、增加或删除域，也可以用于创建计算结果以及嵌套文档</td></tr><tr><td>$match</td><td>用于过滤数据，只输出符合条件的文档。$match使用MongoDB的标准查询操作</td></tr><tr><td>$limit</td><td>用来限制MongoDB聚合管道返回的文档数</td></tr><tr><td>$skip</td><td>在聚合管道中跳过指定数量的文档，并返回余下的文档</td></tr><tr><td>$unwind</td><td>将文档中的某一个数组类型字段拆分成多条，每条包含数组中的一个值</td></tr><tr><td>$group</td><td>将集合中的文档分组，可用于统计结果</td></tr><tr><td>$sort</td><td>将输入文档排序后输出</td></tr><tr><td>$geoNear</td><td>输出接近某一地理位置的有序文档</td></tr><tr><td>$lookup</td><td>多表关联</td></tr></tbody></table><blockquote><p>案例：结果中只有_id,tilte和author三个字段  </p></blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.article</span><span class="hljs-selector-class">.aggregate</span>(<br>    &#123; $<span class="hljs-attribute">project </span>: &#123;<br>        <span class="hljs-attribute">title </span>: <span class="hljs-number">1</span> ,<br>        <span class="hljs-attribute">author </span>: <span class="hljs-number">1</span> ,<br>    &#125;&#125;<br> );<br></code></pre></td></tr></table></figure><p>实际上有还有一个默认添加的字段<code>_id</code>，如果想要取消指定<code>_id:0</code>即可  </p><h3 id="lookup多表查询"><a href="#lookup多表查询" class="headerlink" title="$lookup多表查询"></a><code>$lookup</code>多表查询</h3><p><strong>主要功能</strong><br>处理每个输入的文档，输出的新文档中会包含一个新生成的数组列（户名可根据需要命名新key的名字），如果没有内容适配，集合为空（即<code>[ ]</code>）</p><p><strong>语法</strong>  </p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs smali">&#123;<br>   $lookup:<br>     &#123;<br>       from: &lt;collection to join&gt;,<br>       localField: &lt;field from the input documents&gt;,<br>       foreignField: &lt;field from the documents of the <span class="hljs-string">&quot;from&quot;</span> collection&gt;,<br>       as: &lt;output<span class="hljs-built_in"> array </span>field&gt;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th>语法值</th><th>解释说明</th></tr></thead><tbody><tr><td>from</td><td>同一个数据库中等待被 <code>Join</code> 的集合</td></tr><tr><td>localField</td><td>被<code>Join</code>集合中的 键<br>如果集合中的某个文档没有这个键，那么就认为其实这个文档有这个键，只是个键的值为 <code>null</code></td></tr><tr><td>foreignField</td><td>要<code>Join</code>的集合的 键<br>如果集合中的某个文档没有这个键，那么就认为其实这个文档有这个键，只是个键的值为 <code>None</code></td></tr><tr><td>as</td><td>为输出文档的新增键命名<br>如果输入的集合中已存在该值，则会覆盖掉</td></tr></tbody></table><blockquote><p>例: 查询武器的所有信息  </p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ada">集合 items<br>&#123; <span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-number">1</span>,  <span class="hljs-string">&quot;item&quot;</span>:<span class="hljs-string">&quot;大剑&quot;</span>,  <span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">1200</span>, <span class="hljs-string">&quot;quality&quot;</span>:<span class="hljs-number">100</span> &#125;,<br>&#123; <span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-number">2</span>,  <span class="hljs-string">&quot;item&quot;</span>:<span class="hljs-string">&quot;弓箭&quot;</span>,  <span class="hljs-string">&quot;price&quot;</span>:<span class="hljs-number">800</span>,  <span class="hljs-string">&quot;quality&quot;</span>:<span class="hljs-number">80</span> &#125;,<br><br>集合 effect<br>&#123; <span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-number">1</span>,  <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;弓箭&quot;</span>,  <span class="hljs-string">&quot;attack&quot;</span>: <span class="hljs-number">90</span>,   <span class="hljs-string">&quot;scope&quot;</span> : 300 &#125;,<br>&#123; <span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-number">2</span>,  <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;大剑&quot;</span>,  <span class="hljs-string">&quot;attack&quot;</span>: <span class="hljs-number">200</span>,  <span class="hljs-string">&quot;scope&quot;</span> : 16 &#125;,<br>&#123; <span class="hljs-string">&quot;_id&quot;</span>:<span class="hljs-number">3</span>,  <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;大炮&quot;</span>,  <span class="hljs-string">&quot;attack&quot;</span>: <span class="hljs-number">360</span>,  <span class="hljs-string">&quot;scope&quot;</span> : 900 &#125;,<br></code></pre></td></tr></table></figure><p>进行聚合计算  </p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">db</span><span class="hljs-selector-class">.items</span><span class="hljs-selector-class">.aggregate</span>([<br>   &#123;<br>     $<span class="hljs-attribute">lookup</span>:<br>       &#123;<br>         <span class="hljs-attribute">from</span>: <span class="hljs-string">&quot;effect&quot;</span>,<br>         <span class="hljs-attribute">localField</span>: <span class="hljs-string">&quot;item&quot;</span>,<br>         <span class="hljs-attribute">foreignField</span>: <span class="hljs-string">&quot;name&quot;</span>,<br>         <span class="hljs-attribute">as</span>: <span class="hljs-string">&quot;item_info&quot;</span><br>       &#125;<br>  &#125;<br>])<br></code></pre></td></tr></table></figure><p>得到结果</p><figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme">[<br>    &#123;<span class="hljs-symbol">&#x27;_id</span><span class="hljs-symbol">&#x27;:</span> <span class="hljs-number">1</span>, <span class="hljs-symbol">&#x27;item</span><span class="hljs-symbol">&#x27;:</span> <span class="hljs-symbol">&#x27;大剑</span>&#x27;, <span class="hljs-symbol">&#x27;price</span><span class="hljs-symbol">&#x27;:</span> <span class="hljs-number">1200</span>, <span class="hljs-symbol">&#x27;quality</span><span class="hljs-symbol">&#x27;:</span> <span class="hljs-number">100</span>, <span class="hljs-symbol">&#x27;item_info</span><span class="hljs-symbol">&#x27;:</span> []&#125;, <br>    &#123;<span class="hljs-symbol">&#x27;_id</span><span class="hljs-symbol">&#x27;:</span> <span class="hljs-number">2</span>, <span class="hljs-symbol">&#x27;item</span><span class="hljs-symbol">&#x27;:</span> <span class="hljs-symbol">&#x27;弓箭</span>&#x27;, <span class="hljs-symbol">&#x27;price</span><span class="hljs-symbol">&#x27;:</span> <span class="hljs-number">800</span>, <span class="hljs-symbol">&#x27;quality</span><span class="hljs-symbol">&#x27;:</span> <span class="hljs-number">80</span>, <span class="hljs-symbol">&#x27;item_info</span><span class="hljs-symbol">&#x27;:</span> []&#125;<br>]<br></code></pre></td></tr></table></figure><hr><p>未完成：<a href="https://www.runoob.com/mongodb/mongodb-replication.html">https://www.runoob.com/mongodb/mongodb-replication.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Charles-抓包</title>
    <link href="/post/cdc32bf4/"/>
    <url>/post/cdc32bf4/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Charles</code>是一个Web代理（<a href="https://www.charlesproxy.com/documentation/additional/http-proxy/">HTTP Proxy</a> / <a href="https://www.charlesproxy.com/documentation/additional/http-monitor/">HTTP Monitor</a>）抓包工具<br><code>Charles</code>可以 接收/发送/记录 你的 请求/相应 网络数据  </p><p>官网：<a href="https://www.charlesproxy.com/">https://www.charlesproxy.com/</a><br>文档：<a href="https://www.charlesproxy.com/documentation/">https://www.charlesproxy.com/documentation/</a><br>下载：<a href="https://www.charlesproxy.com/download/">https://www.charlesproxy.com/download/</a>  </p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><a href="https://www.charlesproxy.com/documentation/proxying/ssl-proxying/"><code>SSL Proxying</code></a><br>能看到SSL的请求与响应  </li><li><a href="https://www.charlesproxy.com/documentation/proxying/throttling/"><code>Bandwidth Throttling</code></a>  </li><li>AJAX debugging<br>可以将<code>XML</code>/<code>JSON</code>格式的 请求/响应 以文本或树的形式展现出来  </li><li><a href="https://www.charlesproxy.com/documentation/additional/amf/">AMF</a><br>可以以树形视图查看Flash Remoting / Flex Remoting消息的内容  </li><li>可以重复发送特定的请求  </li><li>可以编辑请求来进行测试  </li><li>提供断点功能来拦截和编辑请求或响应  </li><li>使用W3C验证器验证记录的HTML，CSS和RSS / atom响应  </li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>下载：<a href="https://www.charlesproxy.com/download/">https://www.charlesproxy.com/download/</a><br>下载完毕以后直接安装即可  </p><blockquote><h2 id="破解"><a href="#破解" class="headerlink" title="破解"></a>破解</h2><p>安装以后，打开程序，找到输入注册码的项<br><img src="/Charles-%E6%8A%93%E5%8C%85/20200911114410472.png"><br>输入以下内容完成破解<br>Registered Name: <code>https://zhile.io</code><br>License Key: <code>48891cf209c6d32bf4</code>  </p></blockquote><h1 id="HTTP代理设置"><a href="#HTTP代理设置" class="headerlink" title="HTTP代理设置"></a>HTTP代理设置</h1><h2 id="PC代理端口号设置"><a href="#PC代理端口号设置" class="headerlink" title="PC代理端口号设置"></a>PC代理端口号设置</h2><p><img src="/Charles-%E6%8A%93%E5%8C%85/20200911115300285.png"><br><img src="/Charles-%E6%8A%93%E5%8C%85/20200911023407862.png"><br>可以在这里设置<code>Charles</code>的代理端口号<br>顺便把一些选项给打开  </p><h2 id="手机设置Charles代理"><a href="#手机设置Charles代理" class="headerlink" title="手机设置Charles代理"></a>手机设置<code>Charles</code>代理</h2><p>这里以<code>mumu模拟器为例</code><br><img src="/Charles-%E6%8A%93%E5%8C%85/mumu_proxry.gif"><br>在完毕以后，<code>Charles</code>会弹出是否允许的提问<br><img src="/Charles-%E6%8A%93%E5%8C%85/20200911020913026.png"><br>允许即可  </p><h1 id="HTTPS代理设置"><a href="#HTTPS代理设置" class="headerlink" title="HTTPS代理设置"></a>HTTPS代理设置</h1><p>如果想要让<code>Charles</code>抓取HTTPS包解析出正确的数据，就需要安装<code>Charles SSL证书</code>，让设备信任这个代理  </p><h2 id="PC-SSL设置"><a href="#PC-SSL设置" class="headerlink" title="PC SSL设置"></a>PC SSL设置</h2><h3 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h3><p><img src="/Charles-%E6%8A%93%E5%8C%85/20200911021937269.png"><br><img src="/Charles-%E6%8A%93%E5%8C%85/PC_install_CR.gif"><br>注意将证书存储改为：受信任的根证书颁发机构  </p><h3 id="接受设置"><a href="#接受设置" class="headerlink" title="接受设置"></a>接受设置</h3><p><img src="/Charles-%E6%8A%93%E5%8C%85/20200911023538442.png"><br><img src="/Charles-%E6%8A%93%E5%8C%85/20200911023644056.png"></p><h3 id="安卓安装证书"><a href="#安卓安装证书" class="headerlink" title="安卓安装证书"></a>安卓安装证书</h3><p><img src="/Charles-%E6%8A%93%E5%8C%85/Andr_install_CR.gif"><br>浏览器中打开 charlesproxy.com/getssl 下载证书安装即可  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Charles</tag>
      
      <tag>抓包</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Frida</title>
    <link href="/post/ac853d21/"/>
    <url>/post/ac853d21/</url>
    
    <content type="html"><![CDATA[<p>Frida官方文档的食用记录  </p><h1 id="文档-网址"><a href="#文档-网址" class="headerlink" title="文档/网址"></a>文档/网址</h1><table><thead><tr><th>信息</th><th>网址</th></tr></thead><tbody><tr><td>Frida官网</td><td><a href="https://frida.re/">https://frida.re/</a></td></tr><tr><td>Frida官方文档</td><td><a href="https://frida.re/docs/home/">https://frida.re/docs/home/</a></td></tr></tbody></table><h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><h2 id="什么是Frida"><a href="#什么是Frida" class="headerlink" title="什么是Frida"></a>什么是<code>Frida</code></h2><p><code>Frida</code>是一个动态代码检查工具<br>它可以让你将<code>JavaScript</code>代码诸如到<code>Windows</code>,<code>macOS</code>,<code>Android</code>等系统的程序中<br><code>Frida</code>也为你提供了一些基于其API的小工具，你可以按需获取使用  </p><h2 id="Python-API-与-JavaScript-debugging"><a href="#Python-API-与-JavaScript-debugging" class="headerlink" title="Python API 与 JavaScript debugging"></a>Python API 与 JavaScript debugging</h2><p>Firda 是由C语言编写的。它将 GoogleV8引擎插入到目标进程中。在进程中，你的JS可以访问内存，hooking函数，甚至可以在进程内部调用函数来运行<br>这个过程是通过在程序和JS之间建立双向通信通道来进行的<br>使用Python和JS可以让你快速使用无风险API进行开发（无风险:Firida可以帮助你捕获异常或者错误，但是不会崩溃导致程序崩溃）<br>实际上你可以使用多种不同的方式来使用<code>Frida</code> Node.js, Python， Swift， .NET 都可以  </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h1 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h1><pre><code></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Frida</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-JPype-运行java代码</title>
    <link href="/post/a751dfb9/"/>
    <url>/post/a751dfb9/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>官网：<a href="http://jpype.sourceforge.net/">http://jpype.sourceforge.net/</a><br>官方文档：<a href="http://jpype.sourceforge.net/documentation.html">http://jpype.sourceforge.net/documentation.html</a></p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><blockquote><p><code>JPype</code>请务必不要用<code>pip</code>直接安装，直接安装的话可能会在运行的时候出现一些错误，例如找不到getDefaultJVMPath函数  </p></blockquote><h2 id="java环境安装"><a href="#java环境安装" class="headerlink" title="java环境安装"></a>java环境安装</h2><p>JRE下载：<a href="https://www.java.com/zh_CN/download/?bucket_value=desktop-baiduspider2-unknown&in_query=no">链接</a><br>JDK下载：<a href="https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html">链接</a><br>下载完毕，直接安装即可<br>完毕以后，配置java环境变量：<a href="https://www.cnblogs.com/cnwutianhao/p/5487758.html">链接</a>  </p><h2 id="JPype安装"><a href="#JPype安装" class="headerlink" title="JPype安装"></a>JPype安装</h2><p>找寻对应自己版本的whl文件下载：<a href="https://www.lfd.uci.edu/~gohlke/pythonlibs/#jpype">whll链接</a><br>下载好以后用<code>pip</code>安装<code>whl文件</code>  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="处理-java文件"><a href="#处理-java文件" class="headerlink" title="处理.java文件"></a>处理.java文件</h2><p><code>JPype</code>并不能直接运行<code>.java</code>代码<br>需要将<code>.java文件</code>代码转换<code>.class文件</code>后再转为<code>.jar文件</code>后才能用<code>JPype</code>运行  </p><h3 id="java转-class"><a href="#java转-class" class="headerlink" title=".java转.class"></a><code>.java</code>转<code>.class</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">javac 文件名bai.java<br></code></pre></td></tr></table></figure><blockquote><p>可能会遇到 GBK字符编码问题：<a href="https://blog.csdn.net/gao_zhennan/article/details/89261672">解决</a>  </p></blockquote><h3 id="class转-jar"><a href="#class转-jar" class="headerlink" title=".class转.jar"></a><code>.class</code>转<code>.jar</code></h3><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">jar cvf [生成jar的名称.jar] [列出<span class="hljs-class"><span class="hljs-keyword">class</span>文件] </span><br></code></pre></td></tr></table></figure><h2 id="JPype代码编写"><a href="#JPype代码编写" class="headerlink" title="JPype代码编写"></a>JPype代码编写</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> jpype <span class="hljs-keyword">import</span> startJVM, JClass, getDefaultJVMPath, shutdownJVM<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_run_java_script</span>():</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    通过调用 java代码获取no</span><br><span class="hljs-string">    options = &#123;&#x27;jar_path&#x27;:jar路径&#125;</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-comment"># 启动Java环境</span><br>    startJVM(<br>        getDefaultJVMPath(), <span class="hljs-comment">#  这里是jre的jvm.dll路径,这个方法能让JPype自动去获取，你可以自己写</span><br>        <span class="hljs-string">&quot;-ea&quot;</span>,<br>        <span class="hljs-string">&quot;-Djava.class.path=&quot;</span>+<span class="hljs-string">&quot;ddd.jar&quot;</span>) <span class="hljs-comment">#  jar路径</span><br><br>    <span class="hljs-comment"># 加载自定义的Java代码中的 Java类</span><br>    MyClass = JClass(<span class="hljs-string">&quot;MyClass&quot;</span>)<br>    <span class="hljs-comment"># Java类实例化</span><br>    myclass = MyClass()<br>    <span class="hljs-comment"># 执行成员方法</span><br>    myclass.hello()<br>    <span class="hljs-comment"># 关闭Java环境</span><br>    shutdownJVM()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Java</tag>
      
      <tag>JPype</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-Babel</title>
    <link href="/post/2dd4e617/"/>
    <url>/post/2dd4e617/</url>
    
    <content type="html"><![CDATA[<h1 id="Babel是什么"><a href="#Babel是什么" class="headerlink" title="Babel是什么"></a>Babel是什么</h1><h2 id="Javascript标准ECMA"><a href="#Javascript标准ECMA" class="headerlink" title="Javascript标准ECMA"></a>Javascript标准ECMA</h2><p>百度百科：<a href="https://baike.baidu.com/item/ECMAScript/1889420?fr=aladdin">https://baike.baidu.com/item/ECMAScript/1889420?fr=aladdin</a><br>ES6支持表格：<a href="https://kangax.github.io/compat-table/es6">https://kangax.github.io/compat-table/es6</a>  </p><blockquote><p>Babel的作用<br>如果你的浏览器不支持ES6，Babel可以将将代码转换ES4或者其它版本，让你的浏览器支持  </p></blockquote><h2 id="什么是Babel"><a href="#什么是Babel" class="headerlink" title="什么是Babel"></a>什么是Babel</h2><p>官网描述：Babel 是一个工具链，主要用于将 <code>ECMAScript 2015+ </code>(EC6)版本的代码转换为向后兼容的 <code>JavaScript</code> 语法，以便能够运行在当前和旧版本的浏览器或其他环境中  </p><blockquote><p>例子： 实现语法转换</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Babel 输入： ES6 箭头函数</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> n + <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// Babel 输出： ES5 语法实现的同等功能</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="插件化"><a href="#插件化" class="headerlink" title="插件化"></a>插件化</h2><p><code>Babel</code>构建在插件之上<br>使用现有的或者自己编写的插件可以组成一个转换管道<br>通过使用或创建一个 <code>preset</code> 即可轻松使用一组插件  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 一个插件就是一个函数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">&#123;types: t&#125;</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    visitor: &#123;<br>      <span class="hljs-function"><span class="hljs-title">Identifier</span>(<span class="hljs-params">path</span>)</span> &#123;<br>        <span class="hljs-comment">// 翻转name: JavaScript -&gt; tpircSavaJ</span><br>        <span class="hljs-keyword">let</span> name = path.node.name; <br>        path.node.name = name.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>);<br>      &#125;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p><a href="https://www.babeljs.cn/docs/usage">https://www.babeljs.cn/docs/usage</a>  </p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li><p>安装packages  </p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install --save-dev @babel/core @babel/cli @babel/preset-env<br><span class="hljs-built_in">npm</span> install --save @babel/polyfill<br></code></pre></td></tr></table></figure></li><li><p>根目录下创建一个文件<code>babel.config.json</code>写入  </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;presets&quot;</span>: [<br>    [<br>      <span class="hljs-string">&quot;@babel/env&quot;</span>,<br>      &#123;<br>        <span class="hljs-attr">&quot;targets&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;edge&quot;</span>: <span class="hljs-string">&quot;17&quot;</span>,<br>          <span class="hljs-attr">&quot;firefox&quot;</span>: <span class="hljs-string">&quot;60&quot;</span>,<br>          <span class="hljs-attr">&quot;chrome&quot;</span>: <span class="hljs-string">&quot;67&quot;</span>,<br>          <span class="hljs-attr">&quot;safari&quot;</span>: <span class="hljs-string">&quot;11.1&quot;</span>,<br>        &#125;,<br>        <span class="hljs-attr">&quot;useBuiltIns&quot;</span>: <span class="hljs-string">&quot;usage&quot;</span>,<br>      &#125;<br>    ]<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p> 上面所列明的浏览器版本只是用于展示的示例（标明可以用什么版本以后的），你可以根据需要调整  </p></li><li><p>测试编译代码  </p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal">./node_modules/.bin/babel src --<span class="hljs-keyword">out</span>-dir <span class="hljs-class"><span class="hljs-keyword">lib</span></span><br></code></pre></td></tr></table></figure></li></ol><ul><li><p>src<br>输入js文件 目录/路径  </p></li><li><p>lib<br>输出js文件目录/路径  </p><p>如果填入文件路径，那么就编译单个文件<br>如果填入目录的话，里面所有的js文件都会被编译  </p></li></ul><p>在命令执行完毕后，输出目录会有对应代码出现  </p><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/node_modules/</span>.bin/babel --help<br></code></pre></td></tr></table></figure><h2 id="核心库基本使用"><a href="#核心库基本使用" class="headerlink" title="核心库基本使用"></a>核心库基本使用</h2><p><code>Babel</code>的核心功能位于<code>@babel/core</code>模块中<br>你可以这样子在js代码里引入  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> babel = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>);<br>babel.transform(<span class="hljs-string">&quot;code&quot;</span>, optionsObject);<br></code></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> babel = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;@babel/core&quot;</span>);<br><br><span class="hljs-keyword">const</span> code = <span class="hljs-string">`</span><br><span class="hljs-string">const sayHello = ()=&gt;&#123;</span><br><span class="hljs-string">    console.log(&#x27;Hello Babel&#x27;)</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">sayHello()</span><br><span class="hljs-string">`</span><br><span class="hljs-keyword">const</span> optionsObject = &#123;&#125;<br><span class="hljs-keyword">const</span> result = babel.transform(<span class="hljs-string">&quot;code&quot;</span>, optionsObject);<br><span class="hljs-built_in">console</span>.log(result)<br>&gt;&gt;&gt;&#123;<br>  metadata: &#123;&#125;,<br>  options: &#123;<br>    cloneInputAst: <span class="hljs-literal">true</span>,<br>    babelrc: <span class="hljs-literal">false</span>,<br>    configFile: <span class="hljs-literal">false</span>,<br>    passPerPreset: <span class="hljs-literal">false</span>,<br>    envName: <span class="hljs-string">&#x27;development&#x27;</span>,<br>    cwd: <span class="hljs-string">&#x27;F:\\Environment\\Node_js&#x27;</span>,<br>    root: <span class="hljs-string">&#x27;F:\\Environment\\Node_js&#x27;</span>,<br>    plugins: [],<br>    presets: [],<br>    parserOpts: &#123; <span class="hljs-attr">sourceType</span>: <span class="hljs-string">&#x27;module&#x27;</span>, <span class="hljs-attr">sourceFileName</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">plugins</span>: [] &#125;,<br>    generatorOpts: &#123;<br>      filename: <span class="hljs-literal">undefined</span>,<br>      auxiliaryCommentBefore: <span class="hljs-literal">undefined</span>,<br>      auxiliaryCommentAfter: <span class="hljs-literal">undefined</span>,<br>      retainLines: <span class="hljs-literal">undefined</span>,<br>      comments: <span class="hljs-literal">true</span>,<br>      shouldPrintComment: <span class="hljs-literal">undefined</span>,<br>      compact: <span class="hljs-string">&#x27;auto&#x27;</span>,<br>      minified: <span class="hljs-literal">undefined</span>,<br>      sourceMaps: <span class="hljs-literal">false</span>,<br>      sourceRoot: <span class="hljs-literal">undefined</span>,<br>      sourceFileName: <span class="hljs-string">&#x27;unknown&#x27;</span><br>    &#125;<br>  &#125;,<br>  ast: <span class="hljs-literal">null</span>,<br>  code: <span class="hljs-string">&quot;const sayHello = () =&gt; &#123;\n  console.log(&#x27;Hello Babel&#x27;);\n&#125;;\n\nsayHello();&quot;</span>,<br>  map: <span class="hljs-literal">null</span>,<br>  sourceType: <span class="hljs-string">&#x27;module&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因为没有指定需要适应什么东西，所以ES6的代码并没有转换  </p><h1 id="babel-parser"><a href="#babel-parser" class="headerlink" title="@babel/parser"></a>@babel/parser</h1><p><code>Babel parser</code>是一个<code>Babel</code>的<code>JavaScript</code>分析模块  </p><ul><li>默认启用的最新ECMAScript版本  </li><li>支持 JSX, Flow, Typescript  </li></ul><blockquote><p>这个模块是基于 <a href="https://github.com/marijnh/acorn">acorn</a> 和 <a href="https://github.com/RReverser/acorn-jsx">acorn-jsx</a> ，感谢<a href="https://github.com/RReverser">@RReverser</a> and <a href="https://github.com/marijnh">@marijnh</a></p></blockquote><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @babel/parser -g<br></code></pre></td></tr></table></figure><p>要装在哪里，是否全局安装，按照自己的情况来  </p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="解析函数"><a href="#解析函数" class="headerlink" title="解析函数"></a>解析函数</h3><ul><li><p>babelParser.parse(code, [options])<br><code>parse()</code>将提供的代码作为一个完整的<code>ECMAScript</code>程序进行解析  </p></li><li><p>babelParser.parseExpression(code, [options])<br>parseExpression() 用于解析单个<code>Expression</code>，当你性能比<code>parse()</code>要高  </p></li></ul><h4 id="Options参数"><a href="#Options参数" class="headerlink" title="Options参数"></a>Options参数</h4><ul><li><p>allowImportExportEverywhere<br>默认情况下，<code>import</code> 和 <code>export</code> 声明语句只能出现在程序的最顶层<br>把这个设置为<code>true</code>，可以使得语句在任何地方都可以声明  </p></li><li><p>allowAwaitOutsideFunction<br>默认情况下，仅在 异步函数内部 或 启用<code>topLevelAwait插件</code>时 在模块的顶层内允许使用<code>await</code><br>把这个设置为<code>true</code>，可以使得语句在任何地方都可以声明  </p></li><li><p>allowReturnOutsideFunction<br>默认情况下，如果在顶层中使用<code>return</code>语句会引起错误<br>把这个设置为<code>true</code>，就不会报错  </p></li><li><p>allowSuperOutsideMethod<br>默认情况下，在类和对象方法之外不允许使用<code>super</code><br>把这个设置为<code>true</code>就可以声明  </p></li><li><p>allowUndeclaredExports<br>默认情况下，<code>export</code>一个在当前作用域下未声明的内容会报错<br>把这个设置为<code>true</code>就可以防止解析器过早地抛出未声明的错误  </p></li><li><p>createParenthesizedExpressions<br>默认情况下，<code>parser</code>会在<code>expression</code>节点设置<code>extra.parenthesized</code><br>把这个设置为<code>true</code>，则会设置<code>ParenthesizedExpression</code>AST节点  </p></li><li><p>errorRecovery<br>默认情况下，如果<code>Babel</code>发现一些 不正常的代码 就会抛出错误<br>把这个设置为<code>true</code>，则会在保存解析错误的同时继续解析代码，错误的记录将被保存在 最终生成的AST的<code>errors</code>属性中<br>注意，那些严重的错误依然会终止解析  </p></li><li><p>plugins<br>记录希望启动的插件的数组  </p></li><li><p>sourceType<br>代码的解析方式，你可以填入<code>&quot;script&quot;</code>（默认）,<code>&quot;module&quot;</code> 或 <code>&quot;unambiguous&quot;</code><br>如果设置为”unambiguous”，那么系统会根据ES6语法中的<code>imports</code>和<code>export</code>来判断是<code>&quot;module&quot;</code>还是<code>&quot;script&quot;</code>  </p></li><li><p>sourceFilename<br>将输出的AST节点与其源文件名相关联<br>在你处理多个文件时，这个功能会很有用  </p></li><li><p>startLine<br>默认情况下，第一行代码就是<code>line 1</code>。你可以传入一个数字，作为起始行数<br>这个功能在你整合其他插件的时候会很有用  </p></li><li><p>strictMode<br>默认情况下，只有在声明了”use strict”条件下，ECMAScript代码才会被严格解析<br>将此选项设置为<code>true</code>则始终以严格模式解析文件  </p></li><li><p>ranges<br>添加ranges属性到每一个节点中  </p><blockquote><p>ranges: [node.start, node.end]</p></blockquote></li><li><p>tokens<br>将所有已经解析的<code>tokens</code>保存到<code>File</code>节点的<code>tokens</code>属性中  </p></li></ul><h2 id="输出-Output"><a href="#输出-Output" class="headerlink" title="输出 Output"></a>输出 Output</h2><p><code>Babel parser</code>是根据 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md">Babel AST format</a> 创建AST的<br>而<code>Babel AST format</code>是基于 <a href="https://github.com/estree/estree">ESTree 规范</a> 建立的  </p><p><a href="https://github.com/estree/estree/blob/master/es5.md#literal">ESTree 代码生成对应节点文档</a><br><a href="https://github.com/babel/babel/blob/master/packages/babel-parser/ast/spec.md#stringliteral">Babel parser 代码生成对应节点文档</a></p><blockquote><p><code>Babel parser</code>与ESTree的不同之处  </p><ul><li>用<a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#stringliteral"><code>StringLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#numericliteral"><code>NumericLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#booleanliteral"><code>BooleanLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#nullliteral"><code>NullLiteral</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#regexpliteral"><code>RegExpLiteral</code></a>取代<a href="https://github.com/estree/estree/blob/master/es5.md#literal"><code>Literal</code></a>  </li><li>用 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectproperty"><code>ObjectProperty</code></a> 和 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectmethod"><code>ObjectMethod</code></a>取代<a href="https://github.com/estree/estree/blob/master/es5.md#property"><code>Property</code></a>  </li><li>用<a href="https://github.com/estree/estree/blob/master/es2015.md#methoddefinition"><code>MethodDefinition</code></a>取代<a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#classmethod"><code>ClassMethod</code></a></li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#programs"><code>Program</code></a> and <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#blockstatement"><code>BlockStatement</code></a> 包含的<code>directives</code>用 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#directive"><code>Directive</code></a> 和 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#directiveliteral"><code>DirectiveLiteral</code></a>来填充  </li><li><a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#functionexpression"><code>FunctionExpression</code></a>中的 <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#classmethod"><code>ClassMethod</code></a>, <a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectproperty"><code>ObjectProperty</code></a>,<a href="https://github.com/babel/babel/tree/master/packages/babel-parser/ast/spec.md#objectmethod"><code>ObjectMethod</code></a>属性被引入到<code>main方法</code>节点中  </li></ul></blockquote><h2 id="Semver"><a href="#Semver" class="headerlink" title="Semver"></a>Semver</h2><p>大多数情况下<code>Babel Parser</code>会遵循<code>Semver</code>规定  </p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">require</span>(<span class="hljs-string">&quot;@babel/parser&quot;</span>).parse(<span class="hljs-string">&quot;code&quot;</span>, &#123;<br>  /<span class="hljs-regexp">/ parse in strict mode and allow module declarations</span><br><span class="hljs-regexp">  sourceType: &quot;module&quot;,</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">  plugins: [</span><br><span class="hljs-regexp">    /</span><span class="hljs-regexp">/ enable jsx and flow syntax</span><br><span class="hljs-regexp">    &quot;jsx&quot;,</span><br><span class="hljs-regexp">    &quot;flow&quot;</span><br><span class="hljs-regexp">  ]</span><br><span class="hljs-regexp">&#125;);</span><br></code></pre></td></tr></table></figure><p>剩余请看：<a href="https://www.babeljs.cn/docs/babel-parser">https://www.babeljs.cn/docs/babel-parser</a>  </p><h1 id="babel-traverse"><a href="#babel-traverse" class="headerlink" title="@babel/traverse"></a>@babel/traverse</h1><p>此库通常用于修改节点  </p><h2 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install @babel/traverse -g<br></code></pre></td></tr></table></figure><p>要装在哪里，是否全局安装，按照自己的情况来  </p><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> parser <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@babel/parser&quot;</span>;<br><span class="hljs-keyword">import</span> traverse <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;@babel/traverse&quot;</span>;<br><br><span class="hljs-keyword">const</span> code = <span class="hljs-string">`function square(n) &#123;</span><br><span class="hljs-string">  return n * n;</span><br><span class="hljs-string">&#125;`</span>;<br><br><span class="hljs-keyword">const</span> ast = parser.parse(code);<br><br>traverse(ast, &#123;<br>  <span class="hljs-function"><span class="hljs-title">enter</span>(<span class="hljs-params">path</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (path.isIdentifier(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;n&quot;</span> &#125;)) &#123;<br>      path.node.name = <span class="hljs-string">&quot;x&quot;</span>;<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="安装-3"><a href="#安装-3" class="headerlink" title="安装"></a>安装</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install --save @babel/traverse<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
      <tag>Babel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript-控制流平坦化</title>
    <link href="/post/1cf031df/"/>
    <url>/post/1cf031df/</url>
    
    <content type="html"><![CDATA[<h1 id="有用的链接"><a href="#有用的链接" class="headerlink" title="有用的链接"></a>有用的链接</h1><p>在线开源混淆工具：<a href="https://obfuscator.io/">https://obfuscator.io</a><br>在线AST解析：<a href="https://astexplorer.net/">https://astexplorer.net</a>  </p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>通过引入状态机与循环，破坏代码上下文之间的阅读连续性和代码块之间的关联性<br>将若干个分散的小整体整合成一个巨大的循环体  </p><ul><li>无法还原成原来具体的函数  </li><li>无法以函数为单位的调试方法，大幅度增加调试难度  </li><li>降低代码运行效率，提高爬虫运行时执行js的资源成本  </li><li>可根据js运行时检测到的某些因素自由跳转到蜜罐或跳出代码执行  </li></ul><h2 id="描述过程的简单例子"><a href="#描述过程的简单例子" class="headerlink" title="描述过程的简单例子"></a>描述过程的简单例子</h2><p><img src="/javascript-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96/20200831124831164.png">  例如图中的方式就是 将代码运行流程交给一个变量<code>next</code>来控制<br>每次执行完一小段代码后，都修改next的值，使得下次判断会执行另外的代码块  </p><h2 id="常见实现方式"><a href="#常见实现方式" class="headerlink" title="常见实现方式"></a>常见实现方式</h2><ol><li>多维数组<br><img src="/javascript-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96/20200831010457188.png">  </li><li>数值比较<br><img src="/javascript-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96/20200831010519241.png">  </li></ol><h3 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h3><p><img src="/javascript-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96/20200831010617054.png"></p><h1 id="小规模控制流平坦化处理"><a href="#小规模控制流平坦化处理" class="headerlink" title="小规模控制流平坦化处理"></a>小规模控制流平坦化处理</h1><h2 id="准备实验代码"><a href="#准备实验代码" class="headerlink" title="准备实验代码"></a>准备实验代码</h2><p>首先写一段js源码  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> i = [<span class="hljs-number">101</span>, <span class="hljs-number">102</span>, <span class="hljs-number">103</span>, <span class="hljs-number">104</span>, <span class="hljs-number">105</span>, <span class="hljs-number">106</span>, <span class="hljs-number">107</span>];<br>  i[<span class="hljs-number">1</span>] = i[<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>  output_str = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> ind=<span class="hljs-number">0</span>; ind &lt; i.length; ind++)&#123;<br>  output_str.push(<span class="hljs-built_in">String</span>.fromCharCode(i[ind]))<br>  &#125;<br>  <span class="hljs-keyword">return</span> output_str<br>&#125;<br><span class="hljs-built_in">console</span>.log(test().join(<span class="hljs-string">&#x27;&#x27;</span>))<br></code></pre></td></tr></table></figure><p>拿去在线混淆网站混淆  <a href="https://obfuscator.io/">https://obfuscator.io/</a><br><img src="/javascript-%E6%8E%A7%E5%88%B6%E6%B5%81%E5%B9%B3%E5%9D%A6%E5%8C%96/20200831010352740.png"><br>输入原代码以后在下方设置混淆选项<br>然后点混淆拿到混淆后的代码，重新格式化以后拿到    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> _0xf74e59 = &#123;<br>        <span class="hljs-string">&#x27;IvmKa&#x27;</span>: <span class="hljs-string">&#x27;1|3|2|0|4&#x27;</span>,<br>        <span class="hljs-string">&#x27;Ndyet&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x419593, _0x22a11f</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> _0x419593 &lt; _0x22a11f;<br>        &#125;,<br>        <span class="hljs-string">&#x27;STiJR&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x2d5759, _0x3449ae</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> _0x2d5759 + _0x3449ae;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">var</span> _0x42bf99 = _0xf74e59[<span class="hljs-string">&#x27;IvmKa&#x27;</span>][<span class="hljs-string">&#x27;split&#x27;</span>](<span class="hljs-string">&#x27;|&#x27;</span>);<br>    <span class="hljs-keyword">var</span> _0x3c36ca = <span class="hljs-number">0x0</span>;<br>    <span class="hljs-keyword">while</span> (!![]) &#123;<br>        <span class="hljs-keyword">switch</span> (_0x42bf99[_0x3c36ca++]) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _0x27bf7e = <span class="hljs-number">0x0</span>; _0xf74e59[<span class="hljs-string">&#x27;Ndyet&#x27;</span>](_0x27bf7e, _0x18a535[<span class="hljs-string">&#x27;length&#x27;</span>]); _0x27bf7e++) &#123;<br>                    output_str[<span class="hljs-string">&#x27;push&#x27;</span>](<span class="hljs-built_in">String</span>[<span class="hljs-string">&#x27;fromCharCode&#x27;</span>](_0x18a535[_0x27bf7e]));<br>                &#125;<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:<br>                <span class="hljs-keyword">var</span> _0x18a535 = [<span class="hljs-number">0x65</span>, <span class="hljs-number">0x66</span>, <span class="hljs-number">0x67</span>, <span class="hljs-number">0x68</span>, <span class="hljs-number">0x69</span>, <span class="hljs-number">0x6a</span>, <span class="hljs-number">0x6b</span>];<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:<br>                output_str = [];<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:<br>                _0x18a535[<span class="hljs-number">0x1</span>] = _0xf74e59[<span class="hljs-string">&#x27;STiJR&#x27;</span>](_0x18a535[<span class="hljs-number">0x1</span>], <span class="hljs-number">0x1</span>);<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:<br>                <span class="hljs-keyword">return</span> output_str;<br>        &#125;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>[<span class="hljs-string">&#x27;log&#x27;</span>](test()[<span class="hljs-string">&#x27;join&#x27;</span>](<span class="hljs-string">&#x27;&#x27;</span>));<br></code></pre></td></tr></table></figure><p>代码特点：有一个循环来控制代码运行流程  </p><h2 id="处理思路"><a href="#处理思路" class="headerlink" title="处理思路"></a>处理思路</h2><ol><li>全局观察<br>大致观察每一个代码结构  </li></ol><ul><li><p>是否有类似于<code>DOM</code>操作的代码<br>Node.js环境下课没有DOM这种东西，运行会报错  </p></li><li><p>是否为纯计算型的循环体<br>如果只是纯粹的计算，那么拿到结果就好，过程并不重要<br>比如说上面的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _0xf74e59 = &#123;<br>    <span class="hljs-string">&#x27;IvmKa&#x27;</span>: <span class="hljs-string">&#x27;1|3|2|0|4&#x27;</span>,<br>    <span class="hljs-string">&#x27;Ndyet&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x419593, _0x22a11f</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> _0x419593 &lt; _0x22a11f;<br>    &#125;,<br>    <span class="hljs-string">&#x27;STiJR&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">_0x2d5759, _0x3449ae</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> _0x2d5759 + _0x3449ae;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种赋值，切割字符之类的，无二义性的东西直接记录一下结果就过了，不用管过程  </p></li><li><p>是否有<code>try-catch</code>异常捕获结构<br>比如说用<code>try-catch</code>包围一个DOM操作，Node.js执行的时候报错，捕获到错误以后，相当于代码识别出你不是浏览器了，之后就可以跳转到死机代码或直接跳出，达到防御目的  </p></li></ul><ol start="2"><li>整体分析与载入<br>推荐断点位置：</li></ol><ul><li>断点定于while开头部分  </li><li>断点定于try代码体第一行  </li></ul><p>while循环体整体取出构造原始函数  </p><ol start="3"><li>构造函数<br>查缺补漏，在运行过程中通过不断地运行报错，补充确实的函数或数据  </li></ol><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>对于小型的代码混淆，也许你还能看得出入口和出口大概是在什么地方<br>但对于那种动则几千行的大型混淆来说，几乎就不能看出什么东西来了  </p><blockquote><p>大型代码混淆指不定会有蜜罐<br>比如说发现你没有DOM，给你吐脏数据<br>比如说上下两步操作实践超过时长，判定你打了断点，让你死机  </p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>由于这个函数没有传递参数，是相对固定的执行条件，那么可以通过输出每次执行的代码来得到代码的执行顺序<br>添加输出的这个操作可以通过AST来实现  </p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>将代码丢进 <a href="https://astexplorer.net/">https://astexplorer.net/</a> 进行AST分析  </p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Puppeteer-Pyppeteer</title>
    <link href="/post/54ad1f51/"/>
    <url>/post/54ad1f51/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Puppeteer</code>是一个<code>Node</code> 库，它提供了一个高级 API 来通过 <code>DevTools</code> 协议控制 <code>Chromium</code> 或 <code>Chrome</code><br>有开发者开源了支持Python的<code>Puppeteer</code>库，名为<code>Pyppeteer</code></p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><table><thead><tr><th>内容</th><th>链接</th></tr></thead><tbody><tr><td>Puppeteer Github地址</td><td><a href="https://github.com/puppeteer/puppeteer">https://github.com/puppeteer/puppeteer</a></td></tr><tr><td>Pyppeteer Github地址</td><td><a href="https://github.com/miyakogi/pyppeteer">https://github.com/miyakogi/pyppeteer</a></br><a href="https://github.com/pyppeteer/pyppeteer">https://github.com/pyppeteer/pyppeteer</a></td></tr><tr><td>Pyppeteer 官方文档</td><td><a href="https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.browser.Browser">https://miyakogi.github.io/pyppeteer/ref……</a></td></tr><tr><td>Pyppeteer 网友中文文档</td><td><a href="https://blog.zhangkunzhi.com/2019/05/13/pyppeteer%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%89%8B%E5%86%8C/index.html">https://blog.zhangkunzhi.com/2019/0…..</a></td></tr></tbody></table><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Puppeteer只能运行在python3.6+环境中  </p><p>Puppeteer API 是分层次的，反映了浏览器结构  </p><blockquote><p>注意：在下面的图表中，浅色框体内容目前不在 Puppeteer 中体现  </p></blockquote><p><img src="/Puppeteer-Pyppeteer/20200822070824427.png">  </p><p><code>Puppeteer</code> 使用 <code>DevTools</code> 协议 与浏览器进行通信。<br><code>Browser</code> 实例可以拥有浏览器上下文。<br><code>BrowserContext</code> 实例定义了一个浏览会话并可拥有多个页面。<br><code>Page</code> 至少有一个框架：主框架。 可能还有其他框架由 <code>iframe</code> 或 框<code>架标签</code> 创建。<br><code>frame</code> 至少有一个执行上下文 - 默认的执行上下文 - 框架的 <code>JavaScript</code> 被执行。 一个框架可能有额外的与 扩展 关联的执行上下文。<br>Worker 具有单一执行上下文，并且便于与 WebWorkers 进行交互。</p><h1 id="部分官方文档-中文文档-实践"><a href="#部分官方文档-中文文档-实践" class="headerlink" title="部分官方文档 中文文档 实践"></a>部分官方文档 中文文档 实践</h1><h2 id="0-Hello-World"><a href="#0-Hello-World" class="headerlink" title="0_Hello World"></a>0_Hello World</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   0_hello_world.py</span><br><span class="hljs-string">@Time    :   2020/08/22 19:01:03</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   pyppeteer Hello world 在第一次运行这个程序的时候，pyppeteer会从网上自己下载Chromium</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 创建浏览器对象</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>&#125;)<br>    <span class="hljs-comment"># 打开一个页面</span><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-comment"># 页面访问一个连接</span><br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br>    <span class="hljs-comment"># 给网页弄个截图</span><br>    <span class="hljs-keyword">await</span> page.screenshot(&#123;<span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;example/0_Basic_usage_of_the_library/pyppeteer/baidu.png&#x27;</span>&#125;)<br>    <span class="hljs-comment"># 关闭浏览器</span><br>    <span class="hljs-keyword">await</span> browser.close()<br><br>asyncio.get_event_loop().run_until_complete(main())<br><br></code></pre></td></tr></table></figure><h2 id="1-Launch-args"><a href="#1-Launch-args" class="headerlink" title="1_Launch_args"></a>1_Launch_args</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   1_launch_args.py</span><br><span class="hljs-string">@Time    :   2020/08/22 19:31:40</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   None</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 创建浏览器对象</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-comment"># 无头模式</span><br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-comment"># 忽略https错误，默认false</span><br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-comment"># 界面大小</span><br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-comment"># 脚本执行完后是否自动关闭浏览器</span><br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-comment"># Chromium 或者 Chrome 的路径,如果填入的话，就不用默认的 Chromium</span><br>        <span class="hljs-comment"># &#x27;executablePath&#x27;: &#x27;&#x27;</span><br>        <span class="hljs-comment"># 用户数据目录的路径</span><br>        <span class="hljs-comment"># &#x27;userDataDir&#x27;: &#x27;example/0_Basic_usage_of_the_library/pyppeteer/&#x27;,</span><br>        <span class="hljs-comment"># 打印日志的日志级别。默认与根记录器</span><br>        <span class="hljs-comment"># &#x27;log level&#x27;: &#x27;&#x27;</span><br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br>    <span class="hljs-keyword">await</span> page.screenshot(&#123;<span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;example/0_Basic_usage_of_the_library/pyppeteer/baidu.png&#x27;</span>&#125;)<br>    <span class="hljs-keyword">await</span> browser.close()<br><br>asyncio.get_event_loop().run_until_complete(main())<br><br></code></pre></td></tr></table></figure><h2 id="2-BrowserClass"><a href="#2-BrowserClass" class="headerlink" title="2_BrowserClass"></a>2_BrowserClass</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   2_BrowserClass.py</span><br><span class="hljs-string">@Time    :   2020-8-22 20:20:16</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   浏览器类相关</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    <span class="hljs-comment"># 创建浏览器对象</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    <span class="hljs-comment"># 创建一个新页面</span><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br><br>    <span class="hljs-comment"># 创建一个无痕模式浏览器内容， 以无痕模式内容浏览东西的话不会报错cookie之类的数据</span><br>    <span class="hljs-comment"># context = await browser.createIncognitoBrowserContext()</span><br>    <span class="hljs-comment"># page = await context.newPage()</span><br>    <span class="hljs-comment"># await page.goto(&#x27;https://example.com&#x27;)</span><br><br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    <span class="hljs-comment"># 获取网页中的所有内容</span><br>    c = browser.browserContexts<br>    print(c)<br><br>    <span class="hljs-comment"># 返回浏览器进程</span><br>    c = browser.process<br>    print(c)<br><br>    <span class="hljs-comment"># 返回浏览器UerAgent</span><br>    c = browser.userAgent<br>    print(c)<br><br>    <span class="hljs-comment"># 断开连接</span><br>    browser.disconnect()<br><br>asyncio.get_event_loop().run_until_complete(main())<br><br></code></pre></td></tr></table></figure><h2 id="3-BrowserContextClass"><a href="#3-BrowserContextClass" class="headerlink" title="3_BrowserContextClass"></a>3_BrowserContextClass</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   3_BrowserContextClass.py</span><br><span class="hljs-string">@Time    :   2020-8-22 20:20:16</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   浏览器内容类相关 BrowserContext Class</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">BrowserContext 类 提供了多个独立的浏览器会话  </span><br><span class="hljs-string">当浏览器启动，浏览器会创建一个默认的 BrowserContext实例，这个实例中包含了一个默认的page</span><br><span class="hljs-string">如果一个 BrowserContext实例 通过window.open打开了新的BrowserContext实例，那么新实例会附属于旧实例</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    context = browser.browserContexts[<span class="hljs-number">0</span>]<br><br>    <span class="hljs-comment"># 返回BrowserContext实例的浏览器</span><br>    c = context.browser<br>    print(c)<br><br>    <span class="hljs-comment"># 返回BrowserContext中所有激活的target</span><br>    c = context.targets()<br>    print(c)<br><br>    <span class="hljs-comment"># 关闭BrowserContext实例，属于其下的子BrowserContext实例也会被一并关闭</span><br>    context.close()<br><br><br>asyncio.get_event_loop().run_until_complete(main())<br><br></code></pre></td></tr></table></figure><h2 id="4-PageClass-Selector"><a href="#4-PageClass-Selector" class="headerlink" title="4_PageClass_Selector"></a>4_PageClass_Selector</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   4_PageClass_Selector.py</span><br><span class="hljs-string">@Time    :   2020-8-22 20:20:16</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   页面类 Page Class</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">Page类提供了与标签交互的方法，一个浏览器可以有多个Page对象</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.J(selector: str) 或者 Page.uerySelector() </span><br>    <span class="hljs-comment"># 方法可以通过 选择器 获取一个元素</span><br>    <span class="hljs-comment"># 如果方法找到与选择器匹配的元素，则返回其ElementHandle实例。如果没有找到，返回None。</span><br>    c = <span class="hljs-keyword">await</span> page.J(<span class="hljs-string">&quot;#s_lg_img&quot;</span>)<br>    print(c)<br><br>    <span class="hljs-comment"># Page.JJ(selector: str) 或者 Page.querySelectorAll()</span><br>    <span class="hljs-comment"># 方法可以通过 选择器 获取一些元素</span><br>    c = <span class="hljs-keyword">await</span> page.JJ(<span class="hljs-string">&quot;.c-color-gray2&quot;</span>)<br>    print(c)<br><br>    <span class="hljs-comment"># Page.Jeval(selector: str, pageFunction: str, *args) 或者 Page.querySelectorEval()</span><br>    <span class="hljs-comment"># 方法可以通过 选择器 获取 一个元素 ，并且将元素作为参数，传入到pageFunction中执行一些代码</span><br>    <span class="hljs-comment"># 如果这个函数没有找到匹配的元素，会报错</span><br>    <span class="hljs-comment"># 参数:</span><br>    <span class="hljs-comment"># selector 选择器字符串</span><br>    <span class="hljs-comment"># pageFunction (str) javascript回调函数，在找到元素一些以后，元素会以数组的形式当做一个参数传入到定义的回调函数中</span><br>    <span class="hljs-comment"># args (Any) – 可以传给pageFunction的参数</span><br>    c = <span class="hljs-keyword">await</span> page.Jeval(<span class="hljs-string">&quot;#s_lg_img&quot;</span>, <span class="hljs-string">&quot;function zxc(a)&#123;return &#x27;Found Element :&#x27; + a&#125;&quot;</span>)<br>    print(c)<br><br>    <span class="hljs-comment"># Page.JJeval(selector: str, pageFunction: str, *args) 或者 Page.querySelectorAllEval()</span><br>    <span class="hljs-comment"># 方法可以通过 选择器 获取 一些元素 ，并且将元素作为参数，传入到pageFunction中执行一些代码</span><br>    <span class="hljs-comment"># 如果这个函数没有找到匹配的元素，会报错</span><br>    <span class="hljs-comment"># 参数同上</span><br>    c = <span class="hljs-keyword">await</span> page.JJeval(<span class="hljs-string">&quot;.c-color-gray2&quot;</span>, <span class="hljs-string">&quot;function zxc(a)&#123;return &#x27;Found Element :&#x27; + a&#125;&quot;</span>)<br>    print(c)<br><br>    <span class="hljs-comment"># Page.Jx(expression: str) 或者 xpath()</span><br>    <span class="hljs-comment"># 传入xpath表达式，返回结果为list</span><br>    c = <span class="hljs-keyword">await</span> page.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;s_lg_img&quot;]&#x27;</span>)<br>    print(c)<br><br><br>asyncio.get_event_loop().run_until_complete(main())<br><br></code></pre></td></tr></table></figure><h2 id="5-PageClass-Operations"><a href="#5-PageClass-Operations" class="headerlink" title="5_PageClass_Operations"></a>5_PageClass_Operations</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   5_PageClass_Operations.py</span><br><span class="hljs-string">@Time    :   2020-8-22 23:03:54</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   页面类 Page Class</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">Page类提供了与标签交互的方法，一个浏览器可以有多个Page对象</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.url</span><br>    <span class="hljs-comment"># 返回页面url</span><br>    c = page.url<br>    print(c)<br><br>    <span class="hljs-comment"># Page.viewport</span><br>    <span class="hljs-comment"># 得到页面viewport信息</span><br>    c = page.viewport<br>    print(c)<br><br>    <span class="hljs-comment"># Page.title()</span><br>    <span class="hljs-comment"># 返回页面标题</span><br>    c = <span class="hljs-keyword">await</span> page.title()<br>    print(c)<br><br>    <span class="hljs-comment"># Page.touchscreen</span><br>    <span class="hljs-comment"># 返回页面Touchscreen对象</span><br>    c = page.touchscreen<br>    print(c)<br><br>    <span class="hljs-comment"># Page.tracing</span><br>    <span class="hljs-comment"># 返回页面追踪对象</span><br>    c = page.tracing<br>    print(c)<br><br>    <span class="hljs-comment"># Page.mouse</span><br>    <span class="hljs-comment"># 得到页面的 Mouse 对象</span><br>    c = page.mouse<br>    print(c)<br><br>    <span class="hljs-comment"># isClosed() → bool[source]</span><br>    <span class="hljs-comment"># 页面是否已经关闭</span><br>    c = page.isClosed()<br>    print(c)<br><br>    <span class="hljs-comment"># keyboard</span><br>    <span class="hljs-comment"># 得到页面的 keyboard 对象</span><br>    c = page.keyboard<br>    print(c)<br><br>    <span class="hljs-comment"># mainFrame</span><br>    <span class="hljs-comment"># 得到页面的 Frame 对象</span><br>    c = page.mainFrame<br>    print(c)<br><br>    <span class="hljs-comment"># Page.content() → str</span><br>    <span class="hljs-comment"># 返回页面html</span><br>    c = <span class="hljs-keyword">await</span> page.content()<br>    print(c)<br><br><br>asyncio.get_event_loop().run_until_complete(main())<br></code></pre></td></tr></table></figure><h2 id="6-PageClass-JS"><a href="#6-PageClass-JS" class="headerlink" title="6_PageClass_JS"></a>6_PageClass_JS</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   6_PageClass_JS.py</span><br><span class="hljs-string">@Time    :   2020-8-23 01:11:00</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   页面类 Page Class</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">Page类提供了与标签交互的方法，一个浏览器可以有多个Page对象</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.evaluate(pageFunction: str, *args, force_expr: bool = False) → Any</span><br>    <span class="hljs-comment"># 执行js代码，并返回结果</span><br>    <span class="hljs-comment"># 参数</span><br>    <span class="hljs-comment">#   pageFunction (str) – js代码</span><br>    <span class="hljs-comment">#   force_expr (bool) – If True, evaluate pageFunction as expression. If False (default), try to automatically detect function or expression.</span><br>    c = <span class="hljs-keyword">await</span> page.evaluate(<span class="hljs-string">&#x27;function a()&#123;return &#123;&quot;Hello&quot;:&quot;Page.evaluate&quot;&#125;;&#125;&#x27;</span>)<br>    print(c)<br><br>    <span class="hljs-comment"># Page.evaluateHandle(pageFunction: str, *args) → pyppeteer.execution_context.JSHandle</span><br>    <span class="hljs-comment"># 在页面上执行一个js代码,返回一个JSHandle对象</span><br>    c = <span class="hljs-keyword">await</span> page.evaluateHandle(<span class="hljs-string">&#x27;document.getElementById(&quot;bottom_layer&quot;);&#x27;</span>)<br>    print(c)<br><br><br>asyncio.get_event_loop().run_until_complete(main())<br>python<br></code></pre></td></tr></table></figure><h2 id="7-PageClass-Cookie"><a href="#7-PageClass-Cookie" class="headerlink" title="7_PageClass_Cookie"></a>7_PageClass_Cookie</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   7_PageClass_Cookie.py</span><br><span class="hljs-string">@Time    :   2020-8-23 01:33:25</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   页面类 Page Class</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">Page类提供了与标签交互的方法，一个浏览器可以有多个Page对象</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.cookies(*urls) → dict</span><br>    <span class="hljs-comment"># 获取Cookie</span><br>    <span class="hljs-comment"># 如果指定url那就返回那个url的Cookie，没指定就返回当前页面Cookie</span><br>    c = <span class="hljs-keyword">await</span> page.cookies()<br>    print(c)<br><br>    <span class="hljs-comment"># Page.deleteCookie(*cookies)</span><br>    <span class="hljs-comment"># 删除Cookie</span><br>    <span class="hljs-comment"># cookies可以填入的参数</span><br>    <span class="hljs-comment">#   name (str): 必须传入</span><br>    <span class="hljs-comment">#   url (str)</span><br>    <span class="hljs-comment">#   domain (str)</span><br>    <span class="hljs-comment">#   path (str)</span><br>    <span class="hljs-comment">#   secure (bool)</span><br>    <span class="hljs-keyword">await</span> page.deleteCookie(&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;BAIDUID&#x27;</span>&#125;)<br><br>    <span class="hljs-comment"># Page.setCookie(*cookies) → None[source]</span><br>    <span class="hljs-comment"># 设置Cookie</span><br>    <span class="hljs-comment"># 可选Cookie的参数：</span><br>    <span class="hljs-comment">#   name (str): required</span><br>    <span class="hljs-comment">#   value (str): required</span><br>    <span class="hljs-comment">#   url (str)</span><br>    <span class="hljs-comment">#   domain (str)</span><br>    <span class="hljs-comment">#   path (str)</span><br>    <span class="hljs-comment">#   expires (number): Unix time in seconds</span><br>    <span class="hljs-comment">#   httpOnly (bool)</span><br>    <span class="hljs-comment">#   secure (bool)</span><br>    <span class="hljs-comment">#   sameSite (str): &#x27;Strict&#x27; or &#x27;Lax&#x27;</span><br><br><br>asyncio.get_event_loop().run_until_complete(main())<br></code></pre></td></tr></table></figure><h2 id="8-PageClass-Wait"><a href="#8-PageClass-Wait" class="headerlink" title="8_PageClass_Wait"></a>8_PageClass_Wait</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   8_PageClass_Wait.py</span><br><span class="hljs-string">@Time    :   2020-8-24 12:38:10</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   页面类 Page Class</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">Page类提供了与标签交互的方法，一个浏览器可以有多个Page对象</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.waitFor(selectorOrFunctionOrTimeout: Union[str, int, float], options: dict = None, *args, **kwargs) → Awaitable[T_co]</span><br>    <span class="hljs-comment"># 等待函数执行，超时，元素出现。</span><br>    <span class="hljs-comment"># 这个函数的作用会因为第一个参数传入不同的内容而不同</span><br>    <span class="hljs-comment">#   如果selectorOrFunctionOrTimeout是number (int或float)，那么它将被视为超时(以毫秒为单位)，并返回在超时后执行的future。</span><br>    <span class="hljs-comment">#   如果selectorOrFunctionOrTimeout是一个JavaScript函数字符串，那么这个方法是waitForFunction()的快捷方式。</span><br>    <span class="hljs-comment">#   如果selectorOrFunctionOrTimeout是选择器字符串或xpath字符串，则此方法是waitForSelector（）或waitForXPath（）的快捷方式。 如果字符串以//开头，则将该字符串视为xpath。</span><br>    <span class="hljs-comment"># Pyppeteer尝试自动检测功能或选择器，但有时会漏检。</span><br>    <span class="hljs-comment"># 如果不能按预期工作，请直接使用waitForFunction（）或waitForSelector（）。</span><br>    <span class="hljs-comment"># 参数：</span><br>    <span class="hljs-comment">#   selectorOrFunctionOrTimeout – 选择器, xpath, 函数名 或者时间数字（毫秒）.</span><br>    <span class="hljs-comment">#   args (Any) – 传递给函数的参数</span><br>    <span class="hljs-comment"># 返回值:</span><br>    <span class="hljs-comment">#   Return awaitable object which resolves to a JSHandle of the success value.</span><br><br><br>    <span class="hljs-comment"># Page.waitForFunction(pageFunction: str, options: dict = None, *args, **kwargs) → Awaitable[T_co]</span><br>    <span class="hljs-comment"># 等待，直到函数完成并返回一个值</span><br>    <span class="hljs-comment"># Parameters:args (Any) – 传递给 pageFunction 的参数.</span><br>    <span class="hljs-comment"># Returns:Return awaitable object which resolves when the pageFunction returns a truthy value. It resolves to a JSHandle of the truthy value.</span><br>    <span class="hljs-comment"># 可选参数:</span><br>    <span class="hljs-comment">#   polling (str|number): pageFunction 执行间隔, 默认是 raf. 如果参数传入一个数字，那么它将被视为函数执行的毫秒间隔</span><br>    <span class="hljs-comment">#       raf: 不断执行requestAnimationFrame回调中的pageFunction. This is the tightest polling mode which is suitable to observe styling changes.</span><br>    <span class="hljs-comment">#       mutation: 在每次DOM更变的时候执行 pageFunction</span><br>    <span class="hljs-comment">#   timeout (int|float): 最大等待时间 毫秒. 默认为 30000 (30 seconds). 传入0可以禁用此项.</span><br><br>    <span class="hljs-comment"># Page.waitForNavigation(options: dict = None, **kwargs) → Optional[pyppeteer.network_manager.Response]</span><br>    <span class="hljs-comment"># 等待 导航navigation</span><br>    <span class="hljs-comment"># 参数和goto()相同</span><br>    <span class="hljs-comment"># 当页面导航到新URL或重新加载时，这将返回Response</span><br>    <span class="hljs-comment"># 运行将间接导致页面导航的代码时，它很有用</span><br>    navigationPromise = page.waitForNavigation()<br>    <span class="hljs-keyword">await</span> page.click(<span class="hljs-string">&#x27;#bottom_layer &gt; div.s-bottom-layer-left &gt; p:nth-child(5) &gt; a&#x27;</span>)<br>    <span class="hljs-keyword">await</span> navigationPromise  <span class="hljs-comment"># 等待，直到导航结束</span><br><br>    <span class="hljs-comment"># Page.waitForRequest(urlOrPredicate: Union[str, Callable[[pyppeteer.network_manager.Request], bool]], options: Dict[KT, VT] = None, **kwargs) → pyppeteer.network_manager.Request</span><br>    <span class="hljs-comment"># 等待Request</span><br>    <span class="hljs-comment"># 参数:</span><br>    <span class="hljs-comment">#   urlOrPredicate – 等待的url</span><br>    <span class="hljs-comment">#   选项:</span><br>    <span class="hljs-comment">#       timeout (int|float): 最大等待时间, 默认为 30 秒, 传入0禁用此项.</span><br>    <span class="hljs-keyword">await</span> page.waitForRequest(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br>    <span class="hljs-keyword">await</span> page.waitForRequest(<span class="hljs-keyword">lambda</span> req: req.url == <span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span> <span class="hljs-keyword">and</span> req.method == <span class="hljs-string">&#x27;GET&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.waitForResponse(urlOrPredicate: Union[str, Callable[[pyppeteer.network_manager.Response], bool]], options: Dict[KT, VT] = None, **kwargs) → pyppeteer.network_manager.Response</span><br>    <span class="hljs-comment"># 等待Response</span><br>    <span class="hljs-comment"># 参数同Page.waitForRequest</span><br><br>    <span class="hljs-comment"># Page.waitForSelector(selector: str, options: dict = None, **kwargs) → Awaitable[T_co]</span><br>    <span class="hljs-comment"># 等待与选择器匹配的元素出现，要是页面已经有了匹配的元素，那么会立即返回</span><br>    <span class="hljs-comment"># Returns:Return awaitable object which resolves when element specified by selector string is added to DOM.</span><br>    <span class="hljs-comment"># 参数:</span><br>    <span class="hljs-comment">#   selector (str) – 选择器</span><br>    <span class="hljs-comment">#   可选项：</span><br>    <span class="hljs-comment">#       visible (bool):等待元素在DOM中出现，并且可见; i.e. to not have display: none or visibility: hidden CSS properties. Defaults to False.</span><br>    <span class="hljs-comment">#       hidden (bool): 等待元素在DOM中出现，隐藏的都算, i.e. have display: none or visibility: hidden CSS properties. Defaults to False.</span><br>    <span class="hljs-comment">#       timeout (int|float): 最大等待时间（毫秒）.默认为30000 (30 秒). 传递0禁用此项.</span><br><br>    <span class="hljs-comment"># Page.waitForXPath(xpath: str, options: dict = None, **kwargs) → Awaitable[T_co]</span><br>    <span class="hljs-comment"># 等待与xpath匹配的元素出现，要是页面已经有了匹配的元素，那么会立即返回</span><br>    <span class="hljs-comment"># 参数同 Page.waitForSelector</span><br><br>asyncio.get_event_loop().run_until_complete(main())<br><br></code></pre></td></tr></table></figure><h2 id="9-PageClass-Other"><a href="#9-PageClass-Other" class="headerlink" title="9_PageClass_Other"></a>9_PageClass_Other</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   9_PageClass_Other.py</span><br><span class="hljs-string">@Time    :   2020-8-22 23:03:54</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   页面类 Page Class</span><br><span class="hljs-string">    官方文档：https://miyakogi.github.io/pyppeteer/reference.html#pyppeteer.page.Page.target</span><br><span class="hljs-string">Page类提供了与标签交互的方法，一个浏览器可以有多个Page对象</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> asyncio<br><span class="hljs-keyword">from</span> pyppeteer <span class="hljs-keyword">import</span> launch<br><br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span><br>    browser = <span class="hljs-keyword">await</span> launch(&#123;<br>        <span class="hljs-string">&#x27;headless&#x27;</span>: <span class="hljs-literal">False</span>,<br>        <span class="hljs-string">&#x27;ignorehttpserrrors&#x27;</span>: <span class="hljs-literal">True</span>,<br>        <span class="hljs-string">&#x27;viewport&#x27;</span>: &#123;<span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1280</span>, <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">800</span>&#125;,<br>        <span class="hljs-string">&#x27;autoClose&#x27;</span>: <span class="hljs-literal">True</span>,<br>        &#125;)<br><br>    page = <span class="hljs-keyword">await</span> browser.newPage()<br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.addScriptTag(options: Dict[KT, VT] = None, **kwargs) → pyppeteer.element_handle.ElementHandle</span><br>    <span class="hljs-comment"># 给页面添加一个script标签，可以写入一些东西</span><br>    <span class="hljs-comment"># url, path, content三个参数中必须选一个填入</span><br>    <span class="hljs-comment"># 会返回已经被添加好的 ElementHandle 实例</span><br>    <span class="hljs-comment"># 参数：</span><br>    <span class="hljs-comment">#   url (string): URL of a script to add.</span><br>    <span class="hljs-comment">#   path (string): Path to the local JavaScript file to add.</span><br>    <span class="hljs-comment">#   content (string): JavaScript string to add.</span><br>    <span class="hljs-comment">#   type (string): Script type. Use module in order to load a JavaScript ES6 module</span><br>    <span class="hljs-keyword">await</span> page.addScriptTag(&#123;<br>        <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;console.log(&#x27;Hello addScriptTag&#x27;)&quot;</span><br>    &#125;)<br><br>    <span class="hljs-comment"># Page.addStyleTag(options: Dict[KT, VT] = None, **kwargs) → pyppeteer.element_handle.ElementHandle</span><br>    <span class="hljs-comment"># 给页面添加一个style标签，可以写入一些东西</span><br>    <span class="hljs-comment"># url, path, content三个参数中必须选一个填入</span><br>    <span class="hljs-comment"># 参数：</span><br>    <span class="hljs-comment">#   url (string): URL of the link tag to add.</span><br>    <span class="hljs-comment">#   path (string): Path to the local CSS file to add.</span><br>    <span class="hljs-comment">#   content (string): CSS string to add.</span><br>    <span class="hljs-keyword">await</span> page.addScriptTag(&#123;<br>        <span class="hljs-string">&quot;url&quot;</span>: <span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/twitter-bootstrap/5.0.0-alpha1/css/bootstrap.css&quot;</span><br>    &#125;)<br><br>    <span class="hljs-comment"># Page.bringToFront 将页面置于最前（激活选项卡）</span><br>    <span class="hljs-keyword">await</span> page.bringToFront()<br><br>    <span class="hljs-comment"># Page.click(selector: str, options: dict = None, **kwargs)</span><br>    <span class="hljs-comment"># 此方法使用选择器获取元素，如果需要，将其滚动到视图中，然后使用鼠标在元素的中心单击</span><br>    <span class="hljs-comment"># 如果没有元素匹配选择器，该方法将引发PageError</span><br>    <span class="hljs-comment"># 参数</span><br>    <span class="hljs-comment">#   button (str): left, right, or middle, defaults to left.</span><br>    <span class="hljs-comment">#   clickCount (int): defaults to 1.</span><br>    <span class="hljs-comment">#   delay (int|float): Time to wait between mousedown and mouseup in milliseconds. defaults to 0.</span><br>    <span class="hljs-keyword">await</span> page.click(<span class="hljs-string">&#x27;#su&#x27;</span>)<br><br><br>    <span class="hljs-comment">#  Page.setUserAgent(userAgent: str)</span><br>    <span class="hljs-comment">#  设置UserAgent</span><br>    <span class="hljs-keyword">await</span> page.setUserAgent(<span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36&#x27;</span>)<br><br>    <span class="hljs-comment"># Page.setViewport(viewport: dict)</span><br>    <span class="hljs-comment"># 设置Viewport</span><br>    <span class="hljs-comment"># 可填入选项：</span><br>    <span class="hljs-comment">#   width (int): page width in pixel.</span><br>    <span class="hljs-comment">#   height (int): page height in pixel.</span><br>    <span class="hljs-comment">#   deviceScaleFactor (float): Default to 1.0.</span><br>    <span class="hljs-comment">#   isMobile (bool): Default to False.</span><br>    <span class="hljs-comment">#   hasTouch (bool): Default to False.</span><br>    <span class="hljs-comment">#   isLandscape (bool): Default to False.</span><br>    <span class="hljs-keyword">await</span> page.setViewport(&#123;<br>        <span class="hljs-string">&#x27;width&#x27;</span>: <span class="hljs-number">1024</span>,<br>        <span class="hljs-string">&#x27;height&#x27;</span>: <span class="hljs-number">1024</span>,<br>    &#125;)<br><br>    <span class="hljs-comment"># Page.emulateMedia(mediaType: str = None)</span><br>    <span class="hljs-comment"># 设置CSS  media type</span><br>    <span class="hljs-comment"># 你可以填入 &#x27;screen&#x27;, &#x27;print&#x27;, None 中的一个</span><br>    <span class="hljs-keyword">await</span> page.emulateMedia(<span class="hljs-string">&#x27;screen&#x27;</span>)<br><br><br>    <span class="hljs-comment"># Page.exposeFunction(name: str, pyppeteerFunction: Callable[[…], Any])</span><br>    <span class="hljs-comment"># 将一个Python函数绑定到浏览器window对象中，可以在使用过程中调用</span><br>    <span class="hljs-comment"># 参数：</span><br>    <span class="hljs-comment">#   name (string) – Name of the function on the window object.</span><br>    <span class="hljs-comment">#   pyppeteerFunction (Callable) – Function which will be called on python process. This function should not be asynchronous function.</span><br><br>    <span class="hljs-comment"># Page.focus(selector: str)</span><br>    <span class="hljs-comment"># 为选择器匹配的元素设置焦点</span><br>    <span class="hljs-comment"># 若没有元素被匹配，则报错</span><br>    <span class="hljs-keyword">await</span> page.focus(<span class="hljs-string">&#x27;#kw&#x27;</span>)<br><br><br>    <span class="hljs-comment"># Page.goBack(options: dict = None, **kwargs) → Optional[pyppeteer.network_manager.Response]</span><br>    <span class="hljs-comment"># 页面回退，基于Page访问记录，如果不能回退，则会返回None</span><br>    <span class="hljs-comment"># 参数与goto()一致</span><br>    <span class="hljs-keyword">await</span> page.goBack()<br><br>    <span class="hljs-comment"># goForward(options: dict = None, **kwargs) → Optional[pyppeteer.network_manager.Response]</span><br>    <span class="hljs-comment"># 页面前进，基于Page访问记录，如果不能回退，则会返回None</span><br>    <span class="hljs-comment"># 参数与goto()一致</span><br>    <span class="hljs-keyword">await</span> page.goForward()<br><br><br>    <span class="hljs-comment"># goto(url: str, options: dict = None, **kwargs) → Optional[pyppeteer.network_manager.Response]</span><br>    <span class="hljs-comment"># 页面访问url</span><br>    <span class="hljs-comment"># 参数：</span><br>    <span class="hljs-comment">#   timeout (int): 最大请求时间,默认为 30 秒, 传入0可以禁用此项. 此默认值可以通过 setDefaultNavigationTimeout()方法 来设置.</span><br>    <span class="hljs-comment">#   waitUntil (str|List[str]): 什么时候认为请求已经成功了, 默认是load项. 可选项目：</span><br>    <span class="hljs-comment">#       load: 当 load 事件被触发</span><br>    <span class="hljs-comment">#       domcontentloaded: 当 DOMContentLoaded 事件被触发</span><br>    <span class="hljs-comment">#       networkidle0: 500ms内没有正在连接的网络请求</span><br>    <span class="hljs-comment">#       networkidle2: 500ms内正在连接的网络请求不超过两个</span><br>    <span class="hljs-comment"># 可能引发的错误</span><br>    <span class="hljs-comment">#   url无效</span><br>    <span class="hljs-comment">#   请求超时</span><br>    <span class="hljs-comment">#   资源读取失败</span><br>    <span class="hljs-keyword">await</span> page.goto(<span class="hljs-string">&#x27;https://www.baidu.com/&#x27;</span>)<br><br>    <span class="hljs-comment"># hover(selector: str)</span><br>    <span class="hljs-comment"># 鼠标悬停在选择器匹配的元素上</span><br>    <span class="hljs-comment"># 若没有元素被匹配，则报错</span><br>    <span class="hljs-keyword">await</span> page.hover(<span class="hljs-string">&#x27;#su&#x27;</span>)<br><br><br><br>    <span class="hljs-comment"># metrics() → Dict[str, Any]</span><br>    <span class="hljs-comment"># 返回页面 metrics 信息</span><br>    <span class="hljs-comment"># 信息批注</span><br>    <span class="hljs-comment">#   Timestamp (number): The timestamp when the metrics sample was taken.</span><br>    <span class="hljs-comment">#   Documents (int): Number of documents in the page.</span><br>    <span class="hljs-comment">#   Frames (int): Number of frames in the page.</span><br>    <span class="hljs-comment">#   JSEventListeners (int): Number of events in the page.</span><br>    <span class="hljs-comment">#   Nodes (int): Number of DOM nodes in the page.</span><br>    <span class="hljs-comment">#   LayoutCount (int): Total number of full partial page layout.</span><br>    <span class="hljs-comment">#   RecalcStyleCount (int): Total number of page style recalculations.</span><br>    <span class="hljs-comment">#   LayoutDuration (int): Combined duration of page duration.</span><br>    <span class="hljs-comment">#   RecalcStyleDuration (int): Combined duration of all page style recalculations.</span><br>    <span class="hljs-comment">#   ScriptDuration (int): Combined duration of JavaScript execution.</span><br>    <span class="hljs-comment">#   TaskDuration (int): Combined duration of all tasks performed by the browser.</span><br>    <span class="hljs-comment">#   JSHeapUsedSize (float): Used JavaScript heap size.</span><br>    <span class="hljs-comment">#   JSHeapTotalSize (float): Total JavaScript heap size.</span><br>    c = <span class="hljs-keyword">await</span> page.metrics()<br>    print(c)<br><br>    <span class="hljs-comment"># Page.reload(options: dict = None, **kwargs) → Optional[pyppeteer.network_manager.Response]</span><br>    <span class="hljs-comment"># 刷新这个页面</span><br>    <span class="hljs-comment"># 参数与goto()一致</span><br>    <span class="hljs-keyword">await</span> page.reload()<br><br>    <span class="hljs-comment"># Page.screenshot(options: dict = None, **kwargs) → Union[bytes, str]</span><br>    <span class="hljs-comment"># 给网页弄一张截图</span><br>    <span class="hljs-comment"># 参数：</span><br>    <span class="hljs-comment">#   path (str): The file path to save the image to. The screenshot type will be inferred from the file extension.</span><br>    <span class="hljs-comment">#   type (str): Specify screenshot type, can be either jpeg or png. Defaults to png.</span><br>    <span class="hljs-comment">#   quality (int): The quality of the image, between 0-100. Not applicable to png image.</span><br>    <span class="hljs-comment">#   fullPage (bool): When true, take a screenshot of the full scrollable page. Defaults to False.</span><br>    <span class="hljs-comment">#   clip (dict): An object which specifies clipping region of the page. This option should have the following fields:</span><br>    <span class="hljs-comment">#   x (int): x-coordinate of top-left corner of clip area.</span><br>    <span class="hljs-comment">#   y (int): y-coordinate of top-left corner of clip area.</span><br>    <span class="hljs-comment">#   width (int): width of clipping area.</span><br>    <span class="hljs-comment">#   height (int): height of clipping area.</span><br>    <span class="hljs-comment">#   omitBackground (bool): Hide default white background and allow capturing screenshot with transparency.</span><br>    <span class="hljs-comment">#   encoding (str): The encoding of the image, can be either &#x27;base64&#x27; or &#x27;binary&#x27;. Defaults to &#x27;binary&#x27;.</span><br>    <span class="hljs-keyword">await</span> page.screenshot(&#123;<span class="hljs-string">&#x27;path&#x27;</span>: <span class="hljs-string">&#x27;example/0_Basic_usage_of_the_library/pyppeteer/baidu.png&#x27;</span>&#125;)<br><br>    <span class="hljs-comment"># Page.select(selector: str, *values) → List[str]</span><br>    <span class="hljs-comment"># 选择 options 并返回被选的值</span><br>    <span class="hljs-comment"># 若没有元素被匹配，则报错</span><br><br>    <span class="hljs-comment"># Page.setBypassCSP(enabled: bool) → None</span><br>    <span class="hljs-comment"># 设置Content-Security-Policy</span><br><br>    <span class="hljs-comment"># Page.setCacheEnabled(enabled: bool = True) → None</span><br>    <span class="hljs-comment"># 是否启用Cache</span><br><br>    <span class="hljs-comment"># Page.setContent(html: str) → None</span><br>    <span class="hljs-comment"># 设置网页HTML内容</span><br><br>    <span class="hljs-comment"># Page.setJavaScriptEnabled(enabled: bool)</span><br>    <span class="hljs-comment"># 设置js是否启用</span><br><br>    <span class="hljs-comment"># Page.setOfflineMode(enabled: bool) </span><br>    <span class="hljs-comment"># 设置是否启用离线模式</span><br><br><br>    <span class="hljs-comment"># Page.setRequestInterception(value: bool) </span><br>    <span class="hljs-comment"># 启用/禁用请求拦截。</span><br>    <span class="hljs-comment"># 激活请求拦截可以启用请求类的abort（），continue_（）和response（）方法。 这提供了修改页面发出的网络请求的功能。</span><br><br>    <span class="hljs-comment"># Page.tap(selector: str)</span><br>    <span class="hljs-comment"># Tap选择器匹配的元素</span><br>    <span class="hljs-comment"># 若没有元素被匹配，则报错</span><br><br>    <span class="hljs-comment"># Page.xpath(expression: str) → List[pyppeteer.element_handle.ElementHandle][source]</span><br>    <span class="hljs-comment"># 返回匹配xpath的元素 list</span><br>    <span class="hljs-comment"># 要是没有匹配项则返回空的list</span><br><br><br>    <span class="hljs-comment"># Page.type(selector: str, text: str, options: dict = None, **kwargs)</span><br>    <span class="hljs-comment"># 在指定元素中输入内容</span><br>    <span class="hljs-comment"># 若没有元素被匹配，则报错</span><br><br><br><br><br>    <span class="hljs-comment"># Page.close()</span><br>    <span class="hljs-comment"># 关闭page</span><br>    <span class="hljs-keyword">await</span> page.close()<br><br><br>asyncio.get_event_loop().run_until_complete(main())<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Puppeteer</tag>
      
      <tag>Pyppeteer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS-反爬</title>
    <link href="/post/4280fd2e/"/>
    <url>/post/4280fd2e/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h1><h2 id="CSS是什么"><a href="#CSS是什么" class="headerlink" title="CSS是什么"></a>CSS是什么</h2><p>层叠样式表(英文全称：Cascading Style Sheets)是一种用来表现HTML或XML等文件样式的计算机语言<br>CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化  </p><h2 id="CSS过程"><a href="#CSS过程" class="headerlink" title="CSS过程"></a>CSS过程</h2><p><img src="/CSS-%E5%8F%8D%E7%88%AC/20200821052643339.png">  </p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p><img src="/CSS-%E5%8F%8D%E7%88%AC/20200821053049847.png"><br>伪类：实际上不是真正的类名，而是一个内置影式的有特殊功能的类  </p><h1 id="CSS反爬"><a href="#CSS反爬" class="headerlink" title="CSS反爬"></a>CSS反爬</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>成本低  <ul><li>只需要前端混淆样式（不需要后台配合）  </li><li>不需要复杂的加密技术  </li><li>不需要验证码，流量监控等额外配置  </li></ul></li><li>效果好  <ul><li>难以识别  </li><li>抓取内容与预期相近  </li><li>反爬措施不易发觉  </li><li>可以弄假数据  </li><li>没有成熟的破解套路  </li></ul></li></ul><h2 id="字体反爬"><a href="#字体反爬" class="headerlink" title="字体反爬"></a>字体反爬</h2><ul><li>字体反爬通常会操作<code>font-family</code>字段，让其指向自定义的字体  </li><li>通过定义字体的方法，将HTML中用不常见的unicode映射到常用字体中  </li><li>爬虫抓取的数据只能抓到unicode，从而保护了真实数据  </li></ul><h3 id="应对"><a href="#应对" class="headerlink" title="应对"></a>应对</h3><ol><li>下载<code>woff</code>字体文件，转化为 <code>tff</code>文件  </li><li>用字体编辑器打开<code>tff</code>文件，确认unicode与实际值的映射关系  </li><li>将HTML内容按照映射关系进行替换  </li></ol><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><p>有些网站会动态生成<code>woff</code></p><h2 id="CSS背景反爬"><a href="#CSS背景反爬" class="headerlink" title="CSS背景反爬"></a>CSS背景反爬</h2><p>其原理是CSS Sprite(雪碧图)，一种利用一张图做多个效果的操作的技术<br>在过去，常用于优化网页提升速度。雪碧图的方式只要求请求一次HTTP相比于多次请求来说性能更优  </p><ul><li>数据利用背景图片展示给用户，而不是直接用文本  </li><li>图片包含一张雪碧图，数据利用背景偏移量获取  </li><li>抓取时看不到实际值  </li></ul><h3 id="应对-1"><a href="#应对-1" class="headerlink" title="应对"></a>应对</h3><ol><li>下载雪碧图，手动检查其对应值  </li><li>调试工具中调整<code>background-position</code>的偏移量，找到各偏移量与实际值的映射关系  </li><li>在爬虫中获取袁术元素偏移量，将其转为实际值  </li></ol><h2 id="CSS伪类反爬"><a href="#CSS伪类反爬" class="headerlink" title="CSS伪类反爬"></a>CSS伪类反爬</h2><ul><li>不直接将内容展现在HTML中  </li><li>通过伪类的<code>content</code>属性将要展示的值展示出来  </li></ul><h3 id="难点-1"><a href="#难点-1" class="headerlink" title="难点"></a>难点</h3><p>获取元素的伪类属性  </p><h3 id="应对-2"><a href="#应对-2" class="headerlink" title="应对"></a>应对</h3><ul><li>利用<code>Puppeteer</code>或<code>Selenium</code>在网页中执行JS来获取content  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> el = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.valuable-content&#x27;</span>)  <span class="hljs-comment">// 利用选择器选出目标元素</span><br><span class="hljs-keyword">const</span> styles = getComputedStyle(el, <span class="hljs-string">&#x27;before&#x27;</span>) <span class="hljs-comment">// 获取样式（这里可能是before或者after）</span><br><span class="hljs-built_in">console</span>.log(styles.content)  <span class="hljs-comment">// 打印样式查看</span><br></code></pre></td></tr></table></figure><h2 id="元素定位反爬"><a href="#元素定位反爬" class="headerlink" title="元素定位反爬"></a>元素定位反爬</h2>利用绝对定位将某一个数字或字符将原数字或字符通过一定的偏移量替换  </li><li>替换的数字或字符通常来说是随机的  </li><li>直接抓取会抓到错误信息  </li></ul><h3 id="应对-3"><a href="#应对-3" class="headerlink" title="应对"></a>应对</h3><p>计算替换元素偏移量，与被替换元素做比对，还原真实值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 元素获取</span><br><span class="hljs-keyword">const</span> elPr = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.mb-10 .b-airfly:nth-child(1) .fix_price&#x27;</span>)<br><span class="hljs-comment">// 被替换元素类别</span><br><span class="hljs-keyword">let</span> strArr = <span class="hljs-built_in">Array</span>.from(elPr.querySelectorAll(<span class="hljs-string">&#x27;b:first-child &gt; i&#x27;</span>)).map(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el.innerText)<br><span class="hljs-comment">// 替换元素</span><br>elPr.querySelectorAll(<span class="hljs-string">&#x27;b:not(:first-child)&#x27;</span>).forEach(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 偏移量</span><br>    <span class="hljs-keyword">const</span> left = <span class="hljs-built_in">Number</span>(getComputedStyle(el).left.replace(<span class="hljs-string">&#x27;px&#x27;</span>,<span class="hljs-string">&#x27;&#x27;</span>))<br>    <span class="hljs-comment">// 替换值</span><br>    strArr[strArr.length + left/<span class="hljs-number">16</span>] = el.innerText<br>&#125;)<br><span class="hljs-comment">// 真实值</span><br><span class="hljs-built_in">console</span>.log(strArr.join(<span class="hljs-string">&#x27;&#x27;</span>)) <br></code></pre></td></tr></table></figure><h2 id="利用字符分割"><a href="#利用字符分割" class="headerlink" title="利用字符分割"></a>利用字符分割</h2><ul><li>将字符串用标签分割开来  </li><li>由于其实内联块级(inline-block)，依旧是一行展示  </li><li>通常还混淆有不显示的标签(display:none)  </li></ul><h3 id="应对-4"><a href="#应对-4" class="headerlink" title="应对"></a>应对</h3><p>将内联块级标签的<code>innerText</code>拼接起来<br>注意过滤掉所有的<code>display:none</code>属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 元素获取</span><br><span class="hljs-keyword">const</span> elIp = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.ip&#x27;</span>)<br><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-comment">// 过滤 display: none</span><br><span class="hljs-keyword">const</span> elList = elIp.querySelectorAll(<span class="hljs-string">&#x27;*:not([style=&quot;display: none;&quot;])&#x27;</span>);<br><span class="hljs-comment">// 拼接</span><br>elList.forEach(<span class="hljs-function">(<span class="hljs-params">el, i</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(i === elList.length - <span class="hljs-number">1</span> )<br>        <span class="hljs-keyword">return</span> str += el.innerText<br>&#125;)<br><span class="hljs-built_in">console</span>.log(str)<br></code></pre></td></tr></table></figure><h2 id="推荐CSS反爬步骤"><a href="#推荐CSS反爬步骤" class="headerlink" title="推荐CSS反爬步骤"></a>推荐CSS反爬步骤</h2><ol><li>通过调试工具，人工查看CSS样式  </li><li>判断CSS反爬类型  </li><li>根据不同的类型采用不同的应对措施  </li><li>对于新的CSS反爬，研究其原理，采用合适的反爬策略  </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>反爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编码和加密</title>
    <link href="/post/3b5ddb7/"/>
    <url>/post/3b5ddb7/</url>
    
    <content type="html"><![CDATA[<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="Ascii"><a href="#Ascii" class="headerlink" title="Ascii"></a>Ascii</h2><p>ASCII (American Standard Code for Information Interchange)美国信息交换标准代码 是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言<br>它是最通用的信息交换标准，并等同于国际标准<code>ISO/IEC 646</code><br>ASCII第一次以规范标准的类型发表是在1967年，最后一次更新则是在1986年，到目前为止共定义了128个字符  </p><h3 id="码表"><a href="#码表" class="headerlink" title="码表"></a>码表</h3><p>在计算机中，所有的数据在存储和运算时都要使用二进制数表示（因为计算机用高电平和低电平分别表示<code>1</code>和<code>0</code>）    </p><blockquote><p>例如，像a、b、c、d这样的52个字母（包括大写）以及0、1等数字还有一些常用的符号（例如*、#、@等）  </p></blockquote><p>在计算机中存储时也要使用二进制数来表示，为了记录具体用哪些二进制数字表示哪个符号，人们建立了码表。每个人都可以约定自己的一套编码方式（码表）<br>为了让大家互相通信而不造成混乱，那么大家就必须使用相同的编码规则，于是美国有关的标准化组织就出台了<code>ASCII</code>编码，统一规定了上述常用符号用哪些二进制数来表示<br><img src="/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86/20200819033739113.png">  </p><h3 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   0.py</span><br><span class="hljs-string">@Time    :   2021年1月11日</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.1</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   ASCII 相关</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">char_to_ascii_num</span>(<span class="hljs-params">text: <span class="hljs-built_in">str</span></span>):</span><br>    <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> text:<br>        print(char, <span class="hljs-built_in">ord</span>(char))<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ascii_num_to_char</span>(<span class="hljs-params">char_num_list : <span class="hljs-built_in">str</span></span>):</span><br>    <span class="hljs-keyword">for</span> char_num <span class="hljs-keyword">in</span> char_num_list:<br>        print(char_num, <span class="hljs-built_in">chr</span>(char_num))<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    char_to_ascii_num(<span class="hljs-string">&#x27;Hello world&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;----------------&#x27;</span>)<br>    ascii_num_to_char([<span class="hljs-number">72</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>, <span class="hljs-number">32</span>, <span class="hljs-number">119</span>, <span class="hljs-number">111</span>, <span class="hljs-number">114</span>, <span class="hljs-number">114</span>, <span class="hljs-number">108</span>, <span class="hljs-number">100</span>])<br><br></code></pre></td></tr></table></figure><h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>Base64是一种基于64个<code>可打印字符</code>来表示二进制数据的方法<br>是网络上最常见的用于传输编码方式之一<br><code>3个字节</code> = <code>8位</code> = <code>24比特</code>， 对应于4个<code>Base64</code>单元<br>即3个字节可以由4个可打印字符来表示  </p><blockquote><p>可打印字符：A-Z、a-z、0-9 （一共62个字符）<br>剩余两个字符在不同的系统中表示不同  </p></blockquote><p>多用于处理文本数据 与 二进制数据的表示、传输、存储<br>例如：网页上的图片  </p><blockquote><p>例: 输入6666<br><img src="/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86/20200819035440360.png"><br>由于后面还没够3字节，所以就会补充一些字符  </p></blockquote><p><code>Base64</code>核心原理是将二进制数据进行分组，每 24Bit/3字节 一大组，再把大组的数据分成 6Bit 的小分组  </p><p>由于6Bit数据只能表示64个不同字符(2^6=64)，所以叫<code>Base64 </code>  </p><blockquote><p>大厂会自己定制特定的字符表，来达到混淆的目的<br>虽然都是base64, 但其个字符与值的关系是被更改过的  </p></blockquote><h3 id="码表-1"><a href="#码表-1" class="headerlink" title="码表"></a>码表</h3><p><img src="/%E7%BC%96%E7%A0%81%E5%92%8C%E5%8A%A0%E5%AF%86/20200827043358055.png"><br>默认的码表是 <code>大写字母 + 小写字母 + 数字 + &#39;+&#39; + &#39;/&#39;</code><br>这东西其实能自己定义  </p><h3 id="浏览运行过程"><a href="#浏览运行过程" class="headerlink" title="浏览运行过程"></a>浏览运行过程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   7_base64_charset.py</span><br><span class="hljs-string">@Time    :   2020/08/27 12:05:58</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   自定义字符集的base64编码与解码</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># here put the import lib</span><br><span class="hljs-keyword">import</span> string<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    定义自己的64个字符</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><span class="hljs-comment"># 从标准库里将大写字母，小写字母，数字（一共62个字符）</span><br>char64 = string.ascii_uppercase + string.ascii_lowercase + string.digits<br><span class="hljs-comment"># 额外添加两个字符(一共64个字符)</span><br>char64 += <span class="hljs-string">&#x27;+&#x27;</span>+<span class="hljs-string">&#x27;/&#x27;</span><br>char64 = <span class="hljs-built_in">list</span>(char64)<br><span class="hljs-comment"># 打乱码表</span><br>random.shuffle(char64)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cut</span>(<span class="hljs-params">obj, sec</span>):</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    将字符串按照指定数量进行切分</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    <span class="hljs-keyword">return</span> [obj[i:i+sec] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(obj), sec)]<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ascii_2_base64</span>(<span class="hljs-params">ascii_str: <span class="hljs-built_in">str</span></span>) -&gt; str:</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    正常来说，一个ASCII字符占8位</span><br><span class="hljs-string">    一个base64字符占6位</span><br><span class="hljs-string">    3*8 = 24 = 4*6位</span><br><span class="hljs-string">    这个函数就是用来做这个转换的</span><br><span class="hljs-string">    单个字符位数不够的，计算时会用0补全</span><br><span class="hljs-string">    整个字符位数不够的，在最后会用=来补足</span><br><span class="hljs-string"></span><br><span class="hljs-string">    b1    b2    b3</span><br><span class="hljs-string">    n1  n2  n3  n4</span><br><span class="hljs-string"></span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    print(<span class="hljs-string">&#x27;传入的数据字符串\t&#x27;</span>, ascii_str)<br>    <span class="hljs-comment"># 将数据转为bytes</span><br>    origin_bytes = ascii_str.encode()<br>    print(<span class="hljs-string">&#x27;将传入数据转为bytes\t&#x27;</span>, origin_bytes)<br><br>    <span class="hljs-comment"># 转为八位二进制</span><br>    base64_8_bin = [<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(<span class="hljs-built_in">bin</span>(b)).replace(<span class="hljs-string">&#x27;0b&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>):<span class="hljs-number">0</span>&gt;<span class="hljs-number">8</span>&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> origin_bytes]<br>    print(<span class="hljs-string">&#x27;将数据转为八位二进制\t&#x27;</span>, base64_8_bin)<br><br>    <span class="hljs-comment"># 按每6位切分</span><br>    base64_6_bin = cut(<span class="hljs-string">&#x27;&#x27;</span>.join(base64_8_bin), <span class="hljs-number">6</span>)<br>    print(<span class="hljs-string">&#x27;每6位切分一次数据\t&#x27;</span>, base64_6_bin)<br><br>    <span class="hljs-comment"># 最后一位位数补足到6位</span><br>    base64_6_bin[-<span class="hljs-number">1</span>] += <span class="hljs-string">&#x27;0&#x27;</span> * (<span class="hljs-number">6</span> - <span class="hljs-built_in">len</span>(base64_6_bin[-<span class="hljs-number">1</span>]))<br>    print(<span class="hljs-string">&#x27;将最后一位的位数补足\t&#x27;</span>, base64_6_bin)<br><br>    <span class="hljs-comment"># 将被切分的数据重新转为10进制</span><br>    base64_int = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">int</span>(x, <span class="hljs-number">2</span>), base64_6_bin))<br>    print(<span class="hljs-string">&#x27;每段二进制数转十进制\t&#x27;</span>, base64_int)<br><br>    <span class="hljs-comment"># 码表中寻找目标字符替换对应项</span><br>    base64_str = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: char64[x], base64_int))<br>    print(<span class="hljs-string">&#x27;码表中寻找目标字符替换\t&#x27;</span>, base64_str)<br><br>    <span class="hljs-comment"># 位数不够的地方补=</span><br>    base64_str += [<span class="hljs-string">&#x27;=&#x27;</span>] * (<span class="hljs-number">3</span> - <span class="hljs-built_in">len</span>(base64_8_bin) % <span class="hljs-number">3</span>)<br>    print(<span class="hljs-string">&#x27;用=将数据补全到24*n位\t&#x27;</span>, base64_str)<br><br>    <span class="hljs-comment"># 最终结果</span><br>    base64_str = <span class="hljs-string">&#x27;&#x27;</span>.join(base64_str)<br>    print(<span class="hljs-string">&#x27;ascii转base64 最终结果\t&#x27;</span>, base64_str)<br>    <span class="hljs-keyword">return</span> base64_str<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">base64_2_ascii</span>(<span class="hljs-params">base64_str: <span class="hljs-built_in">str</span></span>) -&gt; str:</span><br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    做和上面相反的操作</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    print(<span class="hljs-string">&#x27;传入的数据字符串\t&#x27;</span>, base64_str)<br>    <span class="hljs-comment"># 处理最后一个字符，通过码表判断是否为填充用的字符，是则在记录后去除</span><br>    <span class="hljs-keyword">if</span> base64_str[-<span class="hljs-number">1</span>] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> char64:<br>        base64_str = base64_str.replace(base64_str[-<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;&#x27;</span>)<br>    print(<span class="hljs-string">&#x27;按码表处理填充字符\t&#x27;</span>, base64_str)<br>    <br>    <span class="hljs-comment"># 码表中寻找目标十进制数字序号替换对应项</span><br>    base64_int = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: char64.index(x), base64_str))<br>    print(<span class="hljs-string">&#x27;码表中寻找目标序号替换\t&#x27;</span>, base64_int)<br><br>    <span class="hljs-comment"># 十进制数字序号转六位二进制</span><br>    base64_6_bin = [<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;<span class="hljs-built_in">bin</span>(x)[<span class="hljs-number">2</span>:]:<span class="hljs-number">0</span>&gt;<span class="hljs-number">6</span>&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> base64_int]<br>    print(<span class="hljs-string">&#x27;十进制序号转六位二进制\t&#x27;</span>, base64_6_bin)<br><br>    <span class="hljs-comment"># 六位二进制转八位二进制</span><br>    base64_8_bin = cut(<span class="hljs-string">&#x27;&#x27;</span>.join(base64_6_bin), <span class="hljs-number">8</span>)<br>    print(<span class="hljs-string">&#x27;六位二进制转八位二进制\t&#x27;</span>, base64_8_bin)<br><br>    <span class="hljs-comment"># 抛弃位数不足的位数</span><br>    base64_8_bin = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">len</span>(x) == <span class="hljs-number">8</span>, base64_8_bin))<br>    print(<span class="hljs-string">&#x27;抛弃位数不足八位的项\t&#x27;</span>, base64_8_bin)<br><br>    <span class="hljs-comment"># 八位二进制转ascii字符</span><br>    ascii_str = [<span class="hljs-built_in">chr</span>(<span class="hljs-built_in">int</span>(x, <span class="hljs-number">2</span>)) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> base64_8_bin]<br>    print(<span class="hljs-string">&#x27;八位二进制转ascii字符\t&#x27;</span>, ascii_str)<br><br>    ascii_str = <span class="hljs-string">&#x27;&#x27;</span>.join(ascii_str)<br>    print(<span class="hljs-string">&#x27;base64转ascii 最终结果\t&#x27;</span>, ascii_str)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    base64_str = ascii_2_base64(<span class="hljs-string">&#x27;Hello&#x27;</span>)<br>    print()<br>    base64_2_ascii(base64_str)<br></code></pre></td></tr></table></figure><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p><code>Unicode</code>，中文又称万国码、国际码、统一码、单一码，是计算机科学领域的业界标准<br>它整理、编码了世界上大部分的文字系统，使得电脑可以用更为简单的方式来呈现和处理文字  </p><p><code>Unicode</code> 为每一个字符而非字形定义唯一的代码（即一个整数）<br>换句话说，统一码以一种抽象的方式（即数字）来处理字符，并将视觉上的演绎工作（例如字体大小、外观形状、字体形态、文体等）留给其他软件来处理，例如网页浏览器或是文字处理器  </p><h3 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h3><ul><li>Universality：提供单一、综合的字符集，编码一切现代与大部分历史文献的字符  </li><li>Efficiency：易于处理与分析  </li><li>Characters, not glyphs：字符，而不是字形  </li><li>Semantics：字符要有良好定义的语  </li><li>Plain text：仅限于文本字符  </li><li>Logical order：默认内存表示是其逻辑序  </li><li>Unification：把不同语言的同一书写系统（scripts）中相同字符统一起来  </li><li>Dynamic composition：附加符号可以动态组合  </li><li>Stability：已分配的字符与语义不再改变  </li><li>Convertibility：Unicode与其他著名字符集可以精确转换  </li></ul><h3 id="文种平面"><a href="#文种平面" class="headerlink" title="文种平面"></a>文种平面</h3><p><code>Unicode</code>字符分为17组编排，每组称为平面（Plane），而每平面拥有65536（即216）个代码点<br>然而目前只用了少数平面  </p><table><thead><tr><th>平面</th><th>始末字符值</th><th>中文名称</th><th>英文名称</th></tr></thead><tbody><tr><td>0号平面</td><td>U+0000 - U+FFFF</td><td>基本多文种平面</td><td>Basic Multilingual Plane，简称BMP</td></tr><tr><td>1号平面</td><td>U+10000 - U+1FFFF</td><td>多文种补充平面</td><td>Supplementary Multilingual Plane，简称SMP</td></tr><tr><td>2号平面</td><td>U+20000 - U+2FFFF</td><td>表意文字补充平面</td><td>Supplementary Ideographic Plane，简称SIP</td></tr><tr><td>3号平面</td><td>U+30000 - U+3FFFF</td><td>表意文字第三平面</td><td>Tertiary Ideographic Plane，简称TIP</td></tr><tr><td>4号平面 至 13号平面</td><td>U+40000 - U+DFFFF</td><td>（尚未使用）</td><td></td></tr><tr><td>14号平面</td><td>U+E0000 - U+EFFFF</td><td>特别用途补充平面</td><td>Supplementary Special-purpose Plane，简称SSP</td></tr><tr><td>15号平面</td><td>U+F0000 - U+FFFFF</td><td>保留作为私人使用区（A区）</td><td>Private Use Area-A，简称PUA-A</td></tr><tr><td>16号平面</td><td>U+100000 - U+10FFFF</td><td>保留作为私人使用区（B区）</td><td>Private Use Area-B，简称PUA-B</td></tr></tbody></table><p>实际，光是 BMP基本多文种平面 就已经非常够用了，现在绝大多数的常用语言都能在这里找到（包括中文）  </p><blockquote><p><a href="https://zh.wikipedia.org/wiki/Unicode%E5%AD%97%E7%AC%A6%E5%B9%B3%E9%9D%A2%E6%98%A0%E5%B0%84">维基百科：Unicode字符平面映射</a>  </p></blockquote><h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><p>目前实际应用的统一码版本对应于<code>UCS-2</code>，即使用 16位 的编码空间。也就是每个字符占用2个字节  </p><blockquote><p><code>I</code>  <code>0049</code> <code>00000000 01001001</code><br><code>知</code> <code>77e5</code> <code>01110111 11100101</code>  </p></blockquote><p>这样理论上一共最多可以表示 2^16 = 65536 个字符<br>基本满足各种语言的使用<br>实际上当前版本的统一码并未完全使用这16位编码，而是保留了大量空间以作为特殊使用或将来扩展  </p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p><code>Unicode</code>的实现方式不同于编码方式<br>一个字符的<code>Unicode</code>编码确定。但是在实际传输过程中，由于不同系统平台的设计不一定一致，以及出于节省空间的目的，对<code>Unicode</code>编码的实现方式有所不同  </p><p><code>Unicode</code>的实现方式称为<code>Unicode</code>转换格式（<code>Unicode Transformation Format</code>，简称为<code>UTF</code>）  </p><blockquote><p><code>I</code>  <code>0049</code> <code>00000000 01001001</code><br><code>知</code> <code>77e5</code> <code>01110111 11100101</code><br>严格按照<code>UCS-2</code>会浪费空间，因为英文只需要一个字节就能够表示出来<br>那一长串的 0 没有记录与传输的必要，因此有了不同的实现方式（比如UTF-8）  </p></blockquote><h3 id="Unicode转换样例"><a href="#Unicode转换样例" class="headerlink" title="Unicode转换样例"></a>Unicode转换样例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- encoding: utf-8 -*-</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">@File    :   8_unicode.py</span><br><span class="hljs-string">@Time    :   2020-8-29 00:21:05</span><br><span class="hljs-string">@Author  :   Recluse Xu</span><br><span class="hljs-string">@Version :   1.0</span><br><span class="hljs-string">@Contact :   444640050@qq.com</span><br><span class="hljs-string">@Desc    :   基础unicode操作</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">char_2_unicode_char</span>(<span class="hljs-params">char: <span class="hljs-built_in">str</span></span>) -&gt; str:</span><br>    <span class="hljs-comment"># 字符编码为unicode字符</span><br>    c = char.encode(<span class="hljs-string">&#x27;unicode_escape&#x27;</span>)<br>    c = <span class="hljs-built_in">str</span>(c)<br>    print(char, <span class="hljs-string">&#x27;Unicode编码结果&#x27;</span>, c)<br>    <span class="hljs-keyword">return</span> c<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unicode_char_2_char</span>(<span class="hljs-params">unicode_char: <span class="hljs-built_in">str</span></span>) -&gt; str:</span><br>    <span class="hljs-comment"># unicode字符解码为字符</span><br>    c = unicode_char.encode().decode(<span class="hljs-string">&#x27;unicode_escape&#x27;</span>)<br>    print(unicode_char, <span class="hljs-string">&#x27;Unicode编码结果&#x27;</span>, c)<br>    <span class="hljs-keyword">return</span> c<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">char_2_unicode_ret</span>(<span class="hljs-params">a_char: <span class="hljs-built_in">str</span></span>) -&gt; int:</span><br>    <span class="hljs-comment"># 得到一个字符的unicode 数值</span><br>    c = <span class="hljs-built_in">ord</span>(a_char)<br>    print(a_char, <span class="hljs-string">&#x27;对应Unicode值&#x27;</span>, c)<br>    <span class="hljs-keyword">return</span> c<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unicode_ret_2_char</span>(<span class="hljs-params">a_ret: <span class="hljs-built_in">int</span></span>) -&gt; int:</span><br>    <span class="hljs-comment"># 根据unicode 数值，得到一个字符</span><br>    c = <span class="hljs-built_in">chr</span>(a_ret)<br>    print(a_ret, <span class="hljs-string">&#x27;对应字符&#x27;</span>, c)<br>    <span class="hljs-keyword">return</span> c<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unicode_ret_2_unicode_char</span>(<span class="hljs-params">a_ret: <span class="hljs-built_in">int</span></span>):</span><br>    <span class="hljs-comment"># 根据unicode 数值，得到一个unicode字符</span><br>    c = <span class="hljs-built_in">chr</span>(a_ret).encode(<span class="hljs-string">&#x27;unicode_escape&#x27;</span>)<br>    print(a_ret, <span class="hljs-string">&#x27;对应字符&#x27;</span>, c)<br>    <span class="hljs-keyword">return</span> c<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    c = <span class="hljs-string">&#x27;齤&#x27;</span><br>    char_2_unicode_char(c)<br>    unicode_char_2_char(<span class="hljs-string">&#x27;\\u4f60\\u597d&#x27;</span>)<br><br>    char_2_unicode_ret(c[<span class="hljs-number">0</span>])<br>    unicode_ret_2_char(<span class="hljs-number">38006</span>)<br>    unicode_ret_2_unicode_char(<span class="hljs-number">38006</span>)<br><br></code></pre></td></tr></table></figure><h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p><code>UTF-8</code>（<code>8-bit Unicode Transformation Format</code>）是一种针对 <code>Unicode</code> 的可变长度字符编码，也是一种前缀码  </p><p>其设计的主要目的是在能正常使用所有字符的同时，减少常用字符（主要指英文/拉丁文）编码长度    </p><h3 id="编码规则"><a href="#编码规则" class="headerlink" title="编码规则"></a>编码规则</h3><ol><li>单字节的字符，字节的第一位设为0，对于英语文本，UTF-8码只占用一个字节，和ASCII码完全相同；  </li><li>n个字节的字符(n&gt;1):<br>第一个字节的前n位设为1<br>第n+1位设为0，后面字节的前两位都设为10，这n个字节的其余空位填充该字符unicode码，高位用0补足  </li></ol><blockquote><p><code>I</code>  = <code>0049</code> = <code>00000000 01001001</code> → <code>01001001</code><br><code>知</code> = <code>77e5</code> = <code>01110111 11100101</code> → <code>11100111 10011111 10100101</code>  </p></blockquote><p>你会发现，<code>UTF-8</code> 编码对于 <code>Unicode</code>字符码 本身较短的字符较为友好，而对于较后的则并不友好（甚至一顿操作后还变长了）  </p><blockquote><p><a href="https://zh.wikipedia.org/wiki/UTF-8"><code>维基百科:UTF-8</code></a>  </p></blockquote><h2 id="百分号编码-URL编码"><a href="#百分号编码-URL编码" class="headerlink" title="百分号编码-URL编码"></a>百分号编码-URL编码</h2><p>百分号编码（英语：Percent-encoding），又称：URL编码（URL encoding）是特定上下文的 统一资源定位符<code>URL</code> 的编码机制，实际上也适用于 统一资源标志符<code>URI</code> 的编码  </p><h3 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h3><ul><li>URI允许字符  <ul><li>保留字符<br>保留字符存在特殊含义  </li><li>未保留字符<br>未保留没有特殊含义  </li></ul></li><li>URI不允许字符  </li></ul><h3 id="保留字符与未保留字符"><a href="#保留字符与未保留字符" class="headerlink" title="保留字符与未保留字符"></a>保留字符与未保留字符</h3><p>保留字符：<code>!</code> <code>*</code> <code>&#39;</code> <code>(</code> <code>)</code> <code>;</code> <code>:</code> <code>@</code> <code>&amp;</code> <code>=</code> <code>+</code> <code>$</code> <code>,</code> <code>/</code> <code>?</code> <code>#</code> <code>[</code> <code>]</code><br>未保留字符: 大小写字母，0<del>9数字，<code>-</code> <code>_</code> <code>.</code> `</del>`  </p><p><code>URI</code>中的其它字符必须用百分号编码<br>如果希望使用保留字符，那么必须要经过百分号编码  </p><p>|<code>!</code>|<code>#</code>|<code>$</code>|<code>&amp;</code>|<code>&#39;</code>|<code>(</code>|<code>)</code>|<code>*</code>|<code>+</code>|<code>,</code>|<code>/</code>|<code>:</code>|<code>;</code>|<code>=</code>|<code>?</code>|<code>@</code>|<code>[</code>|<code>]</code>|<br>|–|–|<br>|%21|%23|%24|%26|%27|%28|%29|%2A|%2B|%2C|%2F|%3A|%3B|%3D|%3F|%40|%5B|%5D|</p><p>其它字符<br>建议先转换为<code>UTF-8</code>字节序列, 然后对其字节值使用百分号编码<br>二进制数据<br>应该表示为8位一组的序列，然后对每个8位组按照上述方式百分号编码. 例如，字节值<code>0F</code> (十六进制)应表示为<code>%0F</code>  </p><h1 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h1><p>信息指纹<br>MD5信息摘要算法（英语：MD5 Message-Digest Algorithm），一种被广泛使用的密码散列函数，可以产生出一个128位（16字节）的散列值（hash value）<br>多用于确保信息传输完整一致  </p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>输入任意长度的信息，经过处理，都会输出128位的信息（信息指纹）  </p><h2 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_string_md5</span>(<span class="hljs-params">text</span>):</span><br>    m = hashlib. md5()<br>    m. update(text.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br>    print(m. hexdigest())<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    get_string_md5(<span class="hljs-string">&#x27;Hello world&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><p>MD5是不可逆的，是不能算回原文的<br>网上所谓的破解只是弄了一个超级大的数据，把绝大多数常用的东西算出来MD5结果，你输入什么就返回什么  </p><blockquote><p>MD5的抗碰撞性已经被人破解<br>简单而言，就是能根据一个MD5值，通过一些算法，快速得得到一些内容，其MD5结果与原本MD5一致<br>校验码一致，内容不一致，使得校验的安全性无法确定  </p></blockquote><h1 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h1><h2 id="加密算法类别"><a href="#加密算法类别" class="headerlink" title="加密算法类别"></a>加密算法类别</h2><h3 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h3><p>一方通过秘钥将信息加密后，将密文传给另一方，另一方通过相同的秘钥解开密文得到明文  </p><h3 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h3><p>A要向B发送消息，A与B都要昌盛一对用于加密和解密的公钥和私钥，公钥用于加密，私钥用于解密<br>各自的私钥各自保密，各自的公钥对对方公开  </p><ol><li>A要发送信息时，A用B的公钥加密信息   </li><li>A将密文用B公钥加密过后的信息发送给B  </li><li>B收到密文后，用B自己的私钥解密密文  </li></ol><p>对于B发送给A的信息也一样<br>由于只有私钥能够解密，这个过程中所有其它收到密文和公钥的人都无法解密信息  </p><h3 id="区别与实际"><a href="#区别与实际" class="headerlink" title="区别与实际"></a>区别与实际</h3><table><thead><tr><th></th><th>对称加密算法</th><th>非对称加密算法</th></tr></thead><tbody><tr><td>安全性</td><td>较低</td><td>较快</td></tr><tr><td>处理速度</td><td>较快</td><td>较慢</td></tr></tbody></table><p>常见的情况是：将 对称加密的秘钥 用 非对称加密公钥 进行加密，接收方使用 非对称加密私钥 解密得到 对称加密的秘钥，然后双方使用 对称加密 进行通信  </p><h2 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h2><p>AES高级加密标准（Advanced Encryption Standard，AES），又称Rijndael加密法，是美国联邦政府采用的一种区块加密标准<br>AES是对称秘钥加密中最流行的算法之一<br>AES是DES的替代品  </p><h3 id="要素"><a href="#要素" class="headerlink" title="要素"></a>要素</h3><h4 id="秘钥"><a href="#秘钥" class="headerlink" title="秘钥"></a>秘钥</h4><p>支持三种秘钥长度128/192/256<br>秘钥越长，越安全，但是处理速度也越慢    </p><h4 id="填充-Padding"><a href="#填充-Padding" class="headerlink" title="填充 Padding"></a>填充 Padding</h4><p>AES并非一股脑将明文加密成密文的，而是把明文拆分成一个个独立的明文块（一块128bit）加密的<br>如果一段明文拆开多个块后，最后一个块没到128bit，那么久需要对明文块进行填充  </p><h5 id="常见填充类型"><a href="#常见填充类型" class="headerlink" title="常见填充类型"></a>常见填充类型</h5><ul><li>NoPadding<br>要求明文本身就符合分块要求，不允许不符合要求的明文  </li><li>ZeroPadding<br>用0进行填充，填充到位数够为止<br>并不推荐使用，当文明快最后一位是0时，解密可能出错  </li><li>PKCS7Padding<br>推荐使用<br>假设数据长度需要填充n(n&gt;0)个字节才对齐，那么填充n个字节，每个字节都是n;如果数据本身就已经对齐了，则填充一块长度为块大小的数据，每个字节都是块大小  </li></ul><h4 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h4><p>AES的工作模式，体现在把明文块加密成密文块的处理过程中<br>AES加密算法提供了五种不同的工作模式CBC、ECB、CTR、CFB、OFB<br>模式之间的主体思想是相似的，在处理细节上有区别  </p><h5 id="ECB模式"><a href="#ECB模式" class="headerlink" title="ECB模式"></a>ECB模式</h5><p>最简单的模式，此模式下，每个明文块的加密都是独立的，互不干涉的<br>优点是简单快捷，有利于并行计算<br>缺点是明文相同的块会变成相同的密文块，安全性比较差  </p><h5 id="CBC模式"><a href="#CBC模式" class="headerlink" title="CBC模式"></a>CBC模式</h5><p>CBC模式引入了一个新的概念：初始向量IV</p><blockquote><p>初始向量IV<br>其作用与 MD5加盐 类似，目的是为了防止 同样的明文块 被加密成 同样的密文块  </p></blockquote><p>CBC模式在每一个明文块加密前会让明文块和一个值做异或操作<br>IV作为初始化变量，参与第一个明文块的异或，后续的每一个明文块和它前一个明文块所加密出来的密文快相异或<br>最终得到 同样的明文块 被加密成 不同样的密文块<br>优点：安全性被提高<br>缺点：无法并行计算，性能不比ECB。引入了IV增加了复杂度  </p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ol><li>把明文按128bit拆分为多个明文块  </li><li>按照选择的填充方式填充最后一个明文块  </li><li>每一个明文块利用AES加密器和秘钥加密成密文块  </li><li>拼接所有的密文块，得到结果  </li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>简单的过程表示</p><p>secret = encrypt(key_type, message)<br>输入 加密信息，明文，得到加密结果<br>message = decrypt(key_type, message)<br>输入 加密信息，密文，得到明文信息</p><p>常用的对称加密算法</p><table><thead><tr><th>算法</th><th>秘钥长度</th><th>工作模式</th><th>填充模式</th></tr></thead><tbody><tr><td>DES</td><td>56/64</td><td>ECB/CBC/PCBC/CTR/…</td><td>NoPadding/PKCS5Padding/…</td></tr><tr><td>AES</td><td>128/192/256</td><td>ECB/CBC/PCBC/CTR/…</td><td>NoPadding/PKCS5Padding/PKCS7Padding/…</td></tr></tbody></table><p>秘钥的长度越长，加密越安全，但处理速度越慢<br>工作模式与填充模式可以看做是对称加密算法的参数和格式选择  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><span class="hljs-keyword">from</span> Crypto.Cipher <span class="hljs-keyword">import</span> AES<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AES_Cipher</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, key</span>):</span><br>        self.bs = <span class="hljs-number">16</span><br>        key = key.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>        self.cipher = AES.new(key, AES.MODE_ECB)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">encrypt</span>(<span class="hljs-params">self, raw</span>):</span><br>        raw = self._pad(raw)<br>        raw = raw.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>        encrypted = self.cipher.encrypt(raw)<br>        encoded = base64.b64encode(encrypted)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(encoded, <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">decrypt</span>(<span class="hljs-params">self, raw</span>):</span><br>        decoded = base64.b64decode(raw)<br>        decrypted = self.cipher.decrypt(decoded)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span>(self._unpad(decrypted), <span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_pad</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-comment"># 填充算法，由于算法需要特定位数，位数不足就需要填充</span><br>        <span class="hljs-keyword">return</span> s + (self.bs - <span class="hljs-built_in">len</span>(s) % self.bs) * <span class="hljs-built_in">chr</span>(self.bs - <span class="hljs-built_in">len</span>(s) % self.bs)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_unpad</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-keyword">return</span> s[:-<span class="hljs-built_in">ord</span>(s[<span class="hljs-built_in">len</span>(s)-<span class="hljs-number">1</span>:])]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    a = <span class="hljs-string">&#x27;HelloWorld&#x27;</span><br>    aes = AES_Cipher(<span class="hljs-string">&#x27;abcdefgh12345678&#x27;</span>)<br>    w = aes.encrypt(a)<br>    print(w)<br>    print(aes.decrypt(w))<br></code></pre></td></tr></table></figure><h1 id="编码与加密常识"><a href="#编码与加密常识" class="headerlink" title="编码与加密常识"></a>编码与加密常识</h1><h2 id="基础通识"><a href="#基础通识" class="headerlink" title="基础通识"></a>基础通识</h2><ul><li>MD5<br>提取结果通常是 32 位，不受明文长度影响   </li><li>Base64<br>编码结果末尾通常会出现一或二个等于符号，受明文长度影响  </li><li>SHA1<br>加密结果值为 40 位，不受明文长度影响  </li><li>SHA256<br>加密结果值为 64 位，不受明文长度影响  </li></ul><h2 id="盲猜技巧"><a href="#盲猜技巧" class="headerlink" title="盲猜技巧"></a>盲猜技巧</h2><ul><li>一长串无规律数字与字母组合的字符大概率是 AES、DES、SHA 相关加密  </li><li>另外，AES、RSA 等对称和非对称加密都喜欢将结果值用 Base64 进行编码，这样易于传递  </li><li>如果你看到一长串字符里出现 <code>+</code> 、<code>\</code> 和末尾的 <code>=</code> ，那大概率就是上一行描述的加密算法加密后又进行了 <code>Base64</code> 编码的结果  </li><li>32 位的字符串有概率是 <code>MD5</code> 摘要结果  </li><li>64 位的字符串有概率是 <code>SHA</code> 加密结果  </li></ul><p>通过全局搜索找寻可疑字符串，在所有文件中寻找关键字<br>在需要的地方打上断点，找寻到目标的加密逻辑  </p><h2 id="复现做法"><a href="#复现做法" class="headerlink" title="复现做法"></a>复现做法</h2><p>在找寻到以后，可以选择：  </p><ul><li>参照js逻辑用其它语言重新实现  </li><li>直接调用js的加密函数  </li></ul><p>从非常长的 javascript文件 中归纳逻辑，建议将一些关键的变量或者函数复制粘贴到另一个 javascript文件 中，运行以后根据 没有定义 的报错 来逐一补全所需，直到得到结果  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Javascript</tag>
      
      <tag>加密</tag>
      
      <tag>编码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-日志</title>
    <link href="/post/ead47af8/"/>
    <url>/post/ead47af8/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Scrapy</code>提供了log功能，可以通过 <code>logging</code> 模块使用</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>通过在<code>setting.py</code>中进行以下设置可以被用来配置<code>logging</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">LOG_FILE = <span class="hljs-string">&quot;mySpider.log&quot;</span><br>LOG_LEVEL = <span class="hljs-string">&quot;INFO&quot;</span><br></code></pre></td></tr></table></figure><p>此处指定了 日志文件地址 与 <code>logging</code>级别</p><h2 id="Log级别"><a href="#Log级别" class="headerlink" title="Log级别"></a>Log级别</h2><p><code>Scrapy</code>提供5层<code>Log</code>级别:</p><ul><li>CRITICAL - 严重错误(critical)</li><li>ERROR - 一般错误(regular errors)</li><li>WARNING - 警告信息(warning messages)</li><li>INFO - 一般信息(informational messages)</li><li>DEBUG - 调试信息(debugging messages)</li></ul><p>级别设置得越高，记录的log内容就越少  </p><h2 id="全部log配置"><a href="#全部log配置" class="headerlink" title="全部log配置"></a>全部log配置</h2><ul><li>LOG_ENABLED<br>默认: True，启用logging  </li><li>LOG_ENCODING<br>默认: ‘utf-8’，logging使用的编码</li><li>LOG_FILE<br>默认: None，在当前目录里创建logging输出文件的文件名  </li><li>LOG_LEVEL<br>默认: ‘DEBUG’，log的最低级别  </li><li>LOG_STDOUT<br>默认: False 如果为 True，进程所有的标准输出(及错误)将会被重定向到log中。<blockquote><p>例如，执行 print “hello” ，其将会在Scrapy log中显示</p></blockquote></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>日志</tag>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQLAlchemy-ORM-Python</title>
    <link href="/post/3e8c19c1/"/>
    <url>/post/3e8c19c1/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>SQLAlchemy</code>是<code>Python</code>的<code>SQL``ORM</code>工具<br><code>SQLAlchemy</code>提供了一整套的持久化方式，提供高性能的数据库访问</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><code>SQLAlchemy</code>是一个强大的<code>ORM</code>，基于关系映射和核心Core制作  </li><li>可以通过操作对象模型，实现SQL的全部功能（包括连接查询，关联等）  </li><li>拥有一个灵活全面的系统，它可以快速的加载<code>Collections</code>与<code>Objects``Collections</code>被缓存在一个<code>Session</code>中，可以一次性查询整个结果也可以单个来进行访问  </li><li><code>SQLAlchemy``Core</code>独立于ORM，它本身是一个完整的数据库抽象层，包括可扩展的基于python的SQL表达式语言、模式元数据、连接池、类型强制和自定义类型  </li><li>所有主键和外键约束都是复合的和自然的。你可以自由组合  </li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><table><thead><tr><th>信息</th><th>链接</th></tr></thead><tbody><tr><td>官网</td><td><a href="https://www.sqlalchemy.org/">https://www.sqlalchemy.org/</a></td></tr><tr><td>文档</td><td><a href="http://www.sqlalchemy.org/docs/">http://www.sqlalchemy.org/docs/</a></td></tr><tr><td>github</td><td><a href="https://github.com/sqlalchemy/sqlalchemy">https://github.com/sqlalchemy/sqlalchemy</a></td></tr></tbody></table><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install SQLAlchemy<br></code></pre></td></tr></table></figure><h2 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">import sqlalchemy<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(sqlalchemy.__version__ )</span></span><br></code></pre></td></tr></table></figure><p>如果看到了版本信息，说明已经安装成功</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> create_engine<br><span class="hljs-meta">&gt;&gt;&gt; </span>engine = create_engine(<span class="hljs-string">&#x27;sqlite:///:memory:&#x27;</span>, echo=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><ul><li>echo参数<br>这个参数用于设置<code>SQLAlchemy</code>日志的记录  <ul><li>True 显示输出，你会在控制台看到所有信息  </li><li>False 这样做会减少输出信息的量  </li></ul></li><li>create_engine函数<br>这个函数会返回一个<code>Engine</code>实例，它代表着数据库核心接口<br>调用方法以后，引擎会建立与数据库的真实DBAPI连接。连接以后将其用于发出SQL  </li></ul><h2 id="声明映射关系类"><a href="#声明映射关系类" class="headerlink" title="声明映射关系类"></a>声明映射关系类</h2><p>声明映射关系的类是根据<code>Base</code>类定义的<br>你可以通过<code>declarative_base()</code>函数来获取<code>Base类</code>  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> sqlalchemy.ext.declarative <span class="hljs-keyword">import</span> declarative_base<br>Base = declarative_base()<br></code></pre></td></tr></table></figure><p>在有了<code>Base类</code>后你就可以声明映射关系的类了  </p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> sqlalchemy <span class="hljs-keyword">import</span> Column, Integer, String<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">User</span>(<span class="hljs-symbol">Base</span>):<br>     <span class="hljs-symbol">__tablename__</span> = &#x27;<span class="hljs-symbol">users</span>&#x27;  # 表名<br><br>     <span class="hljs-symbol">id</span> = <span class="hljs-symbol">Column</span>(<span class="hljs-symbol">Integer, <span class="hljs-symbol">primary_key</span></span>=<span class="hljs-symbol">True</span>)  # <span class="hljs-symbol">int</span>类型主键 <span class="hljs-symbol">id</span><br>     <span class="hljs-symbol">name</span> = <span class="hljs-symbol">Column</span>(<span class="hljs-symbol">String</span>(<span class="hljs-symbol">50</span>), <span class="hljs-symbol">comment</span>=&#x27;姓名&#x27;)  # <span class="hljs-symbol">String</span>类型键<span class="hljs-symbol">name</span><br>     <span class="hljs-symbol">fullname</span> = <span class="hljs-symbol">Column</span>(<span class="hljs-symbol">String</span>(<span class="hljs-symbol">50</span>), <span class="hljs-symbol">comment</span>=&#x27;全名&#x27;)  # <span class="hljs-symbol">String</span>类型键<span class="hljs-symbol">fullname</span><br>     <span class="hljs-symbol">nickname</span> = <span class="hljs-symbol">Column</span>(<span class="hljs-symbol">String</span>(<span class="hljs-symbol">50</span>), <span class="hljs-symbol">comment</span>=&#x27;昵称&#x27;)  # <span class="hljs-symbol">String</span>类型键<span class="hljs-symbol">nickname</span><br></code></pre></td></tr></table></figure><p>定义并不复杂，非常的简单明了，声明键类型与长度，添加注释<br>这个类虽然代表了映射关系，但它本身依旧可以定义和使用成员函数/属性  </p><p>meatadata是一个包含了生成命令的注册机<br>你可以使用<code>MetaData.create_all()</code>来创建表</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Base</span>.</span></span>metadata.create<span class="hljs-constructor">_all(<span class="hljs-params">engine</span>)</span><br></code></pre></td></tr></table></figure><h2 id="创建映射关系实例"><a href="#创建映射关系实例" class="headerlink" title="创建映射关系实例"></a>创建映射关系实例</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ed_user = User(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;ed&#x27;</span>, <span class="hljs-attribute">fullname</span>=<span class="hljs-string">&#x27;Ed Jones&#x27;</span>, <span class="hljs-attribute">nickname</span>=<span class="hljs-string">&#x27;edsnickname&#x27;</span>)<br></code></pre></td></tr></table></figure><p>就算你没有声明构造函数，它也能根据传进来的参数对对应的项进行赋值  </p><h2 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h2><p>使用<code>create_engine()</code>来创建一个<code>Session</code>类（需要传入一个engine）  </p><figure class="highlight nim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nim"><span class="hljs-keyword">from</span> sqlalchemy.orm <span class="hljs-keyword">import</span> sessionmaker<br><span class="hljs-type">Session</span> = sessionmaker(<span class="hljs-keyword">bind</span>=engine)<br></code></pre></td></tr></table></figure><p>这个定制的<code>Session</code>类将创建绑定到我们数据库的新<code>Session对象</code><br>每当需要与数据库进行对话时，都可以实例化一个<code>Session</code>  </p><h2 id="插入-更新-数据"><a href="#插入-更新-数据" class="headerlink" title="插入/更新 数据"></a>插入/更新 数据</h2><p>将实例用<code>session.add()</code>方法添加到<code>Session</code>中，以持久化  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ed_user = User(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;ed&#x27;</span>, <span class="hljs-attribute">fullname</span>=<span class="hljs-string">&#x27;Ed Jones&#x27;</span>, <span class="hljs-attribute">nickname</span>=<span class="hljs-string">&#x27;edsnickname&#x27;</span>)<br>session.<span class="hljs-builtin-name">add</span>(ed_user)<br></code></pre></td></tr></table></figure><p>在执行完这些代码以后，实例会被挂起，并没有发出SQL给数据<br>但如果你通过这个<code>Session</code>使用查询功能，这个实例会被找到<br>你可以通过add_all函数一次性添加多个实例  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">session.add_all([<br>     User(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;wendy&#x27;</span>, <span class="hljs-attribute">fullname</span>=<span class="hljs-string">&#x27;Wendy Williams&#x27;</span>, <span class="hljs-attribute">nickname</span>=<span class="hljs-string">&#x27;windy&#x27;</span>),<br>     User(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;mary&#x27;</span>, <span class="hljs-attribute">fullname</span>=<span class="hljs-string">&#x27;Mary Contrary&#x27;</span>, <span class="hljs-attribute">nickname</span>=<span class="hljs-string">&#x27;mary&#x27;</span>),<br>     User(<span class="hljs-attribute">name</span>=<span class="hljs-string">&#x27;fred&#x27;</span>, <span class="hljs-attribute">fullname</span>=<span class="hljs-string">&#x27;Fred Flintstone&#x27;</span>, <span class="hljs-attribute">nickname</span>=<span class="hljs-string">&#x27;freddy&#x27;</span>)])<br></code></pre></td></tr></table></figure><p>当你真的希望向数据库发送SQL提交事务时可以使用<code>session.commit()</code>  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">session</span>.<span class="hljs-keyword">commit</span>()<br></code></pre></td></tr></table></figure><h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><p>当发生一些冲突（如重复的主键之类的问题时）可以用回滚操作来让Session中的实例回归正常状态  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">session</span>.<span class="hljs-keyword">rollback</span>()<br></code></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>使用<code>session.query()</code>方法，传入关系映射类作为参数来进行查询  </p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smali">for<span class="hljs-built_in"> instance </span>in session.query(User).order_by(User.id):<br>     print(instance.name, instance.fullname)<br></code></pre></td></tr></table></figure><p>可以指定返回的键  </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">for</span> <span class="hljs-keyword">row</span> <span class="hljs-keyword">in</span> <span class="hljs-keyword">session</span>.query(<span class="hljs-keyword">User</span>, <span class="hljs-keyword">User</span>.name).<span class="hljs-keyword">all</span>():<br>    print(<span class="hljs-keyword">row</span>.<span class="hljs-keyword">User</span>, <span class="hljs-keyword">row</span>.name)<br></code></pre></td></tr></table></figure><blockquote><p>all()方法会返回所有结果，在数据量较多时，一次性全载入内存可能会引起问题<br>类似的，first()方法会返回第一个结果<br>可以查询特定的键为某个值的数据  </p></blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">row</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">session</span><span class="hljs-selector-class">.query</span>(User.name.label(<span class="hljs-string">&#x27;name_label&#x27;</span>))<span class="hljs-selector-class">.all</span>():<br>...    <span class="hljs-selector-tag">print</span>(row.name_label)<br></code></pre></td></tr></table></figure><p>结合<code>order_by</code>与切片功能来使用  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">u</span> <span class="hljs-selector-tag">in</span> <span class="hljs-selector-tag">session</span><span class="hljs-selector-class">.query</span>(<span class="hljs-selector-tag">User</span>)<span class="hljs-selector-class">.order_by</span>(<span class="hljs-selector-tag">User</span><span class="hljs-selector-class">.id</span>)<span class="hljs-selector-attr">[1:3]</span>:<br>    <span class="hljs-selector-tag">print</span>(<span class="hljs-selector-tag">u</span>)<br></code></pre></td></tr></table></figure><p>过滤结果</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">for</span> <span class="hljs-type">name</span>, <span class="hljs-keyword">in</span> <span class="hljs-keyword">session</span>.query(<span class="hljs-keyword">User</span>.name).filter_by(fullname=<span class="hljs-string">&#x27;Ed Jones&#x27;</span>):<br>    print(<span class="hljs-type">name</span>)<br></code></pre></td></tr></table></figure><p>后续：<a href="https://docs.sqlalchemy.org/en/13/orm/tutorial.html">https://docs.sqlalchemy.org/en/13/orm/tutorial.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>SQLAlchemy</tag>
      
      <tag>ORM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>javascript-encode混淆</title>
    <link href="/post/a78cd365/"/>
    <url>/post/a78cd365/</url>
    
    <content type="html"><![CDATA[<h1 id="大体思路"><a href="#大体思路" class="headerlink" title="大体思路"></a>大体思路</h1><p>这种让你看不懂代码的方式是通过编码实现的  </p><p>编译器能都识别那些 由 16进制字符 或者 Unicode 字符<br>一般而言为了 让字符看起来非常难顶，代码作者会设计将字符转换成一些奇怪的字符<br>但为了不影响代码逻辑，这些奇怪字符的值依然与原本保持一致  </p><p>代码会被保存为非常长的字符串格式<br>在多数情况下是类似于这样  </p><ul><li><code>()[&quot;constructor&quot;][&quot;constructor&quot;](执行代码)()</code> </li><li>eval(执行代码)</li></ul><p>当然，它不会明面的把函数写上，他会绕来绕去，让你看不出  </p><h1 id="AAencode"><a href="#AAencode" class="headerlink" title="AAencode"></a>AAencode</h1><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>既然是一个开源的，那就查看一下源码吧<br>Github: <a href="https://github.com/bprayudha/jquery.aaencode">https://github.com/bprayudha/jquery.aaencode</a>  </p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> aaencode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">text</span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> t;<br>        <span class="hljs-keyword">var</span> b = [<br>            <span class="hljs-string">&quot;(c^_^o)&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟΘﾟ)&quot;</span> ,<br>            <span class="hljs-string">&quot;((o^_^o) - (ﾟΘﾟ))&quot;</span> ,<br>            <span class="hljs-string">&quot;(o^_^o)&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟｰﾟ)&quot;</span> ,<br>            <span class="hljs-string">&quot;((ﾟｰﾟ) + (ﾟΘﾟ))&quot;</span> ,<br>            <span class="hljs-string">&quot;((o^_^o) +(o^_^o))&quot;</span> ,<br>            <span class="hljs-string">&quot;((ﾟｰﾟ) + (o^_^o))&quot;</span> ,<br>            <span class="hljs-string">&quot;((ﾟｰﾟ) + (ﾟｰﾟ))&quot;</span> ,<br>            <span class="hljs-string">&quot;((ﾟｰﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ))&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟωﾟﾉ&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟΘﾟﾉ&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;c&#x27;]&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟｰﾟﾉ&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟДﾟﾉ&quot;</span> ,<br>            <span class="hljs-string">&quot;(ﾟДﾟ) [ﾟΘﾟ]&quot;</span><br>        ];<br>        <span class="hljs-keyword">var</span> r = <span class="hljs-string">&quot;ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ [&#x27;_&#x27;]; o=(ﾟｰﾟ)  =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); &quot;</span>; <br>        r += <span class="hljs-string">&quot;(ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);&quot;</span> +<br>            <span class="hljs-string">&quot;(ﾟДﾟ)=&#123;ﾟΘﾟ: &#x27;_&#x27; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟΘﾟ] &quot;</span> +<br>            <span class="hljs-string">&quot;,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#x27;_&#x27;)[o^_^o -(ﾟΘﾟ)] &quot;</span>+<br>            <span class="hljs-string">&quot;,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#x27;_&#x27;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [c^_^o];&quot;</span> +<br>            <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;c&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];&quot;</span>+<br>            <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;o&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ﾟΘﾟ];&quot;</span>+<br>            <span class="hljs-string">&quot;(ﾟoﾟ)=(ﾟДﾟ) [&#x27;c&#x27;]+(ﾟДﾟ) [&#x27;o&#x27;]+(ﾟωﾟﾉ +&#x27;_&#x27;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟｰﾟ] + &quot;</span> +<br>            <span class="hljs-string">&quot;((ﾟДﾟ) +&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+&quot;</span> +<br>            <span class="hljs-string">&quot;((ﾟｰﾟ==3) +&#x27;_&#x27;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&#x27;c&#x27;]+&quot;</span> +<br>            <span class="hljs-string">&quot;((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#x27;o&#x27;]+&quot;</span> +<br>            <span class="hljs-string">&quot;((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ];(ﾟДﾟ) [&#x27;_&#x27;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];&quot;</span> +<br>            <span class="hljs-string">&quot;(ﾟεﾟ)=((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+&quot;</span>+<br>            <span class="hljs-string">&quot;((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [o^_^o -ﾟΘﾟ]+&quot;</span> +<br>            <span class="hljs-string">&quot;((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#x27;_&#x27;) [ﾟΘﾟ]; &quot;</span> +<br>            <span class="hljs-string">&quot;(ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&#x27;\\\\&#x27;; &quot;</span> +<br>            <span class="hljs-string">&quot;(ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];&quot;</span> + <br>            <span class="hljs-string">&quot;(oﾟｰﾟo)=(ﾟωﾟﾉ +&#x27;_&#x27;)[c^_^o];&quot;</span> +<br>            <span class="hljs-string">&quot;(ﾟДﾟ) [ﾟoﾟ]=&#x27;\\\&quot;&#x27;;&quot;</span> + <br>            <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;_&#x27;] ( (ﾟДﾟ) [&#x27;_&#x27;] (ﾟεﾟ+&quot;</span> +<br>            <span class="hljs-string">&quot;(ﾟДﾟ)[ﾟoﾟ]+ &quot;</span>;<br><br>        <span class="hljs-keyword">for</span>( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; text.length; i++ ) &#123;<br>            n = text.charCodeAt( i );<br>            t = <span class="hljs-string">&quot;(ﾟДﾟ)[ﾟεﾟ]+&quot;</span>;<br>            <span class="hljs-keyword">if</span>( n &lt;= <span class="hljs-number">127</span> ) &#123;<br>                t += n.toString( <span class="hljs-number">8</span> ).replace( <span class="hljs-regexp">/[0-7]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>) </span>&#123;<br>                  <span class="hljs-keyword">return</span> b[ c ] + <span class="hljs-string">&quot;+ &quot;</span>;<br>                &#125;);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">var</span> m = <span class="hljs-regexp">/[0-9a-f]&#123;4&#125;$/</span>.exec( <span class="hljs-string">&quot;000&quot;</span> + n.toString(<span class="hljs-number">16</span> ) )[<span class="hljs-number">0</span>];<br>                t += <span class="hljs-string">&quot;(oﾟｰﾟo)+ &quot;</span> + m.replace( <span class="hljs-regexp">/[0-9a-f]/gi</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">c</span>) </span>&#123;<br>                  <span class="hljs-keyword">return</span> b[ <span class="hljs-built_in">parseInt</span>( c,<span class="hljs-number">16</span> ) ] + <span class="hljs-string">&quot;+ &quot;</span>;<br>                &#125;);<br>            &#125;<br>            r += t;<br><br>        &#125;<br>        <br>        r += <span class="hljs-string">&quot;(ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#x27;_&#x27;);&quot;</span>;<br>        <br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    $.fn.aaencode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> aaencode(<span class="hljs-built_in">this</span>.val());<br>    &#125;<br>&#125;)(jQuery);<br></code></pre></td></tr></table></figure><p>逐一调试观察逻辑并记录<br>（为了调试方便改写了一些格式，但内容没改）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_aaencode</span>(<span class="hljs-params">text</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> t;<br>    <span class="hljs-comment">// 定义一些表情字符用作替代目标, 里面的每一个表情都对应着一个真正的值</span><br>    <span class="hljs-comment">// 在那些变量被赋值后(如(c^_^o)的c和o)，整个标签符号的值才会真正显现出来</span><br>    <span class="hljs-comment">// 0-9 a-f</span><br>    <span class="hljs-keyword">var</span> b = [<br>        <span class="hljs-string">&quot;(c^_^o)&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟΘﾟ)&quot;</span>,<br>        <span class="hljs-string">&quot;((o^_^o) - (ﾟΘﾟ))&quot;</span>,<br>        <span class="hljs-string">&quot;(o^_^o)&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟｰﾟ)&quot;</span>,<br>        <span class="hljs-string">&quot;((ﾟｰﾟ) + (ﾟΘﾟ))&quot;</span>,<br>        <span class="hljs-string">&quot;((o^_^o) +(o^_^o))&quot;</span>,<br>        <span class="hljs-string">&quot;((ﾟｰﾟ) + (o^_^o))&quot;</span>,<br>        <span class="hljs-string">&quot;((ﾟｰﾟ) + (ﾟｰﾟ))&quot;</span>,<br>        <span class="hljs-string">&quot;((ﾟｰﾟ) + (ﾟｰﾟ) + (ﾟΘﾟ))&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟωﾟﾉ&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟΘﾟﾉ&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;c&#x27;]&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟｰﾟﾉ&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟДﾟ) .ﾟДﾟﾉ&quot;</span>,<br>        <span class="hljs-string">&quot;(ﾟДﾟ) [ﾟΘﾟ]&quot;</span><br>    ];<br>    <span class="hljs-comment">// r 实际上是最终字符串</span><br>    <span class="hljs-comment">// 定义了一些变量</span><br>    <span class="hljs-keyword">var</span> r =<br>        <span class="hljs-comment">// &quot;ﾟωﾟﾉ = /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ [&#x27;_&#x27;]</span><br>        <span class="hljs-string">&quot;ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻   //*´∇｀*/ [&#x27;_&#x27;];&quot;</span> +<br>        <span class="hljs-comment">// o = 3</span><br>        <span class="hljs-comment">// _ = 3</span><br>        <span class="hljs-string">&quot; o=(ﾟｰﾟ)  =_=3;&quot;</span> +<br>        <span class="hljs-comment">// c = 0</span><br>        <span class="hljs-comment">// (ﾟΘﾟ) = 0</span><br>        <span class="hljs-string">&quot; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); &quot;</span>;<br>    r +=<br>        <span class="hljs-comment">// (ﾟДﾟ) = (ﾟΘﾟ) = 1</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);&quot;</span> +<br>        <span class="hljs-comment">// (ﾟДﾟ) = &#123;ﾟΘﾟ: &quot;_&quot;, ﾟωﾟﾉ: &quot;a&quot;, ﾟｰﾟﾉ: &quot;d&quot;, ﾟДﾟﾉ: &quot;e&quot;&#125;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ)=&#123;ﾟΘﾟ: &#x27;_&#x27; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &#x27;_&#x27;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&#x27;_&#x27;)[ﾟｰﾟ] &#125;; &quot;</span> +<br>        <span class="hljs-comment">// (ﾟДﾟ) [ﾟΘﾟ] = &#x27;f&#x27;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [c^_^o];&quot;</span> +<br>        <span class="hljs-comment">// (ﾟДﾟ) [&#x27;c&#x27;] = &#x27;c&#x27;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;c&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];&quot;</span> +<br>        <span class="hljs-comment">// (ﾟДﾟ) [&#x27;o&#x27;] = &#x27;o&#x27;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;o&#x27;] = ((ﾟДﾟ)+&#x27;_&#x27;) [ﾟΘﾟ];&quot;</span> +<br>        <span class="hljs-comment">// constructor</span><br>        <span class="hljs-string">&quot;(ﾟoﾟ)=(ﾟДﾟ) [&#x27;c&#x27;]+(ﾟДﾟ) [&#x27;o&#x27;]+(ﾟωﾟﾉ +&#x27;_&#x27;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&#x27;_&#x27;) [ﾟｰﾟ] + ((ﾟДﾟ) +&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&#x27;c&#x27;]+((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&#x27;o&#x27;]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ];&quot;</span> +<br>        <span class="hljs-comment">// (ﾟДﾟ) [&#x27;_&#x27;] =  3[&#x27;constructor&#x27;][&#x27;constructor&#x27;] 等价于 ƒ Function() &#123; [native code] &#125;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;_&#x27;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];&quot;</span> +<br>        <span class="hljs-comment">// (ﾟεﾟ) = &#x27;return&#x27;</span><br>        <span class="hljs-string">&quot;(ﾟεﾟ)=((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&#x27;_&#x27;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&#x27;_&#x27;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&#x27;_&#x27;) [ﾟΘﾟ]; &quot;</span> +<br>        <span class="hljs-comment">// (ﾟｰﾟ) = 3</span><br>        <span class="hljs-string">&quot;(ﾟｰﾟ)+=(ﾟΘﾟ);&quot;</span>,<br>        <span class="hljs-comment">// (ﾟДﾟ)[ﾟεﾟ] = &quot;\\&quot;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ)[ﾟεﾟ]=&#x27;\\\\&#x27;; &quot;</span> +<br>        <span class="hljs-comment">// (ﾟДﾟ).ﾟΘﾟﾉ = &quot;b&quot;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];&quot;</span> +<br>        <span class="hljs-comment">// (oﾟｰﾟo) = &#x27;u&#x27;</span><br>        <span class="hljs-string">&quot;(oﾟｰﾟo)=(ﾟωﾟﾉ +&#x27;_&#x27;)[c^_^o];&quot;</span> +<br>        <span class="hljs-comment">// (ﾟДﾟ) [ﾟoﾟ] = &quot;\\\&quot;&quot;</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ) [ﾟoﾟ]=&#x27;\\\&quot;&#x27;;&quot;</span> +<br>        <span class="hljs-comment">// function (function (return object 中间导入的字符串 ))</span><br>        <span class="hljs-string">&quot;(ﾟДﾟ) [&#x27;_&#x27;] ( (ﾟДﾟ) [&#x27;_&#x27;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#x27;_&#x27;);&quot;</span>;<br><br>    <span class="hljs-comment">// 遍历传入字符串的所有字符</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; text.length; i++) &#123;<br>        n = text.charCodeAt(i);<br>        <span class="hljs-comment">// charCodeAt() 方法可返回指定位置的字符的 Unicode 编码数</span><br>        <span class="hljs-comment">// 由于实际上是标记的转码字符，这里献给内容加上一个转义字符&#x27;\\&#x27;</span><br>        t = <span class="hljs-string">&quot;(ﾟДﾟ)[ﾟεﾟ]+&quot;</span>;<br>        <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">127</span>) &#123;<br>            <span class="hljs-comment">// unicode 只处理 C0控制与基本的Latin（拉丁字母），这其实已经包含了绝大部分的js源码符号</span><br>            <span class="hljs-comment">// 将 十进制数字符串 转为 为8进制数字符串</span><br>            n = n.toString(<span class="hljs-number">8</span>);<br>            <span class="hljs-comment">// 对八进制数字符串 里的每一个数字(0-7) 用 预先定义好的表情符合进行取代</span><br>            t += n.replace(<span class="hljs-regexp">/[0-7]/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) </span>&#123;<br>                <span class="hljs-keyword">return</span> b[c] + <span class="hljs-string">&quot;+ &quot;</span>;<br>                <span class="hljs-comment">// 取代完以后，在最后添加一个 &#x27;+ &#x27;用于最后eval函数拼接而不出问题</span><br>            &#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 对于非C0控制与基本的Latin（拉丁字母）。即 非js代码部分，诸如中文之类的</span><br>            <span class="hljs-comment">// 用 &quot;000&quot;+原字符数字转16进制</span><br>            n = <span class="hljs-string">&quot;000&quot;</span> + n.toString(<span class="hljs-number">16</span>);<br>            <span class="hljs-comment">// 用正则表达式/[0-9a-f]&#123;4&#125;$/ 在 十六进数字字符 中寻找匹配项 并返回最短匹配</span><br>            <span class="hljs-keyword">var</span> m = <span class="hljs-regexp">/[0-9a-f]&#123;4&#125;$/</span>.exec(n)[<span class="hljs-number">0</span>];<br>            <span class="hljs-comment">// 将这个 十六进数字字符 转为对应的10进制数字（因为记录表情的是一个数组，如果传入a-f字符来获取表情的话会报错，所以转10进制数），再转为表情，在最后添加一个 &#x27;+ &#x27;</span><br>            m = m.replace(<span class="hljs-regexp">/[0-9a-f]/gi</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) </span>&#123;<br>                <span class="hljs-keyword">return</span> b[<span class="hljs-built_in">parseInt</span>(c, <span class="hljs-number">16</span>)] + <span class="hljs-string">&quot;+ &quot;</span>;<br>            &#125;);<br>            <span class="hljs-comment">// 字符结果添加前缀 u以作Unicode字符标记</span><br>            t += <span class="hljs-string">&quot;(oﾟｰﾟo)+ &quot;</span> + m;<br>        &#125;<br>        <span class="hljs-comment">// 单个字符汇总到答案</span><br>        r += t;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 添加结尾字符</span><br>    r += <span class="hljs-string">&quot;(ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&#x27;_&#x27;);&quot;</span>;<br><br>    <span class="hljs-comment">// 返回整个字符串</span><br>    <span class="hljs-keyword">return</span> r;<br>&#125;<br></code></pre></td></tr></table></figure><p>在详细分析以后，过程是比较得明朗的  </p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><ol><li><p>定义一个 表情符号数组<br>为了增加迷惑性，设定一个表情符号数组，用作未来取代<code>javascript</code>代码字符    </p></li><li><p>定义外围函数包围原本的代码<br>最外面包裹着一层 执行解释函数<br>通过各种奇怪的符号构造出 <code>()[&quot;constructor&quot;][&quot;constructor&quot;](执行代码)()</code><br><code>()[&quot;constructor&quot;][&quot;constructor&quot;](执行代码)()</code>等价于<code>Function (执行代码)()</code>，能执行代码  </p></li><li><p>原本的js代码通过<code>unicode编码</code>后映射到了一个数上，作者将这个数做了区分处理  </p><ul><li>这个数在0-127之间，说明是数字字母等javascript代码原本需要用到的字符 <a href="https://www.runoob.com/charsets/ref-utf-basic-latin.html">C0 控制与基本的 Latin（拉丁字母）</a><br>这种字符作者将数转为8进制后，将每一位的数转为表情字符</li><li>这个数超出127，说明这个字符并非常规的字母数字等，而是一些较少使用的字符，如中文之类的<br>这种字符作者将数转为16进制后，将每一位的数转为表情字符，最后在前面添加一个”(oﾟｰﾟo)”（实际上是字符 u）用作标识Unicode字符  </li></ul></li></ol><ul><li>为什么可以转为表情<br>  实际上，在一开始的变量声明完毕以后，表情字符本身的值就等于序号（16进制，超出的会对应a-f）<br>  这是作者设定好的，混淆是让你看不懂，并不会破坏逻辑本身<br>  你可以尝试着去获取那些值  </li></ul><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><ol><li><p>删掉最后的<code>(&#39;_&#39;);&quot;;</code>,若是不行，可以在后面加<code>toString()</code>来把函数转为字符串输出<br>由于代码是<code>()[&quot;constructor&quot;][&quot;constructor&quot;](执行代码)()</code>这种形式的<br>如果你把最后的括号删掉，那么源代码函数就会暴露出来，直接得到源码了  </p></li><li><p>进入虚拟空间VM即可看到源码<br>在执行混淆代码之前，打上断点，步进到混淆代码内部，分析堆栈，进入虚拟空间，就能看到源码了<br>如果内部代码执行报错，那么也可以通过报错的定位进入虚拟空间  </p></li></ol><p style="text-align:right">Recluse<br>2020年8月13日14:53:10 </p>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>js混淆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js</title>
    <link href="/post/747d7228/"/>
    <url>/post/747d7228/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Node.js</code> 是一个基于 <code>Chrome V8</code> 引擎的 <code>JavaScript</code> 运行时   </p><ul><li>官网：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a>  </li><li>官方文档：<a href="https://nodejs.org/zh-cn/docs/">https://nodejs.org/zh-cn/docs/</a>  </li><li>中文文档：<a href="http://nodejs.cn/api/">http://nodejs.cn/api/</a>  </li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>进入官网，下载安装包，安装<br><img src="/Node.js-%E5%9F%BA%E7%A1%80/20200816113530357.png"><br>安装过程中可以改安装路径<br>它会自动给系统添加环境变量  </p></li><li><p>测试<br>cmd中输入<code>npm</code>得到一堆信息，则说明安装成功<br><img src="/Node.js-%E5%9F%BA%E7%A1%80/20200816114606605.png"></p></li><li><p>配置node_cache路径<br>这个文件夹是<code>Node.js</code>用来存放下载包的缓存的地方  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;cache路径&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>设置全局模块存放路径<br>这个文件夹是<code>Node.js</code>用来存放通过全局安装的模块的地方<br><code>Node.js</code>会自动寻找该路径下的<code>node_modules</code>文件夹为实际存放全局模块的路径<br>我一般设置为在Node.js目录  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> prefix <span class="hljs-string">&quot;全局模块存放的路径&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>node_modules文件夹为实际存放全局模块的路径，这也是为啥叫<code>prefix</code>不叫<code>global</code>的原因  </p></blockquote></li><li><p>修改npmrc文件<br>用文本编辑器打开<code>Node.js目录\node_modules\npm\npmrc</code>文件<br>将<code>prefix=$&#123;APPDATA&#125;\npm</code>改为<code>prefix=Node.js根目录</code><br>如果不做这个修改，则在运行<code>npm ls -g</code>的时候，仍然以默认的路径来查找已安装的全局模块  </p></li></ol><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g 包名<br></code></pre></td></tr></table></figure><h2 id="全局卸载"><a href="#全局卸载" class="headerlink" title="全局卸载"></a>全局卸载</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> uninstall -g 包名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS-环境变量配置</title>
    <link href="/post/e68da6e/"/>
    <url>/post/e68da6e/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>为了能在控制台通过命令访问到对应的程序，配置环境变量不可避免  </p><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h2><ol><li>进入环境变量文件夹  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>profile.d<br></code></pre></td></tr></table></figure></li><li>创建环境变量文件  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">sudo vim <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Anaconda</span>.</span></span>sh<br></code></pre></td></tr></table></figure></li><li>编写环境变量  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># set Anaconda environment</span><br>PATH=<span class="hljs-variable">$PATH</span><span class="hljs-symbol">:/home/manager/anaconda3/bin</span><br>export PATH<br></code></pre></td></tr></table></figure>注意对应自己的安装路径，写完<code>:wq</code>保存退出  </li><li>打开新的控制台测试  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda</span><br></code></pre></td></tr></table></figure>看到一堆命令提示就代表成功  </li></ol><h2 id="删除环境变量"><a href="#删除环境变量" class="headerlink" title="删除环境变量"></a>删除环境变量</h2><p>把<code>/etc/profile.d</code>里面对应的<code>.sh文件</code>删除即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫-无限debugger</title>
    <link href="/post/dd59ce18/"/>
    <url>/post/dd59ce18/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><ul><li>实现简单, 效果明显, 一定程度提高安全性  </li><li>反调试，阻止我们调试分析代码的运行逻辑  </li></ul><h1 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h1><p>debugger关键词的嵌套使用  </p><h1 id="应对"><a href="#应对" class="headerlink" title="应对"></a>应对</h1><ul><li>禁用所有断点<br>可以尝试，但并不一定能解决问题，甚至有可能导致死循环吃内存  </li><li>禁用断点语句<br>可以尝试，但并不一定能解决问题，甚至有可能导致死循环吃内存  </li><li>条件断点  </li><li>中间人工具替换字符串  </li><li>reres替换本地修改过的文件<br>本地代理取代对应js资源  </li><li>注入重写关键函数<br>故意进入debug函数<br>观察堆栈调用，最好找到最外层调用函数<br>注入代码再定义函数，使得函数变为空<br>需要注意不要误伤业务逻辑  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chrome插件-ToggleJavaScript-禁用或启用JavaScript脚本</title>
    <link href="/post/fac1a65b/"/>
    <url>/post/fac1a65b/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>这是一个能有禁用或启用JavaScript脚本的浏览器插件<br>谷歌商店：<a href="https://chrome.google.com/webstore/detail/toggle-javascript/cidlcjdalomndpeagkjpnefhljffbnlo?utm_source=chrome-ntp-icon">https://chrome.google.com/webstore/detail/toggle-javascript/cidlcjdalomndpeagkjpnefhljffbnlo?utm_source=chrome-ntp-icon</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Chrome</tag>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chrome插件-EditThisCookie-管理Cookie</title>
    <link href="/post/58054d20/"/>
    <url>/post/58054d20/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p>这是一个用于管理Cookie的浏览器插件<br>官网:<a href="http://www.editthiscookie.com/">http://www.editthiscookie.com/</a><br>下载：<a href="https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg?utm_source=chrome-ntp-icon">https://chrome.google.com/webstore/detail/editthiscookie/fngmhnnpilhplaeedifhccceomclgfbg?utm_source=chrome-ntp-icon</a>  </p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h2><p><img src="/Chrome%E6%8F%92%E4%BB%B6-EditThisCookie-%E7%AE%A1%E7%90%86Cookie/20200811024743389.png"><br>修改设置各种值  </p><h2 id="清空该网站所有Cookie"><a href="#清空该网站所有Cookie" class="headerlink" title="清空该网站所有Cookie"></a>清空该网站所有Cookie</h2><p><img src="/Chrome%E6%8F%92%E4%BB%B6-EditThisCookie-%E7%AE%A1%E7%90%86Cookie/20201214030406382.png">  </p><h2 id="导入-导出"><a href="#导入-导出" class="headerlink" title="导入/导出"></a>导入/导出</h2><p>导入导出Cookie到各种地方<br><img src="/Chrome%E6%8F%92%E4%BB%B6-EditThisCookie-%E7%AE%A1%E7%90%86Cookie/20200811025600323.png">  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Chrome</tag>
      
      <tag>EditThisCookie</tag>
      
      <tag>Cookie</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-加密-混淆</title>
    <link href="/post/876db760/"/>
    <url>/post/876db760/</url>
    
    <content type="html"><![CDATA[<h1 id="为什么要进行JavaScript加密-混淆"><a href="#为什么要进行JavaScript加密-混淆" class="headerlink" title="为什么要进行JavaScript加密/混淆"></a>为什么要进行JavaScript加密/混淆</h1><ul><li>JavaScript 代码运行于客户端<br>不安全，存在被篡改，窃取的可能</li><li>JavaScript 代码是公开的  </li></ul><h1 id="如何对JavaScript进行保护"><a href="#如何对JavaScript进行保护" class="headerlink" title="如何对JavaScript进行保护"></a>如何对JavaScript进行保护</h1><ul><li>代码压缩：去除空格、换行等  </li><li>代码加密：eval、emscripten、WebAssembly等  </li><li>代码混淆：变量混淆、常理混淆、控制流平坦化、调试保护等  </li></ul><h1 id="JavaScript加密实现"><a href="#JavaScript加密实现" class="headerlink" title="JavaScript加密实现"></a>JavaScript加密实现</h1><ul><li><p>eval 加密<br><img src="/Javascript-%E5%8A%A0%E5%AF%86-%E6%B7%B7%E6%B7%86/20200809061141463.png"><br>看似复杂，实际上，只要把参数内容输入到控制台就能得到结果  </p></li><li><p>Emscripten<br>将<code>C</code>/<code>C++</code>代码通过<code>Emscripten</code>编译成<code>asm.js</code>代码，<code>JavaScript</code>调用此代码即实现加密<br><code>asm.js</code>为文本格式</p></li><li><p>WebAssembly<br><img src="/Javascript-%E5%8A%A0%E5%AF%86-%E6%B7%B7%E6%B7%86/20200809062943797.png"><br>和<code>Emscripten</code>类似，但结果是<code>wasm文件</code>，运行更快，所需空间更小<br><code>wasm文件</code>为二进制文件</p></li></ul><h1 id="JavaScript混淆"><a href="#JavaScript混淆" class="headerlink" title="JavaScript混淆"></a>JavaScript混淆</h1><ul><li><p>变量混淆<br>将一些变量名、函数名、之类的变成一些奇怪的字符，让你看着难顶  </p></li><li><p>字符串混淆<br>通过对字符串进行<code>Base64</code>,<code>MD5</code>等转换为一些其它字符，使得你无法直接通过全局搜索关键字找到目标  </p></li><li><p>属性加密<br>很多代码里面都用了很多<code>Object</code>，里面包含了很多的<code>key-value</code>，他可以混淆<code>key-value</code>关系，使得你更难以寻找里面的逻辑  </p></li><li><p>控制流平坦化<br>打乱原本代码的运行流程与调用关系，让你更加难度<br><img src="/Javascript-%E5%8A%A0%E5%AF%86-%E6%B7%B7%E6%B7%86/20200809093259387.png"></p></li><li><p>僵尸代码注入<br>注入无用的代码，让你看起来更难顶  </p></li><li><p>代码压缩<br>去除空格，回车等，代码变为一行，让你更难读  </p></li><li><p>反调试<br>基于浏览器特性，循环<code>debug</code>或定时<code>debug</code>  </p></li><li><p>多态变异<br>代码一旦被调用，原代码就会变成与原来完全不同的代码，但功能保持不变，避免代码被动态分析，调试  </p></li><li><p>锁定域名<br>Javascript必须运行在指定域名的条件下  </p></li><li><p>反格式化<br>在你格式化以后，会有机制使得你运行的时候无法正确运行  </p></li><li><p>特殊编码<br>将Javascript编码成难读的代码</p></li></ul><h2 id="JavaScript混淆-开源项目"><a href="#JavaScript混淆-开源项目" class="headerlink" title="JavaScript混淆  开源项目"></a>JavaScript混淆  开源项目</h2><table><thead><tr><th>开源项目</th><th>地址</th></tr></thead><tbody><tr><td>UglifyJS</td><td><a href="https://github.com/mishoo/UglifyJS">https://github.com/mishoo/UglifyJS</a></td></tr><tr><td>terser</td><td><a href="https://github.com/terser/terser">https://github.com/terser/terser</a></td></tr><tr><td>javascript-obfuscator</td><td><a href="https://github.com/javascript-obfuscator/javascript-obfuscator">https://github.com/javascript-obfuscator/javascript-obfuscator</a></td></tr><tr><td>jsfuck</td><td><a href="https://github.com/aemkei/jsfuck">https://github.com/aemkei/jsfuck</a></td></tr><tr><td>AAencode</td><td><a href="https://github.com/bprayudha/jquery.aaencode">https://github.com/bprayudha/jquery.aaencode</a></td></tr><tr><td>JJEncrypt</td><td><a href="https://github.com/ay86/jEncrypt">https://github.com/ay86/jEncrypt</a></td></tr></tbody></table><h2 id="JavaScript混淆-商业项目"><a href="#JavaScript混淆-商业项目" class="headerlink" title="JavaScript混淆  商业项目"></a>JavaScript混淆  商业项目</h2><p><a href="https://www.javascriptobfuscator.com/">https://www.javascriptobfuscator.com/</a><br><a href="https://jscrambler.com/">https://jscrambler.com/</a><br><a href="http://stunnix.com/">http://stunnix.com/</a>  </p><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><h2 id="加密分析流程"><a href="#加密分析流程" class="headerlink" title="加密分析流程"></a>加密分析流程</h2><ol><li>查看关键包  分析参数</li><li>参数 <ul><li>搜索参数<br>（参数名=）（参数名 =）（参数名:）（参数名 :）（参数名）  </li><li>查看网络面板Initiator</li><li>xhr断点调试</li><li>hook相关逻辑</li></ul></li><li>分析加密  </li><li>补全加密逻辑  </li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>反爬虫</tag>
      
      <tag>Javascript</tag>
      
      <tag>加密</tag>
      
      <tag>混淆</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>协程-进程-线程</title>
    <link href="/post/28d2e22a/"/>
    <url>/post/28d2e22a/</url>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><p><img src="/%E5%8D%8F%E7%A8%8B-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/20200808082113587.png">  </p><h2 id="进程是什么"><a href="#进程是什么" class="headerlink" title="进程是什么"></a>进程是什么</h2><p>进程就是应用程序的启动实例<br>比如我们运行一个游戏，打开一个软件，就是开启了一个进程<br>进程拥有代码和打开的文件资源、数据资源、独立的内存空间  </p><h2 id="线程是什么"><a href="#线程是什么" class="headerlink" title="线程是什么"></a>线程是什么</h2><p>线程从属于进程，是程序的实际执行者<br>一个进程至少包含一个主线程，也可以有更多的子线程<br>线程拥有自己的栈空间<br>线程会在不同状态中不断转化<br><img src="/%E5%8D%8F%E7%A8%8B-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/20200808084316757.png"><br>线程不同状态之间的转化由操作系统内核中的TCB（Thread Control Block）模块实现，这一过程需要耗费一定的CPU资源  </p><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><p>对操作系统来说，线程是最小的执行单元，进程是最小的资源管理单元<br>无论进程还是线程，都是由操作系统所管理的  </p><h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><ul><li>多个线程共同运作时，为了不出现问题，通常要同步加锁  </li><li>线程在 阻塞状态 和 可运行状态 之间切换需要CPU资源  </li><li>线程 上下文切换（指记录程序执行到何处）需要CPU资源  </li></ul><h2 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h2><p>协程是一种比线程更加轻量级的存在<br>正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程<br><img src="/%E5%8D%8F%E7%A8%8B-%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B/20200808110953807.png"><br>最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制<br>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。因此，协程的开销远远小于线程的开销。  </p><h3 id="优缺"><a href="#优缺" class="headerlink" title="优缺"></a>优缺</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>提高性能<br>相对于线程。无需线程上下文切换的开销，协程避免了无意义的调度，由此可以提高性能（但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力）  </li><li>无需原子操作锁定及同步的开销  </li><li>方便切换控制流，简化编程模型  </li><li>高并发+高扩展性+低成本<br>一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法利用多核资源<br>协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上。<br>协程需要和进程配合才能运行在多CPU上。当然日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用  </li><li>进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序  </li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>协程</tag>
      
      <tag>进程</tag>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mitmproxy</title>
    <link href="/post/9d9c1fd2/"/>
    <url>/post/9d9c1fd2/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>顾名思义，mitmproxy 就是用于 MITM 的 proxy，MITM 即中间人攻击（Man-in-the-middle attack）。用于中间人攻击的代理首先会向正常的代理一样转发请求，保障服务端与客户端的通信，其次，会适时的查、记录其截获的数据，或篡改数据，引发服务端或客户端特定的行为  </p><p>不同于 fiddler 或 wireshark 等抓包工具，mitmproxy 不仅可以截获请求帮助开发者查看、分析，更可以通过自定义脚本进行二次开发。举例来说，利用 fiddler 可以过滤出浏览器对某个特定 url 的请求，并查看、分析其数据，但实现不了高度定制化的需求，类似于：“截获对浏览器对该 url 的请求，将返回内容置空，并将真实的返回内容存到某个数据库，出现异常时发出邮件通知”。而对于 mitmproxy，这样的需求可以通过载入自定义 python 脚本轻松实现  </p><p>mitmproxy 工作在 HTTP 层， HTTPS 的普及让客户端拥有了检测并规避中间人攻击的能力，所以要让 mitmproxy 能够正常工作，必须要让客户端（APP 或浏览器）主动信任 mitmproxy 的 SSL 证书，或忽略证书异常  </p><p>利用手机模拟器、无头浏览器来爬取 APP 或网站的数据，mitmpproxy 作为代理可以拦截、存储爬虫获取到的数据，或修改数据调整爬虫的行为  </p><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><table><thead><tr><th>信息</th><th>链接</th></tr></thead><tbody><tr><td>官网</td><td><a href="https://mitmproxy.org/">https://mitmproxy.org/</a></td></tr><tr><td>文档</td><td><a href="https://docs.mitmproxy.org/stable/">https://docs.mitmproxy.org/stable/</a></td></tr><tr><td>Github</td><td><a href="https://github.com/mitmproxy/mitmproxy">https://github.com/mitmproxy/mitmproxy</a></td></tr><tr><td>DockerHub</td><td><a href="https://hub.docker.com/r/mitmproxy/mitmproxy/">https://hub.docker.com/r/mitmproxy/mitmproxy/</a></td></tr></tbody></table><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装程序"><a href="#安装程序" class="headerlink" title="安装程序"></a>安装程序</h2><p><img src="/mitmproxy/20200806041304952.png"><br>官网首页将安装包下载下来，选择一个地方安装好  </p><h2 id="安装证书"><a href="#安装证书" class="headerlink" title="安装证书"></a>安装证书</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>在用户目录下找到<code>mitmproxy</code>证书进行安装<br>一般会在<code>C:\Users\Administrator\.mitmproxy</code>文件夹中<br>证书名为<code>mitmproxy-ca.p12</code>，双击开始安装<br><img src="/mitmproxy/20200806041748503.png"><br>一路下一步，到这里，选择<code>受信任的根证书颁发机构</code><br>最后会弹出警告，选是即可  </p><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><p>操作与上述似，但证书文件是<code>mitmproxy-ca-cert.pem</code>  </p><h2 id="python库安装"><a href="#python库安装" class="headerlink" title="python库安装"></a>python库安装</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> mitmproxy<br></code></pre></td></tr></table></figure><h2 id="使用代理以验证安装"><a href="#使用代理以验证安装" class="headerlink" title="使用代理以验证安装"></a>使用代理以验证安装</h2><p><code>cmd</code>中输入<code>mitmweb</code>以启用<code>mitmweb</code><br><img src="/mitmproxy/20200806064021137.png"><br>启用后会提示 web运行信息 和 代理信息<br>将代理信息记录下来，设置到 浏览器代理 或者 系统代理之中  </p><p>若是使用<code>Chrome</code>浏览器，推荐使用插件<code>SwitchyOmega</code>来管理代理<br><a href="https://github.com/FelisCatus/SwitchyOmega">https://github.com/FelisCatus/SwitchyOmega</a><br><img src="/mitmproxy/20200806064603862.png"><br>进行设置以后，请求/响应都会通过代理进行，在不使用代理时注意关闭<br><img src="/mitmproxy/20200806064950822.png"><br>最终会抓到一些包，显示在控制台上  </p><h1 id="插件-Addons"><a href="#插件-Addons" class="headerlink" title="插件  Addons"></a>插件  Addons</h1><p><code>Mitmproxy</code>的<code>Addons</code>机制由一组API组成<br><code>Addons</code>通过响应事件与<code>mitmproxy</code>进行交互，从而使它们能够参与并改变<code>mitmproxy</code>的行为<br><code>Addons</code>是通过<a href="https://docs.mitmproxy.org/stable/concepts-options/">Option</a>配置的，这些选项可以在<code>mitmproxy</code>的配置文件中设置，也可以由用户交互地更改或通过命令行进行修改<br><code>Addons</code>是<code>mitmproxy</code>的重要组成部分，实际上很多<code>mitmproxy</code>自身的函数都是被定义在 一套<code>Addons</code> 中的<br><code>Mitmproxy</code>为第三方脚本编写程序和扩展程序提供了一套完全相同的工具来实现它自己的功能  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">pydoc</span> <span class="hljs-selector-tag">mitmproxy</span><span class="hljs-selector-class">.http</span><br></code></pre></td></tr></table></figure><p>你可以通过这个命令来查阅API文档  </p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">一个简单的 mitmproxy addon.</span><br><span class="hljs-string">你可以通过这个命令运行: mitmproxy -s anatomy.py</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> ctx<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Counter</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.num = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">request</span>(<span class="hljs-params">self, flow</span>):</span><br>        self.num = self.num + <span class="hljs-number">1</span><br>        ctx.log.info(<span class="hljs-string">&quot;We&#x27;ve seen %d flows&quot;</span> % self.num)<br><br>addons = [<br>    Counter()<br>]<br></code></pre></td></tr></table></figure><p>这是个简单的案例，每当发送新的请求，都会在控制台输出文字  </p><h1 id="事件-Events"><a href="#事件-Events" class="headerlink" title="事件 Events"></a>事件 Events</h1><p><code>Addons</code>通过<code>Events</code>与mitmproxy的内部机制挂钩<br>许多<code>Events</code>接收<code>Flow</code>对象作为参数，通过修改这些参数，<code>Addons</code>能改变包的信息  </p><h2 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;例子：为每一个响应添加一个统计数量的响应头&quot;&quot;&quot;</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddHeader</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.num = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">response</span>(<span class="hljs-params">self, flow</span>):</span><br>        self.num = self.num + <span class="hljs-number">1</span><br>        flow.response.headers[<span class="hljs-string">&quot;count&quot;</span>] = <span class="hljs-built_in">str</span>(self.num)<br><br>addons = [<br>    AddHeader()<br>]<br></code></pre></td></tr></table></figure><p>所支持的所有<code>Events</code>：<a href="https://docs.mitmproxy.org/stable/addons-events/">https://docs.mitmproxy.org/stable/addons-events/</a>  </p><h1 id="选项-Options"><a href="#选项-Options" class="headerlink" title="选项 Options"></a>选项 Options</h1><p><code>Mitmproxy</code>核心的全局设置存储，包含了决定<code>Mitmproxy</code>及其插件行为的设置<br><code>Options</code>会从配置文件中读取，你可以通过命令行来动态改变它  </p><p>所有<code>Options</code>都使用一组受支持的类型进行。<code>Mitmproxy</code>知道如何序列化和反序列化这些类型。强行设置不合适的值会导致错误   </p><h2 id="案例-2"><a href="#案例-2" class="headerlink" title="案例"></a>案例</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">添加一个新的 mitmproxy option</span><br><span class="hljs-string">启动命令: mitmproxy -s 4_options.py --set addheader true</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> ctx<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddHeader</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.num = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load</span>(<span class="hljs-params">self, loader</span>):</span><br>        loader.add_option(<br>            name = <span class="hljs-string">&quot;addheader&quot;</span>,<br>            typespec = <span class="hljs-built_in">bool</span>,<br>            default = <span class="hljs-literal">False</span>,<br>            <span class="hljs-built_in">help</span> = <span class="hljs-string">&quot;Add a count header to responses&quot;</span>,<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">response</span>(<span class="hljs-params">self, flow</span>):</span><br>        <span class="hljs-keyword">if</span> ctx.options.addheader:<br>            self.num = self.num + <span class="hljs-number">1</span><br>            flow.response.headers[<span class="hljs-string">&quot;count&quot;</span>] = <span class="hljs-built_in">str</span>(self.num)<br>addons = [<br>    AddHeader()<br>]<br></code></pre></td></tr></table></figure><p><code>load</code> <code>Event</code>会接收一个可以声明<code>Option</code>和命令的<code>mitmproxy.addonmanager.Loader</code>对象。这个<code>Addon</code>添加了一个<code>bool</code>类型的<code>addheader</code> <code>Option</code><br>在命令行里运行脚本  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">mitmproxy -s 4_options.py --<span class="hljs-builtin-name">set</span> addheader <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>通过代理访问一下网站，就能够在命令行看到一些信息<br>如果你观察包，你会发现<code>HTTP headers</code>并没有<code>addheader</code>项。这是因为<code>add_option</code>的默认值为<code>false</code>它并不会启动<br>按<code>O</code>进入<code>options</code>编辑器，找到<code>addheader</code>项并将它改为<code>true</code>，你就会看到添加了计数项的响应头部  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">HTTP</span>/<span class="hljs-number">1</span>.<span class="hljs-number">1</span> <span class="hljs-number">301</span> Moved Permanently<br><span class="hljs-attribute">Location</span>: http://www.google.com/<br><span class="hljs-attribute">Content</span>-Length: <span class="hljs-number">219</span><br><span class="hljs-attribute">count</span>: <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>在加载这个<code>Addon</code>的时候，<code>addheader</code>的设置会保存在 <a href="https://docs.mitmproxy.org/stable/concepts-options/">设置文件YAML</a>里<br>你也可以在运行命令的时候用<code>--set</code>参数来设置<code>options</code>  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">mitmproxy -s .<span class="hljs-regexp">/examples/</span>addons/<span class="hljs-keyword">options</span>-simple.py --set addheader=<span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure><h2 id="配置更新"><a href="#配置更新" class="headerlink" title="配置更新"></a>配置更新</h2><p><code>configure</code> <code>event</code>能在<code>option</code>更变的时候立即做一些响应<br>当<code>option</code>发生变更，<code>configure</code> <code>event</code> 会被被触发。它会收到一组被更变的<code>options</code>的<code>set</code>，<code>Addon</code>可以检查<code>option</code>是否在<code>set</code>里，然后根据上下文的<code>option</code>对象里获取值并作出一些响应<br>这功能最常见的用法是用来检查<code>option</code>是否有效，若无效，则进行记录（反馈）  </p><h3 id="案例-3"><a href="#案例-3" class="headerlink" title="案例"></a>案例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;React to configuration changes.&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> typing<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> ctx<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> exceptions<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AddHeader</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load</span>(<span class="hljs-params">self, loader</span>):</span><br>        loader.add_option(<br>            name = <span class="hljs-string">&quot;addheader&quot;</span>,<br>            typespec = typing.Optional[<span class="hljs-built_in">int</span>],<br>            default = <span class="hljs-literal">None</span>,<br>            <span class="hljs-built_in">help</span> = <span class="hljs-string">&quot;Add a header to responses&quot;</span>,<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">configure</span>(<span class="hljs-params">self, updates</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;addheader&quot;</span> <span class="hljs-keyword">in</span> updates:<br>            <span class="hljs-keyword">if</span> ctx.options.addheader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> ctx.options.addheader &gt; <span class="hljs-number">100</span>:<br>                <span class="hljs-keyword">raise</span> exceptions.OptionsError(<span class="hljs-string">&quot;addheader must be &lt;= 100&quot;</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">response</span>(<span class="hljs-params">self, flow</span>):</span><br>        <span class="hljs-keyword">if</span> ctx.options.addheader <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            flow.response.headers[<span class="hljs-string">&quot;addheader&quot;</span>] = <span class="hljs-built_in">str</span>(ctx.options.addheader)<br><br><br>addons = [<br>    AddHeader()<br>]<br></code></pre></td></tr></table></figure><p>在你设置一个不符合规定的<code>addheader</code>值时，<code>configure</code> <code>event</code>会给你反馈信息  </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">mitmdump -s .<span class="hljs-regexp">/examples/</span>addons/<span class="hljs-keyword">options</span>-configure.py --set addheader=<span class="hljs-number">1000</span><br>Loading script: .<span class="hljs-regexp">/examples/</span>addons/<span class="hljs-keyword">options</span>-configure.py<br><span class="hljs-regexp">/Users/</span>cortesi<span class="hljs-regexp">/mitmproxy/mi</span>tmproxy<span class="hljs-regexp">/venv/</span>bin/mitmdump: addheader must be &lt;= <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h2 id="options支持的数据类型"><a href="#options支持的数据类型" class="headerlink" title="options支持的数据类型"></a>options支持的数据类型</h2><p><code>str</code>, <code>int</code>, <code>float</code>, <code>bool</code>, <code>typing.Optional</code>, <code>typing.Sequence</code></p><h1 id="命令-Commands"><a href="#命令-Commands" class="headerlink" title="命令 Commands"></a>命令 Commands</h1><p><code>Commands</code>允许用户与插件进行主动交互-查询其状态，命令他们执行操作以或者让它们转换数据。<br><code>Commands</code>是一个非常强大的结构，<code>mitmproxy</code>控制台中的所有用户交互都是通过将命令绑定到<code>keys</code>来构建的</p><h2 id="案例1"><a href="#案例1" class="headerlink" title="案例1"></a>案例1</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;添加一个用户自定义Commands&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> command<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> ctx<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAddon</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.num = <span class="hljs-number">0</span><br><br><span class="hljs-meta">    @command.command(<span class="hljs-params"><span class="hljs-string">&quot;myaddon.inc&quot;</span></span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inc</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.num += <span class="hljs-number">1</span><br>        ctx.log.info(<span class="hljs-string">f&quot;num = <span class="hljs-subst">&#123;self.num&#125;</span>&quot;</span>)<br><br><br>addons = [<br>    MyAddon()<br>]<br></code></pre></td></tr></table></figure><p>运行脚本代码</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">mitmproxy -s commands-<span class="hljs-built_in">simple</span>.py<br></code></pre></td></tr></table></figure><p>输入自己设置的命令即可得到结果</p><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs clojure"><span class="hljs-symbol">:myaddon.inc</span><br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>命令应该是唯一的，不要弄重复  </li><li>你只能运用那些<code>option</code>里能用的变量类型(包括返回值)</li></ul><h2 id="案例2-与flows配合使用"><a href="#案例2-与flows配合使用" class="headerlink" title="案例2 与flows配合使用"></a>案例2 与flows配合使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> typing<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> command<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> ctx<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> flow<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAddon</span>:</span><br><span class="hljs-meta">    @command.command(<span class="hljs-params"><span class="hljs-string">&quot;myaddon.addheader&quot;</span></span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addheader</span>(<span class="hljs-params">self, flows: typing.Sequence[flow.Flow]</span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> flows:<br>            f.request.headers[<span class="hljs-string">&quot;myheader&quot;</span>] = <span class="hljs-string">&quot;value&quot;</span><br>        ctx.log.alert(<span class="hljs-string">&quot;done&quot;</span>)<br><br>addons = [<br>    MyAddon()<br>]<br></code></pre></td></tr></table></figure><p><code>myaddon.addheader</code>命令十分简单，它获取一系列的<code>flows</code>被为请求添加一个头部参数<br>这个案例真正有趣的地方是用户如何指定<code>flows</code>。<code>mitmproxy</code>可以检查类型信息，这意味着你能通过类型信息来设置一些过滤条件，增加灵活性<br>启动脚本</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mitmproxy -s .<span class="hljs-regexp">/examples/</span>addons/commands-flows.py<br></code></pre></td></tr></table></figure><p>尝试不同的参数<br>只对<code>@focus</code>的<code>flows</code>执行<code>addheader</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:myaddon.addheader</span> <span class="hljs-keyword">@focus</span><br></code></pre></td></tr></table></figure><p>对所有的<code>flows</code>执行<code>addheader</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:myaddon.addheader</span> <span class="hljs-keyword">@all</span><br></code></pre></td></tr></table></figure><p>只对来自 google.com 的<code>flows</code>执行<code>addheader</code></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-pseudo">:myaddon.addheader</span> ~<span class="hljs-selector-tag">d</span> <span class="hljs-selector-tag">google</span><span class="hljs-selector-class">.com</span><br></code></pre></td></tr></table></figure><h2 id="案例3-路径类型-paths"><a href="#案例3-路径类型-paths" class="headerlink" title="案例3 路径类型 paths"></a>案例3 路径类型 paths</h2><p>命令可以带有任意数量的参数，演示一种特殊类型：<code>paths</code>  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;将文件路径作为命令参数处理&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> typing<br><br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> command<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> ctx<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> flow<br><span class="hljs-keyword">from</span> mitmproxy <span class="hljs-keyword">import</span> types<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAddon</span>:</span><br><span class="hljs-meta">    @command.command(<span class="hljs-params"><span class="hljs-string">&quot;myaddon.histogram&quot;</span></span>)</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">histogram</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">        self,</span></span><br><span class="hljs-function"><span class="hljs-params">        flows: typing.Sequence[flow.Flow],</span></span><br><span class="hljs-function"><span class="hljs-params">        path: types.Path,</span></span><br><span class="hljs-function"><span class="hljs-params">    </span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        totals = &#123;&#125;<br>        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> flows:<br>            totals[f.request.host] = totals.setdefault(f.request.host, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br><br>        <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path, <span class="hljs-string">&quot;w+&quot;</span>) <span class="hljs-keyword">as</span> fp:<br>            <span class="hljs-keyword">for</span> cnt, dom <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>([(v, k) <span class="hljs-keyword">for</span> (k, v) <span class="hljs-keyword">in</span> totals.items()]):<br>                fp.write(<span class="hljs-string">&quot;%s: %s\n&quot;</span> % (cnt, dom))<br><br>        ctx.log.alert(<span class="hljs-string">&quot;done&quot;</span>)<br><br><br>addons = [<br>    MyAddon()<br>]<br></code></pre></td></tr></table></figure><p>命令的路径参数会作为第二参数来传入，你可以用类似于这种方式来使用它  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">:myaddon.histogram @all <span class="hljs-regexp">/tmp/</span>xxx<br></code></pre></td></tr></table></figure><h2 id="支持的类型"><a href="#支持的类型" class="headerlink" title="支持的类型"></a>支持的类型</h2><ul><li>Primitive types: <code>str</code>, <code>int</code>, <code>bool</code>  </li><li>Sequences: <code>typing.Sequence[str]</code>  </li><li>Flows and flow sequences: <code>flow.Flow</code> and <code>typing.Sequence[flow.Flow]</code>  </li><li>Multiple choice strings: <code>types.Choice</code>  </li><li>Meta-types: <code>types.Command</code> and <code>types.Arg</code>. These are for constructing commands that invoke other commands. This is most commonly useful in keybinding - see the built-in mitmproxy console keybindings for a rich suite of examples  </li><li>Data types: <code>types.CutSpec</code> and <code>types.Data</code>. The cuts mechanism is in alpha at the moment, and provides a convenient way to snip up flow data  </li><li>Path: <code>types.Path</code></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>mitmproxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RESTful架构</title>
    <link href="/post/2654e413/"/>
    <url>/post/2654e413/</url>
    
    <content type="html"><![CDATA[<h1 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h1><p><code>REST</code>这个词，是<code>Roy Thomas Fielding</code>在他2000年的博士论文中提出的  </p><blockquote><p>Fielding，HTTP协议（1.0版和1.1版）的主要设计者、Apache服务器软件的作者之一、Apache基金会的第一任主席  </p></blockquote><h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><p>Fielding将他对互联网软件的架构原则，定名为REST，即<code>Representational State Transfer</code>的缩写<br>如果一个架构符合REST原则，就称它为RESTful架构  </p><p>REST的名称”表现层状态转化”中，省略了主语。”表现层”其实指的是”资源”（Resources）的”表现层”。</p><h2 id="资源-Resources"><a href="#资源-Resources" class="headerlink" title="资源 Resources"></a>资源 Resources</h2><p>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在<br>你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符  </p><h2 id="表现层-Representation"><a href="#表现层-Representation" class="headerlink" title="表现层 Representation"></a>表现层 Representation</h2><p>“资源”是一种信息实体，它可以有多种外在表现形式<br>我们把”资源”具体呈现出来的形式，叫做它的”表现层”（Representation）  </p><p>比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现  </p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述  </p><h2 id="状态转化（State-Transfer）"><a href="#状态转化（State-Transfer）" class="headerlink" title="状态转化（State Transfer）"></a>状态转化（State Transfer）</h2><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化<br>互联网通信协议HTTP协议，是一个无状态协议<br>这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”<br>客户端用到的手段，只能是HTTP协议<br>具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综合上面的解释，我们总结一下什么是RESTful架构：  </p><ol><li>每一个URI代表一种资源  </li><li>客户端和服务器之间，传递这种资源的某种表现层  </li><li>客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”  </li></ol><h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><h2 id="C-S架构"><a href="#C-S架构" class="headerlink" title="C-S架构"></a>C-S架构</h2><p>数据的存储在Server端，Client端只需使用就行。两端彻底分离的好处使client端代码的可移植性变强，Server端的拓展性变强。两端单独开发，互不干扰  </p><h2 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h2><p>http请求本身就是无状态的，基于C-S架构，客户端的每一次请求带有充分的信息能够让服务端识别<br>请求所需的一些信息都包含在URL的查询参数、header、div，服务端能够根据请求的各种参数，无需保存客户端的状态，将响应正确返回给客户端。无状态的特征大大提高的服务端的健壮性和可拓展性  </p><p>当然，这种无状态性的约束也是有缺点的，客户端的每一次请求都必须带上相同重复的信息确定自己的身份和状态，造成传输数据的冗余性，但这种确定对于性能和使用来说，几乎是忽略不计的  </p><h2 id="统一的接口"><a href="#统一的接口" class="headerlink" title="统一的接口"></a>统一的接口</h2><p>REST架构的核心内容，统一的接口对于RESTful服务非常重要。客户端只需要关注实现接口就可以，接口的可读性加强，使用人员方便调用  </p><p>REST接口约束定义为：资源识别; 请求动作; 响应信息; 它表示通过uri标出你要操作的资源，通过请求动作（http method）标识要执行的操作，通过返回的状态码来表示这次请求的执行结果  </p><h2 id="一致的数据格式"><a href="#一致的数据格式" class="headerlink" title="一致的数据格式"></a>一致的数据格式</h2><p>服务端返回的数据格式要么是XML，要么是Json（获取数据），或者直接返回状态码，一些知名网站的开放平台的操作数据的api，post、put、patch都是返回的一个状态码  </p><p>如请求一条微博信息，服务端响应信息应该包含这条微博相关的其他URL，客户端可以进一步利用这些URL发起请求获取感兴趣的信息，再如分页可以从第一页的返回数据中获取下一页的URT也是基于这个原理  </p><h2 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h2><p>在万维网上，客户端可以缓存页面的响应内容。因此响应都应隐式或显式的定义为可缓存的，若不可缓存则要避免客户端在多次请求后用旧数据或脏数据来响应<br>管理得当的缓存会部分地或完全地除去客户端和服务端之间的交互，进一步改善性能和延展性  </p><h2 id="按需编码、可定制代码"><a href="#按需编码、可定制代码" class="headerlink" title="按需编码、可定制代码"></a>按需编码、可定制代码</h2><p>服务端可选择临时给客户端下发一些功能代码让客户端来执行，从而定制和扩展客户端的某些功能<br>比如服务端可以返回一些 Javascript 代码让客户端执行，去实现某些特定的功能。</p><blockquote><p>提示：REST架构中的设计准则中，只有按需编码为可选项。如果某个服务违反了其他任意一项准则，严格意思上不能称之为RESTful风格。</p></blockquote><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>如github开放平台的API：<a href="http://developer.github.com/v3/">http://developer.github.com/v3/</a><br>可以发现，一般的项目加版本v1，v2，v3版本号，为的是兼容一些老版本的接口，这个加版本估计只有大公司大项目才会去使用  </p><h2 id="参数命名规范"><a href="#参数命名规范" class="headerlink" title="参数命名规范"></a>参数命名规范</h2><p>query parameter可以采用驼峰命名法，也可以采用下划线命名的方式，后者比前者的识别度要高<br>其中，做前端开发基本都后后者，而做服务器接口开发基本用前者  </p><h2 id="url命名规范"><a href="#url命名规范" class="headerlink" title="url命名规范"></a>url命名规范</h2><p><code>API</code>命名应该采用约定俗成的方式，保持简洁明了<br>在RESTful架构中，每个url代表一种资源，所以url中不能有动词，只能有名词，并且名词中也应该使用复数<br>实现者应使用相应的Http动词GET、POST、PUT、PATCH、DELETE、HEAD来操作这些资源  </p><h2 id="统一返回数据格式"><a href="#统一返回数据格式" class="headerlink" title="统一返回数据格式"></a>统一返回数据格式</h2><p>对于合法的请求应该返回统一的数据格式，对于返回数据，通常会包含如下字段  </p><ul><li>code<br>包含一个整数类型的HTTP响应状态码  </li><li>status<br>包含文本：”success”，”fail”或”error”。</li><li>HTTP状态响应码<br>在500-599之间为”fail”，在400-499之间为”error”，其它均为”success”（例如：响应状态码为1XX、2XX和3XX）。这个根据实际情况其实是可要可不要的   </li><li>message<br>当状态值为”fail”和”error”时有效，用于显示错误信息。参照国际化（il8n）标准，它可以包含信息号或者编码，可以只包含其中一个，或者同时包含并用分隔符隔开  </li><li>data<br>包含响应的div。当状态值为”fail”或”error”时，data仅包含错误原因或异常名称、或者null也是可以的  </li></ul><hr><p>参考：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2011/09/restful.html">http://www.ruanyifeng.com/blog/2011/09/restful.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/91240556">https://zhuanlan.zhihu.com/p/91240556</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>RESTful</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫-基础</title>
    <link href="/post/5c0a4593/"/>
    <url>/post/5c0a4593/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML-DOM"><a href="#HTML-DOM" class="headerlink" title="HTML DOM"></a>HTML DOM</h1><p>文档对象模型  中立于平台和语言的接口<br>允许程序动态地更新文档内容，结构和样式  </p><blockquote><p>js代码和css样式可以改变 HTML，但只是改变显示样式，并没有真正改变HTML文档本身  </p></blockquote><h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><h2 id="页面渲染流程"><a href="#页面渲染流程" class="headerlink" title="页面渲染流程"></a>页面渲染流程</h2><p><img src="/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/20200807060538670.png"><br><img src="/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/20200807061040811.png"><br>因为其它工具里没有js解释器，CSS解释器，所以可以通过这两个东西来进行反爬虫  </p><h2 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h2><ul><li>Cookies<br>用于服务端通信，存储量小  </li><li>Local Storage<br>存储量比Cookies大一些，只能存字符串  </li><li>Session Storage<br>只存在于当前Session,关闭浏览器就丢失  </li><li>IndexedDB<br>相当于浏览器上的SQL数据库，存储空间大，API较难掌握</li></ul><h1 id="HTTP与HTTPS"><a href="#HTTP与HTTPS" class="headerlink" title="HTTP与HTTPS"></a>HTTP与HTTPS</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>Hyper Text Transfer Protocol<br>超文本传输协议，用于从网络传输超文本数据到本地浏览器的传送协议，能保证高效而准确的传送超文本文档（通常是网页html文件）  </p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>Hyper Text Transfer Protocol over Secure Socket Layer<br>以安全为目标的HTTP通道，即是在HTTP下加入SSL层，简称为HTTPS<br>简单来说就是更安全的HTTP</p><h1 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h1><p>请求一般分为四个部分：请求方法，请求url，请求头，请求体  </p><h2 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>GET</td><td>请求指定的页面信息，并返回实体主体</td></tr><tr><td>POST</td><td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。<BR>POST 请求可能会导致新的资源的建立和/或已有资源的修改</td></tr><tr><td>HEAD</td><td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td>DELETE</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td>CONNECT</td><td>HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器</td></tr><tr><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或诊断</td></tr><tr><td>PATCH</td><td>是对 PUT 方法的补充，用来对已知资源进行局部更新</td></tr></tbody></table><p>现在碰到的绝大部分请求都会是GET和POST请求  </p><h3 id="GET与POST的区别"><a href="#GET与POST的区别" class="headerlink" title="GET与POST的区别"></a>GET与POST的区别</h3><ul><li>GET请求的参数 包含在URL中，POST并非在其中，而是会在请求体中通过表单的形式传递  </li><li>GET请求最多提交1024字节的数据，而POST则没有限制  </li></ul><h2 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h2><table><thead><tr><th>常用信息</th><th>描述</th></tr></thead><tbody><tr><td>Accept</td><td>请求头域，指定接受的内容类型</td></tr><tr><td>Accept-Encoding</td><td>指定接受的内容的编码格式</td></tr><tr><td>Accept-Language</td><td>指定接受的内容的语言</td></tr><tr><td>Host</td><td>指定服务器域名和TCP端口号，如果使用的是服务请求标准端口号，端口号可以省略</td></tr><tr><td>Cookie</td><td>网站为了辨识用户进行绘画跟踪而储存在用户本地的数据。主要功能是维持当前访问会话</td></tr><tr><td>Referer</td><td>用于标识请求从哪个页面发送过来，一般用于给服务器做数据统计</td></tr><tr><td>User-Agent</td><td>简称UA，标明用户使用的操作系统，浏览器信息</td></tr><tr><td>Content-Type</td><td>设置请求体的MIME类型，用于表示具体请求的媒体类型信息</td></tr><tr><td>X-Requested-With</td><td>标识Ajax请求，大部分js框架发送请求时都会设置它为XMLHttpRequest</td></tr><tr><td>Cache-Control</td><td>设置请求响应链上所有的缓存机制必须遵守的指令</td></tr><tr><td>Content-Length</td><td>设置请求体的字节长度</td></tr><tr><td>TE</td><td>设置用户代理期望接受的传输编码格式，和响应头中的Transfer-Encoding字段一样</td></tr><tr><td>DNT</td><td>请求web应用禁用用户追踪</td></tr><tr><td>Connection</td><td>设置当前连接和hop-by-hop协议请求字段列表的控制选项</td></tr><tr><td>Accept-Charset</td><td>接受的字符编码</td></tr></tbody></table><p>比较重要的信息：Cookies、Referer、User-Agent……  </p><h2 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h2><p>承载信息主体</p><h1 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h1><p>响应主要分为三个部分：响应状态码，响应头，响应体  </p><h2 id="响应状态码"><a href="#响应状态码" class="headerlink" title="响应状态码"></a>响应状态码</h2><p>标识请求是否已成功完成<br>响应分为五类：信息响应(100–199)，成功响应(200–299)，重定向(300–399)，客户端错误(400–499)和服务器错误 (500–599)<br>详细：<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status</a>  </p><h2 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h2><table><thead><tr><th>常用信息</th><th>描述</th></tr></thead><tbody><tr><td>Date</td><td>响应产生的时间</td></tr><tr><td>Last-Modified</td><td>文档的最后改动时间</td></tr><tr><td>Allow</td><td>服务器支持哪些请求方法</td></tr><tr><td>Content-Encoding</td><td>文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。</td></tr><tr><td>Content-Length</td><td>内容长度</td></tr><tr><td>Content-Type</td><td>表示后面的文档属于什么MIME类型</td></tr><tr><td>Server</td><td>服务器名字</td></tr><tr><td>Expires</td><td>响应过期时间，数据可以缓存在浏览器或者代理服务器中，如果再次访问，则可以从缓存中加载，降低服务器负荷</td></tr><tr><td>Set-Cookie</td><td>设置和页面关联的Cookie</td></tr></tbody></table><h2 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h2><p>承载信息主体</p><h1 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h1><h2 id="静态页面与动态页面"><a href="#静态页面与动态页面" class="headerlink" title="静态页面与动态页面"></a>静态页面与动态页面</h2><table><thead><tr><th></th><th>静态页面</th><th>动态页面</th></tr></thead><tbody><tr><td>内容</td><td>固定</td><td>可变</td></tr><tr><td>加载速度</td><td>快</td><td>慢</td></tr><tr><td>可维护性</td><td>差</td><td>好</td></tr><tr><td>动态页面可以解析URL中的参数变化，动态呈现不同的页面内容，更加灵活多变</td><td></td><td></td></tr></tbody></table><h2 id="无状态HTTP"><a href="#无状态HTTP" class="headerlink" title="无状态HTTP"></a>无状态HTTP</h2><p>无状态HTTP是指HTTP协议对事物处理是没有记忆能力的<br>向服务器发送请求，服务器解析请求，返回对应响应，这个过程是完全独立的，服务器不会记录前后状态的变化。这意味着如果你需要处理前面处理过的信息，则需要重传，会导致资源浪费<br>于是两个用于保持HTTP连接状态的技术出现了：<code>会话</code> 和 <code>Cookies</code></p><h3 id="会话-1"><a href="#会话-1" class="headerlink" title="会话"></a>会话</h3><p>会话对象用来存储特定用户会话所需的属性和配置信息<br>当用户在Web页面中跳转时，存储在会话对象中的变量不会消失，会在整个用户会话中一直存在下去  </p><blockquote><p>当用户请求Web页时，如果用户还没有会话，Web服务器会自动创建一个会话对象。<br>当会话过期或被抛弃后，服务器将终止会话</p></blockquote><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><p>网站为了辨识用户身份、进行会话跟踪 存储在用户本地终端上的数据  </p><h4 id="会话维持"><a href="#会话维持" class="headerlink" title="会话维持"></a>会话维持</h4><p>客户端第一次请求服务器时，服务器会返回一个相应头中带有<code>Set-Cookie</code>字段的响应给客户端用于标识用户，客户端则会将<code>Cookies</code>存起来<br>在浏览器再次请求该网站，浏览器会把此前存放的<code>Cookies</code>放到请求头里一起提交给服务器<br><code>Cookies</code>携带了会话ID信息，服务器检查就知道其对应的会话了  </p><h4 id="属性结构"><a href="#属性结构" class="headerlink" title="属性结构"></a>属性结构</h4><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>Name</td><td>Cookie名称<br>一旦创建，不可更改</td></tr><tr><td>Value</td><td>Cookie值<br>如果为Unicode字符，则需要为字符编码<br>如果为二进制数据，则需要使用BASE64编码</td></tr><tr><td>Domain</td><td>可以访问该Cookie的域名</td></tr><tr><td>Max Age</td><td>Cookie失效时间，单位为秒，常与Expires一同使用<br>若值为正数，则Cookie在Max Age秒后失效<br>若值为负数，则关闭浏览器后Cookie失效</td></tr><tr><td>Path</td><td>Cookie使用路径<br>如果设置为/path/，则只有路径为/path/的页面才可以访问此Cookie<br>不设置则域名下所有页面均可访问此Cookie</td></tr><tr><td>Size 字段</td><td>Cookie 大小</td></tr><tr><td>HTTP 字段</td><td>Cookie的httponly属性<br>若此属性为true,则只有HTTP头中会带有此Cookie信息，而不能通过document.cookie来访问此Cookie</td></tr><tr><td>Secure</td><td>此Cookie是否只使用安全协议传输</td></tr></tbody></table><h4 id="会话Cookie与持久Cookie"><a href="#会话Cookie与持久Cookie" class="headerlink" title="会话Cookie与持久Cookie"></a>会话Cookie与持久Cookie</h4><p>会话Cookie 指那些被存在浏览器内存中的Cookie，关闭浏览器后该Cookie会失效<br>持久Cookie 指那些保存在客户端硬盘中的Cookie，下次使用浏览器还能用  </p><p>很多时候，Cookie都会被设置为持久Cookie，而且设置一个相当长的失效时间，这样做可以节约登录的资源消耗  </p><h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>服务商的服务器是为普通用户服务的，服务商并不想为爬虫的程序浪费资源，因此会想办法反爬虫<br>在你提交请求的时候，服务器会记录你的IP。当同一个IP在一段时间内访问频率远高于一个正常人操作的频率，那么想都不用想，这就是爬虫程序，他会将你的IP设置在黑名单里，不再接受你的请求<br>使用代理来伪装IP，让服务器以为你是来自不同的地方的用户，本机IP不超出阀值，就不会被封禁</p><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>proxy server 代理服务器，功能是替代用户去获取网络信息，工作性质像是一个物流中转站<br>设置了代理以后，请求和响应都通过代理进行，服务器识别到的请求的IP是代理的IP<br>当代理足够多，将爬虫客户端高频率的请求分摊到多个代理服务器分别请求，形成很多看似合理的低频率访问，服务器就无法通过观察IP访问频率直接封禁IP来达到反爬虫的目的<br>需要注意的是 一个代理和客户端一样 会有访问频率过高而被封的可能，所以依然要注意访问频率</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li>突破IP访问限制<br>能访问到当前IP访问不了的站点  </li><li>提高访问速度<br>通常代理服务器会设置一个较大的硬盘缓冲区，当有外界的信息通过时，会将它保存到缓冲区中。当其他用户访问相同的信息，可以从缓冲区里直接取出信息，提高访问速度  </li><li>隐藏真实IP<br>保护自己或者，避免被封  </li></ul><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="按照协议区分"><a href="#按照协议区分" class="headerlink" title="按照协议区分"></a>按照协议区分</h3><table><thead><tr><th>代理类型</th><th>信息</th><th>协议默认端口</th></tr></thead><tbody><tr><td>FTP代理服务器</td><td>用户访问FTP服务，一般有上传、下载、缓存功能</td><td>21或2121</td></tr><tr><td>HTTP代理服务器</td><td>用于访问网页，一般有内容过滤和缓存功能</td><td>80或8080或3128</td></tr><tr><td>SSL/TLS代理</td><td>用于访问加密网站，一般有SSL或TLS加密功能</td><td>443</td></tr><tr><td>RTSP 代理</td><td>Real流媒体服务器，一般有缓存功能</td><td>554</td></tr><tr><td>Telnet 代理</td><td>用于telnet远程控制（黑客入侵时常用于隐藏身份）</td><td>23</td></tr><tr><td>POP3/SMTP 代理</td><td>POP3/SMTP收发右键，一般有缓存功能</td><td>110、25</td></tr><tr><td>SOCKS 代理</td><td>只是单纯传递数据包，不关心协议和用法，速度较快，一般有缓存功能</td><td>1080</td></tr></tbody></table><blockquote><p>SOCKS代理分类  </p></blockquote><blockquote><table><thead><tr><th></th><th>SOCKS4</th><th>SOCKS5</th></tr></thead><tbody><tr><td>协议支持</td><td>TCP</td><td>TCP/UDP</td></tr><tr><td>身份验证/域名解析</td><td>×</td><td>√</td></tr></tbody></table></blockquote><h3 id="按照匿名程度区分"><a href="#按照匿名程度区分" class="headerlink" title="按照匿名程度区分"></a>按照匿名程度区分</h3><table><thead><tr><th>代理类型</th><th>服务器获取到的IP信息</th><th>数据包改动</th><th>信息</th></tr></thead><tbody><tr><td>高度匿名代理</td><td>代理服务器IP</td><td>×</td><td>原封不动的转发数据包<br></td></tr><tr><td>普通匿名代理</td><td>知道你用了代理，可以追查到真实IP</td><td>√</td><td>通常会在HTTP头带上<code>HTTP_VIA</code>和<code>HTTP_X_FRORWARDED_FOR</code></td></tr><tr><td>透明代理</td><td>真实IP</td><td>√</td><td>会告诉服务器客户端的真实IP<br>主要作用在于利用缓存提高浏览速度，过滤不安全数据包</td></tr><tr><td>间谍代理</td><td>?</td><td>?</td><td>用于记录用户传输数据，然后进行研究，达到监控的目的</td></tr></tbody></table><p>对于爬虫来说，最好是有高匿代理，普通代理对一些小网站也可以用</p><h2 id="常见代理设置"><a href="#常见代理设置" class="headerlink" title="常见代理设置"></a>常见代理设置</h2><table><thead><tr><th>代理类型</th><th>稳定性</th><th>信息</th></tr></thead><tbody><tr><td>免费代理</td><td>差</td><td>可用的不多，使用前最好筛选一下，可以进一步维护出一个代理池</td></tr><tr><td>付费代理</td><td>较好</td><td>质量比免费的好很多</td></tr><tr><td>ADSL拨号</td><td>好</td><td>拨号一次换一个IP，是一种比较有效的解决方案</td></tr></tbody></table><h1 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h1><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）<br><code>AJAX</code> 是一种使用现有标准的新方法<br>利用<code>JavaScript</code>，在页面不刷新的情况下与服务器交换数据，更新部分网页的技术<br>这种技术的使用能节约一部分服务器资源消耗，提升用户体验  </p><h2 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h2><p>一般来说，从发送Ajax请求到更新网页这个过程可以分为三步：发送请求，解析响应，渲染页面<br>这里用原生JavaScript作为例子  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建一个 XMLHttpRequest 对象</span><br><span class="hljs-keyword">var</span> xmlhttp;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.XMLHttpRequest)<br>&#123;<br>    <span class="hljs-comment">//  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码</span><br>    xmlhttp=<span class="hljs-keyword">new</span> XMLHttpRequest();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">// IE6, IE5 浏览器执行代码</span><br>    xmlhttp=<span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//调用 onreadystatechange 进行监听，等待服务器响应</span><br>xmlhttp.onreadystatechange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">// 根据readyState和status判断响应状态</span><br>    <span class="hljs-keyword">if</span> (xmlhttp.readyState==<span class="hljs-number">4</span> &amp;&amp; xmlhttp.status==<span class="hljs-number">200</span>)<br>    &#123;<br>        <span class="hljs-comment">//响应回调，对服务器返回的数据进行的操作，刷新页面元素</span><br>        <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;myDiv&quot;</span>).innerHTML=xmlhttp.responseText;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//调用open()和send()向服务器发送请求</span><br>xmlhttp.open(<span class="hljs-string">&quot;GET&quot;</span>,<span class="hljs-string">&quot;ajax_info.txt&quot;</span>,<span class="hljs-literal">true</span>);<br>xmlhttp.send();<br></code></pre></td></tr></table></figure><table><thead><tr><th>XMLHttpRequest 对象</th><th>信息</th></tr></thead><tbody><tr><td>onreadystatechange</td><td>存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数</td></tr><tr><td>readyState</td><td>存有 XMLHttpRequest 的状态<br>0: 请求未初始化<br>1: 服务器连接已建立<br>2: 请求已接收<br>3: 请求处理中<br>4: 请求已完成，且响应已就绪</td></tr><tr><td>status</td><td>200: “OK”<br>404: 未找到页面</td></tr></tbody></table><h2 id="Ajax分析"><a href="#Ajax分析" class="headerlink" title="Ajax分析"></a>Ajax分析</h2><h3 id="Ajax头部特点"><a href="#Ajax头部特点" class="headerlink" title="Ajax头部特点"></a>Ajax头部特点</h3><p>Ajax有特殊的请求类型<code>xhr</code><br><img src="/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/20200724064909295.png"><br><code>x-requested-with: XMLHttpRequest</code>就标记了此请求是一个<code>Ajax</code>请求<br>如果需要模拟<code>Ajax</code>发送请求，需要在头部添加这个参数</p><h3 id="Ajax结果"><a href="#Ajax结果" class="headerlink" title="Ajax结果"></a>Ajax结果</h3><p>返回的结果类型多数会是json/xml/text<br><img src="/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/20200724070129095.png"><br>其内容可能存在被加密的可能性<br>但由于在页面上显示是正确的内容，所以js中一定存在解密的逻辑  </p><h3 id="Ajax溯源"><a href="#Ajax溯源" class="headerlink" title="Ajax溯源"></a>Ajax溯源</h3><p><img src="/%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80/20200724083416698.png"><br>可以根据<code>GET</code>方法的参数来进行全局查找<br>可以打<code>XHR断点</code>，根据url来寻找  </p><h4 id="Ajax样式"><a href="#Ajax样式" class="headerlink" title="Ajax样式"></a>Ajax样式</h4><p>流星</p><ul><li>AngularJS  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 简单的 GET 请求，可以改为 POST</span><br>$http(&#123;<br>    method: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>    url: <span class="hljs-string">&#x27;/someUrl&#x27;</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">successCallback</span>(<span class="hljs-params">response</span>) </span>&#123;<br>        <span class="hljs-comment">// 请求成功执行代码</span><br>    &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">errorCallback</span>(<span class="hljs-params">response</span>) </span>&#123;<br>        <span class="hljs-comment">// 请求失败执行代码</span><br>&#125;);<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>代理</tag>
      
      <tag>HTTP/HTTPS</tag>
      
      <tag>Ajax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10-优化</title>
    <link href="/post/dc386b6d/"/>
    <url>/post/dc386b6d/</url>
    
    <content type="html"><![CDATA[<p>装机以后的一些操作  </p><h2 id="Bios基本优化"><a href="#Bios基本优化" class="headerlink" title="Bios基本优化"></a>Bios基本优化</h2><p>打开Bios，将<code>GAME BOOST</code>和<code>A-XMP</code>开启  </p><h2 id="将我的文档内容路径修改"><a href="#将我的文档内容路径修改" class="headerlink" title="将我的文档内容路径修改"></a>将我的文档内容路径修改</h2><p>电脑用得越久，我的文档里的内容就会越来越多，越来越大<br><img src="/win10-%E4%BC%98%E5%8C%96/20200720024704628.png"><br><img src="/win10-%E4%BC%98%E5%8C%96/20200720024811707.png"><br>我的文档 文件夹下有挺多内容的，建议全部都改到其它盘的同一个地方，并且路径名只用英文  </p><h2 id="windows显示效果性能优化"><a href="#windows显示效果性能优化" class="headerlink" title="windows显示效果性能优化"></a>windows显示效果性能优化</h2><p><img src="/win10-%E4%BC%98%E5%8C%96/20200720030302780.png"><br>能优化的项目有不少，要是最求极致性能，可以直接点追加性能<br>我一般都会自定义  </p><h2 id="N卡基本优化"><a href="#N卡基本优化" class="headerlink" title="N卡基本优化"></a>N卡基本优化</h2><p>打开N卡控制面板<br><img src="/win10-%E4%BC%98%E5%8C%96/20200720024414502.png"><br><img src="/win10-%E4%BC%98%E5%8C%96/20200720025425287.png">  </p><h2 id="找回Windows照片查看器来使用"><a href="#找回Windows照片查看器来使用" class="headerlink" title="找回Windows照片查看器来使用"></a>找回Windows照片查看器来使用</h2><p>Windows10 默认使用照片来打开图片，这东西很慢<br>此处用旧版的图片查看器来代替现在的照片应用  </p><p>创建一个txt文件，写入以下内容  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ada">Windows Registry Editor Version <span class="hljs-number">5.00</span><br>; Change Extension<span class="hljs-symbol">&#x27;s</span> File <span class="hljs-keyword">Type</span><br>[HKEY_CURRENT_USER\Software\Classes\.jpg]<br>@=<span class="hljs-string">&quot;PhotoViewer.FileAssoc.Tiff&quot;</span><br>; Change Extension<span class="hljs-symbol">&#x27;s</span> File <span class="hljs-keyword">Type</span><br>[HKEY_CURRENT_USER\Software\Classes\.jpeg]<br>@=<span class="hljs-string">&quot;PhotoViewer.FileAssoc.Tiff&quot;</span><br>; Change Extension<span class="hljs-symbol">&#x27;s</span> File <span class="hljs-keyword">Type</span><br>[HKEY_CURRENT_USER\Software\Classes\.gif]<br>@=<span class="hljs-string">&quot;PhotoViewer.FileAssoc.Tiff&quot;</span><br>; Change Extension<span class="hljs-symbol">&#x27;s</span> File <span class="hljs-keyword">Type</span><br>[HKEY_CURRENT_USER\Software\Classes\.png]<br>@=<span class="hljs-string">&quot;PhotoViewer.FileAssoc.Tiff&quot;</span><br>; Change Extension<span class="hljs-symbol">&#x27;s</span> File <span class="hljs-keyword">Type</span><br>[HKEY_CURRENT_USER\Software\Classes\.bmp]<br>@=<span class="hljs-string">&quot;PhotoViewer.FileAssoc.Tiff&quot;</span><br>; Change Extension<span class="hljs-symbol">&#x27;s</span> File <span class="hljs-keyword">Type</span><br>[HKEY_CURRENT_USER\Software\Classes\.tiff]<br>@=<span class="hljs-string">&quot;PhotoViewer.FileAssoc.Tiff&quot;</span><br>; Change Extension<span class="hljs-symbol">&#x27;s</span> File <span class="hljs-keyword">Type</span><br>[HKEY_CURRENT_USER\Software\Classes\.ico]<br>@=<span class="hljs-string">&quot;PhotoViewer.FileAssoc.Tiff&quot;</span><br></code></pre></td></tr></table></figure><p>将文本文件扩展名改为<code>.reg</code>  </p><p>双击打开，确认修改注册表<br>修改图片打开方式<br><img src="/win10-%E4%BC%98%E5%8C%96/a.gif">  </p>]]></content>
    
    
    
    <tags>
      
      <tag>win10</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tesserocr-OCR</title>
    <link href="/post/40d470b0/"/>
    <url>/post/40d470b0/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>tesserocr</code>是 Python 的一个 OCR 识别库<br>其本身其实是对<code>tesseract</code>做的一层<code>python API</code>封装  </p><h1 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h1><table><thead><tr><th>内容</th><th>地址</th></tr></thead><tbody><tr><td>tesserocr GitHub</td><td><a href="https://github.com/sirfz/tesserocr">https://github.com/sirfz/tesserocr</a></td></tr><tr><td>tesserocr PyPi</td><td><a href="https://pypi.org/project/tesserocr/">https://pypi.org/project/tesserocr/</a></td></tr><tr><td>tesseract 下载地址</td><td><a href="https://digi.bib.uni-mannheim.de/tesseract/">https://digi.bib.uni-mannheim.de/tesseract/</a></td></tr><tr><td>tesseract 语言包</td><td><a href="https://github.com/tesseract-ocr/tessdata">https://github.com/tesseract-ocr/tessdata</a></td></tr><tr><td>tesseract 文档</td><td><a href="https://github.com/tesseract-ocr/tesseract/wiki/Documentation">https://github.com/tesseract-ocr/tesseract/wiki/Documentation</a></td></tr></tbody></table><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装tesseract"><a href="#安装tesseract" class="headerlink" title="安装tesseract"></a>安装tesseract</h2><p>首先先下载其核心<code>tesseract</code><br><img src="/tesserocr-OCR/20200720022503493.png"><br>一般选择稳定版下载，也就是那些不带dev/beta之类的字样的版本<br>下载好了以后安装上去，安装的时候，有附带语言包的选项<br>要是有梯，直接勾上就能顺便把想安装的语言包安装上  </p><h3 id="手动安装tesseract语言包"><a href="#手动安装tesseract语言包" class="headerlink" title="手动安装tesseract语言包"></a>手动安装tesseract语言包</h3><p>官方Github：<a href="https://tesseract-ocr.github.io/tessdoc/Data-Files">https://tesseract-ocr.github.io/tessdoc/Data-Files</a><br>官方github里有得下载<br><img src="/tesserocr-OCR/20200728043316303.png"><br>下载好以后，放在tesserocr安装目录这个路径下即可<br><img src="/tesserocr-OCR/20200728043539557.png">  </p><h3 id="添加tesseract到环境变量中"><a href="#添加tesseract到环境变量中" class="headerlink" title="添加tesseract到环境变量中"></a>添加tesseract到环境变量中</h3><h2 id="tesserocr安装"><a href="#tesserocr安装" class="headerlink" title="tesserocr安装"></a>tesserocr安装</h2><p><code>pip install tesserocr pillow</code><br>可以先尝试着直接用pip来安装<br>若是失败的话，可以去下载对应Python版本的whl来进行安装<br>whl下载地址：<br><a href="https://github.com/simonflueckiger/tesserocr-windows_build/releases">https://github.com/simonflueckiger/tesserocr-windows_build/releases</a><br><img src="/tesserocr-OCR/20200728044645155.png"></p><h2 id="测试是否安装成功"><a href="#测试是否安装成功" class="headerlink" title="测试是否安装成功"></a>测试是否安装成功</h2><p><code>import tesserocr from PIL import Image img = Image.open(r&#39;example/0_Basic_usage_of_the_library/tesserocr/pic/0_hello_world.png&#39;) chars = tesserocr.image_to_text(img) print(chars)</code><br>这里的图片路径需要换成你自己的  </p><h3 id="可能发生的错误"><a href="#可能发生的错误" class="headerlink" title="可能发生的错误"></a>可能发生的错误</h3><p><code>RuntimeError: Failed to init API, possibly an invalid tessdata path:......</code><br><img src="/tesserocr-OCR/20200728063611671.png"><br>将<code>tesseract</code>安装目录下的<code>tessdata</code>复制到其指定的地点即可  </p>]]></content>
    
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
      <tag>OCR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-aiohttp-异步web服务-爬虫</title>
    <link href="/post/8d1b1c05/"/>
    <url>/post/8d1b1c05/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>requests</code>是一个阻塞式HTTP请求库，发出一个请求后，程序会一直等待服务器响应，得到响应后，程序才会进行下一步处理。这种等待会大大降低爬取效率<br><code>aiohttp</code>是一个提供异步web服务的库，能让你的程序可以在等待的过程中做一切其他的事情，提高效率  </p><h1 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h1><p>官方文档：<a href="https://docs.aiohttp.org/en/stable/">https://docs.aiohttp.org/en/stable/</a><br>github：<a href="https://github.com/aio-libs/aiohttp">https://github.com/aio-libs/aiohttp</a>  </p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> aiohttp<br></code></pre></td></tr></table></figure><p>另外，官方推荐安装 字符编码检测库 cchardet，加速DNS解析库aiodns  </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> cchardet aiodns<br></code></pre></td></tr></table></figure><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-comment"># 首先，你要引入 aiohttp</span><br><span class="hljs-keyword">import</span> aiohttp<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Hello Aiohttp&#x27;</span>)<br><br><span class="hljs-comment"># 创建一个名为 session 的 ClientSession 对象  </span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:<br>    <span class="hljs-comment"># ClientSession 对象发起请求，获取结果保存为 resp</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>        <span class="hljs-built_in">print</span>(resp.status)  <span class="hljs-comment"># 响应状态码</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())  <span class="hljs-comment"># 响应内容</span><br></code></pre></td></tr></table></figure><p>这段代码创建了一个<code>session</code>以用作访问，但最好不要每一次访问都创建<code>session</code>，如果可以的话同一个网站用同一个session来进行访问  </p><p>实际上除了<code>get()</code>还有一些其它的方法  </p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lasso">session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>, <span class="hljs-built_in">data</span>=b<span class="hljs-string">&#x27;data&#x27;</span>)<br>session.put(<span class="hljs-string">&#x27;http://httpbin.org/put&#x27;</span>, <span class="hljs-built_in">data</span>=b<span class="hljs-string">&#x27;data&#x27;</span>)<br>session.delete(<span class="hljs-string">&#x27;http://httpbin.org/delete&#x27;</span>)<br><span class="hljs-params">...</span><span class="hljs-params">...</span><br></code></pre></td></tr></table></figure><h2 id="带参数的get请求"><a href="#带参数的get请求" class="headerlink" title="带参数的get请求"></a>带参数的get请求</h2><p>传入<code>params</code>参数即可  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">params</span> = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;http://httpbin.org/get&#x27;</span>,<br>                       <span class="hljs-keyword">params</span>=<span class="hljs-keyword">params</span>) <span class="hljs-keyword">as</span> resp:<br>    print(resp.url)<br></code></pre></td></tr></table></figure><h2 id="关于url转换"><a href="#关于url转换" class="headerlink" title="关于url转换"></a>关于url转换</h2><p><code>aiohttp</code>默认会在发送请求之前会在内部执行URL规范化<br>比如将url中的中文转为其它编码<br>如果不希望进行这个过程，可以传入<code>encoded=True</code>禁用  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">await session.<span class="hljs-builtin-name">get</span>(<br>    URL(<span class="hljs-string">&#x27;http://example.com/%30&#x27;</span>, <span class="hljs-attribute">encoded</span>=<span class="hljs-literal">True</span>))<br></code></pre></td></tr></table></figure><p>需要注意的是，如果你<code>get方法</code>中传入了<code>params</code>参数，那么这个禁用会无效  </p><h2 id="二进制响应"><a href="#二进制响应" class="headerlink" title="二进制响应"></a>二进制响应</h2><p>如果响应是二进制文件，那么需要用<code>read()</code>来获取  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">await resp.<span class="hljs-built_in">read</span>()<br></code></pre></td></tr></table></figure><h2 id="Json请求"><a href="#Json请求" class="headerlink" title="Json请求"></a>Json请求</h2><p><code>session</code>的任何方法都可以传入<code>json</code>参数  </p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> <span class="hljs-attribute">session</span>:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-built_in">url</span>, json=&#123;<span class="hljs-string">&#x27;test&#x27;</span>: <span class="hljs-string">&#x27;object&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><p><code>session</code>会使用<code>python</code>自带的<code>json</code>模块来进行序列化<br>你也可以使用比它更快的<code>ujson</code>模块来进行这个过程  </p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">import</span> ujson<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession(<br>        json_serialize=ujson.dumps) <span class="hljs-keyword">as</span> <span class="hljs-attribute">session</span>:<br>    <span class="hljs-keyword">await</span> session.post(<span class="hljs-built_in">url</span>, json=&#123;<span class="hljs-string">&#x27;test&#x27;</span>: <span class="hljs-string">&#x27;object&#x27;</span>&#125;)<br></code></pre></td></tr></table></figure><h2 id="Json响应"><a href="#Json响应" class="headerlink" title="Json响应"></a>Json响应</h2><p><code>resp.json()</code>可以直接解析<code>json</code>  </p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.<span class="hljs-keyword">get</span>(<span class="hljs-string">&#x27;https://api.github.com/events&#x27;</span>) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.json())<br></code></pre></td></tr></table></figure><h2 id="响应内容流"><a href="#响应内容流" class="headerlink" title="响应内容流"></a>响应内容流</h2><p><code>read()</code>，<code>json()</code>、<code>text()</code>方法非常方便，但应该要谨慎使用。这些方法会将整个响应加载到内存中。要是响应很大，就会造成问题  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">with</span> <span class="hljs-keyword">open</span>(filename, <span class="hljs-string">&#x27;wb&#x27;</span>) <span class="hljs-keyword">as</span> fd:<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-keyword">chunk</span> = await resp.content.read(chunk_size)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">chunk</span>:<br>            break<br>        fd.write(<span class="hljs-keyword">chunk</span>)<br></code></pre></td></tr></table></figure><p>你可以一些一些的去处理响应  </p><h2 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h2><p>传入表单参数即可，编码会自动完成  </p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">payload = &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>, <span class="hljs-string">&#x27;key2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>,<br>                        data=payload) <span class="hljs-keyword">as</span> resp:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><p>如果只希望传递字符，可以用<code>data</code>参数</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-built_in">url</span>, data=<span class="hljs-string">&#x27;Тест&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-attribute">resp</span>:<br>    ...<br></code></pre></td></tr></table></figure><h2 id="上传文件"><a href="#上传文件" class="headerlink" title="上传文件"></a>上传文件</h2><p>一点点载入，一点点上传  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">file_sender</span>(<span class="hljs-params">file_name=<span class="hljs-literal">None</span></span>):</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiofiles.<span class="hljs-built_in">open</span>(file_name, <span class="hljs-string">&#x27;rb&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        chunk = <span class="hljs-keyword">await</span> f.read(<span class="hljs-number">64</span>*<span class="hljs-number">1024</span>)<br>        <span class="hljs-keyword">while</span> chunk:<br>            <span class="hljs-keyword">yield</span> chunk<br>            chunk = <span class="hljs-keyword">await</span> f.read(<span class="hljs-number">64</span>*<span class="hljs-number">1024</span>)<br><br><span class="hljs-comment"># Then you can use file_sender as a data provider:</span><br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.post(<span class="hljs-string">&#x27;http://httpbin.org/post&#x27;</span>,<br>                        data=file_sender(file_name=<span class="hljs-string">&#x27;huge_file&#x27;</span>)) <span class="hljs-keyword">as</span> resp:<br>    print(<span class="hljs-keyword">await</span> resp.text())<br></code></pre></td></tr></table></figure><h2 id="WebSockets"><a href="#WebSockets" class="headerlink" title="WebSockets"></a>WebSockets</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.ws_connect(<span class="hljs-string">&#x27;http://example.org/ws&#x27;</span>) <span class="hljs-keyword">as</span> ws:<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> msg <span class="hljs-keyword">in</span> ws:<br>        <span class="hljs-keyword">if</span> msg.<span class="hljs-built_in">type</span> == aiohttp.WSMsgType.TEXT:<br>            <span class="hljs-keyword">if</span> msg.data == <span class="hljs-string">&#x27;close cmd&#x27;</span>:<br>                <span class="hljs-keyword">await</span> ws.close()<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">await</span> ws.send_str(msg.data + <span class="hljs-string">&#x27;/answer&#x27;</span>)<br>        <span class="hljs-keyword">elif</span> msg.<span class="hljs-built_in">type</span> == aiohttp.WSMsgType.ERROR:<br>            <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure><p>You must use the only websocket task for both reading (e.g. await ws.receive() or async for msg in ws:) and writing but may have multiple writer tasks which can only send data asynchronously (by await ws.send_str(‘data’) for example).</p><h2 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h2><p>超时设置存储在<code>ClientTimeout</code>对象中<br>默认情况下，这个超时的时间是5分钟<br>给seesion设置超时  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">timeout = aiohttp.<span class="hljs-constructor">ClientTimeout(<span class="hljs-params">total</span>=60)</span><br>async <span class="hljs-keyword">with</span> aiohttp.<span class="hljs-constructor">ClientSession(<span class="hljs-params">timeout</span>=<span class="hljs-params">timeout</span>)</span> <span class="hljs-keyword">as</span> session:<br>    ...<br></code></pre></td></tr></table></figure><p>给这次get请求设置超时  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">async <span class="hljs-keyword">with</span> session.<span class="hljs-keyword">get</span>(url, <span class="hljs-keyword">timeout</span>=<span class="hljs-keyword">timeout</span>) <span class="hljs-keyword">as</span> resp:<br>    ...<br></code></pre></td></tr></table></figure><p><code>ClientTimeout</code>接收多个参数作为超时标准  </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">aiohttp.ClientTimeout(<span class="hljs-attribute">total</span>=5*60, <span class="hljs-attribute">connect</span>=None,<br>                      <span class="hljs-attribute">sock_connect</span>=None, <span class="hljs-attribute">sock_read</span>=None)<br></code></pre></td></tr></table></figure><ul><li>total<br>总时长  </li><li>connect<br>建立新连接时间 或 在连接池中等待的时间  </li><li>sock_connect<br>A timeout for connecting to a peer for a new connection, not given from a pool  </li><li>sock_read<br>从对等方读取新数据部分之间的最大允许超时时间  </li></ul><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>你可以在<code>session.get()</code>中设置你的proxy：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, proxy=your_proxy_url) <span class="hljs-keyword">as</span> response:<br>    <span class="hljs-keyword">return</span> BeautifulSoup(<span class="hljs-keyword">await</span> response.content, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br></code></pre></td></tr></table></figure><p>如果你的IP需要认证，可以这样设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">proxy = <span class="hljs-string">&#x27;http://your_user:your_password@your_proxy_url:your_proxy_port&#x27;</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, proxy=proxy) <span class="hljs-keyword">as</span> response:<br>    <span class="hljs-keyword">return</span> BeautifulSoup(<span class="hljs-keyword">await</span> response.content, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br></code></pre></td></tr></table></figure><p>或者是这样设置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">proxy = <span class="hljs-string">&#x27;http://your_proxy_url:your_proxy_port&#x27;</span><br>proxy_auth = aiohttp.BasicAuth(<span class="hljs-string">&#x27;your_user&#x27;</span>, <span class="hljs-string">&#x27;your_password&#x27;</span>)<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url, proxy=proxy, proxy_auth=proxy_auth) <span class="hljs-keyword">as</span> response:<br>    <span class="hljs-keyword">return</span> BeautifulSoup(<span class="hljs-keyword">await</span> response.content, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>爬虫</tag>
      
      <tag>aiohttp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无意义记录-搞事</title>
    <link href="/post/f8ae26c5/"/>
    <url>/post/f8ae26c5/</url>
    
    <content type="html"><![CDATA[<h1 id="黑客-溃客-脚本小子"><a href="#黑客-溃客-脚本小子" class="headerlink" title="黑客-溃客-脚本小子"></a>黑客-溃客-脚本小子</h1><h2 id="黑客-Hacker"><a href="#黑客-Hacker" class="headerlink" title="黑客 Hacker"></a>黑客 Hacker</h2><p>黑客（Hacker）是指对设计、编程和计算机科学方面具高度理解的人  </p><h2 id="溃客-Cracker"><a href="#溃客-Cracker" class="headerlink" title="溃客 Cracker"></a>溃客 Cracker</h2><p>溃客（Cracker）才是专指对计算机系统及网络进行恶意破坏的人  </p><h2 id="脚本小子-script-kiddie"><a href="#脚本小子-script-kiddie" class="headerlink" title="脚本小子 script kiddie"></a>脚本小子 script kiddie</h2><p>是一个贬义词，用来描述以“黑客”自居并沾沾自喜的初学者<br>脚本小子不像真正的黑客那样发现系统漏洞，他们通常使用别人开发的程序来恶意破坏他人系统<br>通常的刻板印象为一位没有专科经验的少年，破坏无辜网站企图使得他的朋友感到惊讶，因而称之为脚本小子  </p><h1 id="奇异字符"><a href="#奇异字符" class="headerlink" title="奇异字符"></a>奇异字符</h1><h2 id="西里尔字母"><a href="#西里尔字母" class="headerlink" title="西里尔字母"></a>西里尔字母</h2><p>仔细观察这两个字符<br><code>е</code> 与 <code>e</code><br>虽然肉眼看起来是一样的，但是它们并不相同<br>前者是一个 <code>Cyrillic</code> 字母，后者是正常的英文字母  </p><p>西里尔字母似乎是俄语使用的字符，但其中的一些字符与英文字符外形过于相似  </p><center>西里尔字母表</center><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>字符</td><td>А</td></tr><tr><td>对应</td><td>A</td></tr><tr><td>字符</td><td>З</td></tr><tr><td>对应</td><td>Ze</td></tr><tr><td>字符</td><td>Н</td></tr><tr><td>对应</td><td>En</td></tr><tr><td>字符</td><td>Ф</td></tr><tr><td>对应</td><td>Ef</td></tr><tr><td>字符</td><td>Я</td></tr><tr><td>对应</td><td>Ja</td></tr></tbody></table><p>其中与那些 阿拉伯数字/英文字母 相似的字符有不少，比如<br><code>А</code> <code>В</code> <code>Е</code> <code>І</code> <code>Ј</code> <code>К</code> <code>Н</code> <code>О</code> <code>Р</code> <code>С</code> <code>Т</code> <code>о</code> <code>U</code> <code>З</code></p><p>如果将这些用这些字符替换正确的代码，一定会很有趣  </p><blockquote><p>参考：<a href="https://zh.wikipedia.org/wiki/%E8%A5%BF%E9%87%8C%E5%B0%94%E5%AD%97%E6%AF%8D">维基百科-西里尔字母</a></p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Fiddler-抓包</title>
    <link href="/post/86bce51a/"/>
    <url>/post/86bce51a/</url>
    
    <content type="html"><![CDATA[<h1 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h1><p><a href="https://www.telerik.com/fiddler">https://www.telerik.com/fiddler</a><br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713090624596.png"><br>官网下载，然后安装即可  </p><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200712101230463.png"><br>其工作过程就像一个中间人</p><ul><li>浏览器发送给服务器的请求会被<code>Fiddler</code>拦截下来，可以进行请求内容的修改，改完以后再继续发送给服务器  </li><li>服务器返回给浏览器的响应会被<code>Fiddler</code>拦截下来，可以进行请求内容的修改，改完以后再继续返回给浏览器  </li></ul><h1 id="配置流程"><a href="#配置流程" class="headerlink" title="配置流程"></a>配置流程</h1><h2 id="开-关"><a href="#开-关" class="headerlink" title="开/关"></a>开/关</h2><p>一般情况下，打开抓取就会开始抓取<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713091309453.png"></p><h2 id="浏览器配置"><a href="#浏览器配置" class="headerlink" title="浏览器配置"></a>浏览器配置</h2><blockquote><p>这个情况并不一定会发生</p></blockquote><p>有些时候，浏览器发请求，<code>Fiddler</code>会没反应<br>在这种情况下，你需要为浏览器配置<code>Fiddler</code>为代理  </p><blockquote><p><code>Fiddler</code> 默认代理ip: 127.0.0.1  端口:8888<br>（你可以在设置那里查看，随着版本更新，也许会改变）</p></blockquote><h2 id="SSL解析"><a href="#SSL解析" class="headerlink" title="SSL解析"></a>SSL解析</h2><p>经过上述步骤后，会发现有很多的443错误<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713092416800.png"><br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713092543274.png"><br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713103203826.png"><br>勾选，会弹出一些安全性的警告，同意以后，即可解析HTTPS包  </p><h3 id="获取证书文件"><a href="#获取证书文件" class="headerlink" title="获取证书文件"></a>获取证书文件</h3><p>在你成功设置以后，可以在浏览器访问<code>localhost:Fiddler端口号</code><br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200712114356658.png"><br>你可以在这里下载到<code>Fiddler</code>的证书文件  </p><h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><p>用Fiddler抓包能抓到连接过程中所有的包，包括建立TCP连接之类的<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713093429418.png"><br>在中间界面选一个包的信息，在右边会显示对应的请求和响应的相关信息  </p><h3 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h3><p>只处理特定的包<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713102714872.png"><br>这里规定只处理url包含bilibili的包  </p><h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><p>那些无关紧要的包就丢掉好了<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713104232160.png"><br>有很多种移除，根据情况选择就是</p><h3 id="自动编码"><a href="#自动编码" class="headerlink" title="自动编码"></a>自动编码</h3><p><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713110920538.png"><br>如果不编码的话，结果可能会是一些乱码  </p><h3 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h3><p>这东西藏在最下面的角落里<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713112151266.png">  </p><table><thead><tr><th>图标</th><th>情况说明</th></tr></thead><tbody><tr><td><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713112345931.png"></td><td>发送请求时打断</td></tr><tr><td><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713112443154.png"></td><td>收到响应时打断</td></tr><tr><td><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713112520590.png"></td><td>不打断</td></tr></tbody></table><h2 id="抓手机app数据包"><a href="#抓手机app数据包" class="headerlink" title="抓手机app数据包"></a>抓手机app数据包</h2><ol><li><p>手机连上wifi<br>让手机连上wifi，保持和电脑处于同一网络下  </p></li><li><p>设置wifi代理项<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/wifi_set.gif">  </p></li><li><p>查看电脑ip地址<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200712115949681.png">  </p></li><li><p>Fillder允许远程设备连接<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713092416800.png"><br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713093511176.png"></p></li><li><p>下载证书文件<br>大多数下载好了以后还需要去点信任证书才能启用<br>手机浏览器访问 电脑ip:Fiddler端口号下载证书<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713064053107.png"></p><blockquote><p>注意是需要下载下来<br>许多的浏览器都会自己管理证书。如果直接点击，可能只是让手机浏览器信任证书。<br>现在是需要让我手机app信任<code>Fiddler</code>而不是只是让手机浏览器信任。</p></blockquote></li><li><p>安装证书<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/cer_install.gif"><br>证书叫啥名字其实都可以</p><blockquote><p>需要注意的是，有些操作系统需要在证书安全那里点信任<br>在一些高版本的安卓系统里，用户证书不能被信任，需要Root+开发者模式来解决</p></blockquote></li><li><p>验证是否成功抓包<br>这个很简单，在手机上打开一个app进行一些需要访问网络的操作即可<br>抓出来的包与在PC上抓的也大致相同<br>这里通过bilibili app 包来验证  </p><ol><li>清理面板，把过滤器打开<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713105813435.png"></li><li>打开Bilibili app，做一些操作<br>这里我做搜索操作<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713110559660.png"></li><li>确定抓到的包<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713111223122.png"><br>查看包里的内容，看看是否是所需，这里看到内容和app内一致，说明验证成功</li></ol></li></ol><h2 id="中间人修改"><a href="#中间人修改" class="headerlink" title="中间人修改"></a>中间人修改</h2><p>通过修改服务器返回的响应，使得数据变得不同</p><ol><li><p>原始目标包抓取<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200714120413692.png"><br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200714120439773.png">  </p></li><li><p>修改过滤器，精准抓包<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200714120538028.png"><br>在上面的抓包中，已经知道了更详细的的url，更改的话能避免显示无意义包  </p></li><li><p>设置响应断点，在响应时打断<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200713112806185.png">  </p></li><li><p>手机重新发送请求，响应抓到包，进行修改后复制下来<br>手工修改需要一些时间，一般而言，app会进行三次左右的请求尝试并等待一段时间。要是超时会显示加载失败，手工操作来进行修改的话，需要一定手速<br>为了手工实现快速更改内容，这里将包修改后复制下来<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/change_hot_text.gif"><br>由于手工修改缓慢，app发送的三个请求都被拦截，相当于app没有收到响应。于是没有显示任何内容在app上<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200714121605950.png"><br>在下次访问时，会继续发送请求。这为修改提供了便利  </p></li><li><p>重新发送请求，并快速修改包的内容<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/change_and_send.gif"><br>一顿操作过后，热搜就有了我的名字，虽然这只是在骗自己<br><img src="/Fiddler-%E6%8A%93%E5%8C%85/20200714125355969.png"></p><blockquote><p>若是失败，可以清理app缓存数据（甚至所有数据）来避免app不发送请求而通过缓存加载</p></blockquote></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>抓包</tag>
      
      <tag>Fiddler</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-基础-1</title>
    <link href="/post/b666810f/"/>
    <url>/post/b666810f/</url>
    
    <content type="html"><![CDATA[<h1 id="Javascript信息"><a href="#Javascript信息" class="headerlink" title="Javascript信息"></a>Javascript信息</h1><blockquote><p><code>JavaScript</code> 这个名字的原意是“很像Java的脚本语言”  </p></blockquote><h2 id="语言信息"><a href="#语言信息" class="headerlink" title="语言信息"></a>语言信息</h2><ul><li>轻量级脚本语言<br>它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”  </li><li>嵌入式（embedded）语言<br>它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。不提供任何与 <code>I/O</code> 相关的 <code>API</code>，都要靠宿主环境（host）提供，所以 <code>JavaScript</code> 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 <code>API</code><br>最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。</li><li>弱类型  </li><li>解释型 或 即时编译型  </li></ul><p><code>JavaScript</code> 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格  </p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="语法灵活"><a href="#语法灵活" class="headerlink" title="语法灵活"></a>语法灵活</h3><p>既支持类似 <code>C</code> 语言清晰的过程式编程，也支持灵活的函数式编程，可以用来写并发处理（concurrent）<br>这些语法特性已经被证明非常强大，可以用于许多场合，尤其适用异步编程  </p><p><code>JavaScript</code> 的所有值都是对象，这为程序员提供了灵活性和便利性。因为你可以很方便地、按照需要随时创造数据结构，不用进行麻烦的预定义  </p><h3 id="支持编译运行"><a href="#支持编译运行" class="headerlink" title="支持编译运行"></a>支持编译运行</h3><p>虽然是一种解释型语言，但是在现代浏览器中，<code>JavaScript</code> 都是编译后运行。编译后，程序会被高度优化，运行效率接近二进制程序  </p><h3 id="事件驱动和非阻塞式设计"><a href="#事件驱动和非阻塞式设计" class="headerlink" title="事件驱动和非阻塞式设计"></a>事件驱动和非阻塞式设计</h3><p><code>JavaScript</code> 程序可以采用事件驱动（<code>event-driven</code>）和非阻塞式（<code>non-blocking</code>）设计，在服务器端适合高并发环境，普通的硬件就可以承受很大的访问量  </p><h2 id="语言历史"><a href="#语言历史" class="headerlink" title="语言历史"></a>语言历史</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>网景（<code>Netscape</code>）公司开发了 <code>Navigator</code> 浏览器，发现浏览器应该需要脚本语言来实现一些简单的功能<br>此时Sum公司<code>JAVA</code>语言问世，并且相当成功。网景公司决定于Sum公司合作，让浏览器支持<code>JAVA</code><br>网景公司研究了一段时间，发现<code>JAVA</code>太重，不合适，但决定未来浏览器脚本语言语法要接近<code>JAVA</code><br>网景公司雇佣了 <code>Brendan Eich</code> 大佬来开发这种新的语言<br><code>Brendan Eich</code> 大佬以 <code>Scheme</code> 语言为蓝本，花费10天时间，完成了这个语言的第一版  </p><ul><li>基本语法：借鉴 <code>C</code> 语言和 <code>Java</code> 语言  </li><li>数据结构：借鉴 <code>Java</code> 语言，包括将值分成原始值和对象两大类  </li><li>函数的用法：借鉴 <code>Scheme</code> 语言和 <code>Awk</code> 语言，将函数当作第一等公民，并引入闭包  </li><li>原型继承模型：借鉴 <code>Self</code> 语言（<code>Smalltalk</code> 的一种变种）  </li><li>正则表达式：借鉴 <code>Perl</code> 语言  </li><li>字符串和数组处理：借鉴 <code>Python</code> 语言  </li></ul><p>这个脚本语言，最初名字叫做 <code>Mocha</code>，1995年9月改为 <code>LiveScript</code>。12月，网景公司与 Sun公司 达成协议，后者允许将这种语言叫做 <code>JavaScript</code>  </p><h3 id="JavaScript-与-ECMAScript"><a href="#JavaScript-与-ECMAScript" class="headerlink" title="JavaScript 与 ECMAScript"></a>JavaScript 与 ECMAScript</h3><p>1996年8月，微软模仿 <code>JavaScript</code> 开发了一种相近的语言，取名为<code>JScript</code>（<code>JavaScript</code> 是 网景公司 的注册商标，微软不能用），内置于 <code>IE</code>3.0。网景公司面临丧失浏览器脚本语言的主导权的局面  </p><p>1996年11月，网景公司决定将 <code>JavaScript</code> 提交给国际标准化组织 <code>ECMA</code>（European Computer Manufacturers Association），希望 <code>JavaScript</code> 能够成为国际标准，以此抵抗微软。ECMA 的39号技术委员会（Technical Committee 39）负责制定和审核这个标准，成员由业内的大公司派出的工程师组成  </p><p>1997年7月，ECMA组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 <code>ECMAScript</code>。这个版本就是 <code>ECMAScript</code> 1.0 版  </p><p>之所以不叫 <code>JavaScript</code>，<br>一方面是由于商标的关系，<code>Java</code> 是 <code>Sun</code> 公司的商标，根据授权协议，只有 网景公司可以合法地使用 <code>JavaScript</code> 这个名字， <code>JavaScript</code> 已经被 网景公司注册为商标<br>另一方面也是想体现这门语言的制定者是 <code>ECMA</code>，不是 网景公司，这样有利于保证这门语言的开放性和中立性。因此，<code>ECMAScript</code> 和 <code>JavaScript</code> 的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的  </p><h3 id="更新迭代"><a href="#更新迭代" class="headerlink" title="更新迭代"></a>更新迭代</h3><p>1997年7月，<code>ECMAScript</code> 1.0发布  </p><p>1998年6月，<code>ECMAScript</code> 2.0版发布  </p><p>1999年12月，<code>ECMAScript</code> 3.0版发布，成为 <code>JavaScript</code> 的通行标准，得到了广泛支持  </p><p>2007年10月，<code>ECMAScript</code> 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 <code>JavaScript</code> 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案  </p><p>2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，<code>ECMA</code> 开会决定，中止 <code>ECMAScript</code> 4.0 的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为 <code>ECMAScript</code> 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 <code>Harmony</code>（和谐）。会后不久，<code>ECMAScript</code> 3.1 就改名为 <code>ECMAScript</code> 5。</p><p>2009年12月，<code>ECMAScript</code> 5.0版 正式发布。<code>Harmony</code> 项目则一分为二，一些较为可行的设想定名为 <code>JavaScript.next</code> 继续开发，后来演变成 <code>ECMAScript</code> 6；一些不是很成熟的设想，则被视为 <code>JavaScript.next.next</code>，在更远的将来再考虑推出。TC39 的总体考虑是，<code>ECMAScript</code> 5 与 <code>ECMAScript</code> 3 基本保持兼容，较大的语法修正和新功能加入，将由 <code>JavaScript.next</code> 完成。当时，<code>JavaScript.next</code> 指的是<code>ECMAScript</code> 6。第六版发布以后，将指 <code>ECMAScript</code> 7。TC39 预计，<code>ECMAScript</code> 5 会在2013年的年中成为 <code>JavaScript</code> 开发的主流标准，并在此后五年中一直保持这个位置。</p><p>2011年6月，<code>ECMAScript</code> 5.1版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持 ECMAScript 5.1版的全部功能。</p><p>2013年3月，<code>ECMAScript</code> 6 草案冻结，不再添加新功能。新的功能设想将被放到 <code>ECMAScript</code> 7  </p><p>2013年12月，<code>ECMAScript</code> 6 草案发布  </p><p>2015年6月，<code>ECMAScript</code> 6 正式发布，并且更名为 <code>ECMAScript</code>2015。这是因为 TC39 委员会计划，以后每年发布一个 <code>ECMAScript</code> 的版本，下一个版本在2016年发布，称为 <code>ECMAScript</code> 2016，2017年发布 <code>ECMAScript</code> 2017，以此类推  </p><h2 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h2><ul><li>前端 <code>React</code>, <code>Vue</code>, <code>Angular</code>  </li><li>后端 <code>Node.js</code>  </li><li>桌面端 <code>Electron</code>  </li><li>物联网 <code>Arduino</code>  </li><li>数据库 <code>MongoDB</code>  </li><li>移动端 <code>React Native</code></li></ul><h1 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h1><h2 id="语句-与-表达式"><a href="#语句-与-表达式" class="headerlink" title="语句 与 表达式"></a>语句 与 表达式</h2><p><code>JavaScript</code> 程序的执行单位为<strong>行（<code>line</code>）</strong>，也就是一行一行地执行。一般情况下，每一行就是一个语句  </p><p><strong>语句（<code>statement</code>）</strong>是为了完成某种任务而进行的操作，一般情况下不需要返回值<br><strong>表达式（<code>expression</code>）</strong>，指一个为了得到返回值的计算式  </p><p>比如下面的代码  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>这是 一<strong>行</strong> 赋值 <strong>语句</strong>，这条语句先用<code>var</code>命令，声明了变量a 然后将 <code>表达式</code> <code>1 + 3</code> 的运算结果赋值给变量<code>a</code>  </p><p>凡是 <code>JavaScript</code> 语言中预期为值的地方，都可以使用<strong>表达式</strong><br>比如，赋值<strong>语句</strong>的等号右边，预期是一个值，因此可以放置各种<strong>表达式</strong>  </p><p><strong>语句</strong>以分号结尾，一个分号就表示一个<strong>语句</strong>结束。多个语句可以写在一行内  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">3</span> ; <span class="hljs-keyword">var</span> b = <span class="hljs-string">&#x27;abc&#x27;</span>;<br></code></pre></td></tr></table></figure><p>分号前面可以没有任何内容，<code>JavaScript</code> 引擎将其视为 空<strong>语句</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">;;;<br></code></pre></td></tr></table></figure><p><strong>表达式</strong> 不需要分号 <strong>结尾</strong>。一旦在表达式后面添加分号，则 <code>JavaScript</code> 引擎就将表达式视为 <strong>语句</strong>，这样会产生一些没有任何意义的 <strong>语句</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> + <span class="hljs-number">3</span>;<br><span class="hljs-string">&#x27;abc&#x27;</span>;<br></code></pre></td></tr></table></figure><p>上面两行语句只是单纯地产生一个值，并没有任何实际的意义  </p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>变量</strong> 是对 “值” 的具名引用<br><strong>变量</strong>就是为“值”起名，然后引用这个名字，就等同于引用这个值。<strong>变量</strong>的名字就是<strong>变量名</strong>  </p><h3 id="声明与赋值"><a href="#声明与赋值" class="headerlink" title="声明与赋值"></a>声明与赋值</h3><blockquote><p><strong>注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量</strong>  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a<br>以后，引用变量名a就会得到数值1。最前面的<code>var</code>，是变量声明命令。它表示通知解释引擎，要创建一个变量a  </p><p>变量的 声明 和 赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<br>a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>可以在同一条 <code>var</code> 命令中声明多个变量  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javasript">var a, b;<br></code></pre></td></tr></table></figure><hr><p><strong>只声明不赋值的变量</strong><br>如果 只是声明变量 而 没有赋值，则该变量的值是<code>undefined</code><br><code>undefined</code>是一个特殊的值，表示“无定义”  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<br>a <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：无定义与空是完全不同的</strong>  </p></blockquote><hr><p><strong>不使用命令的变量声明与赋值</strong><br>如果变量赋值的时候，忘了写<code>var</code>命令，这条语句也是有效的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 词句与var a = 1;几乎完全相同 </span><br></code></pre></td></tr></table></figure><p>但不写<code>var</code>的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用 <code>var</code> 命令声明变量  </p><hr><p><strong>动态语言特性</strong><br><code>JavaScript</code> 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>a = <span class="hljs-string">&#x27;hello&#x27;</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，变量a起先被赋值为一个数值，后来又被重新赋值为一个字符串  </p><hr><p><strong>重复声明</strong><br>如果使用<code>var</code>重新声明一个已经存在的变量，是无效的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> x;<br></code></pre></td></tr></table></figure><p>上面代码中，变量x声明了两次，但第二次声明是无效的<br>但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 此时x被赋值为2，并不会无效</span><br></code></pre></td></tr></table></figure><p>这是由于声明和赋值是两个操作，声明无效了不会导致赋值无效<br>上面的代码相当于  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> x;  <span class="hljs-comment">// 无效</span><br>x = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 有效</span><br></code></pre></td></tr></table></figure><h3 id="变量提升-Hoisting"><a href="#变量提升-Hoisting" class="headerlink" title="变量提升 Hoisting"></a>变量提升 Hoisting</h3><p><code>JavaScript</code> 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行<br>这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做 <strong>变量提升（hoisting）</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>上面代码首先使用<code>console.log</code>方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<br><span class="hljs-built_in">console</span>.log(a);<br>a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>最后的结果是显示<code>undefined</code>，表示变量<code>a</code>已声明，但还未赋值。</p><h2 id="标识符-Identifier"><a href="#标识符-Identifier" class="headerlink" title="标识符 Identifier"></a>标识符 Identifier</h2><p><strong>标识符（identifier）</strong>指的是用来识别各种值的合法名称<br><code>JavaScript</code> 语言的标识符对大小写敏感，所以<code>a</code>和<code>A</code>是两个不同的标识符  </p><p>标识符有一套命名规则，不符合规则的就是非法标识符。<code>JavaScript</code>引擎遇到非法标识符会报错  </p><p>标识符命名规则:  </p><ul><li>第一个字符，可以是任意 <code>Unicode</code> 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）  </li><li>第二个字符及后面的字符，除了 <code>Unicode</code> 字母、美元符号和下划线，还可以用数字0-9  </li></ul><p>由于<code>Unicode</code>字符里存在中文字符，所以中文变量也是合法的  </p><p>和其它语言类似，<code>JavaScript</code> 有一些保留字，不能用作标识符<br><code>arguments</code>、<code>break</code>、<code>case</code>、<code>catch</code>、<code>class</code>、<code>const</code>、<code>continue</code>、<code>debugger</code>、<code>default</code>、<code>delete</code>、<code>do</code>、<code>else</code>、<code>enum</code>、<code>eval</code>、<code>export</code>、<code>extends</code>、<code>false</code>、<code>finally</code>、<code>for</code>、<code>function</code>、<code>if</code>、<code>implements</code>、<code>import</code>、<code>in</code>、<code>instanceof</code>、<code>interface</code>、<code>let</code>、<code>new</code>、<code>null</code>、<code>package</code>、<code>private</code>、<code>protected</code>、<code>public</code>、<code>return</code>、<code>static</code>、<code>super</code>、<code>switch</code>、<code>this</code>、<code>throw</code>、<code>true</code>、<code>try</code>、<code>typeof</code>、<code>var</code>、<code>void</code>、<code>while</code>、<code>with</code>、<code>yield</code>  </p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>源码中被 <code>JavaScript</code> 引擎忽略的部分就叫做注释，它的作用是对代码进行解释<br><code>JavaScript</code> 提供两种注释的写法<br>单行注释，用<code>//</code>起头；多行注释，放在<code>/*和*/</code>之间  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 单行注释</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 多行</span><br><span class="hljs-comment"> 注释</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><hr><p><strong>不推荐使用的 HTML注释</strong><br>由于历史上 <code>JavaScript</code> 可以兼容 <code>HTML</code> 代码的注释，所以<code>&lt;!--</code>和<code>--&gt;</code>也被视为合法的单行注释  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">x = <span class="hljs-number">1</span>; &lt;!-- 我是注释 <br>--&gt;<br></code></pre></td></tr></table></figure><p>需要注意的是，<code>--&gt;</code>只有在行首，才会被当成单行注释，否则会当作正常的运算  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countdown</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">while</span> (n --&gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">console</span>.log(n);<br>&#125;<br>countdown(<span class="hljs-number">3</span>)<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>n --&gt; 0</code>实际上会当作<code>n--</code> <code>&gt; 0</code>，因此输出2、1、0  </p><h2 id="区块-Block"><a href="#区块-Block" class="headerlink" title="区块 Block"></a>区块 Block</h2><p><code>JavaScript</code> 使用大括号，将多个相关的语句组合在一起，称为<strong>“区块”（block）</strong>  </p><p>对于<code>var</code>命令来说，<code>JavaScript</code> 的区块不构成单独的<strong>作用域（scope）</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>&#125;<br>a <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码在区块内部，使用<code>var</code>命令声明并赋值了变量a，然后在区块外部，变量a依然有效，区块对于<code>var</code>命令不构成单独的作用域，与不使用区块的情况没有任何区别<br>在 <code>JavaScript</code> 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如<code>for</code>、<code>if</code>、<code>while</code>、<code>function</code>等  </p><h2 id="条件判断结构"><a href="#条件判断结构" class="headerlink" title="条件判断结构"></a>条件判断结构</h2><p><code>JavaScript</code> 提供<code>if</code>结构和<code>switch</code>结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句  </p><h3 id="if-结构"><a href="#if-结构" class="headerlink" title="if 结构"></a>if 结构</h3><p><code>if</code>结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (布尔值) 语句;<br></code></pre></td></tr></table></figure><p>“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值<br>如果表达式的求值结果为<code>true</code>，就执行紧跟在后面的语句；如果结果为<code>false</code>，则跳过紧跟在后面的语句  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (m === <span class="hljs-number">3</span>) m = m + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>上面代码表示，只有在m等于3时，才会将其值加上1。</p><p>这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在<code>if</code>的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (m === <span class="hljs-number">3</span>) &#123;<br>  m += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>建议总是在if语句中使用大括号，因为这样方便插入语句  </p></blockquote><h3 id="if…else-结构"><a href="#if…else-结构" class="headerlink" title="if…else 结构"></a>if…else 结构</h3><p><code>if</code>代码块后面，还可以跟一个<code>else</code>代码块，表示不满足条件时，所要执行的代码  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (m === <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-comment">// 满足条件时，执行的语句</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 不满足条件时，执行的语句</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码判断变量m是否等于3，如果等于就执行<code>if</code>代码块，否则执行<code>else</code>代码块  </p><p>对同一个变量进行多次判断时，多个<code>if...else</code>语句可以连写在一起。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (m === <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-regexp">//</span> ...<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m === <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-regexp">//</span> ...<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m === <span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-regexp">//</span> ...<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-regexp">//</span> ...<br>&#125;<br></code></pre></td></tr></table></figure><p><code>else</code>代码块总是与离自己最近的那个if语句配对  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span> (m !== <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;world&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面代码不会有任何输出，<code>else</code>代码块不会得到执行，因为它跟着的是最近的那个<code>if</code>语句，相当于下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (m !== <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;world&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="switch-结构"><a href="#switch-结构" class="headerlink" title="switch 结构"></a>switch 结构</h3><p>多个<code>if...else</code>连在一起使用的时候，可以转为使用更方便的<code>switch</code>结构  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (fruit) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;banana&quot;</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;apple&quot;</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码根据变量<code>fruit</code>的值，选择执行相应的<code>case</code><br>如果所有<code>case</code>都不符合，则执行最后的<code>default</code>部分<br>需要注意的是，每个<code>case</code>代码块内部的<code>break</code>语句不能少，否则会接下去执行下一个<code>case</code>代码块，而不是跳出<code>switch</code>结构  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">switch</span> (x) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x 等于1&#x27;</span>);<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x 等于2&#x27;</span>);<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x 等于其他值&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>case</code>代码块之中没有<code>break</code>语句，导致不会跳出<code>switch</code>结构，而会一直执行下去  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (x) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x 等于1&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x 等于2&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x 等于其他值&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>switch语句部分和case语句部分，都可以使用表达式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (<span class="hljs-number">1</span> + <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span>:<br>    f();<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    neverHappens();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码的<code>default</code>部分，是永远不会执行到的。</p><h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符 ?:"></a>三元运算符 ?:</h2><p><code>JavaScript</code> 还有一个三元运算符（即该运算符需要三个运算子）<code>?:，</code>也可以用于逻辑判断  </p><p><code>(条件) ? 表达式1 : 表达式2</code><br>上面代码中，如果“条件”为<code>true</code>，则返回“表达式1”的值，否则返回“表达式2”的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> even = (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，如果n可以被2整除，则<code>even</code>等于<code>true</code>，否则等于<code>false</code>  它等同于下面的形式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> even;<br><span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>  even = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  even = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个三元运算符可以被视为<code>if...else...</code>的简写形式，因此可以用于多种场合  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myVar;<br><span class="hljs-built_in">console</span>.log(<br>  myVar ?<br>  <span class="hljs-string">&#x27;myVar has a value&#x27;</span> :<br>  <span class="hljs-string">&#x27;myVar does not have a value&#x27;</span><br>)<br><span class="hljs-comment">// myVar does not have a value</span><br></code></pre></td></tr></table></figure><p>上面代码利用三元运算符，输出相应的提示  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> msg = <span class="hljs-string">&#x27;数字&#x27;</span> + n + <span class="hljs-string">&#x27;是&#x27;</span> + (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;偶数&#x27;</span> : <span class="hljs-string">&#x27;奇数&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面代码利用三元运算符，在字符串之中插入不同的值  </p><h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句用于重复执行某个操作，它有多种形式  </p><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p><code>While</code>语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块  </p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">while</span> (条件)语句;<br></code></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">while</span> (条件) &#123;<br>  语句;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>while</code>语句的循环条件是一个表达式，必须放在圆括号中<br>代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i 当前为：&#x27;</span> + i);<br>  i = i + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码将循环100次，直到i等于100为止。</p><p>下面的例子是一个无限循环，因为循环条件总是为真。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello, world&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><code>for</code>语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (初始化表达式; 条件; 递增表达式) 语句<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (初始化表达式; 条件; 递增表达式) &#123;<br>  语句<br>&#125;<br></code></pre></td></tr></table></figure><p><code>for</code>语句后面的括号里面，有三个表达式  </p><p><strong>初始化表达式（initialize）</strong>：确定循环变量的初始值，只在循环开始时执行一次<br><strong>条件表达式（test）</strong>：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环<br><strong>递增表达式（increment）</strong>：每轮循环的最后一个操作，通常用来递增循环变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) &#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，初始化表达式是var i = 0，即初始化一个变量i；<br>测试表达式是i &lt; x，即只要i小于x，就会执行循环；<br>递增表达式是i++，即每次循环结束后，i增大1  </p><hr><p><strong>忽略成分</strong><br>for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> ( ; ; )&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环  </p><h3 id="do…while-循环"><a href="#do…while-循环" class="headerlink" title="do…while 循环"></a>do…while 循环</h3><p><code>do...while</code>循环与<code>while</code>循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">do</span><br>  语句<br><span class="hljs-keyword">while</span> (条件);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">do</span> &#123;<br>  语句<br>&#125; <span class="hljs-keyword">while</span> (条件);<br></code></pre></td></tr></table></figure><p>不管条件是否为真，<code>do...while</code>循环至少运行一次，这是这种结构最大的特点  </p><blockquote><p>注意不要省略 <code>while</code>语句后面的分号  </p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>  i++;<br>&#125; <span class="hljs-keyword">while</span>(i &lt; x);<br></code></pre></td></tr></table></figure><h3 id="break-语句和-continue-语句"><a href="#break-语句和-continue-语句" class="headerlink" title="break 语句和 continue 语句"></a>break 语句和 continue 语句</h3><p>break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行<br>break语句用于跳出代码块或循环  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">100</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i 当前为：&#x27;</span> + i);<br>  i++;<br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码只会执行10次循环，一旦i等于10，就会跳出循环。</p><p>continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>)&#123;<br>  i++;<br>  <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i 当前为：&#x27;</span> + i);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环  </p><p>如果存在多重循环，不带参数的<code>break</code>语句和<code>continue</code>语句都只针对最内层循环  </p><h2 id="标签-Label"><a href="#标签-Label" class="headerlink" title="标签 Label"></a>标签 Label</h2><p>(不建议使用)<br><code>JavaScript</code> 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">label:<br>  语句<br></code></pre></td></tr></table></figure><p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句  </p><p>标签通常与break语句和continue语句配合使用，跳出特定的循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">top:<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br>      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span> &amp;&amp; j === <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span> top;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i=&#x27;</span> + i + <span class="hljs-string">&#x27;, j=&#x27;</span> + j);<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// i=0, j=0</span><br><span class="hljs-comment">// i=0, j=1</span><br><span class="hljs-comment">// i=0, j=2</span><br><span class="hljs-comment">// i=1, j=0</span><br></code></pre></td></tr></table></figure><p>上面代码为一个双重循环区块，<code>break</code>命令后面加上了<code>top</code>标签（注意，top不用加引号），满足条件时，直接跳出双层循环<br>如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环  </p><p>标签也可以用于跳出代码块  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">foo: &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">break</span> foo;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;本行不会输出&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码执行到break foo，就会跳出区块。</p><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="类型测定"><a href="#类型测定" class="headerlink" title="类型测定"></a>类型测定</h2><p><code>JavaScript</code> 有三种方法，可以确定一个值到底是什么类型  </p><ul><li><code>typeof</code> 运算符  </li><li><code>instanceof</code> 运算符  </li><li><code>Object.prototype.toString</code> 方法  </li></ul><p><code>instanceof</code>运算符 和 <code>Object.prototype.toString</code>方法，将在后文介绍。这里介绍 <code>typeof</code>运算符  </p><p><code>typeof</code>运算符可以返回一个值的数据类型  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span>  <span class="hljs-comment">// &quot;number&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;123&#x27;</span>  <span class="hljs-comment">// &quot;string&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">// &quot;boolean&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">typeof</span> f  <span class="hljs-comment">// &quot;function&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>  <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> &#123;&#125; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> [] <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：typeof null 返回的是 “object”</strong>  </p></blockquote><h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><p><code>null</code>与<code>undefined</code>都可以表示“没有”，含义非常相似<br>将一个变量赋值为<code>undefined</code>或<code>null</code>，语法效果几乎没区别  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，变量a分别被赋值为<code>undefined</code>和<code>null</code>，这两种写法的效果几乎等价  </p><p>在<code>if</code>语句中，它们都会被自动转为<code>false</code>，相等运算符（==）甚至直接报告两者相等  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!<span class="hljs-literal">undefined</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;undefined is false&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;null is false&#x27;</span>);<br>&#125;<br><br><span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>从上面代码可见，两者的行为是何等相似！<br>谷歌公司开发的 <code>JavaScript</code> 语言的替代品 <code>Dart</code> 语言，就明确规定只有<code>null</code>，没有<code>undefined</code>  </p><p>既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关  </p><blockquote><p><strong>历史原因</strong><br>1995年 <code>JavaScript</code> 诞生时，最初像 <code>Java</code> 一样，只设置了<code>null</code>表示”无”。根据 <code>C</code> 语言的传统，<code>null</code>可以自动转为0<br>但是，<code>JavaScript</code> 的设计者 Brendan Eich，觉得这样做还不够<br>首先，第一版的 <code>JavaScript</code> 里面，<code>null</code>就像在 <code>Java</code> 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象<br>其次，那时的 <code>JavaScript</code> 不包括错误处理机制，Brendan Eich 觉得，如果<code>null</code>自动转为0，很不容易发现错误<br>因此，他又设计了一个 <code>undefined</code>。区别是这样的：<br><code>null</code>是一个表示“空”的对象，转为数值时为0；<br><code>undefined</code>是一个表示”此处无定义”的原始值，转为数值时为NaN  </p></blockquote><p>对于<code>null</code>和<code>undefined</code>，大致可以像下面这样理解  </p><p><code>null</code>表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入<code>null</code>，表示该参数为空  </p><p><code>undefined</code>表示“未定义”，下面是返回<code>undefined</code>的典型场景  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 变量声明了，但没有赋值</span><br><span class="hljs-keyword">var</span> i;<br>i <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br>f() <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// 对象没有赋值的属性</span><br><span class="hljs-keyword">var</span>  o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>o.p <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// 函数没有返回值时，默认返回 undefined</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>f() <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><h2 id="Boolean-布尔值"><a href="#Boolean-布尔值" class="headerlink" title="Boolean 布尔值"></a>Boolean 布尔值</h2><p>布尔值代表“真”和“假”两个状态<br>“真”用关键字<code>true</code>表示，“假”用关键字<code>false</code>表示。布尔值只有这两个值<br>进行逻辑运算会得到布尔值  </p><ul><li>前置逻辑运算符： <code>!(Not)</code>  </li><li>相等运算符：<code>===</code>，<code>!==</code>，<code>==</code>，<code>!=</code>  </li><li>比较运算符：<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code><br>如果 <code>JavaScript</code> 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值  </li></ul><p><strong>转换规则</strong><br>转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code><br><code>undefined</code>、<code>null</code>、<code>false</code>、<code>0</code>、<code>NaN</code>、<code>&quot;&quot;</code>(空字符串）、<code>&#39;&#39;</code>(空字符串）、<code>[]</code>(空数组)、<code>&#123;&#125;</code>(空对象)  </p><p>布尔值往往用于程序流程的控制  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;&#x27;</span>) &#123;  <span class="hljs-comment">// 没有任何输出</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，if命令后面的判断条件，预期应该是一个布尔值，所以 JavaScript 自动将空字符串，转为布尔值false，导致程序不会进入代码块，所以没有任何输出  </p><h2 id="Number-数值"><a href="#Number-数值" class="headerlink" title="Number 数值"></a>Number 数值</h2><h3 id="只有浮点数"><a href="#只有浮点数" class="headerlink" title="只有浮点数"></a>只有浮点数</h3><p><code>JavaScript</code> 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> === <span class="hljs-number">1.0</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 <code>JavaScript</code> 会自动把64位浮点数，转成32位整数，然后再进行运算  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> === <span class="hljs-number">0.3</span><br><span class="hljs-comment">// false</span><br><br><span class="hljs-number">0.3</span> / <span class="hljs-number">0.</span><br><span class="hljs-comment">// 2.9999999999999996</span><br><br>(<span class="hljs-number">0.3</span> - <span class="hljs-number">0.2</span>) === (<span class="hljs-number">0.2</span> - <span class="hljs-number">0.1</span>)<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h3 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h3><p><code>JavaScript</code> 浮点数的64个二进制位，从最左边开始，是这样组成的。</p><ul><li>第1位：符号位，0表示正数，1表示负数  </li><li>第2位到第12位（共11位）：指数部分  </li><li>第13位到第64位（共52位）：小数部分（即有效数字）<br>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度  </li></ul><p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即 -2^53 到 2^53，都可以精确表示  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>)<br><span class="hljs-comment">// 9007199254740992</span><br><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) + <span class="hljs-number">1</span><br><span class="hljs-comment">// 9007199254740992</span><br><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) + <span class="hljs-number">2</span><br><span class="hljs-comment">// 9007199254740994</span><br><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) + <span class="hljs-number">3</span><br><span class="hljs-comment">// 9007199254740996</span><br><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) + <span class="hljs-number">4</span><br><span class="hljs-comment">// 9007199254740996</span><br></code></pre></td></tr></table></figure><p>上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理  </p><h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 <code>JavaScript</code> 能够表示的数值范围为2^1024到2^-1023（开区间），超出这个范围的数无法表示  </p><p>如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回<code>Infinity</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">1024</span>)  <span class="hljs-comment">// Infinity</span><br></code></pre></td></tr></table></figure><p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 <code>JavaScript</code> 无法表示这么小的数，这时会直接返回0  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, -<span class="hljs-number">1075</span>)  <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p><code>JavaScript</code> 提供<code>Number</code>对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>.MAX_VALUE  <span class="hljs-comment">// 1.7976931348623157e+308</span><br><span class="hljs-built_in">Number</span>.MIN_VALUE  <span class="hljs-comment">// 5e-324</span><br></code></pre></td></tr></table></figure><h3 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h3><p><code>JavaScript</code> 的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">123e3</span> <span class="hljs-comment">// 123000</span><br><span class="hljs-number">123e-3</span> <span class="hljs-comment">// 0.123</span><br>-<span class="hljs-number">3.1E+12</span><br><span class="hljs-number">.1e-23</span><br></code></pre></td></tr></table></figure><p>科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分  </p><p>以下两种情况，<code>JavaScript</code> 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示  </p><ol><li>小数点前的数字多于21位  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1234567890123456789012</span><br><span class="hljs-comment">// 1.2345678901234568e+21</span><br><br><span class="hljs-number">123456789012345678901</span><br><span class="hljs-comment">// 123456789012345680000</span><br></code></pre></td></tr></table></figure></li><li>小数点后的零多于5个  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 小数点后紧跟5个以上的零，</span><br><span class="hljs-comment">// 就自动转为科学计数法</span><br><span class="hljs-number">0.0000003</span> <span class="hljs-comment">// 3e-7</span><br><br><span class="hljs-comment">// 否则，就保持原来的字面形式</span><br><span class="hljs-number">0.000003</span> <span class="hljs-comment">// 0.000003</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>使用字面量（<code>Literal</code>）直接表示一个数值时，<code>JavaScript</code> 对整数提供四种进制的表示方法：  </p><ul><li>十进制：没有前导0的数值  </li><li>八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值  </li><li>十六进制：有前缀0x或0X的数值  </li><li>二进制：有前缀0b或0B的数值  </li></ul><p>默认情况下，<code>JavaScript</code> 内部会自动将八进制、十六进制、二进制转为十进制  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0xff</span> <span class="hljs-comment">// 255</span><br><span class="hljs-number">0o377</span> <span class="hljs-comment">// 255</span><br><span class="hljs-number">0b11</span> <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">0xzz <span class="hljs-comment">// 报错</span><br>0o88 <span class="hljs-comment">// 报错</span><br>0b22 <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0888</span> <span class="hljs-comment">// 888</span><br><span class="hljs-number">0777</span> <span class="hljs-comment">// 511</span><br></code></pre></td></tr></table></figure><p>前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法  </p><h3 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h3><h4 id="正零和负零"><a href="#正零和负零" class="headerlink" title="正零和负零"></a>正零和负零</h4><p><code>JavaScript</code> 内部实际上存在2个0：一个是+0，一个是-0<br>区别就是64位浮点数表示法的符号位不同。它们是等价的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">-<span class="hljs-number">0</span> === +<span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">0</span> === -<span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">0</span> === +<span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>几乎所有场合，正零和负零都会被当作正常的0  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">+<span class="hljs-number">0</span> <span class="hljs-comment">// 0</span><br>-<span class="hljs-number">0</span> <span class="hljs-comment">// 0</span><br>(-<span class="hljs-number">0</span>).toString() <span class="hljs-comment">// &#x27;0&#x27;</span><br>(+<span class="hljs-number">0</span>).toString() <span class="hljs-comment">// &#x27;0&#x27;</span><br></code></pre></td></tr></table></figure><p>唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-number">1</span> / +<span class="hljs-number">0</span>) === (<span class="hljs-number">1</span> / -<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面的代码之所以出现这样结果，是因为除以正零得到<code>+Infinity</code>，除以负零得到<code>-Infinity</code>，这两者是不相等的  </p><h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p><code>NaN</code>是 <code>JavaScript</code> 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">5</span> - <span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为<code>NaN</code>，表示它是“非数字”  </p><p>另外，一些数学函数的运算结果会出现NaN  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.acos(<span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Math</span>.log(-<span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Math</span>.sqrt(-<span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>0除以0也会得到<code>NaN</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> / <span class="hljs-number">0</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>需要注意的是，<code>NaN</code>不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于<code>Number</code>，使用<code>typeof</code>运算符可以看得很清楚  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span> <span class="hljs-comment">// &#x27;number&#x27;</span><br></code></pre></td></tr></table></figure><p><code>NaN</code>不等于任何值，包括它本身  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>数组的<code>indexOf</code>方法内部使用的是严格相等运算符，所以该方法对<code>NaN</code>不成立  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-literal">NaN</span>].indexOf(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><p><code>NaN</code>在布尔运算时被当作<code>false</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><code>NaN</code>与任何数（包括它自己）的运算，得到的都是<code>NaN</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">NaN</span> + <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">NaN</span> - <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">NaN</span> * <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">NaN</span> / <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h4 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h4><p><code>Infinity</code>表示“无穷”，用来表示两种场景  </p><ul><li>一个正的数值太大，或一个负的数值太小，无法表示  </li><li>另一种是非0数值除以0，得到Infinity  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 场景一</span><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">1024</span>)<br><span class="hljs-comment">// Infinity</span><br><br><span class="hljs-comment">// 场景二</span><br><span class="hljs-number">0</span> / <span class="hljs-number">0</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-number">1</span> / <span class="hljs-number">0</span> <span class="hljs-comment">// Infinity</span><br></code></pre></td></tr></table></figure>上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回<code>Infinity</code>。第二个场景是0除以0会得到NaN，而非0数值除以0，会返回<code>Infinity</code>  </li></ul><p><code>Infinity</code>有正负之分，<code>Infinity</code>表示正的无穷，<code>-Infinity</code>表示负的无穷  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">Infinity</span> === -<span class="hljs-literal">Infinity</span> <span class="hljs-comment">// false</span><br><br><span class="hljs-number">1</span> / -<span class="hljs-number">0</span> <span class="hljs-comment">// -Infinity</span><br>-<span class="hljs-number">1</span> / -<span class="hljs-number">0</span> <span class="hljs-comment">// Infinity</span><br></code></pre></td></tr></table></figure><p>由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，<code>JavaScript</code> 都不报错，所以单纯的数学运算几乎没有可能抛出错误  </p><p><code>Infinity</code>大于一切数值（除了<code>NaN</code>），<code>-Infinity</code>小于一切数值（除了<code>NaN</code>）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">Infinity</span> &gt; <span class="hljs-number">1000</span> <span class="hljs-comment">// true</span><br>-<span class="hljs-literal">Infinity</span> &lt; -<span class="hljs-number">1000</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>Infinity</code>与<code>NaN</code>比较，总是返回<code>false</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">Infinity</span> &gt; <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br>-<span class="hljs-literal">Infinity</span> &gt; <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><br><span class="hljs-literal">Infinity</span> &lt; <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br>-<span class="hljs-literal">Infinity</span> &lt; <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><code>Infinity</code>的四则运算，符合无穷的数学计算规则  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascirpt">&#x2F;&#x2F; 0乘以&#96;Infinity&#96;，返回NaN；0除以&#96;Infinity&#96;，返回0；Infinity除以0，返回Infinity  <br>5 * Infinity &#x2F;&#x2F; Infinity<br>5 - Infinity &#x2F;&#x2F; -Infinity<br>Infinity &#x2F; 5 &#x2F;&#x2F; Infinity<br>5 &#x2F; Infinity &#x2F;&#x2F; 0<br><br>&#x2F;&#x2F; Infinity加上或乘以Infinity，返回的还是Infinity<br>0 * Infinity &#x2F;&#x2F; NaN<br>0 &#x2F; Infinity &#x2F;&#x2F; 0<br>Infinity &#x2F; 0 &#x2F;&#x2F; Infinity<br><br>&#x2F;&#x2F; Infinity减去或除以Infinity，得到NaN  <br>Infinity + Infinity &#x2F;&#x2F; Infinity<br>Infinity * Infinity &#x2F;&#x2F; Infinity<br><br>&#x2F;&#x2F; Infinity与null计算时，null会转成0，等同于与0的计算<br>Infinity - Infinity &#x2F;&#x2F; NaN<br>Infinity &#x2F; Infinity &#x2F;&#x2F; NaN<br><br>&#x2F;&#x2F; Infinity与undefined计算，返回的都是NaN<br>null * Infinity &#x2F;&#x2F; NaN<br>null &#x2F; Infinity &#x2F;&#x2F; 0<br>Infinity &#x2F; null &#x2F;&#x2F; Infinity<br><br>undefined + Infinity &#x2F;&#x2F; NaN<br>undefined - Infinity &#x2F;&#x2F; NaN<br>undefined * Infinity &#x2F;&#x2F; NaN<br>undefined &#x2F; Infinity &#x2F;&#x2F; NaN<br>Infinity &#x2F; undefined &#x2F;&#x2F; NaN<br></code></pre></td></tr></table></figure><h3 id="常用全局方法"><a href="#常用全局方法" class="headerlink" title="常用全局方法"></a>常用全局方法</h3><h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h4><p>用于将字符串转为整数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;123&#x27;</span>) <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>如果字符串头部有空格，空格会被自动去除  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;   81&#x27;</span>) <span class="hljs-comment">// 81</span><br></code></pre></td></tr></table></figure><p>如果<code>parseInt</code>的参数不是字符串，则会先转为字符串再转换  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1.23</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1.23&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>字符串转为整数的时候，是一个个字符依次转换<br>如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;8a&#x27;</span>) <span class="hljs-comment">// 8</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;12**&#x27;</span>) <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;12.34&#x27;</span>) <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;15e2&#x27;</span>) <span class="hljs-comment">// 15</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;15px&#x27;</span>) <span class="hljs-comment">// 15</span><br></code></pre></td></tr></table></figure><p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;.3&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;+&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;+1&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>如果字符串以<code>0x</code>或<code>0X</code>开头，<code>parseInt</code>会将其按照十六进制数解析<br>如果字符串以<code>0</code>开头，将其按照10进制解析  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;0x10&#x27;</span>) <span class="hljs-comment">// 16</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;011&#x27;</span>) <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure><p>对于那些会自动转为科学计数法的数字，<code>parseInt</code>会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1000000000000000000000.5</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1e+21&#x27;</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0.0000008</span>) <span class="hljs-comment">// 8</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;8e-7&#x27;</span>) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><p><code>parseInt</code>方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数<br>默认情况下，<code>parseInt</code>的第二个参数为10，即默认是十进制转十进制  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 8</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 216</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 512</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>) <span class="hljs-comment">// 默认10进制，1000</span><br></code></pre></td></tr></table></figure><p>如果第二个参数不是数值，会被自动转为一个整数<br>这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回<code>NaN</code><br>如果第二个参数是<code>0</code>、<code>undefined</code>和<code>null</code>，则直接忽略  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">37</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-literal">null</span>) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值<br>如果最高位无法转换，则直接返回<code>NaN</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1546&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;546&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>对于二进制来说，1是有意义的字符，而5、4、6都是无意义的字符，所以第一行返回1，第二行返回<code>NaN</code>  </p><p>前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0x11</span>, <span class="hljs-number">36</span>) <span class="hljs-comment">// 43</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0x11</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">String</span>(<span class="hljs-number">0x11</span>), <span class="hljs-number">36</span>)<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">String</span>(<span class="hljs-number">0x11</span>), <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;17&#x27;</span>, <span class="hljs-number">36</span>)<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;17&#x27;</span>, <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1  </p><p>这种处理方式，对于八进制的前缀0，尤其需要注意。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">011</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">String</span>(<span class="hljs-number">011</span>), <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">String</span>(<span class="hljs-number">9</span>), <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><p>上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回<code>NaN</code>。如果直接计算<code>parseInt(&#39;011&#39;, 2)</code>，011则是会被当作二进制处理，返回3  </p><p><code>JavaScript</code> 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定  </p><h4 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h4><p><code>parseFloat</code>方法用于将一个字符串转为浮点数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;3.14&#x27;</span>) <span class="hljs-comment">// 3.14</span><br></code></pre></td></tr></table></figure><p>如果字符串符合科学计数法，则会进行相应的转换  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;314e-2&#x27;</span>) <span class="hljs-comment">// 3.14</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;0.0314E+2&#x27;</span>) <span class="hljs-comment">// 3.14</span><br></code></pre></td></tr></table></figure><p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;3.14more non-digit characters&#x27;</span>) <span class="hljs-comment">// 3.14</span><br></code></pre></td></tr></table></figure><p><code>parseFloat</code>方法会自动过滤字符串前导的空格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;\t\v\r12.34\n &#x27;</span>) <span class="hljs-comment">// 12.34</span><br></code></pre></td></tr></table></figure><p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>([]) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;FF2&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>上面代码中，尤其值得注意，<code>parseFloat</code>会将空字符串转为<code>NaN</code>  </p><p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-literal">true</span>)  <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;123.45#&#x27;</span>) <span class="hljs-comment">// 123.45</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;123.45#&#x27;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><h4 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h4><p><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>但是，<code>isNaN</code>只对数值有效，如果传入其他值，会被先转成数值<br>比如，传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回<code>true</code>，这一点要特别引起注意。也就是说，<code>isNaN</code>为<code>true</code>的值，有可能不是<code>NaN</code>，而是一个字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 相当于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>出于同样的原因，对于对象和数组，<code>isNaN</code>也返回<code>true</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>(&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">Number</span>(&#123;&#125;)) <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-string">&#x27;xzy&#x27;</span>]) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">Number</span>([<span class="hljs-string">&#x27;xzy&#x27;</span>])) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>但是，对于空数组和只有一个数值成员的数组，<code>isNaN</code>返回<code>false</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>([]) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-number">123</span>]) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-string">&#x27;123&#x27;</span>]) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值  </p><p>因此，使用isNaN之前，最好判断一下数据类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myIsNaN</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-built_in">isNaN</span>(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myIsNaN</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> value !== value;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h4><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">Infinity</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(-<span class="hljs-literal">Infinity</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">isFinite</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>  </p><h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h2><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-string">&quot;abc&quot;</span><br></code></pre></td></tr></table></figure><p>单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;key = &quot;value&quot;&#x27;</span><br><span class="hljs-string">&quot;It&#x27;s a long journey&quot;</span><br></code></pre></td></tr></table></figure><p>如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;Did she say \&#x27;Hello\&#x27;?&#x27;</span>  <span class="hljs-comment">// &quot;Did she say &#x27;Hello&#x27;?&quot;</span><br><span class="hljs-string">&quot;Did she say \&quot;Hello\&quot;?&quot;</span>  <span class="hljs-comment">// &quot;Did she say &quot;Hello&quot;?&quot;</span><br></code></pre></td></tr></table></figure><p>由于 HTML 语言的属性值使用双引号，所以很多项目约定 <code>JavaScript</code> 语言的字符串只使用单引号，默认应该遵守这个约定  </p><p>字符串默认只能写在一行内，分成多行将会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a</span><br><span class="hljs-string">b</span><br><span class="hljs-string">c&#x27;</span><br><span class="hljs-comment">// SyntaxError: Unexpected token ILLEGAL</span><br></code></pre></td></tr></table></figure><p>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> longString = <span class="hljs-string">&#x27;Long \</span><br><span class="hljs-string">long \</span><br><span class="hljs-string">long \</span><br><span class="hljs-string">string&#x27;</span>;<br><br>longString<br><span class="hljs-comment">// &quot;Long long long string&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错  </p><p>连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> longString = <span class="hljs-string">&#x27;Long &#x27;</span><br>  + <span class="hljs-string">&#x27;long &#x27;</span><br>  + <span class="hljs-string">&#x27;long &#x27;</span><br>  + <span class="hljs-string">&#x27;string&#x27;</span>;<br></code></pre></td></tr></table></figure><p>如果想输出多行字符串，有一种利用多行注释的变通方法  </p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> &#123; /*</span><br><span class="hljs-built_in">line</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">line</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">line</span> <span class="hljs-number">3</span><br>*/&#125;).toString().<span class="hljs-keyword">split</span>(<span class="hljs-string">&#x27;\n&#x27;</span>).slice(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>// <span class="hljs-comment">&quot;line 1</span><br>// <span class="hljs-built_in">line</span> <span class="hljs-number">2</span><br>// <span class="hljs-built_in">line</span> <span class="hljs-number">3</span><span class="hljs-comment">&quot;</span><br></code></pre></td></tr></table></figure><p>上面的例子中，输出的字符串就是多行  </p><h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符  </p><p>需要用反斜杠转义的特殊字符，主要有下面这些  </p><ul><li>\0 ：null（\u0000）  </li><li>\b ：后退键（\u0008）  </li><li>\f ：换页符（\u000C）  </li><li>\n ：换行符（\u000A）  </li><li>\r ：回车键（\u000D）  </li><li>\t ：制表符（\u0009）  </li><li>\v ：垂直制表符（\u000B）  </li><li>&#39; ：单引号（\u0027）  </li><li>&quot; ：双引号（\u0022）  </li><li>\ ：反斜杠（\u005C）  </li></ul><p>反斜杠还有三种特殊用法。</p><ol><li><p>\HHH<br>反斜杠后面紧跟三个八进制数（000到377），代表一个字符<br>HHH对应该字符的 <code>Unicode</code> 码点，比如\251表示版权符号<br>显然，这种方法只能输出256种字符  </p></li><li><p>\xHH<br>\x后面紧跟两个十六进制数（00到FF），代表一个字符<br>HH对应该字符的 Unicode 码点，比如\xA9表示版权符号<br>这种方法也只能输出256种字符  </p></li><li><p>\uXXXX<br>\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符<br>XXXX对应该字符的 <code>Unicode</code> 码点，比如\u00A9表示版权符号  </p></li></ol><p>下面是这三种字符特殊写法的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;\251&#x27;</span> <span class="hljs-comment">// &quot;©&quot;</span><br><span class="hljs-string">&#x27;\xA9&#x27;</span> <span class="hljs-comment">// &quot;©&quot;</span><br><span class="hljs-string">&#x27;\u00A9&#x27;</span> <span class="hljs-comment">// &quot;©&quot;</span><br><br><span class="hljs-string">&#x27;\172&#x27;</span> === <span class="hljs-string">&#x27;z&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;\x7A&#x27;</span> === <span class="hljs-string">&#x27;z&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;\u007A&#x27;</span> === <span class="hljs-string">&#x27;z&#x27;</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;\a&#x27;</span><br><span class="hljs-comment">// &quot;a&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，a是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略  </p><h3 id="字符串与数组"><a href="#字符串与数组" class="headerlink" title="字符串与数组"></a>字符串与数组</h3><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>s[<span class="hljs-number">0</span>] <span class="hljs-comment">// &quot;h&quot;</span><br>s[<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;e&quot;</span><br>s[<span class="hljs-number">4</span>] <span class="hljs-comment">// &quot;o&quot;</span><br><br><span class="hljs-comment">// 直接对字符串使用方括号运算符</span><br><span class="hljs-string">&#x27;hello&#x27;</span>[<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;e&quot;</span><br></code></pre></td></tr></table></figure><p>如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回<code>undefined</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>[<span class="hljs-number">3</span>] <span class="hljs-comment">// undefined</span><br><span class="hljs-string">&#x27;abc&#x27;</span>[-<span class="hljs-number">1</span>] <span class="hljs-comment">// undefined</span><br><span class="hljs-string">&#x27;abc&#x27;</span>[<span class="hljs-string">&#x27;x&#x27;</span>] <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><br><span class="hljs-keyword">delete</span> s[<span class="hljs-number">0</span>];<br>s <span class="hljs-comment">// &quot;hello&quot;</span><br><br>s[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>s <span class="hljs-comment">// &quot;hello&quot;</span><br><br>s[<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;!&#x27;</span>;<br>s <span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><p><code>length</code>属性返回字符串的长度，该属性也是无法改变的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>s.length <span class="hljs-comment">// 5</span><br><br>s.length = <span class="hljs-number">3</span>;<br>s.length <span class="hljs-comment">// 5</span><br><br>s.length = <span class="hljs-number">7</span>;<br>s.length <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p><code>JavaScript</code> 使用 <code>Unicode</code> 字符集<br><code>JavaScript</code> 引擎内部，所有字符都用 <code>Unicode</code> 表示  </p><p><code>JavaScript</code> 不仅以 <code>Unicode</code> 储存字符，还允许直接在程序中使用 <code>Unicode</code> 码点表示字符，即将字符写成 \uxxxx 的形式，其中xxxx代表该字符的 <code>Unicode</code> 码点  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;\u00A9&#x27;</span>;<br>s <span class="hljs-comment">// &quot;©&quot;</span><br></code></pre></td></tr></table></figure><p>解析代码的时候，<code>JavaScript</code> 会自动识别一个字符是字面形式表示，还是 <code>Unicode</code> 形式表示<br>输出给用户的时候，所有字符都会转成字面形式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f\u006F\u006F = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>foo <span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></td></tr></table></figure><p>每个字符在 <code>JavaScript</code> 内部都是以16位（即2个字节）的 <code>UTF-16</code> 格式储存<br><code>JavaScript</code> 的单位字符长度固定为16位长度，即2个字节<br>但是，<code>UTF-16</code> 有两种长度：对于码点在 U+0000 到 U+FFFF 之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在 0xD800 到 0xDBFF 之间，后两个字节在 0xDC00 到 0xDFFF 之间<br>举例来说，码点 U+1D306 对应的字符为 𝌆，它写成 <code>UTF-16</code> 就是 0xD834 0xDF06  </p><p><code>JavaScript</code> 对 <code>UTF-16</code> 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符<br>这是因为 <code>JavaScript</code> 第一版发布的时候，<code>Unicode</code> 的码点只编到 U+FFFF，因此两字节足够表示了。后来，<code>Unicode</code> 纳入的字符越来越多，出现了四字节的编码。但是，<code>JavaScript</code> 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符𝌆，浏览器会正确识别这是一个字符，但是 <code>JavaScript</code> 无法识别，会认为这是两个字符  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;𝌆&#x27;</span>.length <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>JavaScript</code> 认为𝌆的长度为2，而不是1  </p><p>对于码点在 U+10000 到 U+10FFFF 之间的字符，<code>JavaScript</code> 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，<code>JavaScript</code> 返回的字符串长度可能是不正确的  </p><h3 id="Base64-转码"><a href="#Base64-转码" class="headerlink" title="Base64 转码"></a>Base64 转码</h3><p>有时，文本里面包含一些不可打印的符号，比如 <code>ASCII</code> 码0到31的符号都无法打印出来，这时可以使用 <code>Base64</code> 编码，将它们转成可以打印的字符<br>另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 <code>Base64</code> 编码  </p><p>所谓 <code>Base64</code> 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符<br>使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理  </p><p><code>JavaScript</code> 原生提供两个 <code>Base64</code> 相关的方法  </p><ul><li>btoa()：任意值转为 Base64 编码  </li><li>atob()：Base64 编码转为原来的值  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> string = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br>btoa(string) <span class="hljs-comment">// &quot;SGVsbG8gV29ybGQh&quot;</span><br>atob(<span class="hljs-string">&#x27;SGVsbG8gV29ybGQh&#x27;</span>) <span class="hljs-comment">// &quot;Hello World!&quot;</span><br></code></pre></td></tr></table></figure><p>注意，这两个方法不适合非 <code>ASCII</code> 码的字符，会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">btoa(<span class="hljs-string">&#x27;你好&#x27;</span>) <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>要将非 <code>ASCII</code> 码字符转为 <code>Base64</code> 编码，必须中间插入一个转码环节，再使用这两个方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b64Encode</span>(<span class="hljs-params">str</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> btoa(<span class="hljs-built_in">encodeURIComponent</span>(str));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b64Decode</span>(<span class="hljs-params">str</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">decodeURIComponent</span>(atob(str));<br>&#125;<br><br>b64Encode(<span class="hljs-string">&#x27;你好&#x27;</span>) <span class="hljs-comment">// &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;</span><br>b64Decode(<span class="hljs-string">&#x27;JUU0JUJEJUEwJUU1JUE1JUJE&#x27;</span>) <span class="hljs-comment">// &quot;你好&quot;</span><br></code></pre></td></tr></table></figure><h2 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h2><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><p>对象（object）是 <code>JavaScript</code> 语言的核心概念，也是最重要的数据类型  </p><p>什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  foo: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>  bar: <span class="hljs-string">&#x27;World&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>上面代码中，大括号就定义了一个对象，它被赋值给变量<code>obj</code>，所以变量<code>obj</code>就指向一个对象<br>该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是<code>foo: &#39;Hello&#39;</code>，其中<code>foo</code>是“键名”（成员的名称），字符串<code>Hello</code>是“键值”（成员的值）<br>键名与键值之间用冒号分隔。第二个键值对是<code>bar: &#39;World&#39;</code>，<code>bar</code>是键名，<code>World</code>是键值。两个键值对之间用逗号分隔  </p><h3 id="键名"><a href="#键名" class="headerlink" title="键名"></a>键名</h3><p>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-string">&#x27;foo&#x27;</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>  <span class="hljs-string">&#x27;bar&#x27;</span>: <span class="hljs-string">&#x27;World&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如果键名是数值，会被自动转为字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>  <span class="hljs-number">3.2</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>  <span class="hljs-number">1e2</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-number">1e-2</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-number">.234</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-number">0xFF</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br>obj<br><span class="hljs-comment">// Object &#123;</span><br><span class="hljs-comment">//   1: &quot;a&quot;,</span><br><span class="hljs-comment">//   3.2: &quot;b&quot;,</span><br><span class="hljs-comment">//   100: true,</span><br><span class="hljs-comment">//   0.01: true,</span><br><span class="hljs-comment">//   0.234: true,</span><br><span class="hljs-comment">//   255: true</span><br><span class="hljs-comment">// &#125;</span><br><br>obj[<span class="hljs-string">&#x27;100&#x27;</span>] <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>的所有键名虽然看上去像数值，实际上都被自动转成了字符串。</p><p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  1p: <span class="hljs-string">&#x27;Hello World&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 不报错</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-string">&#x27;1p&#x27;</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span>,<br>  <span class="hljs-string">&#x27;h w&#x27;</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span>,<br>  <span class="hljs-string">&#x27;p+q&#x27;</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型<br>如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x;<br>  &#125;<br>&#125;;<br><br>obj.p(<span class="hljs-number">1</span>) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>如果属性的值还是一个对象，就形成了链式引用  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123;&#125;;<br><span class="hljs-keyword">var</span> o2 = &#123; <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;;<br><br>o1.foo = o2;<br>o1.foo.bar <span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>o1</code>的属性<code>foo</code>指向对象<code>o2</code>，就可以链式引用<code>o2</code>的属性。</p><p>对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-number">123</span>,<br>  m: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; ... &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>属性可以动态创建，不必在对象声明时就指定  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.foo = <span class="hljs-number">123</span>;<br>obj.foo <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><h3 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h3><p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址<br>修改其中一个变量，会影响到其他所有变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123;&#125;;<br><span class="hljs-keyword">var</span> o2 = o1;<br><br>o1.a = <span class="hljs-number">1</span>;<br>o2.a <span class="hljs-comment">// 1</span><br><br>o2.b = <span class="hljs-number">2</span>;<br>o1.b <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性  </p><p>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123;&#125;;<br><span class="hljs-keyword">var</span> o2 = o1;<br><br>o1 = <span class="hljs-number">1</span>;<br>o2 <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，然后<code>o1</code>的值变为1，这时不会对<code>o2</code>产生影响，<code>o2</code>还是指向原来的那个对象  </p><p>但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> y = x;<br><br>x = <span class="hljs-number">2</span>;<br>y <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面的代码中，当<code>x</code>的值发生变化后，<code>y</code>的值并不变，这就表示<code>y</code>和<code>x</code>并不是指向同一个内存地址  </p><h3 id="表达式还是语句？"><a href="#表达式还是语句？" class="headerlink" title="表达式还是语句？"></a>表达式还是语句？</h3><p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span> &#125;<br></code></pre></td></tr></table></figure><p><code>JavaScript</code> 引擎读到上面这行代码，会发现可能有两种含义<br>第一种可能是，这是一个表达式，表示一个包含<code>foo</code>属性的对象；<br>第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签<code>foo</code>，指向表达式<code>123</code>  </p><p>为了避免这种歧义，<code>JavaScript</code> 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>) &#125; <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p>上面的语句是一个代码块，而且只有解释为代码块，才能执行  </p><p>如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span> &#125;) <span class="hljs-comment">// 正确</span><br>(&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>) &#125;) <span class="hljs-comment">// 报错</span><br></code></pre></td></tr></table></figure><p>这种差异在<code>eval</code>语句（作用是对字符串求值）中反映得最明显  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;&#123;foo: 123&#125;&#x27;</span>) <span class="hljs-comment">// 123</span><br><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;(&#123;foo: 123&#125;)&#x27;</span>) <span class="hljs-comment">// &#123;foo: 123&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，如果没有圆括号，<code>eval</code>将其理解为一个代码块；加上圆括号以后，就理解成一个对象  </p><h3 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h3><h4 id="属性的读取"><a href="#属性的读取" class="headerlink" title="属性的读取"></a>属性的读取</h4><p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-string">&#x27;Hello World&#x27;</span><br>&#125;;<br><br>obj.p <span class="hljs-comment">// &quot;Hello World&quot;</span><br>obj[<span class="hljs-string">&#x27;p&#x27;</span>] <span class="hljs-comment">// &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码分别采用点运算符和方括号运算符，读取属性<code>p</code>。</p><p>请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  foo: <span class="hljs-number">1</span>,<br>  bar: <span class="hljs-number">2</span><br>&#125;;<br><br>obj.foo  <span class="hljs-comment">// 1</span><br>obj[foo]  <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，引用对象<code>obj</code>的<code>foo</code>属性时，如果使用点运算符，<code>foo</code>就是字符串；<br>如果使用方括号运算符，但是不使用引号，那么<code>foo</code>就是一个变量，指向字符串<code>bar</code>  </p><p>方括号运算符内部还可以使用表达式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">obj[<span class="hljs-string">&#x27;hello&#x27;</span> + <span class="hljs-string">&#x27; world&#x27;</span>]<br>obj[<span class="hljs-number">3</span> + <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p>数字键可以不加引号，因为会自动转成字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-number">0.7</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span><br>&#125;;<br><br>obj[<span class="hljs-string">&#x27;0.7&#x27;</span>] <span class="hljs-comment">// &quot;Hello World&quot;</span><br>obj[<span class="hljs-number">0.7</span>] <span class="hljs-comment">// &quot;Hello World&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>的数字键<code>0.7</code>，加不加引号都可以，因为会被自动转为字符串<br>注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-number">123</span>: <span class="hljs-string">&#x27;hello world&#x27;</span><br>&#125;;<br><br>obj<span class="hljs-number">.123</span> <span class="hljs-comment">// 报错</span><br>obj[<span class="hljs-number">123</span>] <span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码的第一个表达式，对数值键名<code>123</code>使用点运算符，结果报错<br>第二个表达式使用方括号运算符，结果就是正确的  </p><h3 id="属性的赋值"><a href="#属性的赋值" class="headerlink" title="属性的赋值"></a>属性的赋值</h3><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br>obj.foo = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>obj[<span class="hljs-string">&#x27;bar&#x27;</span>] = <span class="hljs-string">&#x27;World&#x27;</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，分别使用点运算符和方括号运算符，对属性赋值  </p><p><code>JavaScript</code> 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-comment">// 等价于</span><br><br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.p = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="属性的查看"><a href="#属性的查看" class="headerlink" title="属性的查看"></a>属性的查看</h3><p>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  key1: <span class="hljs-number">1</span>,<br>  key2: <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.keys(obj);<br><span class="hljs-comment">// [&#x27;key1&#x27;, &#x27;key2&#x27;]</span><br></code></pre></td></tr></table></figure><h3 id="属性的删除：delete-命令"><a href="#属性的删除：delete-命令" class="headerlink" title="属性的删除：delete 命令"></a>属性的删除：delete 命令</h3><p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-built_in">Object</span>.keys(obj) <span class="hljs-comment">// [&quot;p&quot;]</span><br><br><span class="hljs-keyword">delete</span> obj.p <span class="hljs-comment">// true</span><br>obj.p <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">Object</span>.keys(obj) <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>delete</code>命令删除对象<code>obj</code>的<code>p</code>属性。删除后，再读取<code>p</code>属性就会返回<code>undefined</code>，而且<code>Object.keys</code>方法的返回值也不再包括该属性  </p><p>注意，删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-keyword">delete</span> obj.p <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>并没有<code>p</code>属性，但是<code>delete</code>命令照样返回<code>true</code><br>因此，不能根据<code>delete</code>命令的结果，认定某个属性是存在的  </p><p>只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">123</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><br>obj.p <span class="hljs-comment">// 123</span><br><span class="hljs-keyword">delete</span> obj.p <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码之中，对象<code>obj</code>的<code>p</code>属性是不能删除的，所以<code>delete</code>命令返回<code>false</code>  </p><p>另外，需要注意的是，<code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-keyword">delete</span> obj.toString <span class="hljs-comment">// true</span><br>obj.toString <span class="hljs-comment">// function toString() &#123; [native code] &#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在<br>这个例子还说明，即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值  </p><h3 id="属性是否存在：in-运算符"><a href="#属性是否存在：in-运算符" class="headerlink" title="属性是否存在：in 运算符"></a>属性是否存在：in 运算符</h3><p><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code><br>它的左边是一个字符串，表示属性名，右边是一个对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-string">&#x27;p&#x27;</span> <span class="hljs-keyword">in</span> obj <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> obj <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><code>in</code>运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象<code>obj</code>本身并没有<code>toString</code>属性，但是<code>in</code>运算符会返回<code>true</code>，因为这个属性是继承的  </p><p>这时，可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-built_in">console</span>.log(obj.hasOwnProperty(<span class="hljs-string">&#x27;toString&#x27;</span>)) <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="属性的遍历：for…in-循环"><a href="#属性的遍历：for…in-循环" class="headerlink" title="属性的遍历：for…in 循环"></a>属性的遍历：for…in 循环</h3><p><code>for...in</code>循环用来遍历一个对象的全部属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;键名：&#x27;</span>, i);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;键值：&#x27;</span>, obj[i]);<br>&#125;<br><span class="hljs-comment">// 键名： a</span><br><span class="hljs-comment">// 键值： 1</span><br><span class="hljs-comment">// 键名： b</span><br><span class="hljs-comment">// 键值： 2</span><br><span class="hljs-comment">// 键名： c</span><br><span class="hljs-comment">// 键值： 3</span><br></code></pre></td></tr></table></figure><p><code>for...in</code>循环有两个使用注意点。</p><ul><li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</li><li>它不仅遍历对象自身的属性，还遍历继承的属性。</li></ul><p>举例来说，对象都继承了<code>toString</code>属性，但是<code>for...in</code>循环不会遍历到这个属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-comment">// toString 属性是存在的</span><br>obj.toString <span class="hljs-comment">// toString() &#123; [native code] &#125;</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-built_in">console</span>.log(p);<br>&#125; <span class="hljs-comment">// 没有任何输出</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>继承了<code>toString</code>属性，该属性不会被<code>for...in</code>循环遍历到，因为它默认是“不可遍历”的  </p><p>如果继承的属性是可遍历的，那么就会被<code>for...in</code>循环遍历到<br>但是，一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;老张&#x27;</span> &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> person) &#123;<br>  <span class="hljs-keyword">if</span> (person.hasOwnProperty(key)) &#123;<br>    <span class="hljs-built_in">console</span>.log(key);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// name</span><br></code></pre></td></tr></table></figure><h3 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h3><p>不建议使用  </p><p><code>with</code>语句的格式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">with</span> (对象) &#123;<br>  语句;<br>&#125;<br></code></pre></td></tr></table></figure><p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 例一</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  p1: <span class="hljs-number">1</span>,<br>  p2: <span class="hljs-number">2</span>,<br>&#125;;<br><span class="hljs-keyword">with</span> (obj) &#123;<br>  p1 = <span class="hljs-number">4</span>;<br>  p2 = <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-comment">// 等同于</span><br>obj.p1 = <span class="hljs-number">4</span>;<br>obj.p2 = <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// 例二</span><br><span class="hljs-keyword">with</span> (<span class="hljs-built_in">document</span>.links[<span class="hljs-number">0</span>])&#123;<br>  <span class="hljs-built_in">console</span>.log(href);<br>  <span class="hljs-built_in">console</span>.log(title);<br>  <span class="hljs-built_in">console</span>.log(style);<br>&#125;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.links[<span class="hljs-number">0</span>].href);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.links[<span class="hljs-number">0</span>].title);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.links[<span class="hljs-number">0</span>].style);<br></code></pre></td></tr></table></figure><p>注意，如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-keyword">with</span> (obj) &#123;<br>  p1 = <span class="hljs-number">4</span>;<br>  p2 = <span class="hljs-number">5</span>;<br>&#125;<br><br>obj.p1 <span class="hljs-comment">// undefined</span><br>p1 <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>并没有<code>p1</code>属性，对<code>p1</code>赋值等于创造了一个全局变量<code>p1</code><br>正确的写法应该是，先定义对象<code>obj</code>的属性<code>p1</code>，然后在<code>with</code>区块内操作它  </p><p>这是因为<code>with</code>区块没有改变作用域，它的内部依然是当前作用域<br>这造成了<code>with</code>语句的一个很大的弊病，就是绑定对象不明确  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">with</span> (obj) &#123;<br>  <span class="hljs-built_in">console</span>.log(x);<br>&#125;<br></code></pre></td></tr></table></figure><p>单纯从上面的代码块，根本无法判断<code>x</code>到底是全局变量，还是对象<code>obj</code>的一个属性<br>这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度<br>因此，建议不要使用<code>with</code>语句，可以考虑用一个临时变量代替<code>with</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">with</span>(<span class="hljs-params">obj1.obj2.obj3</span>)</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(p1 + p2);<br>&#125;<br><br><span class="hljs-comment">// 可以写成</span><br><span class="hljs-keyword">var</span> temp = obj1.obj2.obj3;<br><span class="hljs-built_in">console</span>.log(temp.p1 + temp.p2);<br></code></pre></td></tr></table></figure><h2 id="Function-函数"><a href="#Function-函数" class="headerlink" title="Function 函数"></a>Function 函数</h2><p>函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值  </p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h4><p><strong>（1）function 命令</strong>  </p><p><code>function</code>命令声明的代码区块，就是一个函数<br><code>function</code>命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(s);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码命名了一个<code>print</code>函数，以后使用<code>print()</code>这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）  </p><p><strong>（2）函数表达式</strong>  </p><p>除了用<code>function</code>命令声明函数，还可以采用变量赋值的写法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(s);<br>&#125;;<br></code></pre></td></tr></table></figure><p>这种写法将一个匿名函数赋值给变量<br>这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式  </p><p>采用函数表达式声明函数时，<code>function</code>命令后面不带有函数名<br>如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> x);<br>&#125;;<br><br>x<br><span class="hljs-comment">// ReferenceError: x is not defined</span><br><br>print()<br><span class="hljs-comment">// function</span><br></code></pre></td></tr></table></figure><p>上面代码在函数表达式中，加入了函数名<code>x</code>。这个<code>x</code>只在函数体内部可用，指代函数表达式本身，其他地方都不可用<br>这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br></code></pre></td></tr></table></figure><p>需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束<br>而函数的声明在结尾的大括号后面不用加分号<br>总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的  </p><p><strong>（3）Function 构造函数</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> add = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<br>  <span class="hljs-string">&#x27;x&#x27;</span>,<br>  <span class="hljs-string">&#x27;y&#x27;</span>,<br>  <span class="hljs-string">&#x27;return x + y&#x27;</span><br>);<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>Function</code>构造函数接受三个参数，除了最后一个参数是<code>add</code>函数的“函数体”，其他参数都是<code>add</code>函数的参数  </p><p>你可以传递任意数量的参数给<code>Function</code>构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<br>  <span class="hljs-string">&#x27;return &quot;hello world&quot;;&#x27;</span><br>);<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>Function</code>构造函数可以不使用<code>new</code>命令，返回结果完全一样  </p><p>总的来说，这种声明函数的方式非常不直观，几乎无人使用  </p><h3 id="函数的重复声明"><a href="#函数的重复声明" class="headerlink" title="函数的重复声明"></a>函数的重复声明</h3><p>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>&#125;<br>f() <span class="hljs-comment">// 2</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;<br>f() <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，后一次的函数声明覆盖了前面一次<br>而且，由于函数名的提升，前一次声明在任何时候都是无效的，这一点要特别注意  </p><h3 id="圆括号运算符，return-语句和递归"><a href="#圆括号运算符，return-语句和递归" class="headerlink" title="圆括号运算符，return 语句和递归"></a>圆括号运算符，return 语句和递归</h3><p>调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数  </p><p>函数体内部的<code>return</code>语句，表示返回。JavaScript 引擎遇到<code>return</code>语句，就直接返回<code>return</code>后面的那个表达式的值，后面即使还有语句，也不会得到执行<br>也就是说，<code>return</code>语句所带的那个表达式，就是函数的返回值。<code>return</code>语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回<code>undefined</code>  </p><p>函数可以调用自身，这就是递归（recursion）<br>下面就是通过递归，计算斐波那契数列的代码  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (num === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> fib(num - <span class="hljs-number">2</span>) + fib(num - <span class="hljs-number">1</span>);<br>&#125;<br><br>fib(<span class="hljs-number">6</span>) <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>fib</code>函数内部又调用了<code>fib</code>，计算得到斐波那契数列的第6个元素是8  </p><h3 id="第一等公民"><a href="#第一等公民" class="headerlink" title="第一等公民"></a>第一等公民</h3><p><code>JavaScript</code> 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同<br>凡是可以使用值的地方，就能使用函数<br>比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回<br>函数只是一个可以执行的值，此外并无特殊之处  </p><p>由于函数与其他数据类型地位平等，所以在 <code>JavaScript</code> 语言中又称函数为第一等公民  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-comment">// 将函数赋值给一个变量</span><br><span class="hljs-keyword">var</span> operator = add;<br><br><span class="hljs-comment">// 将函数作为参数和返回值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">op</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> op;<br>&#125;<br>a(add)(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><h3 id="函数名的提升"><a href="#函数名的提升" class="headerlink" title="函数名的提升"></a>函数名的提升</h3><p><code>JavaScript</code> 引擎将函数名视同变量名，所以采用<code>function</code>命令声明函数时，整个函数会像变量声明一样，被提升到代码头部  </p><p>所以，下面的代码不会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">f();<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>表面上，上面代码好像在声明之前就调用了函数<code>f</code><br>但是实际上，由于“变量提升”，函数<code>f</code>被提升到了代码头部，也就是在调用之前已经声明了  但是，如果采用赋值语句定义函数，JavaScript 就会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">f();<br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;&#125;;<br><span class="hljs-comment">// TypeError: undefined is not a function</span><br></code></pre></td></tr></table></figure><p>上面的代码等同于下面的形式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f;<br>f();<br>f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br></code></pre></td></tr></table></figure><p>上面代码第二行，调用<code>f</code>的时候，<code>f</code>只是被声明了，还没有被赋值，等于<code>undefined</code>，所以会报错  </p><p>注意，如果像下面例子那样，采用<code>function</code>命令和<code>var</code>赋值语句声明同一个函数，由于存在函数提升，最后会采用<code>var</code>赋值语句的定义  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>&#125;<br><br>f() <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面例子中，表面上后面声明的函数<code>f</code>，应该覆盖前面的<code>var</code>赋值语句，但是由于存在函数提升，实际上正好反过来  </p><h3 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h3><h4 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h4><p>函数的<code>name</code>属性返回函数的名字  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>f1.name <span class="hljs-comment">// &quot;f1&quot;</span><br></code></pre></td></tr></table></figure><p>如果是通过变量赋值定义的函数，那么<code>name</code>属性返回变量名  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>f2.name <span class="hljs-comment">// &quot;f2&quot;</span><br></code></pre></td></tr></table></figure><p>但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此<br>如果变量的值是一个具名函数，那么<code>name</code>属性返回<code>function</code>关键字之后的那个函数名  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f3 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myName</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br>f3.name <span class="hljs-comment">// &#x27;myName&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>f3.name</code>返回函数表达式的名字。注意，真正的函数名还是<code>f3</code>，而<code>myName</code>这个名字只在函数体内部可用  </p><p><code>name</code>属性的一个用处，就是获取参数函数的名字  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">f</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(f.name);<br>&#125;<br><br>test(myFunc) <span class="hljs-comment">// myFunc</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>test</code>内部通过<code>name</code>属性，就可以知道传入的参数是什么函数  </p><h4 id="length-属性-1"><a href="#length-属性-1" class="headerlink" title="length 属性"></a>length 属性</h4><p>函数的<code>length</code>属性返回函数预期传入的参数个数，即函数定义之中的参数个数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, b</span>) </span>&#123;&#125;<br>f.length <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码定义了空函数<code>f</code>，它的<code>length</code>属性就是定义时的参数个数<br>不管调用时输入了多少个参数，<code>length</code>属性始终等于2  </p><p><code>length</code>属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）  </p><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>函数的<code>toString()</code>方法返回一个字符串，内容是函数的源码  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  a();<br>  b();<br>  c();<br>&#125;<br><br>f.toString()<br><span class="hljs-comment">// function f() &#123;</span><br><span class="hljs-comment">//  a();</span><br><span class="hljs-comment">//  b();</span><br><span class="hljs-comment">//  c();</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></td></tr></table></figure><p>上面示例中，函数<code>f</code>的<code>toString()</code>方法返回了<code>f</code>的源码，包含换行符在内  </p><p>对于那些原生的函数，<code>toString()</code>方法返回<code>function ()&#123;[native code]&#125;</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.sqrt.toString()<br><span class="hljs-comment">// &quot;function sqrt() &#123; [native code] &#125;&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Math.sqrt()</code>是 JavaScript 引擎提供的原生函数，<code>toString()</code>方法就返回原生代码的提示  </p><p>函数内部的注释也可以返回  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">/*</span><br><span class="hljs-comment">  这是一个</span><br><span class="hljs-comment">  多行注释</span><br><span class="hljs-comment">*/</span>&#125;<br><br>f.toString()<br><span class="hljs-comment">// &quot;function f()&#123;/*</span><br><span class="hljs-comment">//   这是一个</span><br><span class="hljs-comment">//   多行注释</span><br><span class="hljs-comment">// */&#125;&quot;</span><br></code></pre></td></tr></table></figure><p>利用这一点，可以变相实现多行字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> multiline = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> arr = fn.toString().split(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>  <span class="hljs-keyword">return</span> arr.slice(<span class="hljs-number">1</span>, arr.length - <span class="hljs-number">1</span>).join(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">/*</span><br><span class="hljs-comment">  这是一个</span><br><span class="hljs-comment">  多行注释</span><br><span class="hljs-comment">*/</span>&#125;<br><br>multiline(f);<br><span class="hljs-comment">// &quot; 这是一个</span><br><span class="hljs-comment">//   多行注释&quot;</span><br></code></pre></td></tr></table></figure><p>上面示例中，函数<code>f</code>内部有一个多行注释，<code>toString()</code>方法拿到<code>f</code>的源码后，去掉首尾两行，就得到了一个多行字符串  </p><h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>作用域（scope）指的是变量存在的范围。在 ES5 的规范中，<code>JavaScript</code> 只有两种作用域：<br>一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取<br>另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本教程不涉及  </p><p>对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> v = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(v);<br>&#125;<br><br>f()<br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面的代码表明，函数<code>f</code>内部可以读取全局变量<code>v</code>  </p><p>在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> v = <span class="hljs-number">1</span>;<br>&#125;<br><br>v <span class="hljs-comment">// ReferenceError: v is not defined</span><br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>v</code>在函数内部定义，所以是一个局部变量，函数之外就无法读取  </p><p>函数内部定义的变量，会在该作用域内覆盖同名全局变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> v = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> v = <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">console</span>.log(v);<br>&#125;<br><br>f() <span class="hljs-comment">// 2</span><br>v <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>v</code>同时在函数的外部和内部有定义<br>结果，在函数内部定义，局部变量<code>v</code>覆盖了全局变量<code>v</code>  </p><p>注意，对于<code>var</code>命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>x</code>在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取  </p><h4 id="函数内部的变量提升"><a href="#函数内部的变量提升" class="headerlink" title="函数内部的变量提升"></a>函数内部的变量提升</h4><p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象<br><code>var</code>命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">100</span>) &#123;<br>    <span class="hljs-keyword">var</span> tmp = x - <span class="hljs-number">100</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> tmp;<br>  <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">100</span>) &#123;<br>    tmp = x - <span class="hljs-number">100</span>;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="函数本身的作用域"><a href="#函数本身的作用域" class="headerlink" title="函数本身的作用域"></a>函数本身的作用域</h4><p>函数本身也是一个值，也有自己的作用域<br>它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> x = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>  x();<br>&#125;<br><br>f() <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>x</code>是在函数<code>f</code>的外部声明的，所以它的作用域绑定外层，内部变量<code>a</code>不会到函数<code>f</code>体内取值，所以输出<code>1</code>，而不是<code>2</code>  </p><p>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域  </p><p>很容易犯错的一点是，如果函数<code>A</code>调用函数<code>B</code>，却没考虑到函数<code>B</code>不会引用函数<code>A</code>的内部变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span>(<span class="hljs-params">f</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>  f();<br>&#125;<br><br>y(x)<br><span class="hljs-comment">// ReferenceError: a is not defined</span><br></code></pre></td></tr></table></figure><p>上面代码将函数<code>x</code>作为参数，传入函数<code>y</code><br>但是，函数<code>x</code>是在函数<code>y</code>体外声明的，作用域绑定外层，因此找不到函数<code>y</code>的内部变量<code>a</code>，导致报错。</p><p>同样的，函数体内部声明的函数，作用域绑定函数体内部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(x);<br>  &#125;<br>  <span class="hljs-keyword">return</span> bar;<br>&#125;<br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">var</span> f = foo();<br>f() <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>foo</code>内部声明了一个函数<code>bar</code>，<code>bar</code>的作用域绑定<code>foo</code><br>当我们在<code>foo</code>外部取出<code>bar</code>执行时，变量<code>x</code>指向的是<code>foo</code>内部的<code>x</code>，而不是<code>foo</code>外部的<code>x</code><br>正是这种机制，构成了下文要讲解的“闭包”现象  </p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br>square(<span class="hljs-number">2</span>) <span class="hljs-comment">// 4</span><br>square(<span class="hljs-number">3</span>) <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure><p>上式的<code>x</code>就是<code>square</code>函数的参数<br>每次运行的时候，需要提供这个值，否则得不到结果  </p><h4 id="参数的省略"><a href="#参数的省略" class="headerlink" title="参数的省略"></a>参数的省略</h4><p>函数参数不是必需的，JavaScript 允许省略参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><br>f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 1</span><br>f(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br>f() <span class="hljs-comment">// undefined</span><br><br>f.length <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码的函数<code>f</code>定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），<code>JavaScript</code> 都不会报错<br>省略的参数的值就变为<code>undefined</code><br>需要注意的是，函数的<code>length</code>属性与实际传入的参数个数无关，只反映函数预期传入的参数个数  </p><p>但是，没有办法只省略靠前的参数，而保留靠后的参数<br>如果一定要省略靠前的参数，只有显式传入<code>undefined</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><br>f( , <span class="hljs-number">1</span>) <span class="hljs-comment">// SyntaxError: Unexpected token ,(…)</span><br>f(<span class="hljs-literal">undefined</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>上面代码中，如果省略第一个参数，就会报错  </p><h4 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h4><p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）<br>这意味着，在函数体内修改参数值，不会影响到函数外部  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p = <span class="hljs-number">2</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">p</span>) </span>&#123;<br>  p = <span class="hljs-number">3</span>;<br>&#125;<br>f(p);<br><br>p <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>p</code>是一个原始类型的值，传入函数<code>f</code>的方式是传值传递<br>因此，在函数内部，<code>p</code>的值是原始值的拷贝，无论怎么修改，都不会影响到原始值  </p><p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）<br>也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">o</span>) </span>&#123;<br>  o.p = <span class="hljs-number">2</span>;<br>&#125;<br>f(obj);<br><br>obj.p <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，传入函数<code>f</code>的是参数对象<code>obj</code>的地址<br>因此，在函数内部修改<code>obj</code>的属性<code>p</code>，会影响到原始值  </p><p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">o</span>) </span>&#123;<br>  o = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>&#125;<br>f(obj);<br><br>obj <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>上面代码中，在函数<code>f()</code>内部，参数对象<code>obj</code>被整个替换成另一个值<br>这时不会影响到原始值。这是因为，形式参数（<code>o</code>）的值实际是参数<code>obj</code>的地址，重新对<code>o</code>赋值导致<code>o</code>指向另一个地址，保存在原地址上的值当然不受影响  </p><h4 id="同名参数"><a href="#同名参数" class="headerlink" title="同名参数"></a>同名参数</h4><p>如果有同名的参数，则取最后出现的那个值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, a</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br><br>f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>f()</code>有两个参数，且参数名都是<code>a</code><br>取值的时候，以后面的<code>a</code>为准，即使后面的<code>a</code>没有值或被省略，也是以其为准  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, a</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br><br>f(<span class="hljs-number">1</span>) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>调用函数<code>f()</code>的时候，没有提供第二个参数，<code>a</code>的取值就变成了<code>undefined</code><br>这时，如果要获得第一个<code>a</code>的值，可以使用<code>arguments</code>对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, a</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]);<br>&#125;<br><br>f(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><h4 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h4><p><strong>（1）定义</strong></p><p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是<code>arguments</code>对象的由来  </p><p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推<br>这个对象只有在函数体内部，才可以使用  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">one</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>]);<br>&#125;<br><br>f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>正常模式下，<code>arguments</code>对象可以在运行时修改  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;<br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br>f(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>f()</code>调用时传入的参数，在函数内部被修改成<code>3</code>和<code>2</code>  </p><p>严格模式下，<code>arguments</code>对象与函数参数不具有联动关系<br>也就是说，修改<code>arguments</code>对象不会影响到实际的函数参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>; <span class="hljs-comment">// 开启严格模式</span><br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;<br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br>f(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数体内是严格模式，这时修改<code>arguments</code>对象，不会影响到真实参数<code>a</code>和<code>b</code>  </p><p>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length;<br>&#125;<br><br>f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 3</span><br>f(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br>f() <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p><strong>（2）与数组的关系</strong></p><p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用  </p><p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">var</span> args = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) &#123;<br>  args.push(<span class="hljs-built_in">arguments</span>[i]);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>（3）callee 属性</strong></p><p><code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>.callee === f);<br>&#125;<br><br>f() <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>可以通过<code>arguments.callee</code>，达到调用函数自身的目的<br>这个属性在严格模式里面是禁用的，因此不建议使用  </p><h3 id="函数的其他知识点"><a href="#函数的其他知识点" class="headerlink" title="函数的其他知识点"></a>函数的其他知识点</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包（closure）是 <code>JavaScript</code> 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现  </p><p>理解闭包，首先必须理解变量作用域<br>前面提到，<code>JavaScript</code> 有两种作用域：全局作用域和函数作用域<br>函数内部可以直接读取全局变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(n);<br>&#125;<br>f1() <span class="hljs-comment">// 999</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>f1</code>可以读取全局变量<code>n</code>  </p><p>但是，正常情况下，函数外部无法读取函数内部声明的变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(n)<br><span class="hljs-comment">// Uncaught ReferenceError: n is not defined(</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>f1</code>内部声明的变量<code>n</code>，函数外是无法读取的  </p><p>如果出于种种原因，需要得到函数内的局部变量<br>正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>　　<span class="hljs-built_in">console</span>.log(n); <span class="hljs-comment">// 999</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。但是反过来就不行，<code>f2</code>内部的局部变量，对<code>f1</code>就是不可见的<br>这就是 <code>JavaScript</code> 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量<br>所以，父对象的所有变量，对子对象都是可见的，反之则不成立  </p><p>既然<code>f2</code>可以读取<code>f1</code>的局部变量，那么只要把<code>f2</code>作为返回值，我们不就可以在<code>f1</code>外部读取它的内部变量了吗！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(n);<br>  &#125;<br>  <span class="hljs-keyword">return</span> f2;<br>&#125;<br><br><span class="hljs-keyword">var</span> result = f1();<br>result(); <span class="hljs-comment">// 999</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>f1</code>的返回值就是函数<code>f2</code>，由于<code>f2</code>可以读取<code>f1</code>的内部变量，所以就可以在外部获得<code>f1</code>的内部变量了  </p><p>闭包就是函数<code>f2</code>，即能够读取其他函数内部变量的函数<br>由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”<br>闭包最大的特点，就是它可以“记住”诞生的环境，比如<code>f2</code>记住了它诞生的环境<code>f1</code>，所以从<code>f2</code>可以得到<code>f1</code>的内部变量<br>在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁  </p><p>闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在<br>请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createIncrementor</span>(<span class="hljs-params">start</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> start++;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> inc = createIncrementor(<span class="hljs-number">5</span>);<br><br>inc() <span class="hljs-comment">// 5</span><br>inc() <span class="hljs-comment">// 6</span><br>inc() <span class="hljs-comment">// 7</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>start</code>是函数<code>createIncrementor</code>的内部变量<br>通过闭包，<code>start</code>的状态被保留了，每一次调用都是在上一次调用的基础上进行计算<br>从中可以看到，闭包<code>inc</code>使得函数<code>createIncrementor</code>的内部环境，一直存在<br>所以，闭包可以看作是函数内部作用域的一个接口  </p><p>为什么闭包能够返回外层函数的内部变量？<br>原因是闭包（上例的<code>inc</code>）用到了外层变量（<code>start</code>），导致外层函数（<code>createIncrementor</code>）不能从内存释放<br>只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取  </p><p>闭包的另一个用处，是封装对象的私有属性和私有方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> _age;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setAge</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    _age = n;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> _age;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    name: name,<br>    getAge: getAge,<br>    setAge: setAge<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> p1 = Person(<span class="hljs-string">&#x27;张三&#x27;</span>);<br>p1.setAge(<span class="hljs-number">25</span>);<br>p1.getAge() <span class="hljs-comment">// 25</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>Person</code>的内部变量<code>_age</code>，通过闭包<code>getAge</code>和<code>setAge</code>，变成了返回对象<code>p1</code>的私有变量。</p><p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大<br>因此不能滥用闭包，否则会造成网页的性能问题  </p><h4 id="立即调用的函数表达式-IIFE"><a href="#立即调用的函数表达式-IIFE" class="headerlink" title="立即调用的函数表达式 IIFE"></a>立即调用的函数表达式 IIFE</h4><p>根据 JavaScript 的语法，圆括号<code>()</code>跟在函数名之后，表示调用该函数<br>比如，<code>print()</code>就表示调用<code>print</code>函数  </p><p>有时，我们需要在定义函数之后，立即调用该函数<br>这时，你不能在函数的定义之后加上圆括号，这会产生语法错误  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br><span class="hljs-comment">// SyntaxError: Unexpected token (</span><br></code></pre></td></tr></table></figure><p>产生这个错误的原因是，<code>function</code>这个关键字即可以当作语句，也可以当作表达式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 语句</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br><span class="hljs-comment">// 表达式</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>当作表达式时，函数可以定义后直接加圆括号调用  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;();<br>f <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面的代码中，函数定义后直接加圆括号调用，没有报错<br>原因就是<code>function</code>作为表达式，引擎就把函数定义当作一个值。这种情况下，就不会报错  </p><p>为了避免解析的歧义，JavaScript 规定，如果<code>function</code>关键字出现在行首，一律解释成语句<br>因此，引擎看到行首是<code>function</code>关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了  </p><p>函数定义后立即调用的解决方法，就是不要让<code>function</code>出现在行首，让引擎将其理解成一个表达式<br>最简单的处理，就是将其放在一个圆括号里面  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;());<br><span class="hljs-comment">// 或者</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;)();<br></code></pre></td></tr></table></figure><p>上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表达式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 <code>IIFE</code>  </p><p>注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 <code>IIFE</code>，可能就会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;())<br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;())<br></code></pre></td></tr></table></figure><p>上面代码的两行之间没有分号，<code>JavaScript</code> 会将它们连在一起解释，将第二行解释为第一行的参数  </p><p>推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>; &#125;();<br><span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br><span class="hljs-number">0</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br></code></pre></td></tr></table></figure><p>甚至像下面这样写，也是可以的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">!<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br>~<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br>-<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br>+<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br></code></pre></td></tr></table></figure><p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”<br>它的目的有两个：<br>一是不必为函数命名，避免了污染全局变量<br>二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法一</span><br><span class="hljs-keyword">var</span> tmp = newData;<br>processData(tmp);<br>storeData(tmp);<br><br><span class="hljs-comment">// 写法二</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> tmp = newData;<br>  processData(tmp);<br>  storeData(tmp);<br>&#125;());<br></code></pre></td></tr></table></figure><p>上面代码中，写法二比写法一更好，因为完全避免了污染全局变量  </p><h3 id="eval-命令"><a href="#eval-命令" class="headerlink" title="eval 命令"></a>eval 命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;var a = 1;&#x27;</span>);<br>a <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码将字符串当作语句运行，生成了变量<code>a</code>  </p><p>如果参数字符串无法当作语句运行，那么就会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;3x&#x27;</span>) <span class="hljs-comment">// Uncaught SyntaxError: Invalid or unexpected token</span><br></code></pre></td></tr></table></figure><p>放在<code>eval</code>中的字符串，应该有独自存在的意义，不能用来与<code>eval</code>以外的命令配合使用<br>举例来说，下面的代码将会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;return;&#x27;</span>); <span class="hljs-comment">// Uncaught SyntaxError: Illegal return statement</span><br></code></pre></td></tr></table></figure><p>上面代码会报错，因为<code>return</code>不能单独使用，必须在函数中使用  </p><p>如果<code>eval</code>的参数不是字符串，那么会原样返回  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// 123</span><br></code></pre></td></tr></table></figure><p><code>eval</code>没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;a = 2&#x27;</span>);<br><br>a <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>eval</code>命令修改了外部变量<code>a</code>的值<br>由于这个原因，<code>eval</code>有安全风险  </p><p>为了防止这种风险，<code>JavaScript</code> 规定，如果使用严格模式，<code>eval</code>内部声明的变量，不会影响到外部作用域  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;var foo = 123&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.log(foo);  <span class="hljs-comment">// ReferenceError: foo is not defined</span><br>&#125;)()<br></code></pre></td></tr></table></figure><p>上面代码中，函数<code>f</code>内部是严格模式，这时<code>eval</code>内部声明的<code>foo</code>变量，就不会影响到外部  </p><p>不过，即使在严格模式下，<code>eval</code>依然可以读写当前作用域的变量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;foo = 2&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.log(foo);  <span class="hljs-comment">// 2</span><br>&#125;)()<br></code></pre></td></tr></table></figure><p>上面代码中，严格模式下，<code>eval</code>内部还是改写了外部变量，可见安全风险依然存在  </p><p>总之，<code>eval</code>的本质是在当前作用域之中，注入代码<br>由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用<br>通常情况下，<code>eval</code>最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的<code>JSON.parse</code>方法  </p><h4 id="eval-的别名调用"><a href="#eval-的别名调用" class="headerlink" title="eval 的别名调用"></a>eval 的别名调用</h4><p>前面说过<code>eval</code>不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是<code>eval</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-built_in">eval</span>;<br>m(<span class="hljs-string">&#x27;var x = 1&#x27;</span>);<br>x <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>m</code>是<code>eval</code>的别名<br>静态代码分析阶段，引擎分辨不出<code>m(&#39;var x = 1&#39;)</code>执行的是<code>eval</code>命令  </p><p>为了保证<code>eval</code>的别名不影响代码优化，<code>JavaScript</code> 的标准规定，凡是使用别名执行<code>eval</code>，<code>eval</code>内部一律是全局作用域  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">var</span> e = <span class="hljs-built_in">eval</span>;<br>  e(<span class="hljs-string">&#x27;console.log(a)&#x27;</span>);<br>&#125;<br><br>f() <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>eval</code>是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的<code>a</code>为全局变量<br>这样的话，引擎就能确认<code>e()</code>不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉  </p><p><code>eval</code>的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨<code>eval()</code>这一种形式是直接调用  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>.call(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;...&#x27;</span>)<br><span class="hljs-built_in">window</span>.eval(<span class="hljs-string">&#x27;...&#x27;</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-built_in">eval</span>)(<span class="hljs-string">&#x27;...&#x27;</span>)<br>(<span class="hljs-built_in">eval</span>, <span class="hljs-built_in">eval</span>)(<span class="hljs-string">&#x27;...&#x27;</span>)<br></code></pre></td></tr></table></figure><p>上面这些形式都是<code>eval</code>的别名调用，作用域都是全局作用域  </p><h2 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a>Array 数组</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>数组（array）是按次序排列的一组值<br>每个值的位置都有编号（从0开始），整个数组用方括号表示  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br></code></pre></td></tr></table></figure><p>上面代码中的<code>a</code>、<code>b</code>、<code>c</code>就构成一个数组，两端的方括号是数组的标志。<code>a</code>是0号位置，<code>b</code>是1号位置，<code>c</code>是2号位置  </p><p>除了在定义时赋值，数组也可以先定义后赋值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<br><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>arr[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;c&#x27;</span>;<br></code></pre></td></tr></table></figure><p>任何类型的数据，都可以放入数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<br>  &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;,<br>  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br>];<br><br>arr[<span class="hljs-number">0</span>] <span class="hljs-comment">// Object &#123;a: 1&#125;</span><br>arr[<span class="hljs-number">1</span>] <span class="hljs-comment">// [1, 2, 3]</span><br>arr[<span class="hljs-number">2</span>] <span class="hljs-comment">// function ()&#123;return true;&#125;</span><br></code></pre></td></tr></table></figure><p>上面数组<code>arr</code>的3个成员依次是对象、数组、函数  </p><p>如果数组的元素还是数组，就形成了多维数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];<br>a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] <span class="hljs-comment">// 2</span><br>a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><h3 id="数组的本质"><a href="#数组的本质" class="headerlink" title="数组的本质"></a>数组的本质</h3><p>本质上，数组属于一种特殊的对象。<code>typeof</code>运算符会返回数组的类型是<code>object</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码表明，<code>typeof</code>运算符认为数组的类型就是对象  </p><p>数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br><span class="hljs-built_in">Object</span>.keys(arr)<br><span class="hljs-comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>Object.keys</code>方法返回数组的所有键名<br>可以看到数组的键名就是整数0、1、2  </p><p>由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名<br><code>JavaScript</code> 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串<br>之所以可以用数值读取，是因为非字符串的键名会被转为字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>arr[<span class="hljs-string">&#x27;0&#x27;</span>] <span class="hljs-comment">// &#x27;a&#x27;</span><br>arr[<span class="hljs-number">0</span>] <span class="hljs-comment">// &#x27;a&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串  </p><p>注意，这点在赋值时也成立。一个值总是先转成字符串，再作为键名进行赋值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [];<br><br>a[<span class="hljs-number">1.00</span>] = <span class="hljs-number">6</span>;<br>a[<span class="hljs-number">1</span>] <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure><p>上面代码中，由于<code>1.00</code>转成字符串是<code>1</code>，所以通过数字键<code>1</code>可以读取值  </p><p>上一章说过，对象有两种读取成员的方法：点结构（<code>object.key</code>）和方括号结构（<code>object[key]</code>）。但是，对于数值的键名，不能使用点结构  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr<span class="hljs-number">.0</span> <span class="hljs-comment">// SyntaxError</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>arr.0</code>的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号<code>arr[0]</code>表示（方括号是运算符，可以接受数值）  </p><h3 id="length-属性-2"><a href="#length-属性-2" class="headerlink" title="length 属性"></a>length 属性</h3><p>数组的<code>length</code>属性，返回数组的成员数量  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>].length <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>JavaScript 使用一个32位整数，保存数组的元素个数<br>这意味着，数组成员最多只有 4294967295 个（2<sup>32</sup> - 1）个，也就是说<code>length</code>属性的最大值就是 4294967295  </p><p>只要是数组，就一定有<code>length</code>属性<br>该属性是一个动态的值，等于键名中的最大整数加上<code>1</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>];<br>arr.length <span class="hljs-comment">// 2</span><br><br>arr[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;c&#x27;</span>;<br>arr.length <span class="hljs-comment">// 3</span><br><br>arr[<span class="hljs-number">9</span>] = <span class="hljs-string">&#x27;d&#x27;</span>;<br>arr.length <span class="hljs-comment">// 10</span><br><br>arr[<span class="hljs-number">1000</span>] = <span class="hljs-string">&#x27;e&#x27;</span>;<br>arr.length <span class="hljs-comment">// 1001</span><br></code></pre></td></tr></table></figure><p>上面代码表示，数组的数字键不需要连续，<code>length</code>属性的值总是比最大的那个整数键大<code>1</code><br>另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员  </p><p><code>length</code>属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到<code>length</code>设置的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> ];<br>arr.length <span class="hljs-comment">// 3</span><br><br>arr.length = <span class="hljs-number">2</span>;<br>arr <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;]</span><br></code></pre></td></tr></table></figure><p>上面代码表示，当数组的<code>length</code>属性设为2（即最大的整数键只能是1）那么整数键2（值为<code>c</code>）就已经不在数组中了，被自动删除了  </p><p>清空数组的一个有效方法，就是将<code>length</code>属性设为0  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> ];<br><br>arr.length = <span class="hljs-number">0</span>;<br>arr <span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><p>如果人为设置<code>length</code>大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>];<br><br>a.length = <span class="hljs-number">3</span>;<br>a[<span class="hljs-number">1</span>] <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>上面代码表示，当<code>length</code>属性设为大于数组个数时，读取新增的位置都会返回<code>undefined</code>  </p><p>如果人为设置<code>length</code>为不合法的值，<code>JavaScript</code> 会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 设置负值</span><br>[].length = -<span class="hljs-number">1</span><br><span class="hljs-comment">// RangeError: Invalid array length</span><br><br><span class="hljs-comment">// 数组元素个数大于等于2的32次方</span><br>[].length = <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>)<br><span class="hljs-comment">// RangeError: Invalid array length</span><br><br><span class="hljs-comment">// 设置字符串</span><br>[].length = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-comment">// RangeError: Invalid array length</span><br></code></pre></td></tr></table></figure><p>值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响<code>length</code>属性的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [];<br><br>a[<span class="hljs-string">&#x27;p&#x27;</span>] = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>a.length <span class="hljs-comment">// 0</span><br><br>a[<span class="hljs-number">2.1</span>] = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>a.length <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>上面代码将数组的键分别设为字符串和小数，结果都不影响<code>length</code>属性<br>因为，<code>length</code>属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以<code>length</code>属性保持为<code>0</code>  </p><p>如果数组的键名是添加超出范围的数值，该键名会自动转为字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<br>arr[-<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>arr[<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>)] = <span class="hljs-string">&#x27;b&#x27;</span>;<br><br>arr.length <span class="hljs-comment">// 0</span><br>arr[-<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;a&quot;</span><br>arr[<span class="hljs-number">4294967296</span>] <span class="hljs-comment">// &quot;b&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，我们为数组<code>arr</code>添加了两个不合法的数字键，结果<code>length</code>属性没有发生变化<br>这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串  </p><h3 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h3><p>检查某个键名是否存在的运算符<code>in</code>，适用于对象，也适用于数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> ];<br><span class="hljs-number">2</span> <span class="hljs-keyword">in</span> arr  <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-keyword">in</span> arr <span class="hljs-comment">// true</span><br><span class="hljs-number">4</span> <span class="hljs-keyword">in</span> arr <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码表明，数组存在键名为<code>2</code>的键。由于键名都是字符串，所以数值<code>2</code>会自动转成字符串  </p><p>注意，如果数组的某个位置是空位，<code>in</code>运算符返回<code>false</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<br>arr[<span class="hljs-number">100</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br><br><span class="hljs-number">100</span> <span class="hljs-keyword">in</span> arr <span class="hljs-comment">// true</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">in</span> arr <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，数组<code>arr</code>只有一个成员<code>arr[100]</code>，其他位置的键名都会返回<code>false</code>  </p><h3 id="for…in-循环和数组的遍历"><a href="#for…in-循环和数组的遍历" class="headerlink" title="for…in 循环和数组的遍历"></a>for…in 循环和数组的遍历</h3><p><code>for...in</code>循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> a) &#123;<br>  <span class="hljs-built_in">console</span>.log(a[i]);<br>&#125;<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>但是，<code>for...in</code>不仅会遍历数组所有的数字键，还会遍历非数字键  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>a.foo = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> a) &#123;<br>  <span class="hljs-built_in">console</span>.log(key);<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// foo</span><br></code></pre></td></tr></table></figure><p>上面代码在遍历数组时，也遍历到了非整数键<code>foo</code>。所以，不推荐使用<code>for...in</code>遍历数组  </p><p>数组的遍历可以考虑使用<code>for</code>循环或<code>while</code>循环  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// for循环</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>  <span class="hljs-built_in">console</span>.log(a[i]);<br>&#125;<br><br><span class="hljs-comment">// while循环</span><br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; a.length) &#123;<br>  <span class="hljs-built_in">console</span>.log(a[i]);<br>  i++;<br>&#125;<br><br><span class="hljs-keyword">var</span> l = a.length;<br><span class="hljs-keyword">while</span> (l--) &#123;<br>  <span class="hljs-built_in">console</span>.log(a[l]);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>];<br>colors.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">color</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(color);<br>&#125;);<br><span class="hljs-comment">// red</span><br><span class="hljs-comment">// green</span><br><span class="hljs-comment">// blue</span><br></code></pre></td></tr></table></figure><h3 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h3><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, , <span class="hljs-number">1</span>];<br>a.length <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面代码表明，数组的空位不影响<code>length</code>属性  </p><p>需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,];<br><br>a.length <span class="hljs-comment">// 3</span><br>a <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>上面代码中，数组最后一个成员后面有一个逗号，这不影响<code>length</code>属性的值，与没有这个逗号时效果一样  </p><p>数组的空位是可以读取的，返回<code>undefined</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [, , ,];<br>a[<span class="hljs-number">1</span>] <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">delete</span> a[<span class="hljs-number">1</span>];<br><br>a[<span class="hljs-number">1</span>] <span class="hljs-comment">// undefined</span><br>a.length <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面代码用<code>delete</code>命令删除了数组的第二个元素，这个位置就形成了空位，但是对<code>length</code>属性没有影响<br>也就是说，<code>length</code>属性不过滤空位<br>所以，使用<code>length</code>属性进行数组遍历，一定要非常小心  </p><p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的<br>如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [, , ,];<br><br>a.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, i</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&#x27;. &#x27;</span> + x);<br>&#125;)<br><span class="hljs-comment">// 不产生任何输出</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> a) &#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br><span class="hljs-comment">// 不产生任何输出</span><br><br><span class="hljs-built_in">Object</span>.keys(a)<br><span class="hljs-comment">// []</span><br></code></pre></td></tr></table></figure><p>如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>];<br><br>a.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, i</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&#x27;. &#x27;</span> + x);<br>&#125;);<br><span class="hljs-comment">// 0. undefined</span><br><span class="hljs-comment">// 1. undefined</span><br><span class="hljs-comment">// 2. undefined</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> a) &#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><br><span class="hljs-built_in">Object</span>.keys(a)<br><span class="hljs-comment">// [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]</span><br></code></pre></td></tr></table></figure><p>这就是说，空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是<code>undefined</code>，所以遍历不会跳过  </p><h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><p>如果一个对象的所有键名都是正整数或零，并且有<code>length</code>属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>  <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;c&#x27;</span>,<br>  length: <span class="hljs-number">3</span><br>&#125;;<br><br>obj[<span class="hljs-number">0</span>] <span class="hljs-comment">// &#x27;a&#x27;</span><br>obj[<span class="hljs-number">1</span>] <span class="hljs-comment">// &#x27;b&#x27;</span><br>obj.length <span class="hljs-comment">// 3</span><br>obj.push(<span class="hljs-string">&#x27;d&#x27;</span>) <span class="hljs-comment">// TypeError: obj.push is not a function</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象<code>obj</code>就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法<br>对象<code>obj</code>没有数组的<code>push</code>方法，使用该方法就会报错  </p><p>“类似数组的对象”的根本特征，就是具有<code>length</code>属性<br>只要有<code>length</code>属性，就可以认为这个对象类似于数组<br>但是有一个问题，这种<code>length</code>属性不是动态值，不会随着成员的变化而变化  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  length: <span class="hljs-number">0</span><br>&#125;;<br>obj[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;d&#x27;</span>;<br>obj.length <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>上面代码为对象<code>obj</code>添加了一个数字键，但是<code>length</code>属性没变。这就说明了<code>obj</code>不是数组  </p><p>典型的“类似数组的对象”是函数的<code>arguments</code>对象，以及大多数 DOM 元素集，还有字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// arguments对象</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">args</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span> &#125;<br><span class="hljs-keyword">var</span> arrayLike = args(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);<br><br>arrayLike[<span class="hljs-number">0</span>] <span class="hljs-comment">// &#x27;a&#x27;</span><br>arrayLike.length <span class="hljs-comment">// 2</span><br>arrayLike <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// DOM元素集</span><br><span class="hljs-keyword">var</span> elts = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;h3&#x27;</span>);<br>elts.length <span class="hljs-comment">// 3</span><br>elts <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 字符串</span><br><span class="hljs-string">&#x27;abc&#x27;</span>[<span class="hljs-number">1</span>] <span class="hljs-comment">// &#x27;b&#x27;</span><br><span class="hljs-string">&#x27;abc&#x27;</span>.length <span class="hljs-comment">// 3</span><br><span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码包含三个例子，它们都不是数组（<code>instanceof</code>运算符返回<code>false</code>），但是看上去都非常像数组  </p><p>数组的<code>slice</code>方法可以将“类似数组的对象”变成真正的数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Array</span>.prototype.slice.call(arrayLike);<br></code></pre></td></tr></table></figure><p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过<code>call()</code>把数组的方法放到对象上面  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">value, index</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(index + <span class="hljs-string">&#x27; : &#x27;</span> + value);<br>&#125;<br><br><span class="hljs-built_in">Array</span>.prototype.forEach.call(arrayLike, print);<br></code></pre></td></tr></table></figure><p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用  </p><p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// forEach 方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logArgs</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">Array</span>.prototype.forEach.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, i</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&#x27;. &#x27;</span> + elem);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 等同于 for 循环</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logArgs</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) &#123;<br>    <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&#x27;. &#x27;</span> + <span class="hljs-built_in">arguments</span>[i]);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.forEach.call(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chr</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(chr);<br>&#125;);<br><span class="hljs-comment">// a</span><br><span class="hljs-comment">// b</span><br><span class="hljs-comment">// c</span><br></code></pre></td></tr></table></figure><p>注意，这种方法比直接使用数组原生的<code>forEach</code>要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-string">&#x27;abc&#x27;</span>);<br>arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chr</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(chr);<br>&#125;);<br><span class="hljs-comment">// a</span><br><span class="hljs-comment">// b</span><br><span class="hljs-comment">// c</span><br></code></pre></td></tr></table></figure><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><code>JavaScript</code> 共提供10个算术运算符，用来完成基本的算术运算  </p><p>加法运算符：<code>x + y</code><br>减法运算符： <code>x - y</code><br>乘法运算符： <code>x * y</code><br>除法运算符：<code>x / y</code><br>指数运算符：<code>x ** y</code><br>余数运算符：<code>x % y</code><br>自增运算符：<code>++x</code> 或者 <code>x++</code><br>自减运算符：<code>--x</code> 或者 <code>x--</code><br>数值运算符： <code>+x</code><br>负数值运算符：<code>-x</code><br>减法、乘法、除法运算法比较单纯，就是执行相应的数学运算，重点是加法运算符  </p><h3 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符"></a>加法运算符</h3><h4 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h4><p>加法运算符（+）是最常见的运算符，用来求两个数值的和  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>JavaScript 允许非数值的相加  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">true</span> + <span class="hljs-literal">true</span> <span class="hljs-comment">// 2</span><br><span class="hljs-number">1</span> + <span class="hljs-literal">true</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，第一行是两个布尔值相加，第二行是数值与布尔值相加<br>这两种情况，布尔值都会自动转成数值，然后再相加  </p><p>比较特殊的是，如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-string">&#x27;bc&#x27;</span> <span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></td></tr></table></figure><p>如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> + <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-comment">// &quot;1a&quot;</span><br><span class="hljs-literal">false</span> + <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-comment">// &quot;falsea&quot;</span><br></code></pre></td></tr></table></figure><p>加法运算符是在运行时决定，到底是执行相加，还是执行连接<br>也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）<br>由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;3&#x27;</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> <span class="hljs-comment">// &quot;345&quot;</span><br><span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-comment">// &quot;75&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，由于从左到右的运算次序，字符串的位置不同会导致不同的结果  </p><p>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载<br>它们的规则是：所有运算子一律转为数值，再进行相应的数学运算  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> - <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// -1</span><br><span class="hljs-number">1</span> * <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 2</span><br><span class="hljs-number">1</span> / <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 0.5</span><br></code></pre></td></tr></table></figure><p>上面代码中，减法、除法和乘法运算符，都是将字符串自动转为数值，然后再运算  </p><h4 id="对象的相加"><a href="#对象的相加" class="headerlink" title="对象的相加"></a>对象的相加</h4><p>如果运算子是对象，必须先转成原始类型的值，然后再相加  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br>obj + <span class="hljs-number">2</span> <span class="hljs-comment">// &quot;[object Object]2&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象obj转成原始类型的值是<code>[object Object]</code>，再加2就得到了上面的结果  </p><p>对象转成原始类型的值，规则如下。</p><p>首先，自动调用对象的valueOf方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br>obj.valueOf() <span class="hljs-comment">// &#123; p: 1 &#125;</span><br></code></pre></td></tr></table></figure><p>一般来说，对象的<code>valueOf</code>方法总是返回对象自身，这时再自动调用对象的<code>toString</code>方法，将其转为字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br>obj.valueOf().toString() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>对象的<code>toString</code>方法默认返回<code>[object Object]</code>，所以就得到了最前面那个例子的结果  </p><p>知道了这个规则以后，就可以自己定义<code>valueOf</code>方法或<code>toString</code>方法，得到想要的结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;;<br><br>obj + <span class="hljs-number">2</span> <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面代码中，我们定义 obj对象的<code>valueOf</code>方法返回1，于是 obj + 2 就得到了3<br>这个例子中，由于<code>valueOf</code>方法直接返回一个原始类型的值，所以不再调用<code>toString</code>方法  </p><p>下面是自定义<code>toString</code>方法的例子  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span>;<br>  &#125;<br>&#125;;<br><br>obj + <span class="hljs-number">2</span> <span class="hljs-comment">// &quot;hello2&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象obj的<code>toString</code>方法返回字符串hello<br>前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串  </p><p>这里有一个特例，如果运算子是一个 <code>Date</code>对象的实例，那么会优先执行<code>toString</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>obj.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &#125;;<br>obj.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span> &#125;;<br><br>obj + <span class="hljs-number">2</span> <span class="hljs-comment">// &quot;hello2&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，对象obj是一个<code>Date</code>对象的实例，并且自定义了<code>valueOf</code>方法和<code>toString</code>方法，结果<code>toString</code>方法优先执行  </p><h3 id="余数运算符"><a href="#余数运算符" class="headerlink" title="余数运算符"></a>余数运算符</h3><p>余数运算符（<code>%</code>）返回前一个运算子被后一个运算子除，所得的余数  </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">12 </span>% <span class="hljs-number">5</span> // <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>需要注意的是，运算结果的正负号由第一个运算子的正负号决定  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">-<span class="hljs-number">1</span> % <span class="hljs-number">2</span> <span class="hljs-regexp">//</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span> % -<span class="hljs-number">2</span> <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>所以，为了得到负数的正确余数值，可以先使用绝对值函数  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 错误的写法</span><br><span class="hljs-keyword">function</span> is<span class="hljs-constructor">Odd(<span class="hljs-params">n</span>)</span> &#123;<br>  return n % <span class="hljs-number">2</span><span class="hljs-operator"> === </span><span class="hljs-number">1</span>;<br>&#125;<br>is<span class="hljs-constructor">Odd(-5)</span> <span class="hljs-comment">// false</span><br>is<span class="hljs-constructor">Odd(-4)</span> <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 正确的写法</span><br><span class="hljs-keyword">function</span> is<span class="hljs-constructor">Odd(<span class="hljs-params">n</span>)</span> &#123;<br>  return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(n % <span class="hljs-number">2</span>)<span class="hljs-operator"> === </span><span class="hljs-number">1</span>;<br>&#125;<br>is<span class="hljs-constructor">Odd(-5)</span> <span class="hljs-comment">// true</span><br>is<span class="hljs-constructor">Odd(-4)</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">6.5</span> % <span class="hljs-number">2.1</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">0.19999999999999973</span><br></code></pre></td></tr></table></figure><h3 id="自增和自减运算符"><a href="#自增和自减运算符" class="headerlink" title="自增和自减运算符"></a>自增和自减运算符</h3><p>自增和自减运算符，是一元运算符，只需要一个运算子  </p><p>它们的作用是将运算子首先转为数值，然后加上1或者减去1  </p><p>它们会修改原始变量  </p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span> = <span class="hljs-number">1</span>;<br>++<span class="hljs-symbol">x</span> <span class="hljs-comment">// 2</span><br><span class="hljs-symbol">x</span> <span class="hljs-comment">// 2</span><br><br>--<span class="hljs-symbol">x</span> <span class="hljs-comment">// 1</span><br><span class="hljs-symbol">x</span> <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码的变量<code>x</code>自增后，返回<code>2</code>，再进行自减，返回<code>1</code>  </p><p>这两种情况都会使得，原始变量<code>x</code>的值发生改变  </p><p>运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）  </p><p>自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值  </p><p>自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值  </p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-symbol">y</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-symbol">x</span>++ <span class="hljs-comment">// 1</span><br>++<span class="hljs-symbol">y</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>x</code>是先返回当前值，然后自增，所以得到<code>1</code>；<code>y</code>是先自增，然后返回新的值，所以得到<code>2</code>  </p><h3 id="数值运算符，负数值运算符"><a href="#数值运算符，负数值运算符" class="headerlink" title="数值运算符，负数值运算符"></a>数值运算符，负数值运算符</h3><p>数值运算符（<code>+</code>）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）  </p><p>数值运算符的作用在于可以将任何值转为数值（与<code>Number</code>函数的作用相同）  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">+true <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>+[] <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br>+&#123;&#125; <span class="hljs-regexp">//</span> NaN<br></code></pre></td></tr></table></figure><p>上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行<code>NaN</code>也是数值）  </p><p>负数值运算符（<code>-</code>），也同样具有将一个值转为数值的功能，只不过得到的值正负相反  </p><p>连用两个负数值运算符，等同于数值运算符  </p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span> = <span class="hljs-number">1</span>;<br>-<span class="hljs-symbol">x</span> <span class="hljs-comment">// -1</span><br>-(-<span class="hljs-symbol">x</span>) <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码最后一行的圆括号不可少，否则会变成自减运算符  </p><p>数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值  </p><h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h3><p>指数运算符（<code>**</code>）完成指数运算，前一个运算子是底数，后一个运算子是指数  </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>** <span class="hljs-number">4</span> // <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p>注意，指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 相当于 <span class="hljs-number">2</span> ** (<span class="hljs-number">3</span> ** <span class="hljs-number">2</span>)<br><span class="hljs-number">2</span> ** <span class="hljs-number">3</span> ** <span class="hljs-number">2</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">512</span><br></code></pre></td></tr></table></figure><p>上面代码中，由于指数运算符是右结合，所以先计算第二个指数运算符，而不是第一个  </p><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符（Assignment Operators）用于给变量赋值  </p><p>最常见的赋值运算符，当然就是等号（<code>=</code>）  </p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">// 将 1 赋值给变量 x</span><br><span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 将变量 y 的值赋值给变量 x</span><br><span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span> = <span class="hljs-symbol">y</span>;<br></code></pre></td></tr></table></figure><p>赋值运算符还可以与其他运算符结合，形成变体  </p><p>下面是与算术运算符的结合  </p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">// 等同于 x = x + y</span><br><span class="hljs-symbol">x</span> += <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x - y</span><br><span class="hljs-symbol">x</span> -= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x * y</span><br><span class="hljs-symbol">x</span> *= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x / y</span><br><span class="hljs-symbol">x</span> /= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x % y</span><br><span class="hljs-symbol">x</span> %= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x ** y</span><br><span class="hljs-symbol">x</span> **= <span class="hljs-symbol">y</span><br></code></pre></td></tr></table></figure><p>下面是与位运算符的结合（关于位运算符，请见后文的介绍）  </p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs gml"><span class="hljs-comment">// 等同于 x = x &gt;&gt; y</span><br><span class="hljs-symbol">x</span> &gt;&gt;= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x &lt;&lt; y</span><br><span class="hljs-symbol">x</span> &lt;&lt;= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x &gt;&gt;&gt; y</span><br><span class="hljs-symbol">x</span> &gt;&gt;&gt;= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x &amp; y</span><br><span class="hljs-symbol">x</span> &amp;= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x | y</span><br><span class="hljs-symbol">x</span> |= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x ^ y</span><br><span class="hljs-symbol">x</span> ^= <span class="hljs-symbol">y</span><br></code></pre></td></tr></table></figure><p>这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量  </p><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件  </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>&gt; <span class="hljs-number">1</span> // true<br></code></pre></td></tr></table></figure><p>上面代码比较<code>2</code>是否大于<code>1</code>，返回<code>true</code>  </p><blockquote><p>注意，比较运算符可以比较各种类型的值，不仅仅是数值  </p></blockquote><p>JavaScript 一共提供了8个比较运算符  </p><ul><li><code>&gt;</code> 大于运算符  </li><li><code>&lt;</code> 小于运算符  </li><li><code>&lt;=</code> 小于或等于运算符  </li><li><code>&gt;=</code> 大于或等于运算符  </li><li><code>==</code> 相等运算符  </li><li><code>===</code> 严格相等运算符  </li><li><code>!=</code> 不相等运算符  </li><li><code>!==</code> 严格不相等运算符  </li></ul><p>这八个比较运算符分成两类：相等比较和非相等比较  </p><p>两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。</p><h3 id="非相等运算符：字符串的比较"><a href="#非相等运算符：字符串的比较" class="headerlink" title="非相等运算符：字符串的比较"></a>非相等运算符：字符串的比较</h3><p>字符串按照字典顺序进行比较  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;cat&#x27;</span> &gt; <span class="hljs-string">&#x27;dog&#x27;</span> <span class="hljs-regexp">//</span> false<br><span class="hljs-string">&#x27;cat&#x27;</span> &gt; <span class="hljs-string">&#x27;catalog&#x27;</span> <span class="hljs-regexp">//</span> false<br></code></pre></td></tr></table></figure><p><code>JavaScript</code> 引擎内部首先比较首字符的 <code>Unicode</code> 码点  </p><p>如果相等，再比较第二个字符的 <code>Unicode</code> 码点，以此类推  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;cat&#x27;</span> &gt; <span class="hljs-string">&#x27;Cat&#x27;</span> <span class="hljs-regexp">//</span> true<span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中，小写的<code>c</code>的<code>Unicode</code> 码点（<code>99</code>）大于大写的<code>C</code>的 <code>Unicode</code> 码点（<code>67</code>），所以返回<code>true</code>。</p><p>由于所有字符都有 <code>Unicode</code> 码点，因此汉字也可以比较  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;大&#x27;</span> &gt; <span class="hljs-string">&#x27;小&#x27;</span> <span class="hljs-regexp">//</span> false<br></code></pre></td></tr></table></figure><p>上面代码中，“大”的 <code>Unicode</code> 码点是22823，“小”是<code>23567</code>，因此返回<code>false</code>  </p><h3 id="非相等运算符：非字符串的比较"><a href="#非相等运算符：非字符串的比较" class="headerlink" title="非相等运算符：非字符串的比较"></a>非相等运算符：非字符串的比较</h3><p>如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况  </p><p><strong>（1）原始类型值</strong></p><p>如果两个运算子都是原始类型的值，则是先转成数值再比较  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">5</span> &gt; <span class="hljs-string">&#x27;4&#x27;</span> <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">5</span> &gt; Number(<span class="hljs-string">&#x27;4&#x27;</span>)<br><span class="hljs-regexp">//</span> 即 <span class="hljs-number">5</span> &gt; <span class="hljs-number">4</span><br><br>true &gt; false <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 Number(true) &gt; Number(false)<br><span class="hljs-regexp">//</span> 即 <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span><br><br><span class="hljs-number">2</span> &gt; true <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">2</span> &gt; Number(true)<br><span class="hljs-regexp">//</span> 即 <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>上面代码中，字符串和布尔值都会先转成数值，再进行比较  </p><p>这里需要注意与<code>NaN</code>的比较。任何值（包括<code>NaN</code>本身）与<code>NaN</code>使用非相等运算符进行比较，返回的都是<code>false</code>  </p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">1</span> &gt; <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-number">1</span> &lt;= <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-string">&#x27;1&#x27;</span> &gt; <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-string">&#x27;1&#x27;</span> &lt;= <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">NaN</span> &gt; <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">NaN</span> &lt;= <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p><strong>（2）对象</strong></p><p>如果运算子是对象，会转为原始类型的值，再进行比较  </p><p>对象转换成原始类型的值，算法是先调用<code>valueOf</code>方法  </p><p>如果返回的还是对象，再接着调用<code>toString</code>方法  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">var x = [<span class="hljs-number">2</span>];<br>x &gt; <span class="hljs-string">&#x27;11&#x27;</span> <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 [<span class="hljs-number">2</span>].valueOf().toString() &gt; <span class="hljs-string">&#x27;11&#x27;</span><br><span class="hljs-regexp">//</span> 即 <span class="hljs-string">&#x27;2&#x27;</span> &gt; <span class="hljs-string">&#x27;11&#x27;</span><br><br>x.valueOf = <span class="hljs-keyword">function</span> () &#123; return <span class="hljs-string">&#x27;1&#x27;</span> &#125;;<br>x &gt; <span class="hljs-string">&#x27;11&#x27;</span> <span class="hljs-regexp">//</span> false<br><span class="hljs-regexp">//</span> 等同于 [<span class="hljs-number">2</span>].valueOf() &gt; <span class="hljs-string">&#x27;11&#x27;</span><br><span class="hljs-regexp">//</span> 即 <span class="hljs-string">&#x27;1&#x27;</span> &gt; <span class="hljs-string">&#x27;11&#x27;</span><br></code></pre></td></tr></table></figure><p>两个对象之间的比较也是如此  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk">[<span class="hljs-number">2</span>] &gt; [<span class="hljs-number">1</span>] <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 [<span class="hljs-number">2</span>].valueOf().toString() &gt; [<span class="hljs-number">1</span>].valueOf().toString()<br><span class="hljs-regexp">//</span> 即 <span class="hljs-string">&#x27;2&#x27;</span> &gt; <span class="hljs-string">&#x27;1&#x27;</span><br><br>[<span class="hljs-number">2</span>] &gt; [<span class="hljs-number">11</span>] <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 [<span class="hljs-number">2</span>].valueOf().toString() &gt; [<span class="hljs-number">11</span>].valueOf().toString()<br><span class="hljs-regexp">//</span> 即 <span class="hljs-string">&#x27;2&#x27;</span> &gt; <span class="hljs-string">&#x27;11&#x27;</span><br><br>&#123; x: <span class="hljs-number">2</span> &#125; &gt;= &#123; x: <span class="hljs-number">1</span> &#125; <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 &#123; x: <span class="hljs-number">2</span> &#125;.valueOf().toString() &gt;= &#123; x: <span class="hljs-number">1</span> &#125;.valueOf().toString()<br><span class="hljs-regexp">//</span> 即 <span class="hljs-string">&#x27;[object Object]&#x27;</span> &gt;= <span class="hljs-string">&#x27;[object Object]&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="严格相等运算符"><a href="#严格相等运算符" class="headerlink" title="严格相等运算符"></a>严格相等运算符</h3><p>JavaScript 提供两种相等运算符：<code>==</code>和<code>===</code>。</p><p>简单说，它们的区别是相等运算符（<code>==</code>）比较两个值是否相等，严格相等运算符（<code>===</code>）比较它们是否为“同一个值”    </p><p>如果两个值不是同一类型，严格相等运算符（<code>===</code>）直接返回<code>false</code>，而相等运算符（<code>==</code>）会将它们转换成同一个类型，再用严格相等运算符进行比较  </p><p><strong>（1）不同类型的值</strong>  </p><p>如果两个值的类型不同，直接返回<code>false</code>  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">1</span> === <span class="hljs-string">&quot;1&quot;</span> // <span class="hljs-literal">false</span><br><span class="hljs-attr">true</span> === <span class="hljs-string">&quot;true&quot;</span> // <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p>上面代码比较数值的<code>1</code>与字符串的“1”、布尔值的<code>true</code>与字符串<code>&quot;true&quot;</code>，因为类型不同，结果都是<code>false</code>  </p><p><strong>（2）同一类的原始类型值</strong>  </p><p>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回<code>true</code>，值不同就返回<code>false</code>  </p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>=== <span class="hljs-number">0</span>x1 // true<br></code></pre></td></tr></table></figure><p>上面代码比较十进制的<code>1</code>与十六进制的<code>1</code>，因为类型和值都相同，返回<code>true</code>  </p><p>需要注意的是，<code>NaN</code>与任何值都不相等（包括自身）  </p><p>另外，正<code>0</code>等于负<code>0</code>  </p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span>  <span class="hljs-comment">// false</span><br>+<span class="hljs-number">0</span> === <span class="hljs-number">-0</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p><strong>（3）复合类型值</strong>  </p><p>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址  </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">&#123;&#125; === &#123;&#125; <span class="hljs-comment">// false</span><br>[] === [] <span class="hljs-comment">// false</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;&#125; === <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;&#125;) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等  </p><p>原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是<code>false</code>  </p><p>如果两个变量引用同一个对象，则它们相等  </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">var</span> <span class="hljs-built_in">v1</span> = &#123;&#125;<span class="hljs-comment">;</span><br><span class="hljs-symbol">var</span> <span class="hljs-built_in">v2</span> = <span class="hljs-built_in">v1</span><span class="hljs-comment">;</span><br><span class="hljs-symbol">v1</span> === <span class="hljs-built_in">v2</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">var obj1 = &#123;&#125;;<br>var obj2 = &#123;&#125;;<br><br>obj1 &gt; obj2 <span class="hljs-regexp">//</span> false<br>obj1 &lt; obj2 <span class="hljs-regexp">//</span> false<br>obj1 === obj2 <span class="hljs-regexp">//</span> false<br></code></pre></td></tr></table></figure><p>上面的三个比较，前两个比较的是值，最后一个比较的是地址，所以都返回<code>false</code>  </p><p><strong>（4）undefined 和 null</strong></p><p><code>undefined</code>和<code>null</code>与自身严格相等  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">undefined</span> <span class="hljs-string">===</span> <span class="hljs-string">undefined</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br><span class="hljs-literal">null</span> <span class="hljs-string">===</span> <span class="hljs-literal">null</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>由于变量声明后默认值是<code>undefined</code>，因此两个只声明未赋值的变量是相等的  </p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">var</span> <span class="hljs-built_in">v1</span><span class="hljs-comment">;</span><br><span class="hljs-symbol">var</span> <span class="hljs-built_in">v2</span><span class="hljs-comment">;</span><br><span class="hljs-symbol">v1</span> === <span class="hljs-built_in">v2</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h3 id="严格不相等运算符"><a href="#严格不相等运算符" class="headerlink" title="严格不相等运算符"></a>严格不相等运算符</h3><p>严格相等运算符有一个对应的“严格不相等运算符”（<code>!==</code>），它的算法就是先求严格相等运算符的结果，然后返回相反值  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span> !== <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于<br>!(<span class="hljs-number">1</span> === <span class="hljs-string">&#x27;1&#x27;</span>)<br></code></pre></td></tr></table></figure><p>上面代码中，感叹号<code>!</code>是求出后面表达式的相反值  </p><h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样   </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span> == <span class="hljs-number">1.0</span><br><span class="hljs-regexp">//</span> 等同于<br><span class="hljs-number">1</span> === <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较  </p><p>下面分成几种情况，讨论不同类型的值互相比较的规则  </p><p><strong>（1）原始类型值</strong></p><p>原始类型的值会转换成数值再进行比较  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span> == true <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">1</span> === Number(true)<br><br><span class="hljs-number">0</span> == false <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">0</span> === Number(false)<br><br><span class="hljs-number">2</span> == true <span class="hljs-regexp">//</span> false<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">2</span> === Number(true)<br><br><span class="hljs-number">2</span> == false <span class="hljs-regexp">//</span> false<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">2</span> === Number(false)<br><br><span class="hljs-string">&#x27;true&#x27;</span> == true <span class="hljs-regexp">//</span> false<br><span class="hljs-regexp">//</span> 等同于 Number(<span class="hljs-string">&#x27;true&#x27;</span>) === Number(true)<br><span class="hljs-regexp">//</span> 等同于 NaN === <span class="hljs-number">1</span><br><br><span class="hljs-string">&#x27;&#x27;</span> == <span class="hljs-number">0</span> <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 Number(<span class="hljs-string">&#x27;&#x27;</span>) === <span class="hljs-number">0</span><br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">0</span> === <span class="hljs-number">0</span><br><br><span class="hljs-string">&#x27;&#x27;</span> == false  <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 Number(<span class="hljs-string">&#x27;&#x27;</span>) === Number(false)<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">0</span> === <span class="hljs-number">0</span><br><br><span class="hljs-string">&#x27;1&#x27;</span> == true  <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 Number(<span class="hljs-string">&#x27;1&#x27;</span>) === Number(true)<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">1</span> === <span class="hljs-number">1</span><br><br><span class="hljs-string">&#x27;\n  123  \t&#x27;</span> == <span class="hljs-number">123</span> <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 因为字符串转为数字时，省略前置和后置的空格<br></code></pre></td></tr></table></figure><p>上面代码将字符串和布尔值都转为数值，然后再进行比较  </p><p><strong>（2）对象与原始类型值比较</strong></p><p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较  </p><p>具体来说，先调用对象的<code>valueOf()</code>方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用<code>toString()</code>方法，得到字符串形式，再进行比较  </p><p>下面是数组与原始类型值比较的例子  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 数组与数值的比较<br>[<span class="hljs-number">1</span>] == <span class="hljs-number">1</span> <span class="hljs-regexp">//</span> true<br><br><span class="hljs-regexp">//</span> 数组与字符串的比较<br>[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-regexp">//</span> true<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;1,2&#x27;</span> <span class="hljs-regexp">//</span> true<br><br><span class="hljs-regexp">//</span> 对象与布尔值的比较<br>[<span class="hljs-number">1</span>] == true <span class="hljs-regexp">//</span> true<br>[<span class="hljs-number">2</span>] == true <span class="hljs-regexp">//</span> false<br></code></pre></td></tr></table></figure><p>上面例子中，<code>Javascript</code> 引擎会先对数组<code>[1]</code>调用数组的<code>valueOf()</code>方法，由于返回的还是一个数组，所以会接着调用数组的<code>toString()</code>方法，得到字符串形式，再按照上一小节的规则进行比较  </p><p>下面是一个更直接的例子  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行 valueOf()&#x27;</span>);<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;,<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行 toString()&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<br>  &#125;<br>&#125;;<br><br>obj == <span class="hljs-string">&#x27;foo&#x27;</span><br><span class="hljs-comment">// 执行 valueOf()</span><br><span class="hljs-comment">// 执行 toString()</span><br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面例子中，<code>obj</code>是一个自定义了<code>valueOf()</code>和<code>toString()</code>方法的对象。这个对象与字符串<code>&#39;foo&#39;</code>进行比较时，会依次调用<code>valueOf()</code>和<code>toString()</code>方法，最后返回<code>&#39;foo&#39;</code>，所以比较结果是<code>true</code>。</p><p><strong>（3）undefined 和 null</strong></p><p><code>undefined</code>和<code>null</code>只有与自身比较，或者互相比较时，才会返回<code>true</code>；与其他类型的值比较时，结果都为<code>false</code>  </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">undefined</span> <span class="hljs-string">==</span> <span class="hljs-string">undefined</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br><span class="hljs-literal">null</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br><span class="hljs-string">undefined</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br><br><span class="hljs-literal">false</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span><br><span class="hljs-literal">false</span> <span class="hljs-string">==</span> <span class="hljs-string">undefined</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span><br><br><span class="hljs-number">0</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span><br><span class="hljs-number">0</span> <span class="hljs-string">==</span> <span class="hljs-string">undefined</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><strong>（4）相等运算符的缺点</strong></p><p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果  </p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">0</span> == <span class="hljs-string">&#x27;&#x27;</span>             // <span class="hljs-literal">true</span><br><span class="hljs-attr">0</span> == <span class="hljs-string">&#x27;0&#x27;</span>            // <span class="hljs-literal">true</span><br><br><span class="hljs-attr">2</span> == <span class="hljs-literal">true</span>           // <span class="hljs-literal">false</span><br><span class="hljs-attr">2</span> == <span class="hljs-literal">false</span>          // <span class="hljs-literal">false</span><br><br><span class="hljs-attr">false</span> == <span class="hljs-string">&#x27;false&#x27;</span>    // <span class="hljs-literal">false</span><br><span class="hljs-attr">false</span> == <span class="hljs-string">&#x27;0&#x27;</span>        // <span class="hljs-literal">true</span><br><br><span class="hljs-attr">false</span> == undefined  // <span class="hljs-literal">false</span><br><span class="hljs-attr">false</span> == null       // <span class="hljs-literal">false</span><br><span class="hljs-attr">null</span> == undefined   // <span class="hljs-literal">true</span><br><br><span class="hljs-attr">&#x27; \t\r\n &#x27;</span> == <span class="hljs-number">0</span>     // <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>上面这些表达式都不同于直觉，很容易出错  </p><p>因此建议不要使用相等运算符（<code>==</code>），最好只使用严格相等运算符（<code>===</code>）。</p><h3 id="不相等运算符"><a href="#不相等运算符" class="headerlink" title="不相等运算符"></a>不相等运算符</h3><p>相等运算符有一个对应的“不相等运算符”（<code>!=</code>），它的算法就是先求相等运算符的结果，然后返回相反值  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span> != <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-regexp">//</span> false<br><br><span class="hljs-regexp">//</span> 等同于<br>!(<span class="hljs-number">1</span> == <span class="hljs-string">&#x27;1&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>布尔运算符用于将表达式转为布尔值，一共包含四个运算符  </p><ul><li>取反运算符：<code>!</code></li><li>且运算符：<code>&amp;&amp;</code></li><li>或运算符：<code>||</code></li><li>三元运算符：<code>?:</code></li></ul><h3 id="取反运算符"><a href="#取反运算符" class="headerlink" title="取反运算符 !"></a>取反运算符 !</h3><p>取反运算符是一个感叹号，用于将布尔值变为相反值，即<code>true</code>变成<code>false</code>，<code>false</code>变成<code>true</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">!<span class="hljs-literal">true</span> <span class="hljs-comment">// false</span><br>!<span class="hljs-literal">false</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为<code>true</code>，其他值都为<code>false</code>  </p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>false</code></li><li><code>0</code></li><li><code>NaN</code></li><li>空字符串（<code>&#39;&#39;</code>）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">!<span class="hljs-literal">undefined</span> <span class="hljs-comment">// true</span><br>!<span class="hljs-literal">null</span> <span class="hljs-comment">// true</span><br>!<span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br>!<span class="hljs-literal">NaN</span> <span class="hljs-comment">// true</span><br>!<span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// true</span><br><br>!<span class="hljs-number">54</span> <span class="hljs-comment">// false</span><br>!<span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-comment">// false</span><br>![] <span class="hljs-comment">// false</span><br>!&#123;&#125; <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，不管什么类型的值，经过取反运算后，都变成了布尔值  </p><p>如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与<code>Boolean</code>函数的作用相同  </p><p>这是一种常用的类型转换的写法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">!!x<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">Boolean</span>(x)<br></code></pre></td></tr></table></figure><p>上面代码中，不管<code>x</code>是什么类型的值，经过两次取反运算后，变成了与<code>Boolean</code>函数结果相同的布尔值  </p><p>所以，两次取反就是将一个值转为布尔值的简便写法  </p><h3 id="且运算符-amp-amp"><a href="#且运算符-amp-amp" class="headerlink" title="且运算符 &amp;&amp;"></a>且运算符 &amp;&amp;</h3><p>且运算符（<code>&amp;&amp;</code>）往往用于多个表达式的求值  </p><p>运算规则：  </p><p>如果第一个运算子的布尔值为<code>true</code>，则返回第二个运算子的值（注意是值，不是布尔值）  </p><p>如果第一个运算子的布尔值为<code>false</code>，则直接返回第一个运算子的值，且不再对第二个运算子求值    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;t&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// &quot;&quot;</span><br><span class="hljs-string">&#x27;t&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;f&#x27;</span> <span class="hljs-comment">// &quot;f&quot;</span><br><span class="hljs-string">&#x27;t&#x27;</span> &amp;&amp; (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br><span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;f&#x27;</span> <span class="hljs-comment">// &quot;&quot;</span><br><span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// &quot;&quot;</span><br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>(<span class="hljs-number">1</span> - <span class="hljs-number">1</span>) &amp;&amp; ( x += <span class="hljs-number">1</span>) <span class="hljs-comment">// 0</span><br>x <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码的最后一个例子，由于且运算符的第一个运算子的布尔值为<code>false</code>，则直接返回它的值<code>0</code>，而不再对第二个运算子求值，所以变量<code>x</code>的值没变    </p><p>这种跳过第二个运算子的机制，被称为“短路”    </p><p>有些程序员喜欢用它取代<code>if</code>结构，比如下面是一段<code>if</code>结构的代码，就可以用且运算符改写  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (i) &#123;<br>  doSomething();<br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><br>i &amp;&amp; doSomething();<br></code></pre></td></tr></table></figure><p>上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用  </p><p>且运算符可以多个连用，这时返回第一个布尔值为<code>false</code>的表达式的值。如果所有表达式的布尔值都为<code>true</code>，则返回最后一个表达式的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-string">&#x27;foo&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-string">&#x27;foo&#x27;</span> &amp;&amp; <span class="hljs-literal">true</span><br><span class="hljs-comment">// &#x27;&#x27;</span><br><br><span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-number">3</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面代码中，例一里面，第一个布尔值为<code>false</code>的表达式为第三个表达式，所以得到一个空字符串  </p><p>例二里面，所有表达式的布尔值都是<code>true</code>，所以返回最后一个表达式的值<code>3</code>   </p><h3 id="或运算符"><a href="#或运算符" class="headerlink" title="或运算符 ||"></a>或运算符 ||</h3><p>或运算符（<code>||</code>）也用于多个表达式的求值  </p><p>它的运算规则是：如果第一个运算子的布尔值为<code>true</code>，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为<code>false</code>，则返回第二个运算子的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;t&#x27;</span> || <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// &quot;t&quot;</span><br><span class="hljs-string">&#x27;t&#x27;</span> || <span class="hljs-string">&#x27;f&#x27;</span> <span class="hljs-comment">// &quot;t&quot;</span><br><span class="hljs-string">&#x27;&#x27;</span> || <span class="hljs-string">&#x27;f&#x27;</span> <span class="hljs-comment">// &quot;f&quot;</span><br><span class="hljs-string">&#x27;&#x27;</span> || <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// &quot;&quot;</span><br></code></pre></td></tr></table></figure><p>短路规则对这个运算符也适用  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-literal">true</span> || (x = <span class="hljs-number">2</span>) <span class="hljs-comment">// true</span><br>x <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，或运算符的第一个运算子为<code>true</code>，所以直接返回<code>true</code>，不再运行第二个运算子  </p><p>所以，<code>x</code>的值没有改变。这种只通过第一个表达式的值，控制是否运行第二个表达式的机制，就称为“短路”（short-cut）  </p><p>或运算符可以多个连用，这时返回第一个布尔值为<code>true</code>的表达式的值  </p><p>如果所有表达式都为<code>false</code>，则返回最后一个表达式的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-literal">false</span> || <span class="hljs-number">0</span> || <span class="hljs-string">&#x27;&#x27;</span> || <span class="hljs-number">4</span> || <span class="hljs-string">&#x27;foo&#x27;</span> || <span class="hljs-literal">true</span><br><span class="hljs-comment">// 4</span><br><br><span class="hljs-literal">false</span> || <span class="hljs-number">0</span> || <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment">// &#x27;&#x27;</span><br></code></pre></td></tr></table></figure><p>上面代码中，例一里面，第一个布尔值为<code>true</code>的表达式是第四个表达式，所以得到数值4  </p><p>例二里面，所有表达式的布尔值都为<code>false</code>，所以返回最后一个表达式的值  </p><p>或运算符常用于为一个变量设置默认值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">saveText</span>(<span class="hljs-params">text</span>) </span>&#123;<br>  text = text || <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 或者写成</span><br>saveText(<span class="hljs-built_in">this</span>.text || <span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure><p>上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串  </p><h3 id="三元条件运算符"><a href="#三元条件运算符" class="headerlink" title="三元条件运算符 ?:"></a>三元条件运算符 ?:</h3><p>三元条件运算符由问号<code>?</code>和冒号<code>:</code>组成，分隔三个表达式  </p><p>它是 <code>JavaScript</code> 语言唯一一个需要三个运算子的运算符  </p><p>如果第一个表达式的布尔值为<code>true</code>，则返回第二个表达式的值，否则返回第三个表达式的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;t&#x27;</span> ? <span class="hljs-string">&#x27;hello&#x27;</span> : <span class="hljs-string">&#x27;world&#x27;</span> <span class="hljs-comment">// &quot;hello&quot;</span><br><span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;hello&#x27;</span> : <span class="hljs-string">&#x27;world&#x27;</span> <span class="hljs-comment">// &quot;world&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码的<code>t</code>和<code>0</code>的布尔值分别为<code>true</code>和<code>false</code>，所以分别返回第二个和第三个表达式的值  </p><p>通常来说，三元条件表达式与<code>if...else</code>语句具有同样表达效果，前者可以表达的，后者也能表达  </p><p>但是两者具有一个重大差别，<code>if...else</code>是语句，没有返回值；三元条件表达式是表达式，具有返回值  </p><p>所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用<code>if..else</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> ? <span class="hljs-string">&#x27;T&#x27;</span> : <span class="hljs-string">&#x27;F&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面代码中，<code>console.log</code>方法的参数必须是一个表达式，这时就只能使用三元条件表达式  </p><p>如果要用<code>if...else</code>语句，就必须改变整个代码写法了  </p><h2 id="二进制位运算符"><a href="#二进制位运算符" class="headerlink" title="二进制位运算符"></a>二进制位运算符</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>二进制位运算符用于直接对二进制位进行计算，一共有7个。</p><ul><li><strong>二进制或运算符</strong>（or）：符号为<code>|</code>，表示若两个二进制位都为<code>0</code>，则结果为<code>0</code>，否则为<code>1</code>。</li><li><strong>二进制与运算符</strong>（and）：符号为<code>&amp;</code>，表示若两个二进制位都为1，则结果为1，否则为0。</li><li><strong>二进制否运算符</strong>（not）：符号为<code>~</code>，表示对一个二进制位取反。</li><li><strong>异或运算符</strong>（xor）：符号为<code>^</code>，表示若两个二进制位不相同，则结果为1，否则为0。</li><li><strong>左移运算符</strong>（left shift）：符号为<code>&lt;&lt;</code>，详见下文解释。</li><li><strong>右移运算符</strong>（right shift）：符号为<code>&gt;&gt;</code>，详见下文解释。</li><li><strong>头部补零的右移运算符</strong>（zero filled right shift）：符号为<code>&gt;&gt;&gt;</code>，详见下文解释。</li></ul><p>这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。</p><p>有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">i = i | <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>上面这行代码的意思，就是将<code>i</code>（不管是整数或小数）转为32位整数。</p><p>利用这个特性，可以写出一个函数，将任意数值转为32位整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toInt32</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x | <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个函数将任意值与<code>0</code>进行一次或运算，这个位运算会自动将一个值转为32位整数。下面是这个函数的用法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">toInt32(<span class="hljs-number">1.001</span>) <span class="hljs-comment">// 1</span><br>toInt32(<span class="hljs-number">1.999</span>) <span class="hljs-comment">// 1</span><br>toInt32(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br>toInt32(-<span class="hljs-number">1</span>) <span class="hljs-comment">// -1</span><br>toInt32(<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>) + <span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br>toInt32(<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>) - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>toInt32</code>可以将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于或等于2的32次方的整数，大于32位的数位都会被舍去。</p><h3 id="二进制或运算符"><a href="#二进制或运算符" class="headerlink" title="二进制或运算符"></a>二进制或运算符</h3><p>二进制或运算符（<code>|</code>）逐位比较两个运算子，两个二进制位之中只要有一个为<code>1</code>，就返回<code>1</code>，否则返回<code>0</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> | <span class="hljs-number">3</span> <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>0</code>和<code>3</code>的二进制形式分别是<code>00</code>和<code>11</code>，所以进行二进制或运算会得到<code>11</code>（即<code>3</code>）  </p><p>位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分  </p><p>所以，将一个小数与<code>0</code>进行二进制或运算，等同于对该数去除小数部分，即取整数位  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">2.9</span> | <span class="hljs-number">0</span> <span class="hljs-comment">// 2</span><br>-<span class="hljs-number">2.9</span> | <span class="hljs-number">0</span> <span class="hljs-comment">// -2</span><br></code></pre></td></tr></table></figure><p>需要注意的是，这种取整方法不适用超过32位整数最大值<code>2147483647</code>的数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">2147483649.4</span> | <span class="hljs-number">0</span>;<br><span class="hljs-comment">// -2147483647</span><br></code></pre></td></tr></table></figure><h3 id="二进制与运算符"><a href="#二进制与运算符" class="headerlink" title="二进制与运算符"></a>二进制与运算符</h3><p>二进制与运算符（<code>&amp;</code>）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为<code>0</code>，就返回<code>0</code>，否则返回<code>1</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> &amp; <span class="hljs-number">3</span> <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>上面代码中，0（二进制<code>00</code>）和3（二进制<code>11</code>）进行二进制与运算会得到<code>00</code>（即<code>0</code>）。</p><h3 id="二进制否运算符"><a href="#二进制否运算符" class="headerlink" title="二进制否运算符"></a>二进制否运算符</h3><p>二进制否运算符（<code>~</code>）将每个二进制位都变为相反值（<code>0</code>变为<code>1</code>，<code>1</code>变为<code>0</code>）  </p><p>它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">~ <span class="hljs-number">3</span> <span class="hljs-comment">// -4</span><br></code></pre></td></tr></table></figure><p>上面表达式对<code>3</code>进行二进制否运算，得到<code>-4</code>。之所以会有这样的结果，是因为位运算时，JavaScript 内部将所有的运算子都转为32位的二进制整数再进行运算。</p><p><code>3</code>的32位整数形式是<code>00000000000000000000000000000011</code>，二进制否运算以后得到<code>11111111111111111111111111111100</code>  </p><p>由于第一位（符号位）是1，所以这个数是一个负数  </p><p><code>JavaScript</code> 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值  </p><p>这个数减去1等于<code>11111111111111111111111111111011</code>，再取一次反得到<code>00000000000000000000000000000100</code>，再加上负号就是<code>-4</code>  </p><p>考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于-1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">~ -<span class="hljs-number">3</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面表达式可以这样算，<code>-3</code>的取反值等于<code>-1</code>减去<code>-3</code>，结果为<code>2</code>  </p><p>对一个整数连续两次二进制否运算，得到它自身  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">~~<span class="hljs-number">3</span> <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>所有的位运算都只对整数有效  </p><p>二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分  </p><p>所以，对一个小数连续进行两次二进制否运算，能达到取整效果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">~~<span class="hljs-number">2.9</span> <span class="hljs-comment">// 2</span><br>~~<span class="hljs-number">47.11</span> <span class="hljs-comment">// 47</span><br>~~<span class="hljs-number">1.9999</span> <span class="hljs-comment">// 1</span><br>~~<span class="hljs-number">3</span> <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>使用二进制否运算取整，是所有取整方法中最快的一种  </p><p>对字符串进行二进制否运算，<code>Javascript</code> 引擎会先调用<code>Number</code>函数，将字符串转为数值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 相当于~Number(&#x27;011&#x27;)</span><br>~<span class="hljs-string">&#x27;011&#x27;</span>  <span class="hljs-comment">// -12</span><br><br><span class="hljs-comment">// 相当于~Number(&#x27;42 cats&#x27;)</span><br>~<span class="hljs-string">&#x27;42 cats&#x27;</span> <span class="hljs-comment">// -1</span><br><br><span class="hljs-comment">// 相当于~Number(&#x27;0xcafebabe&#x27;)</span><br>~<span class="hljs-string">&#x27;0xcafebabe&#x27;</span> <span class="hljs-comment">// 889275713</span><br><br><span class="hljs-comment">// 相当于~Number(&#x27;deadbeef&#x27;)</span><br>~<span class="hljs-string">&#x27;deadbeef&#x27;</span> <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><p>对于其他类型的值，二进制否运算也是先用<code>Number</code>转为数值，然后再进行处理  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 相当于 ~Number([])</span><br>~[] <span class="hljs-comment">// -1</span><br><br><span class="hljs-comment">// 相当于 ~Number(NaN)</span><br>~<span class="hljs-literal">NaN</span> <span class="hljs-comment">// -1</span><br><br><span class="hljs-comment">// 相当于 ~Number(null)</span><br>~<span class="hljs-literal">null</span> <span class="hljs-comment">// -1</span><br></code></pre></td></tr></table></figure><h3 id="异或运算符"><a href="#异或运算符" class="headerlink" title="异或运算符"></a>异或运算符</h3><p>异或运算（<code>^</code>）在两个二进制位不同时返回<code>1</code>，相同时返回<code>0</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> ^ <span class="hljs-number">3</span> <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>上面表达式中，<code>0</code>（二进制<code>00</code>）与<code>3</code>（二进制<code>11</code>）进行异或运算，它们每一个二进制位都不同，所以得到<code>11</code>（即<code>3</code>）  </p><p>“异或运算”有一个特殊运用，连续对两个数<code>a</code>和<code>b</code>进行三次异或运算，<code>a^=b; b^=a; a^=b;</code>，可以<a href="http://en.wikipedia.org/wiki/XOR_swap_algorithm">互换</a>它们的值  </p><p>这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">99</span>;<br><br>a ^= b, b ^= a, a ^= b;<br><br>a <span class="hljs-comment">// 99</span><br>b <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>这是互换两个变量的值的最快方法  </p><p>异或运算也可以用来取整  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">12.9</span> ^ <span class="hljs-number">0</span> <span class="hljs-comment">// 12</span><br></code></pre></td></tr></table></figure><h3 id="左移运算符"><a href="#左移运算符" class="headerlink" title="左移运算符"></a>左移运算符</h3><p>左移运算符（<code>&lt;&lt;</code>）表示将一个数的二进制值向左移动指定的位数，尾部补<code>0</code>，即乘以<code>2</code>的指定次方  </p><p>向左移动的时候，最高位的符号位是一起移动的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 4 的二进制形式为100，</span><br><span class="hljs-comment">// 左移一位为1000（即十进制的8）</span><br><span class="hljs-comment">// 相当于乘以2的1次方</span><br><span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">1</span><br><span class="hljs-comment">// 8</span><br><br>-<span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">1</span><br><span class="hljs-comment">// -8</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>-4</code>左移一位得到<code>-8</code>，是因为<code>-4</code>的二进制形式是<code>11111111111111111111111111111100</code>，左移一位后得到<code>11111111111111111111111111111000</code>，该数转为十进制（减去1后取反，再加上负号）即为<code>-8</code>  </p><p>如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">13.5</span> &lt;&lt; <span class="hljs-number">0</span><br><span class="hljs-comment">// 13</span><br><br>-<span class="hljs-number">13.5</span> &lt;&lt; <span class="hljs-number">0</span><br><span class="hljs-comment">// -13</span><br></code></pre></td></tr></table></figure><p>左移运算符用于二进制数值非常方便  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = &#123;<span class="hljs-attr">r</span>: <span class="hljs-number">186</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">218</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">85</span>&#125;;<br><br><span class="hljs-comment">// RGB to HEX</span><br><span class="hljs-comment">// (1 &lt;&lt; 24)的作用为保证结果是6位数</span><br><span class="hljs-keyword">var</span> rgb2hex = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r, g, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;#&#x27;</span> + ((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">24</span>) + (r &lt;&lt; <span class="hljs-number">16</span>) + (g &lt;&lt; <span class="hljs-number">8</span>) + b)<br>    .toString(<span class="hljs-number">16</span>) <span class="hljs-comment">// 先转成十六进制，然后返回字符串</span><br>    .substr(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 去除字符串的最高位，返回后面六个字符串</span><br>&#125;<br><br>rgb2hex(color.r, color.g, color.b)<br><span class="hljs-comment">// &quot;#bada55&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值  </p><h3 id="右移运算符"><a href="#右移运算符" class="headerlink" title="右移运算符"></a>右移运算符</h3><p>右移运算符（<code>&gt;&gt;</code>）表示将一个数的二进制值向右移动指定的位数  </p><p>如果是正数，头部全部补<code>0</code>；如果是负数，头部全部补<code>1</code>  </p><p>右移运算符基本上相当于除以<code>2</code>的指定次方（最高位即符号位参与移动）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// 因为4的二进制形式为 00000000000000000000000000000100，</span><br><span class="hljs-comment">// 右移一位得到 00000000000000000000000000000010，</span><br><span class="hljs-comment">// 即为十进制的2</span><br><span class="hljs-comment">*/</span><br><br>-<span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">1</span><br><span class="hljs-comment">// -2</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// 因为-4的二进制形式为 11111111111111111111111111111100，</span><br><span class="hljs-comment">// 右移一位，头部补1，得到 11111111111111111111111111111110,</span><br><span class="hljs-comment">// 即为十进制的-2</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>右移运算可以模拟 2 的整除运算  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">5</span> &gt;&gt; <span class="hljs-number">1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 相当于 5 / 2 = 2</span><br><br><span class="hljs-number">21</span> &gt;&gt; <span class="hljs-number">2</span><br><span class="hljs-comment">// 5</span><br><span class="hljs-comment">// 相当于 21 / 4 = 5</span><br><br><span class="hljs-number">21</span> &gt;&gt; <span class="hljs-number">3</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 相当于 21 / 8 = 2</span><br><br><span class="hljs-number">21</span> &gt;&gt; <span class="hljs-number">4</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 相当于 21 / 16 = 1</span><br></code></pre></td></tr></table></figure><h3 id="头部补零的右移运算符"><a href="#头部补零的右移运算符" class="headerlink" title="头部补零的右移运算符"></a>头部补零的右移运算符</h3><p>头部补零的右移运算符（<code>&gt;&gt;&gt;</code>）与右移运算符（<code>&gt;&gt;</code>）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位  </p><p>所以，该运算总是得到正值  </p><p>对于正数，该运算的结果与右移运算符（<code>&gt;&gt;</code>）完全一致，区别主要在于负数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">4</span> &gt;&gt;&gt; <span class="hljs-number">1</span><br><span class="hljs-comment">// 2</span><br><br>-<span class="hljs-number">4</span> &gt;&gt;&gt; <span class="hljs-number">1</span><br><span class="hljs-comment">// 2147483646</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// 因为-4的二进制形式为11111111111111111111111111111100，</span><br><span class="hljs-comment">// 带符号位的右移一位，得到01111111111111111111111111111110，</span><br><span class="hljs-comment">// 即为十进制的2147483646。</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>这个运算实际上将一个值转为32位无符号整数  </p><p>查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">-<span class="hljs-number">1</span> &gt;&gt;&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// 4294967295</span><br></code></pre></td></tr></table></figure><p>上面代码表示，<code>-1</code>作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 4294967295（即<code>(2^32)-1</code>，等于<code>11111111111111111111111111111111</code>）。</p><h3 id="开关作用"><a href="#开关作用" class="headerlink" title="开关作用"></a>开关作用</h3><p>位运算符可以用作设置对象属性的开关。</p><p>假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> FLAG_A = <span class="hljs-number">1</span>; <span class="hljs-comment">// 0001</span><br><span class="hljs-keyword">var</span> FLAG_B = <span class="hljs-number">2</span>; <span class="hljs-comment">// 0010</span><br><span class="hljs-keyword">var</span> FLAG_C = <span class="hljs-number">4</span>; <span class="hljs-comment">// 0100</span><br><span class="hljs-keyword">var</span> FLAG_D = <span class="hljs-number">8</span>; <span class="hljs-comment">// 1000</span><br></code></pre></td></tr></table></figure><p>上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位  </p><p>然后，就可以用二进制与运算，检查当前设置是否打开了指定开关  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> flags = <span class="hljs-number">5</span>; <span class="hljs-comment">// 二进制的0101</span><br><br><span class="hljs-keyword">if</span> (flags &amp; FLAG_C) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-comment">// 0101 &amp; 0100 =&gt; 0100 =&gt; true</span><br></code></pre></td></tr></table></figure><p>上面代码检验是否打开了开关<code>C</code>。如果打开，会返回<code>true</code>，否则返回<code>false</code>  </p><p>现在假设需要打开<code>A</code>、<code>B</code>、<code>D</code>三个开关，我们可以构造一个掩码变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> mask = FLAG_A | FLAG_B | FLAG_D;<br><span class="hljs-comment">// 0001 | 0010 | 1000 =&gt; 1011</span><br></code></pre></td></tr></table></figure><p>上面代码对<code>A</code>、<code>B</code>、<code>D</code>三个变量进行二进制或运算，得到掩码值为二进制的<code>1011</code>  </p><p>有了掩码，二进制或运算可以确保打开指定的开关  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">flags = flags | mask;<br></code></pre></td></tr></table></figure><p>上面代码中，计算后得到的<code>flags</code>变量，代表三个开关的二进制位都打开了  </p><p>二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">flags = flags &amp; mask;<br></code></pre></td></tr></table></figure><p>异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">flags = flags ^ mask;<br></code></pre></td></tr></table></figure><p>二进制否运算可以翻转当前设置，即原设置为<code>0</code>，运算后变为<code>1</code>；原设置为<code>1</code>，运算后变为<code>0</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">flags = ~flags;<br></code></pre></td></tr></table></figure><h2 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h2><p><code>void</code>运算符的作用是执行一个表达式，然后不返回任何值，或者说返回<code>undefined</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-number">0</span> <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">void</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure><p>上面是<code>void</code>运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号  </p><p>因为<code>void</code>运算符的优先性很高，如果不使用括号，容易造成错误的结果  </p><p>比如，<code>void 4 + 7</code>实际上等同于<code>(void 4) + 7</code>。</p><p>下面是<code>void</code>运算符的一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">void</span> (x = <span class="hljs-number">5</span>) <span class="hljs-comment">//undefined</span><br>x <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello World&#x27;</span>);</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;f(); return false;&quot;</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面代码中，点击链接后，会先执行<code>onclick</code>的代码，由于<code>onclick</code>返回<code>false</code>，所以浏览器不会跳转到 example.com  </p><p><code>void</code>运算符可以取代上面的写法  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript: void(f())&quot;</span>&gt;</span>文字<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转  </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript: void(document.form.submit())&quot;</span>&gt;</span><br>  提交<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>逗号运算符用于对两个表达式求值，并返回后一个表达式的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-comment">// &quot;b&quot;</span><br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> y = (x++, <span class="hljs-number">10</span>);<br>x <span class="hljs-comment">// 1</span><br>y <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><p>上面代码中，逗号运算符返回后一个表达式的值。</p><p>逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> value = (<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi!&#x27;</span>), <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// Hi!</span><br><br>value <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>上面代码中，先执行逗号之前的操作，然后返回逗号后面的值  </p><h2 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><code>Javascript</code> 各种运算符的优先级别（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">4</span> + <span class="hljs-number">5</span> * <span class="hljs-number">6</span> <span class="hljs-comment">// 34</span><br></code></pre></td></tr></table></figure><p>上面的代码中，乘法运算符<code>*</code>的优先性高于加法运算符<code>+</code>，所以先执行乘法，再执行加法，相当于下面这样  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">4</span> + (<span class="hljs-number">5</span> * <span class="hljs-number">6</span>) <span class="hljs-comment">// 34</span><br></code></pre></td></tr></table></figure><p>如果多个运算符混写在一起，常常会导致令人困惑的代码  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> arr = [];<br><br><span class="hljs-keyword">var</span> y = arr.length &lt;= <span class="hljs-number">0</span> || arr[<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span> ? x : arr[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>y</code>的值就很难看出来，因为这个表达式涉及5个运算符，到底谁的优先级最高，实在不容易记住  </p><p>根据语言规格，这五个运算符的优先级从高到低依次为：  </p><p>小于等于（<code>&lt;=</code>)、严格相等（<code>===</code>）、或（<code>||</code>）、三元（<code>?:</code>）、等号（<code>=</code>）  </p><p>因此上面的表达式，实际的运算顺序如下  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> y = ((arr.length &lt;= <span class="hljs-number">0</span>) || (arr[<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span>)) ? x : arr[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure><p>记住所有运算符的优先级，是非常难的，也是没有必要的  </p><h3 id="圆括号的作用"><a href="#圆括号的作用" class="headerlink" title="圆括号的作用"></a>圆括号的作用</h3><p>圆括号（<code>()</code>）可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-number">4</span> + <span class="hljs-number">5</span>) * <span class="hljs-number">6</span> <span class="hljs-comment">// 54</span><br></code></pre></td></tr></table></figure><p>上面代码中，由于使用了圆括号，加法会先于乘法执行  </p><p>运算符的优先级别十分繁杂，且都是硬性规定，因此建议总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要  </p><p>顺便说一下，圆括号不是运算符，而是一种语法结构。它一共有两种用法：</p><ul><li>把表达式放在圆括号之中，提升运算的优先级  </li><li>跟在函数的后面，作用是调用函数  </li></ul><p>注意，因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>(x) = <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>上面代码的第二行，如果圆括号具有求值作用，那么就会变成<code>1 = 2</code>，这是会报错了  </p><p>但是，上面的代码可以运行，这验证了圆括号只改变优先级，不会求值  </p><p>这也意味着，如果整个表达式都放在圆括号之中，那么不会有任何效果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(expression)<br><span class="hljs-comment">// 等同于</span><br>expression<br></code></pre></td></tr></table></figure><p>函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br>(f) <span class="hljs-comment">// function f()&#123;return 1;&#125;</span><br>f() <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，函数放在圆括号之中会返回函数本身，圆括号跟在函数后面则是调用函数  </p><p>圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>)<br><span class="hljs-comment">// SyntaxError: Unexpected token var</span><br></code></pre></td></tr></table></figure><h3 id="左结合与右结合"><a href="#左结合与右结合" class="headerlink" title="左结合与右结合"></a>左结合与右结合</h3><p>对于优先级别相同的运算符，同时出现的时候，就会有计算顺序的问题  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a OP b OP c<br></code></pre></td></tr></table></figure><p>上面代码中，<code>OP</code>表示运算符。它可以有两种解释方式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 方式一</span><br>(a OP b) OP c<br><br><span class="hljs-comment">// 方式二</span><br>a OP (b OP c)<br></code></pre></td></tr></table></figure><p>上面的两种方式，得到的计算结果往往是不一样的  </p><p>方式一是将左侧两个运算数结合在一起，采用这种解释方式的运算符，称为“左结合”（left-to-right associativity）运算符  </p><p>方式二是将右侧两个运算数结合在一起，这样的运算符称为“右结合”运算符（right-to-left associativity）  </p><p>JavaScript 语言的大多数运算符是“左结合”，请看下面加法运算符的例子   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">x + y + z<br><br><span class="hljs-comment">// 引擎解释如下</span><br>(x + y) + z<br></code></pre></td></tr></table></figure><p>上面代码中，<code>x</code>与<code>y</code>结合在一起，它们的预算结果再与<code>z</code>进行运算  </p><p>少数运算符是“右结合”，其中最主要的是赋值运算符（<code>=</code>）和三元条件运算符（<code>?:</code>）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">w = x = y = z;<br>q = a ? b : c ? d : e ? f : g;<br></code></pre></td></tr></table></figure><p>上面代码的解释方式如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">w = (x = (y = z));<br>q = a ? b : (c ? d : (e ? f : g));<br></code></pre></td></tr></table></figure><p>上面的两行代码，都是右侧的运算数结合在一起。</p><p>另外，指数运算符（<code>**</code>）也是右结合。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">2</span> ** <span class="hljs-number">3</span> ** <span class="hljs-number">2</span><br><span class="hljs-comment">// 相当于 2 ** (3 ** 2)</span><br><span class="hljs-comment">// 512</span><br></code></pre></td></tr></table></figure><h1 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h1><p><code>Javascript</code> 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = y ? <span class="hljs-number">1</span> : <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></td></tr></table></figure><p>上面代码中，变量<code>x</code>到底是数值还是字符串，取决于另一个变量<code>y</code>的值  </p><p><code>y</code>为<code>true</code>时，<code>x</code>是一个数值；<code>y</code>为<code>false</code>时，<code>x</code>是一个字符串  </p><p>这意味着，<code>x</code>的类型没法在编译阶段就知道，必须等到运行时才能知道  </p><p>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的  </p><p>如果运算符发现，运算子的类型与预期不符，就会自动转换类型  </p><p>比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;4&#x27;</span> - <span class="hljs-string">&#x27;3&#x27;</span> <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码中，虽然是两个字符串相减，但是依然会得到结果数值<code>1</code>，原因就在于<code> Javascript</code> 将运算子自动转为了数值  </p><p>本章讲解数据类型自动转换的规则。在此之前，先讲解如何手动强制转换数据类型  </p><h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>强制转换主要指使用<code>Number()</code>、<code>String()</code>和<code>Boolean()</code>三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值  </p><h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><p>使用<code>Number</code>函数，可以将任意类型的值转化成数值  </p><p>下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象  </p><p><strong>（1）原始类型值</strong></p><p>原始类型值的转换规则如下  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 数值：转换后还是原来的值</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-number">324</span>) <span class="hljs-comment">// 324</span><br><br><span class="hljs-comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;324&#x27;</span>) <span class="hljs-comment">// 324</span><br><br><span class="hljs-comment">// 字符串：如果不可以被解析为数值，返回 NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;324abc&#x27;</span>) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// 空字符串转为0</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// 布尔值：true 转成 1，false 转成 0</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// undefined：转成 NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// null：转成0</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p><code>Number</code>函数将字符串转为数值，要比<code>parseInt</code>函数严格很多  </p><p>基本上，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;42 cats&#x27;</span>) <span class="hljs-comment">// 42</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;42 cats&#x27;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>parseInt</code>逐个解析字符，而<code>Number</code>函数整体转换字符串的类型  </p><p>另外，<code>parseInt</code>和<code>Number</code>函数都会自动过滤一个字符串前导和后缀的空格  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;\t\v\r12.34\n&#x27;</span>) <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;\t\v\r12.34\n&#x27;</span>) <span class="hljs-comment">// 12.34</span><br></code></pre></td></tr></table></figure><p><strong>（2）对象</strong></p><p>简单的规则是，<code>Number</code>方法的参数是对象时，将返回<code>NaN</code>，除非是包含单个数值的数组  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>([<span class="hljs-number">5</span>]) <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><p>之所以会这样，是因为<code>Number</code>背后的转换规则比较复杂  </p><ol><li><p>调用对象自身的<code>valueOf</code>方法。如果返回原始类型的值，则直接对该值使用<code>Number</code>函数，不再进行后续步骤  </p></li><li><p>如果<code>valueOf</code>方法返回的还是对象，则改为调用对象自身的<code>toString</code>方法。如果<code>toString</code>方法返回原始类型的值，则对该值使用<code>Number</code>函数，不再进行后续步骤  </p></li><li><p>如果<code>toString</code>方法返回的是对象，就报错  </p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">Number</span>(obj) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj.valueOf() === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>  <span class="hljs-built_in">Number</span>(obj.toString());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">Number</span>(obj.valueOf());<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>Number</code>函数将<code>obj</code>对象转为数值。背后发生了一连串的操作，首先调用<code>obj.valueOf</code>方法, 结果返回对象本身；于是，继续调用<code>obj.toString</code>方法，这时返回字符串<code>[object Object]</code>，对这个字符串使用<code>Number</code>函数，得到<code>NaN</code>  </p><p>默认情况下，对象的<code>valueOf</code>方法返回对象本身，所以一般总是会调用<code>toString</code>方法，而<code>toString</code>方法返回对象的类型字符串（比如<code>[object Object]</code>）。所以，会有下面的结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>(&#123;&#125;) <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>如果<code>toString</code>方法返回的不是原始类型的值，结果就会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;,<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">Number</span>(obj)<br><span class="hljs-comment">// TypeError: Cannot convert object to primitive value</span><br></code></pre></td></tr></table></figure><p>上面代码的<code>valueOf</code>和<code>toString</code>方法，返回的都是对象，所以转成数值时会报错  </p><p>从上例还可以看到，<code>valueOf</code>和<code>toString</code>方法，都是可以自定义的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>(&#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// 2</span><br><br><span class="hljs-built_in">Number</span>(&#123;<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// 3</span><br><br><span class="hljs-built_in">Number</span>(&#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;,<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>上面代码对三个对象使用<code>Number</code>函数。第一个对象返回<code>valueOf</code>方法的值，第二个对象返回<code>toString</code>方法的值，第三个对象表示<code>valueOf</code>方法先于<code>toString</code>方法执行  </p><h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><p><code>String</code>函数可以将任意类型的值转化成字符串，转换规则如下  </p><p><strong>（1）原始类型值</strong></p><ul><li><strong>数值</strong>：转为相应的字符串  </li><li><strong>字符串</strong>：转换后还是原来的值  </li><li><strong>布尔值</strong>：<code>true</code>转为字符串<code>&quot;true&quot;</code>，<code>false</code>转为字符串<code>&quot;false&quot;</code>  </li><li><strong>undefined</strong>：转为字符串<code>&quot;undefined&quot;</code>  </li><li><strong>null</strong>：转为字符串<code>&quot;null&quot;</code>   </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// &quot;123&quot;</span><br><span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) <span class="hljs-comment">// &quot;abc&quot;</span><br><span class="hljs-built_in">String</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// &quot;true&quot;</span><br><span class="hljs-built_in">String</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-built_in">String</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// &quot;null&quot;</span><br></code></pre></td></tr></table></figure><p><strong>（2）对象</strong></p><p><code>String</code>方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-built_in">String</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// &quot;1,2,3&quot;</span><br></code></pre></td></tr></table></figure><p><code>String</code>方法背后的转换规则，与<code>Number</code>方法基本相同，只是互换了<code>valueOf</code>方法和<code>toString</code>方法的执行顺序  </p><ol><li><p>先调用对象自身的<code>toString</code>方法。如果返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</p></li><li><p>如果<code>toString</code>方法返回的是对象，再调用原对象的<code>valueOf</code>方法。如果<code>valueOf</code>方法返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤  </p></li><li><p>如果<code>valueOf</code>方法返回的是对象，就报错  </p></li></ol><p>下面是一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;)<br><span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">String</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;.toString())<br><span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码先调用对象的<code>toString</code>方法，发现返回的是字符串<code>[object Object]</code>，就不再调用<code>valueOf</code>方法了  </p><p>如果<code>toString</code>法和<code>valueOf</code>方法，返回的都是对象，就会报错  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;,<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">String</span>(obj)<br><span class="hljs-comment">// TypeError: Cannot convert object to primitive value</span><br></code></pre></td></tr></table></figure><p>下面是通过自定义<code>toString</code>方法，改变返回值的例子  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>(&#123;<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// &quot;3&quot;</span><br><br><span class="hljs-built_in">String</span>(&#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br><span class="hljs-built_in">String</span>(&#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;,<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// &quot;3&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码对三个对象使用<code>String</code>函数。第一个对象返回<code>toString</code>方法的值（数值3），第二个对象返回的还是<code>toString</code>方法的值（<code>[object Object]</code>），第三个对象表示<code>toString</code>方法先于<code>valueOf</code>方法执行  </p><h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h3><p><code>Boolean()</code>函数可以将任意类型的值转为布尔值  </p><p>它的转换规则相对简单：除了以下五个值的转换结果为<code>false</code>，其他的值全部为<code>true</code>。</p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>0</code>（包含<code>-0</code>和<code>+0</code>）</li><li><code>NaN</code></li><li><code>&#39;&#39;</code>（空字符串）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>当然，<code>true</code>和<code>false</code>这两个布尔值不会发生变化  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>注意，所有对象（包括空对象）的转换结果都是<code>true</code>，甚至连<code>false</code>对应的布尔对象<code>new Boolean(false)</code>也是<code>true</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Boolean</span>(&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>([]) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>所有对象的布尔值都是<code>true</code>，这是因为 <code>Javascript</code> 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于<code>obj1 &amp;&amp; obj2</code>这样的场景，可能会需要较多的计算  </p><p>为了保证性能，就统一规定，对象的布尔值为<code>true</code>  </p><h2 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h2><p>下面介绍自动转换，它是以强制转换为基础的  </p><p>遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见  </p><ol><li>不同类型的数据互相运算  </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">123</span> + <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-comment">// &quot;123abc&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>对非布尔值类型的数据求布尔值  </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;abc&#x27;</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>&#125;  <span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>对非数值类型的值使用一元运算符（即<code>+</code>和<code>-</code>）  </li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">+ &#123;<span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125; <span class="hljs-comment">// NaN</span><br>- [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数  </p><p>比如，某个位置预期为字符串，就调用<code>String()</code>函数进行转换。如果该位置既可以是字符串，也可能是数值，那么默认转为数值  </p><p>由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用<code>Boolean()</code>、<code>Number()</code>和<code>String()</code>函数进行显式转换。</p><h3 id="自动转换为布尔值"><a href="#自动转换为布尔值" class="headerlink" title="自动转换为布尔值"></a>自动转换为布尔值</h3><p><code>Javascript</code> 遇到预期为布尔值的地方（比如<code>if</code>语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用<code>Boolean()</code>函数  </p><p>因此除了以下五个值，其他都是自动转为<code>true</code>  </p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>+0</code>或<code>-0</code></li><li><code>NaN</code></li><li><code>&#39;&#39;</code>（空字符串）</li></ul><p>下面这个例子中，条件部分的每个值都相当于<code>false</code>，使用否定运算符后，就变成了<code>true</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> ( !<span class="hljs-literal">undefined</span><br>  &amp;&amp; !<span class="hljs-literal">null</span><br>  &amp;&amp; !<span class="hljs-number">0</span><br>  &amp;&amp; !<span class="hljs-literal">NaN</span><br>  &amp;&amp; !<span class="hljs-string">&#x27;&#x27;</span><br>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>下面两种写法，有时也用于将一个表达式转为布尔值。它们内部调用的也是<code>Boolean()</code>函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法一</span><br>expression ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// 写法二</span><br>!! expression<br></code></pre></td></tr></table></figure><h3 id="自动转换为字符串"><a href="#自动转换为字符串" class="headerlink" title="自动转换为字符串"></a>自动转换为字符串</h3><p><code>Javascript</code> 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串  </p><p>具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串  </p><p>字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// &#x27;51&#x27;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">true</span> <span class="hljs-comment">// &quot;5true&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">false</span> <span class="hljs-comment">// &quot;5false&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + &#123;&#125; <span class="hljs-comment">// &quot;5[object Object]&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + [] <span class="hljs-comment">// &quot;5&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;&#125; <span class="hljs-comment">// &quot;5function ()&#123;&#125;&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">undefined</span> <span class="hljs-comment">// &quot;5undefined&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">null</span> <span class="hljs-comment">// &quot;5null&quot;</span><br></code></pre></td></tr></table></figure><p>这种自动转换很容易出错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  width: <span class="hljs-string">&#x27;100&#x27;</span><br>&#125;;<br><br>obj.width + <span class="hljs-number">20</span> <span class="hljs-comment">// &quot;10020&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，开发者可能期望返回<code>120</code>，但是由于自动转换，实际上返回了一个字符<code>10020</code>  </p><h3 id="自动转换为数值"><a href="#自动转换为数值" class="headerlink" title="自动转换为数值"></a>自动转换为数值</h3><p><code>Javascript</code> 遇到预期为数值的地方，就会将参数值自动转换为数值  </p><p>系统内部会自动调用<code>Number()</code>函数。  </p><p>除了加法运算符（<code>+</code>）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;5&#x27;</span> - <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 3</span><br><span class="hljs-string">&#x27;5&#x27;</span> * <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 10</span><br><span class="hljs-literal">true</span> - <span class="hljs-number">1</span>  <span class="hljs-comment">// 0</span><br><span class="hljs-literal">false</span> - <span class="hljs-number">1</span> <span class="hljs-comment">// -1</span><br><span class="hljs-string">&#x27;1&#x27;</span> - <span class="hljs-number">1</span>   <span class="hljs-comment">// 0</span><br><span class="hljs-string">&#x27;5&#x27;</span> * []    <span class="hljs-comment">// 0</span><br><span class="hljs-literal">false</span> / <span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-comment">// 0</span><br><span class="hljs-string">&#x27;abc&#x27;</span> - <span class="hljs-number">1</span>   <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">null</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// 1</span><br><span class="hljs-literal">undefined</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure><p>上面代码中，运算符两侧的运算子，都被转成了数值  </p><blockquote><p>注意：<code>null</code>转为数值时为<code>0</code>，而<code>undefined</code>转为数值时为<code>NaN</code>  </p></blockquote><p>一元运算符也会把运算子转成数值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">+<span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-comment">// NaN</span><br>-<span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-comment">// NaN</span><br>+<span class="hljs-literal">true</span> <span class="hljs-comment">// 1</span><br>-<span class="hljs-literal">false</span> <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><h1 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h1><h2 id="Error-实例对象"><a href="#Error-实例对象" class="headerlink" title="Error 实例对象"></a>Error 实例对象</h2><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象  </p><p><code>Javascript</code> 原生提供<code>Error</code>构造函数，所有抛出的错误都是这个构造函数的实例  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>err.message <span class="hljs-comment">// &quot;出错了&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码中，我们调用<code>Error</code>构造函数，生成一个实例对象<code>err</code>    </p><p><code>Error</code>构造函数接受一个参数，表示错误提示，可以从实例的<code>message</code>属性读到这个参数  </p><p>抛出<code>Error</code>实例对象以后，整个程序就中断在发生错误的地方，不再往下执行  </p><p><code>Javascript</code> 语言标准只提到，<code>Error</code>实例对象必须有<code>message</code>属性，表示出错时的提示信息，没有提到其他属性  </p><p>大多数 <code>Javascript</code> 引擎，对<code>Error</code>实例还提供<code>name</code>和<code>stack</code>属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有  </p><ul><li><strong>message</strong>：错误提示信息</li><li><strong>name</strong>：错误名称（非标准属性）</li><li><strong>stack</strong>：错误的堆栈（非标准属性）</li></ul><p>使用<code>name</code>和<code>message</code>这两个属性，可以对发生什么错误有一个大概的了解  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (error.name) &#123;<br>  <span class="hljs-built_in">console</span>.log(error.name + <span class="hljs-string">&#x27;: &#x27;</span> + error.message);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>stack</code>属性用来查看错误发生时的堆栈。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwit</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">catchit</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    throwit();<br>  &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>    <span class="hljs-built_in">console</span>.log(e.stack); <span class="hljs-comment">// print stack trace</span><br>  &#125;<br>&#125;<br><br>catchit()<br><span class="hljs-comment">// Error</span><br><span class="hljs-comment">//    at throwit (~/examples/throwcatch.js:9:11)</span><br><span class="hljs-comment">//    at catchit (~/examples/throwcatch.js:3:9)</span><br><span class="hljs-comment">//    at repl:1:5</span><br></code></pre></td></tr></table></figure><p>上面代码中，错误堆栈的最内层是<code>throwit</code>函数，然后是<code>catchit</code>函数，最后是函数的运行环境  </p><h2 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h2><p><code>Error</code>实例对象是最一般的错误类型，在它的基础上，<code>Javascript</code> 还定义了其他6种错误对象  </p><p>也就是说，存在<code>Error</code>的6个派生对象  </p><h3 id="SyntaxError-对象"><a href="#SyntaxError-对象" class="headerlink" title="SyntaxError 对象"></a>SyntaxError 对象</h3><p><code>SyntaxError</code>对象是解析代码时发生的语法错误  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 变量名错误</span><br><span class="hljs-keyword">var</span> 1a;<br><span class="hljs-comment">// Uncaught SyntaxError: Invalid or unexpected token</span><br><br><span class="hljs-comment">// 缺少括号</span><br><span class="hljs-built_in">console</span>.log <span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-comment">// Uncaught SyntaxError: Unexpected string</span><br></code></pre></td></tr></table></figure><p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”  </p><h3 id="ReferenceError-对象"><a href="#ReferenceError-对象" class="headerlink" title="ReferenceError 对象"></a>ReferenceError 对象</h3><p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误    </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用一个不存在的变量</span><br>unknownVariable<br><span class="hljs-comment">// Uncaught ReferenceError: unknownVariable is not defined</span><br></code></pre></td></tr></table></figure><p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 等号左侧不是变量</span><br><span class="hljs-built_in">console</span>.log() = <span class="hljs-number">1</span><br><span class="hljs-comment">// Uncaught ReferenceError: Invalid left-hand side in assignment</span><br></code></pre></td></tr></table></figure><p>上面代码对函数<code>console.log</code>的运行结果赋值，结果引发了<code>ReferenceError</code>错误  </p><h3 id="RangeError-对象"><a href="#RangeError-对象" class="headerlink" title="RangeError 对象"></a>RangeError 对象</h3><p><code>RangeError</code>对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是<code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 数组长度不得为负数</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(-<span class="hljs-number">1</span>)<br><span class="hljs-comment">// Uncaught RangeError: Invalid array length</span><br></code></pre></td></tr></table></figure><h3 id="TypeError-对象"><a href="#TypeError-对象" class="headerlink" title="TypeError 对象"></a>TypeError 对象</h3><p><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误  </p><p>比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-number">123</span><br><span class="hljs-comment">// Uncaught TypeError: number is not a func</span><br><br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.unknownMethod()<br><span class="hljs-comment">// Uncaught TypeError: obj.unknownMethod is not a function</span><br></code></pre></td></tr></table></figure><p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数  </p><h3 id="URIError-对象"><a href="#URIError-对象" class="headerlink" title="URIError 对象"></a>URIError 对象</h3><p><code>URIError</code>对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">decodeURI</span>(<span class="hljs-string">&#x27;%2&#x27;</span>)<br><span class="hljs-comment">// URIError: URI malformed</span><br></code></pre></td></tr></table></figure><h3 id="EvalError-对象"><a href="#EvalError-对象" class="headerlink" title="EvalError 对象"></a>EvalError 对象</h3><p><code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> err1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了！&#x27;</span>);<br><span class="hljs-keyword">var</span> err2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RangeError</span>(<span class="hljs-string">&#x27;出错了，变量超出有效范围！&#x27;</span>);<br><span class="hljs-keyword">var</span> err3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;出错了，变量类型无效！&#x27;</span>);<br><br>err1.message <span class="hljs-comment">// &quot;出错了！&quot;</span><br>err2.message <span class="hljs-comment">// &quot;出错了，变量超出有效范围！&quot;</span><br>err3.message <span class="hljs-comment">// &quot;出错了，变量类型无效！&quot;</span><br></code></pre></td></tr></table></figure><h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserError</span>(<span class="hljs-params">message</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.message = message || <span class="hljs-string">&#x27;默认信息&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;UserError&#x27;</span>;<br>&#125;<br><br>UserError.prototype = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();<br>UserError.prototype.constructor = UserError;<br></code></pre></td></tr></table></figure><p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> UserError(<span class="hljs-string">&#x27;这是自定义的错误！&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="throw-语句"><a href="#throw-语句" class="headerlink" title="throw 语句"></a>throw 语句</h2><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;x 必须为正数&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// Uncaught ReferenceError: x is not defined</span><br></code></pre></td></tr></table></figure><p>上面代码中，如果变量<code>x</code>小于等于<code>0</code>，就手动抛出一个错误，告诉用户<code>x</code>的值不正确，整个程序就会在这里中断执行。可以看到，<code>throw</code>抛出的错误就是它的参数，这里是一个<code>Error</code>实例  </p><p><code>throw</code>也可以抛出自定义错误  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserError</span>(<span class="hljs-params">message</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.message = message || <span class="hljs-string">&#x27;默认信息&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;UserError&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UserError(<span class="hljs-string">&#x27;出错了！&#x27;</span>);<br><span class="hljs-comment">// Uncaught UserError &#123;message: &quot;出错了！&quot;, name: &quot;UserError&quot;&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例  </p><p>实际上，<code>throw</code>可以抛出任何类型的值。也就是说，它的参数可以是任何值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 抛出一个字符串</span><br><span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Error！&#x27;</span>;<br><span class="hljs-comment">// Uncaught Error！</span><br><br><span class="hljs-comment">// 抛出一个数值</span><br><span class="hljs-keyword">throw</span> <span class="hljs-number">42</span>;<br><span class="hljs-comment">// Uncaught 42</span><br><br><span class="hljs-comment">// 抛出一个布尔值</span><br><span class="hljs-keyword">throw</span> <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// Uncaught true</span><br><br><span class="hljs-comment">// 抛出一个对象</span><br><span class="hljs-keyword">throw</span> &#123;<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Error!&#x27;</span>;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// Uncaught &#123;toString: ƒ&#125;</span><br></code></pre></td></tr></table></figure><p>对于 <code>Javascript</code> 引擎来说，遇到<code>throw</code>语句，程序就中止了。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值  </p><h2 id="try…catch-结构"><a href="#try…catch-结构" class="headerlink" title="try…catch 结构"></a>try…catch 结构</h2><p>一旦发生错误，程序就中止执行了  </p><p><code>Javascript</code> 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行   </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了!&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-built_in">console</span>.log(e.name + <span class="hljs-string">&quot;: &quot;</span> + e.message);<br>  <span class="hljs-built_in">console</span>.log(e.stack);<br>&#125;<br><span class="hljs-comment">// Error: 出错了!</span><br><span class="hljs-comment">//   at &lt;anonymous&gt;:3:9</span><br><span class="hljs-comment">//   ...</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），<code>Javascript</code> 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。<code>catch</code>接受一个参数，表示<code>try</code>代码块抛出的值  </p><p>如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  f();<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>  <span class="hljs-comment">// 处理错误</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，如果函数<code>f</code>执行报错，就会进行<code>catch</code>代码块，接着对错误进行处理  </p><p><code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;出错了&quot;</span>;<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>);<br><span class="hljs-comment">// 111</span><br><span class="hljs-comment">// 222</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行  </p><p><code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">throw</span> n;<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-keyword">if</span> (e &lt;= <span class="hljs-number">50</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">throw</span> e;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// Uncaught 100</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>catch</code>代码之中又抛出了一个错误  </p><p>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  foo.bar();<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">EvalError</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(e.name + <span class="hljs-string">&quot;: &quot;</span> + e.message);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RangeError</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(e.name + <span class="hljs-string">&quot;: &quot;</span> + e.message);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码中，<code>catch</code>捕获错误之后，会判断错误类型（<code>EvalError</code>还是<code>RangeError</code>），进行不同的处理  </p><h2 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h2><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleansUp</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了……&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;此行不会执行&#x27;</span>);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成清理工作&#x27;</span>);<br>  &#125;<br>&#125;<br><br>cleansUp()<br><span class="hljs-comment">// 完成清理工作</span><br><span class="hljs-comment">// Uncaught Error: 出错了……</span><br><span class="hljs-comment">//    at cleansUp (&lt;anonymous&gt;:3:11)</span><br><span class="hljs-comment">//    at &lt;anonymous&gt;:10:1</span><br></code></pre></td></tr></table></figure><p>上面代码中，由于没有<code>catch</code>语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行<code>finally</code>代码块，然后再向用户提示报错信息  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">idle</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result&#x27;</span>;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;FINALLY&#x27;</span>);<br>  &#125;<br>&#125;<br><br>idle(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-comment">// hello</span><br><span class="hljs-comment">// FINALLY</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>try</code>代码块没有发生错误，而且里面还包括<code>return</code>语句，但是<code>finally</code>代码块依然会执行。而且，这个函数的返回值还是<code>result</code>  </p><p>下面的例子说明，<code>return</code>语句的执行是排在<code>finally</code>代码之前，只是等<code>finally</code>代码执行完毕后才返回  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countUp</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> count;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    count++;<br>  &#125;<br>&#125;<br><br>countUp()<br><span class="hljs-comment">// 0</span><br>count<br><span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>上面代码说明，<code>return</code>语句里面的<code>count</code>的值，是在<code>finally</code>代码块运行之前就获取了  </p><p>下面是<code>finally</code>代码块用法的典型场景  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">openFile();<br><br><span class="hljs-keyword">try</span> &#123;<br>  writeFile(Data);<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>  handleError(e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  closeFile();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码首先打开一个文件，然后在<code>try</code>代码块中写入文件，如果没有发生错误，则运行<code>finally</code>代码块关闭文件；一旦发生错误，则先使用<code>catch</code>代码块处理错误，再使用<code>finally</code>代码块关闭文件  </p><p>下面的例子充分反映了<code>try...catch...finally</code>这三者之间的执行顺序  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;bug&#x27;</span>;<br>  &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 这句原本会延迟到 finally 代码块结束再执行</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>); <span class="hljs-comment">// 不会运行</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 这句会覆盖掉前面那句 return</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>); <span class="hljs-comment">// 不会运行</span><br>  &#125;<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>); <span class="hljs-comment">// 不会运行</span><br>&#125;<br><br><span class="hljs-keyword">var</span> result = f();<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 3</span><br><br>result<br><span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>catch</code>代码块结束执行之前，会先执行<code>finally</code>代码块  </p><p><code>catch</code>代码块之中，触发转入<code>finally</code>代码块的标志，不仅有<code>return</code>语句，还有<code>throw</code>语句  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;出错了！&#x27;</span>;<br>  &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;捕捉到内部错误&#x27;</span>);<br>    <span class="hljs-keyword">throw</span> e; <span class="hljs-comment">// 这句原本会等到finally结束再执行</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 直接返回</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>  f();<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>  <span class="hljs-comment">// 此处不会执行</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;caught outer &quot;bogus&quot;&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//  捕捉到内部错误</span><br></code></pre></td></tr></table></figure><p>上面代码中，进入<code>catch</code>代码块之后，一遇到<code>throw</code>语句，就会去执行<code>finally</code>代码块，其中有<code>return false</code>语句，因此就直接返回了，不再会回去执行<code>catch</code>代码块剩下的部分了  </p><p><code>try</code>代码块内部，还可以再使用<code>try</code>代码块  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    consle.log(<span class="hljs-string">&#x27;Hello world!&#x27;</span>); <span class="hljs-comment">// 报错</span><br>  &#125;<br>  <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Finally&#x27;</span>);<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Will I run?&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>  <span class="hljs-built_in">console</span>.error(error.message);<br>&#125;<br><span class="hljs-comment">// Finally</span><br><span class="hljs-comment">// consle is not defined</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>try</code>里面还有一个<code>try</code>。内层的<code>try</code>报错（<code>console</code>拼错了），这时会执行内层的<code>finally</code>代码块，然后抛出错误，被外层的<code>catch</code>捕获  </p><h1 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>“编程风格”（programming style）指的是编写代码的样式规则。不同的程序员，往往有不同的编程风格  </p><p>有人说，编译器的规范叫做“语法规则”（grammar），这是程序员必须遵守的；而编译器忽略的部分，就叫“编程风格”（programming style），这是程序员可以自由选择的。这种说法不完全正确，程序员固然可以自由选择编程风格，但是好的编程风格有助于写出质量更高、错误更少、更易于维护的程序  </p><p>所以，编程风格的选择不应该基于个人爱好、熟悉程度、打字量等因素，而要考虑如何尽量使代码清晰易读、减少出错。你选择的，不是你喜欢的风格，而是一种能够清晰表达你的意图的风格。这一点，对于 <code>Javascript</code> 这种语法自由度很高的语言尤其重要  </p><p>必须牢记的一点是，如果你选定了一种“编程风格”，就应该坚持遵守，切忌多种风格混用。如果你加入他人的项目，就应该遵守现有的风格  </p><h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>行首的空格和 Tab 键，都可以产生代码缩进效果（indent）  </p><p>Tab 键可以节省击键次数，但不同的文本编辑器对 Tab 的显示不尽相同，有的显示四个空格，有的显示两个空格，所以有人觉得，空格键可以使得显示效果更统一    </p><p>无论你选择哪一种方法，都是可以接受的，要做的就是始终坚持这一种选择。不要一会使用 Tab 键，一会使用空格键  </p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>如果循环和判断的代码体只有一行，<code>Javascript</code> 允许该区块（block）省略大括号  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (a)<br>  b();<br>  c();<br></code></pre></td></tr></table></figure><p>上面代码的原意可能是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (a) &#123;<br>  b();<br>  c();<br>&#125;<br></code></pre></td></tr></table></figure><p>但是，实际效果却是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (a) &#123;<br>  b();<br>&#125;<br>  c();<br></code></pre></td></tr></table></figure><p>因此，建议总是使用大括号表示区块  </p><p>另外，区块起首的大括号的位置，有许多不同的写法。最流行的有两种，一种是起首的大括号另起一行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">block<br>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>另一种是起首的大括号跟在关键字的后面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">block &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一般来说，这两种写法都可以接受。但是，<code>Javascript</code> 要使用后一种，因为 <code>Javascript</code> 会自动添加句末的分号，导致一些难以察觉的错误  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span><br>&#123;<br>  key: value<br>&#125;;<br><br><span class="hljs-comment">// 相当于</span><br><span class="hljs-keyword">return</span>;<br>&#123;<br>  key: value<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的代码的原意，是要返回一个对象，但实际上返回的是<code>undefined</code>，因为 JavaScript 自动在<code>return</code>语句后面添加了分号。为了避免这一类错误，需要写成下面这样  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> &#123;<br>  key : value<br>&#125;;<br></code></pre></td></tr></table></figure><p>因此，表示区块起首的大括号，不要另起一行  </p><h2 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h2><p>圆括号（parentheses）在<code> Javascript</code> 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 圆括号表示函数的调用</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;abc&#x27;</span>);<br><br><span class="hljs-comment">// 圆括号表示表达式的组合</span><br>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) * <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>建议可以用空格，区分这两种不同的括号  </p><blockquote><ol><li><p>表示函数调用时，函数名与左括号之间没有空格。</p></li><li><p>表示函数定义时，函数名与左括号之间没有空格。</p></li><li><p>其他情况时，前面位置的语法元素与左括号之间，都有一个空格。</p></li></ol></blockquote><p>按照上面的规则，下面的写法都是不规范的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">foo (bar)<br><span class="hljs-keyword">return</span>(a+b);<br><span class="hljs-keyword">if</span>(a === <span class="hljs-number">0</span>) &#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">b</span>) </span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>上面代码的最后一行是一个匿名函数，<code>function</code>是语法关键字，不是函数名，所以与左括号之间应该要有一个空格  </p><h2 id="行尾的分号"><a href="#行尾的分号" class="headerlink" title="行尾的分号"></a>行尾的分号</h2><p>分号表示一条语句的结束。<code>Javascript</code> 允许省略行尾的分号  </p><p>事实上，确实有一些开发者行尾从来不写分号。但是，由于下面要讨论的原因，建议还是不要省略这个分号  </p><h3 id="不使用分号的情况"><a href="#不使用分号的情况" class="headerlink" title="不使用分号的情况"></a>不使用分号的情况</h3><p>首先，以下三种情况，语法规定本来就不需要在结尾添加分号  </p><p><strong>（1）for 和 while 循环</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> ( ; ; ) &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br></code></pre></td></tr></table></figure><p>注意，<code>do...while</code>循环是有分号的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">do</span> &#123;<br>  a--;<br>&#125; <span class="hljs-keyword">while</span>(a &gt; <span class="hljs-number">0</span>); <span class="hljs-comment">// 分号不能省略</span><br></code></pre></td></tr></table></figure><p><strong>（2）分支语句：if，switch，try</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br><br><span class="hljs-keyword">switch</span> () &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br><br><span class="hljs-keyword">try</span> &#123;<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br></code></pre></td></tr></table></figure><p><strong>（3）函数的声明语句</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br></code></pre></td></tr></table></figure><p>注意，函数表达式仍然要使用分号  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125;;<br></code></pre></td></tr></table></figure><p>以上三种情况，如果使用了分号，并不会出错。因为，解释引擎会把这个分号解释为空语句  </p><h3 id="分号的自动添加"><a href="#分号的自动添加" class="headerlink" title="分号的自动添加"></a>分号的自动添加</h3><p>除了上一节的三种情况，所有语句都应该使用分号  </p><p>但是，如果没有使用分号，大多数情况下，Javascript 会自动添加  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>这种语法特性被称为“分号的自动添加”（Automatic Semicolon Insertion，简称 ASI）  </p><p>因此，有人提倡省略句尾的分号。麻烦的是，如果下一行的开始可以与本行的结尾连在一起解释，<code>Javascript</code> 就不会自动添加分号  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 等同于 var a = 3</span><br><span class="hljs-keyword">var</span><br>a<br>=<br><span class="hljs-number">3</span><br><br><span class="hljs-comment">// 等同于 &#x27;abc&#x27;.length</span><br><span class="hljs-string">&#x27;abc&#x27;</span><br>.length<br><br><span class="hljs-comment">// 等同于 return a + b;</span><br><span class="hljs-keyword">return</span> a +<br>b;<br><br><span class="hljs-comment">// 等同于 obj.foo(arg1, arg2);</span><br>obj.foo(arg1,<br>arg2);<br><br><span class="hljs-comment">// 等同于 3 * 2 + 10 * (27 / 6)</span><br><span class="hljs-number">3</span> * <span class="hljs-number">2</span><br>+<br><span class="hljs-number">10</span> * (<span class="hljs-number">27</span> / <span class="hljs-number">6</span>)<br></code></pre></td></tr></table></figure><p>上面代码都会多行放在一起解释，不会每一行自动添加分号。这些例子还是比较容易看出来的，但是下面这个例子就不那么容易看出来了  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">x = y<br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)();<br><br><span class="hljs-comment">// 等同于</span><br>x = y(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;...&#125;)();<br></code></pre></td></tr></table></figure><p>下面是更多不会自动添加分号的例子  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 引擎解释为 c(d+e)</span><br><span class="hljs-keyword">var</span> a = b + c<br>(d+e).toString();<br><br><span class="hljs-comment">// 引擎解释为 a = b/hi/g.exec(c).map(d)</span><br><span class="hljs-comment">// 正则表达式的斜杠，会当作除法运算符</span><br>a = b<br>/hi/g.exec(c).map(d);<br><br><span class="hljs-comment">// 解释为&#x27;b&#x27;[&#x27;red&#x27;, &#x27;green&#x27;]，</span><br><span class="hljs-comment">// 即把字符串当作一个数组，按索引取值</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;b&#x27;</span><br>[<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(c);<br>&#125;)<br><br><span class="hljs-comment">// 解释为 function (x) &#123; return x &#125;(a++)</span><br><span class="hljs-comment">// 即调用匿名函数，结果f等于0</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123; <span class="hljs-keyword">return</span> x &#125;<br>(a++)<br></code></pre></td></tr></table></figure><p>只有下一行的开始与本行的结尾，无法放在一起解释，<code>Javascript</code> 引擎才会自动添加分号  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>) a = <span class="hljs-number">0</span><br><span class="hljs-built_in">console</span>.log(a)<br><br><span class="hljs-comment">// 等同于下面的代码，</span><br><span class="hljs-comment">// 因为 0console 没有意义</span><br><span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>) a = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">console</span>.log(a)<br></code></pre></td></tr></table></figure><p>另外，如果一行的起首是“自增”（<code>++</code>）或“自减”（<code>--</code>）运算符，则它们的前面会自动添加分号  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = b = c = <span class="hljs-number">1</span><br><br>a<br>++<br>b<br>--<br>c<br><br><span class="hljs-built_in">console</span>.log(a, b, c)<br><span class="hljs-comment">// 1 2 0</span><br></code></pre></td></tr></table></figure><p>上面代码之所以会得到<code>1 2 0</code>的结果，原因是自增和自减运算符前，自动加上了分号。上面的代码实际上等同于下面的形式  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = b = c = <span class="hljs-number">1</span>;<br>a;<br>++b;<br>--c;<br></code></pre></td></tr></table></figure><p>如果<code>continue</code>、<code>break</code>、<code>return</code>和<code>throw</code>这四个语句后面，直接跟换行符，则会自动添加分号  </p><p>这意味着，如果<code>return</code>语句返回的是一个对象的字面量，起首的大括号一定要写在同一行，否则得不到预期结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span><br>&#123; <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;Jane&#x27;</span> &#125;;<br><br><span class="hljs-comment">// 解释成</span><br><span class="hljs-keyword">return</span>;<br>&#123; <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;Jane&#x27;</span> &#125;;<br></code></pre></td></tr></table></figure><p>由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号  </p><p>不应该省略结尾的分号，还有一个原因。有些 <code>Javascript</code> 代码压缩器（uglifier）不会自动添加分号，因此遇到没有分号的结尾，就会让代码保持原状，而不是压缩成一行，使得压缩无法得到最优的结果  </p><p>另外，不写结尾的分号，可能会导致脚本合并出错。所以，有的代码库在第一行语句开始前，会加上一个分号  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">;<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// ...</span><br></code></pre></td></tr></table></figure><p>上面这种写法就可以避免与其他脚本合并时，排在前面的脚本最后一行语句没有分号，导致运行出错的问题。</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利  </p><p>因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如<code>UPPER_CASE</code>  </p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p><code>Javascript</code> 会自动将变量声明“提升”（hoist）到代码块（block）的头部  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!x) &#123;<br>  <span class="hljs-keyword">var</span> x = &#123;&#125;;<br>&#125;<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">var</span> x;<br><span class="hljs-keyword">if</span> (!x) &#123;<br>  x = &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>这意味着，变量<code>x</code>是<code>if</code>代码块之前就存在了。为了避免可能出现的问题，最好把变量声明都放在代码块的头部  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 写成</span><br><span class="hljs-keyword">var</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这样的写法，就容易看出存在一个全局的循环变量<code>i</code>  </p><p>另外，所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部  </p><h2 id="with-语句-1"><a href="#with-语句-1" class="headerlink" title="with 语句"></a>with 语句</h2><p><code>with</code>可以减少代码的书写，但是会造成混淆  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">with</span> (o) &#123;<br>　foo = bar;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码，可以有四种运行结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">o.foo = bar;<br>o.foo = o.bar;<br>foo = bar;<br>foo = o.bar;<br></code></pre></td></tr></table></figure><p>这四种结果都可能发生，取决于不同的变量是否有定义。因此，不要使用<code>with</code>语句  </p><h2 id="相等和严格相等"><a href="#相等和严格相等" class="headerlink" title="相等和严格相等"></a>相等和严格相等</h2><p>JavaScript 有两个表示相等的运算符：“相等”（<code>==</code>）和“严格相等”（<code>===</code>）  </p><p>相等运算符会自动转换变量类型，造成很多意想不到的情况  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">0</span> == <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">// true</span><br><span class="hljs-number">1</span> == <span class="hljs-literal">true</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">2</span> == <span class="hljs-literal">true</span> <span class="hljs-comment">// false</span><br><span class="hljs-number">0</span> == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-literal">false</span> == <span class="hljs-string">&#x27;false&#x27;</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">false</span> == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27; \t\r\n &#x27;</span> == <span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>因此，建议不要使用相等运算符（<code>==</code>），只使用严格相等运算符（<code>===</code>）  </p><h2 id="语句的合并"><a href="#语句的合并" class="headerlink" title="语句的合并"></a>语句的合并</h2><p>有些程序员追求简洁，喜欢合并不同目的的语句。比如，原来的语句是  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a = b;<br><span class="hljs-keyword">if</span> (a) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>他喜欢写成下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (a = b) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>虽然语句少了一行，但是可读性大打折扣，而且会造成误读，让别人误解这行代码的意思是下面这样  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> （a === b）&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>建议不要将不同目的的语句，合并成一行  </p><h2 id="自增和自减运算符-1"><a href="#自增和自减运算符-1" class="headerlink" title="自增和自减运算符"></a>自增和自减运算符</h2><p>自增（<code>++</code>）和自减（<code>--</code>）运算符，放在变量的前面或后面，返回的值不一样，很容易发生错误。事实上，所有的<code>++</code>运算符都可以用<code>+= 1</code>代替  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">++x<br><span class="hljs-comment">// 等同于</span><br>x += <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>改用<code>+= 1</code>，代码变得更清晰了  </p><p>建议自增（<code>++</code>）和自减（<code>--</code>）运算符尽量使用<code>+=</code>和<code>-=</code>代替  </p><h2 id="switch…case-结构"><a href="#switch…case-结构" class="headerlink" title="switch…case 结构"></a>switch…case 结构</h2><p><code>switch...case</code>结构要求，在每一个<code>case</code>的最后一行必须是<code>break</code>语句，否则会接着运行下一个<code>case</code>。这样不仅容易忘记，还会造成代码的冗长  </p><p>而且，<code>switch...case</code>不使用大括号，不利于代码形式的统一  </p><p>此外，这种结构类似于<code>goto</code>语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAction</span>(<span class="hljs-params">action</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span> (action) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;hack&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hack&#x27;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;slash&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;slash&#x27;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;run&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;run&#x27;</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Invalid action.&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码建议改写成对象结构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAction</span>(<span class="hljs-params">action</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> actions = &#123;<br>    <span class="hljs-string">&#x27;hack&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hack&#x27;</span>;<br>    &#125;,<br>    <span class="hljs-string">&#x27;slash&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;slash&#x27;</span>;<br>    &#125;,<br>    <span class="hljs-string">&#x27;run&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;run&#x27;</span>;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> actions[action] !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Invalid action.&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> actions[action]();<br>&#125;<br></code></pre></td></tr></table></figure><p>因此，建议<code>switch...case</code>结构可以用对象结构代替  </p><h1 id="console-对象与控制台"><a href="#console-对象与控制台" class="headerlink" title="console 对象与控制台"></a>console 对象与控制台</h1><h2 id="console-对象"><a href="#console-对象" class="headerlink" title="console 对象"></a>console 对象</h2><p><code>console</code>对象是 <code>Javascript</code> 的原生对象，它有点像 Unix 系统的标准输出<code>stdout</code>和标准错误<code>stderr</code>，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法  </p><p><code>console</code>的常见用途有两个  </p><ul><li>调试程序，显示网页代码运行时的错误信息  </li><li>提供了一个命令行接口，用来与网页代码互动  </li></ul><h2 id="console-对象的静态方法"><a href="#console-对象的静态方法" class="headerlink" title="console 对象的静态方法"></a>console 对象的静态方法</h2><p><code>console</code>对象提供的各种静态方法，用来与控制台窗口互动  </p><h3 id="console-log-，console-info-，console-debug"><a href="#console-log-，console-info-，console-debug" class="headerlink" title="console.log()，console.info()，console.debug()"></a>console.log()，console.info()，console.debug()</h3><p><code>console.log</code>方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello World&#x27;</span>)<br><span class="hljs-comment">// Hello World</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-comment">// a b c</span><br></code></pre></td></tr></table></figure><p><code>console.log</code>方法会自动在每次输出的结尾，添加换行符。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>如果第一个参数是格式字符串（使用了格式占位符），<code>console.log</code>方法将依次用后面的参数替换占位符，然后再进行输出  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27; %s + %s = %s&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">//  1 + 1 = 2</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>console.log</code>方法的第一个参数有三个占位符（<code>%s</code>），第二、三、四个参数会在显示时，依次替换掉这个三个占位符  </p><p><code>console.log</code>方法支持以下占位符，不同类型的数据必须使用对应的占位符  </p><ul><li><code>%s</code> 字符串   </li><li><code>%d</code> 整数  </li><li><code>%i</code> 整数  </li><li><code>%f</code> 浮点数  </li><li><code>%o</code> 对象的链接  </li><li><code>%c</code> CSS 格式字符串  </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> number = <span class="hljs-number">11</span> * <span class="hljs-number">9</span>;<br><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;%d %s balloons&#x27;</span>, number, color);<br><span class="hljs-comment">// 99 red balloons</span><br></code></pre></td></tr></table></figure><p>上面代码中，第二个参数是数值，对应的占位符是<code>%d</code>，第三个参数是字符串，对应的占位符是<code>%s</code>  </p><p>使用<code>%c</code>占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<br>  <span class="hljs-string">&#x27;%cThis text is styled!&#x27;</span>,<br>  <span class="hljs-string">&#x27;color: red; background: yellow; font-size: 24px;&#x27;</span><br>)<br></code></pre></td></tr></table></figure><p>上面代码运行后，输出的内容将显示为黄底红字  </p><p><code>console.log</code>方法的两种参数格式，可以结合在一起使用  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27; %s + %s &#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;= 2&#x27;</span>)<br><span class="hljs-comment">// 1 + 1  = 2</span><br></code></pre></td></tr></table></figure><p>如果参数是一个对象，<code>console.log</code>会显示该对象的值  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(&#123;<span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125;)<br><span class="hljs-comment">// Object &#123;foo: &quot;bar&quot;&#125;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Date</span>)<br><span class="hljs-comment">// function Date() &#123; [native code] &#125;</span><br></code></pre></td></tr></table></figure><p>上面代码输出<code>Date</code>对象的值，结果为一个构造函数  </p><p><code>console.info</code>是<code>console.log</code>方法的别名，用法完全一样。只不过<code>console.info</code>方法会在输出信息的前面，加上一个蓝色图标  </p><p><code>console.debug</code>方法与<code>console.log</code>方法类似，会在控制台输出调试信息。但是，默认情况下，<code>console.debug</code>输出的信息不会显示，只有在打开显示级别在<code>verbose</code>的情况下，才会显示  </p><p><code>console</code>对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义<code>console.log</code>方法  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;log&#x27;</span>, <span class="hljs-string">&#x27;info&#x27;</span>, <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;error&#x27;</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">method</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>[method] = <span class="hljs-built_in">console</span>[method].bind(<br>    <span class="hljs-built_in">console</span>,<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString()<br>  );<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;出错了！&quot;</span>);<br><span class="hljs-comment">// 2014-05-18T09:00.000Z 出错了！</span><br></code></pre></td></tr></table></figure><p>上面代码表示，使用自定义的<code>console.log</code>方法，可以在显示结果添加当前时间  </p><h3 id="console-warn-，console-error"><a href="#console-warn-，console-error" class="headerlink" title="console.warn()，console.error()"></a>console.warn()，console.error()</h3><p><code>warn</code>方法和<code>error</code>方法也是在控制台输出信息，它们与<code>log</code>方法的不同之处在于，<code>warn</code>方法输出信息时，在最前面加一个黄色三角，表示警告；<code>error</code>方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;Error: %s (%i)&#x27;</span>, <span class="hljs-string">&#x27;Server is not responding&#x27;</span>, <span class="hljs-number">500</span>)<br><span class="hljs-comment">// Error: Server is not responding (500)</span><br><span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&#x27;Warning! Too few nodes (%d)&#x27;</span>, <span class="hljs-built_in">document</span>.childNodes.length)<br><span class="hljs-comment">// Warning! Too few nodes (1)</span><br></code></pre></td></tr></table></figure><p>可以这样理解，<code>log</code>方法是写入标准输出（<code>stdout</code>），<code>warn</code>方法和<code>error</code>方法是写入标准错误（<code>stderr</code>）  </p><h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h3><p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> languages = [<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-attr">fileExtension</span>: <span class="hljs-string">&quot;.js&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;TypeScript&quot;</span>, <span class="hljs-attr">fileExtension</span>: <span class="hljs-string">&quot;.ts&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;CoffeeScript&quot;</span>, <span class="hljs-attr">fileExtension</span>: <span class="hljs-string">&quot;.coffee&quot;</span> &#125;<br>];<br><br><span class="hljs-built_in">console</span>.table(languages);<br></code></pre></td></tr></table></figure><p>上面代码的<code>language</code>变量，转为表格显示如下  </p><table><thead><tr><th>(index)</th><th>name</th><th>fileExtension</th></tr></thead><tbody><tr><td>0</td><td>“JavaScript”</td><td>“.js”</td></tr><tr><td>1</td><td>“TypeScript”</td><td>“.ts”</td></tr><tr><td>2</td><td>“CoffeeScript”</td><td>“.coffee”</td></tr></tbody></table><p>下面是显示表格内容的例子  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> languages = &#123;<br>  csharp: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;C#&quot;</span>, <span class="hljs-attr">paradigm</span>: <span class="hljs-string">&quot;object-oriented&quot;</span> &#125;,<br>  fsharp: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;F#&quot;</span>, <span class="hljs-attr">paradigm</span>: <span class="hljs-string">&quot;functional&quot;</span> &#125;<br>&#125;;<br><br><span class="hljs-built_in">console</span>.table(languages);<br></code></pre></td></tr></table></figure><p>上面代码的<code>language</code>，转为表格显示如下  </p><table><thead><tr><th>(index)</th><th>name</th><th>paradigm</th></tr></thead><tbody><tr><td>csharp</td><td>“C#”</td><td>“object-oriented”</td></tr><tr><td>fsharp</td><td>“F#”</td><td>“functional”</td></tr></tbody></table><h3 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h3><p><code>count</code>方法用于计数，输出它被调用了多少次  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.count();<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hi &#x27;</span> + user;<br>&#125;<br><br>greet(<span class="hljs-string">&#x27;bob&#x27;</span>)<br><span class="hljs-comment">//  : 1</span><br><span class="hljs-comment">// &quot;hi bob&quot;</span><br><br>greet(<span class="hljs-string">&#x27;alice&#x27;</span>)<br><span class="hljs-comment">//  : 2</span><br><span class="hljs-comment">// &quot;hi alice&quot;</span><br><br>greet(<span class="hljs-string">&#x27;bob&#x27;</span>)<br><span class="hljs-comment">//  : 3</span><br><span class="hljs-comment">// &quot;hi bob&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码每次调用<code>greet</code>函数，内部的<code>console.count</code>方法就输出执行次数  </p><p>该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.count(user);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi &quot;</span> + user;<br>&#125;<br><br>greet(<span class="hljs-string">&#x27;bob&#x27;</span>)<br><span class="hljs-comment">// bob: 1</span><br><span class="hljs-comment">// &quot;hi bob&quot;</span><br><br>greet(<span class="hljs-string">&#x27;alice&#x27;</span>)<br><span class="hljs-comment">// alice: 1</span><br><span class="hljs-comment">// &quot;hi alice&quot;</span><br><br>greet(<span class="hljs-string">&#x27;bob&#x27;</span>)<br><span class="hljs-comment">// bob: 2</span><br><span class="hljs-comment">// &quot;hi bob&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码根据参数的不同，显示<code>bob</code>执行了两次，<code>alice</code>执行了一次  </p><h3 id="console-dir-，console-dirxml"><a href="#console-dir-，console-dirxml" class="headerlink" title="console.dir()，console.dirxml()"></a>console.dir()，console.dirxml()</h3><p><code>dir</code>方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(&#123;<span class="hljs-attr">f1</span>: <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-attr">f2</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125;)<br><span class="hljs-comment">// Object &#123;f1: &quot;foo&quot;, f2: &quot;bar&quot;&#125;</span><br><br><span class="hljs-built_in">console</span>.dir(&#123;<span class="hljs-attr">f1</span>: <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-attr">f2</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125;)<br><span class="hljs-comment">// Object</span><br><span class="hljs-comment">//   f1: &quot;foo&quot;</span><br><span class="hljs-comment">//   f2: &quot;bar&quot;</span><br><span class="hljs-comment">//   __proto__: Object</span><br></code></pre></td></tr></table></figure><p>上面代码显示<code>dir</code>方法的输出结果，比<code>log</code>方法更易读，信息也更丰富   </p><p>该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.dir(<span class="hljs-built_in">document</span>.body)<br></code></pre></td></tr></table></figure><p>Node 环境之中，还可以指定以代码高亮的形式输出  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.dir(obj, &#123;<span class="hljs-attr">colors</span>: <span class="hljs-literal">true</span>&#125;)<br></code></pre></td></tr></table></figure><p><code>dirxml</code>方法主要用于以目录树的形式，显示 DOM 节点  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.dirxml(<span class="hljs-built_in">document</span>.body)<br></code></pre></td></tr></table></figure><p>如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code>console.dirxml</code>等同于<code>console.dir</code>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.dirxml([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">console</span>.dir([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br></code></pre></td></tr></table></figure><h3 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert()"></a>console.assert()</h3><p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确  </p><p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为<code>false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.assert(<span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;判断条件不成立&#x27;</span>)<br><span class="hljs-comment">// Assertion failed: 判断条件不成立</span><br><br><span class="hljs-comment">// 相当于</span><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;判断条件不成立&#x27;</span>);<br>  &#125;<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>  <span class="hljs-built_in">console</span>.error(e);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个例子，判断子节点的个数是否大于等于500  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.assert(list.childNodes.length &lt; <span class="hljs-number">500</span>, <span class="hljs-string">&#x27;节点个数大于等于500&#x27;</span>)<br></code></pre></td></tr></table></figure><p>上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本  </p><h3 id="console-time-，console-timeEnd"><a href="#console-time-，console-timeEnd" class="headerlink" title="console.time()，console.timeEnd()"></a>console.time()，console.timeEnd()</h3><p>这两个方法用于计时，可以算出一个操作所花费的准确时间  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;Array initialize&#x27;</span>);<br><br><span class="hljs-keyword">var</span> array= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000000</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = array.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>  array[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>&#125;;<br><br><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;Array initialize&#x27;</span>);<br><span class="hljs-comment">// Array initialize: 1914.481ms</span><br></code></pre></td></tr></table></figure><p><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”  </p><h3 id="console-group-，console-groupEnd-，console-groupCollapsed"><a href="#console-group-，console-groupEnd-，console-groupCollapsed" class="headerlink" title="console.group()，console.groupEnd()，console.groupCollapsed()"></a>console.group()，console.groupEnd()，console.groupCollapsed()</h3><p><code>console.group</code>和<code>console.groupEnd</code>这两个方法用于将显示的信息分组  </p><p>它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.group(<span class="hljs-string">&#x27;一级分组&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;一级分组的内容&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.group(<span class="hljs-string">&#x27;二级分组&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;二级分组的内容&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.groupEnd(); <span class="hljs-comment">// 二级分组结束</span><br><span class="hljs-built_in">console</span>.groupEnd(); <span class="hljs-comment">// 一级分组结束</span><br></code></pre></td></tr></table></figure><p>上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容  </p><p><code>console.groupCollapsed</code>方法与<code>console.group</code>方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.groupCollapsed(<span class="hljs-string">&#x27;Fetching Data&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Request Sent&#x27;</span>);<br><span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;Error: Server not responding (500)&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.groupEnd();<br></code></pre></td></tr></table></figure><p>上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行  </p><h3 id="console-trace-，console-clear"><a href="#console-trace-，console-clear" class="headerlink" title="console.trace()，console.clear()"></a>console.trace()，console.clear()</h3><p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.trace()<br><span class="hljs-comment">// console.trace()</span><br><span class="hljs-comment">//   (anonymous function)</span><br><span class="hljs-comment">//   InjectedScript._evaluateOn</span><br><span class="hljs-comment">//   InjectedScript._evaluateAndWrap</span><br><span class="hljs-comment">//   InjectedScript.evaluate</span><br></code></pre></td></tr></table></figure><p><code>console.clear</code>方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，<code>console.clear</code>方法将不起作用  </p><h2 id="控制台命令行-API"><a href="#控制台命令行-API" class="headerlink" title="控制台命令行 API"></a>控制台命令行 API</h2><p>浏览器控制台中，除了使用<code>console</code>对象，还可以使用一些控制台自带的命令行方法  </p><p>（1）<code>$_</code></p><p><code>$_</code>属性返回上一个表达式的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">2</span> + <span class="hljs-number">2</span><br><span class="hljs-comment">// 4</span><br>$_<br><span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure><p>（2）<code>$0</code> - <code>$4</code></p><p>控制台保存了最近5个在 Elements 面板选中的 DOM 元素，<code>$0</code>代表倒数第一个（最近一个），<code>$1</code>代表倒数第二个，以此类推直到<code>$4</code>。</p><p>（3）<code>$(selector)</code></p><p><code>$(selector)</code>返回第一个匹配的元素，等同于<code>document.querySelector()</code>。注意，如果页面脚本对<code>$</code>有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行<code>$(selector)</code>就会采用 jQuery 的实现，返回一个数组。</p><p>（4）<code>$$(selector)</code></p><p><code>$$(selector)</code>返回选中的 DOM 对象，等同于<code>document.querySelectorAll</code>。</p><p>（5）<code>$x(path)</code></p><p><code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$x(<span class="hljs-string">&quot;//p[a]&quot;</span>)<br></code></pre></td></tr></table></figure><p>上面代码返回所有包含<code>a</code>元素的<code>p</code>元素。</p><p>（6）<code>inspect(object)</code></p><p><code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在<code>Elements</code>面板中显示，比如<code>inspect(document)</code>会在 Elements 面板显示<code>document</code>元素。JavaScript 对象在控制台面板<code>Profiles</code>面板中显示，比如<code>inspect(window)</code>。</p><p>（7）<code>getEventListeners(object)</code></p><p><code>getEventListeners(object)</code>方法返回一个对象，该对象的成员为<code>object</code>登记了回调函数的各种事件（比如<code>click</code>或<code>keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。</p><p>（8）<code>keys(object)</code>，<code>values(object)</code></p><p><code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。</p><p><code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<span class="hljs-string">&#x27;p1&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p2&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>&#125;;<br><br>keys(o)<br><span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;]</span><br>values(o)<br><span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;]</span><br></code></pre></td></tr></table></figure><p>（9）<code>monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</code></p><p><code>monitorEvents(object[, events])</code>方法监听特定对象上发生的特定事件。事件发生时，会返回一个<code>Event</code>对象，包含该事件的相关信息。<code>unmonitorEvents</code>方法用于停止监听。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">monitorEvents(<span class="hljs-built_in">window</span>, <span class="hljs-string">&quot;resize&quot;</span>);<br>monitorEvents(<span class="hljs-built_in">window</span>, [<span class="hljs-string">&quot;resize&quot;</span>, <span class="hljs-string">&quot;scroll&quot;</span>])<br></code></pre></td></tr></table></figure><p>上面代码分别表示单个事件和多个事件的监听方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">monitorEvents($<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;mouse&#x27;</span>);<br>unmonitorEvents($<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;mousemove&#x27;</span>);<br></code></pre></td></tr></table></figure><p>上面代码表示如何停止监听。</p><p><code>monitorEvents</code>允许监听同一大类的事件。所有事件可以分成四个大类。</p><ul><li>mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”</li><li>key：”keydown”, “keyup”, “keypress”, “textInput”</li><li>touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”</li><li>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">monitorEvents($(<span class="hljs-string">&quot;#msg&quot;</span>), <span class="hljs-string">&quot;key&quot;</span>);<br></code></pre></td></tr></table></figure><p>上面代码表示监听所有<code>key</code>大类的事件。</p><p>（10）其他方法</p><p>命令行 API 还提供以下方法。</p><ul><li><code>clear()</code>：清除控制台的历史。</li><li><code>copy(object)</code>：复制特定 DOM 元素到剪贴板。</li><li><code>dir(object)</code>：显示特定对象的所有属性，是<code>console.dir</code>方法的别名。</li><li><code>dirxml(object)</code>：显示特定对象的 XML 形式，是<code>console.dirxml</code>方法的别名。</li></ul><h2 id="debugger-语句"><a href="#debugger-语句" class="headerlink" title="debugger 语句"></a>debugger 语句</h2><p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，<code>Javascript</code> 引擎自动跳过这一句  </p><p>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">2</span>) <span class="hljs-keyword">debugger</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理  </p><h1 id="Javascript进阶"><a href="#Javascript进阶" class="headerlink" title="Javascript进阶"></a>Javascript进阶</h1><h2 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环  Event Loop"></a>事件循环  Event Loop</h2><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><ul><li>进程是cpu资源分配的最小单位（系统会给它分配内存）</li><li>不同的进程之间是可以同学的，如管道、FIFO(命名管道)、消息队列 </li><li>一个进程里有单个或多个线程</li><li>浏览器是多进程的，因为系统给它的进程分配了资源（cpu、内存）（打开Chrome会有一个主进程，每打开一个Tab页就有一个独立的进程）  </li></ul><h3 id="浏览器的渲染进程是多线程的"><a href="#浏览器的渲染进程是多线程的" class="headerlink" title="浏览器的渲染进程是多线程的"></a>浏览器的渲染进程是多线程的</h3><ul><li>GUI渲染线程  </li><li>JS引擎线程  </li><li>事件触发线程  </li><li>定时触发器线程  </li><li>异步HTTP请求线程  </li></ul><h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h3><p>实际上是描述了一些函数处理顺序和过程<br>参考：<a href="https://www.bilibili.com/video/bv1kf4y1U7Ln">https://www.bilibili.com/video/bv1kf4y1U7Ln</a>  </p><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>现在有1个类A,我想要创建一个类B,这个类是以A为原型的,并且能进行扩展。我们称B的原型为A  </p><h4 id="原型关系"><a href="#原型关系" class="headerlink" title="原型关系"></a>原型关系</h4><p><img src="/Javascript-%E5%9F%BA%E7%A1%80-1/20200807110353813.png">  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>A.prototype.name = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> A();<br><span class="hljs-built_in">console</span>.log(a.name)<br></code></pre></td></tr></table></figure><ul><li><p>.prototype<br>返回原型对象的引用  </p></li><li><p>__proto__  (实际上是[[prototype]]，不过浏览器里一般都简写)<br>这个属性保存着原型对象的属性  </p><blockquote><p>Object是所有对象的“老祖宗”，所有的__proto__最终都会指向Object，Object本身并没有__proto__属性  </p></blockquote>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">a.__proto__ = A.prototype;<br></code></pre></td></tr></table></figure></li><li><p>constructor<br>A原型的属性，指向A  </p></li></ul><p>参考：<a href="https://www.bilibili.com/video/BV117411v76o">https://www.bilibili.com/video/BV117411v76o</a>  </p><h4 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h4><p>参考：<a href="https://www.bilibili.com/video/BV1N7411k7D2">https://www.bilibili.com/video/BV1N7411k7D2</a></p><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>参考：<a href="https://www.bilibili.com/video/BV15J411G7FG?from=search&amp;seid=7940074723107809573">https://www.bilibili.com/video/BV15J411G7FG?from=search&amp;seid=7940074723107809573</a></p><h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>客户端与不同源服务端的通信  </p><ul><li>CORS<br>跨域资源共享，解决跨域请求的成熟方案  </li><li>JSONP<br>基于<code>&lt;script&gt;</code>标签，具有可跨域特性<br>只能用于GET请求</li><li>iframe<br>通过<code>&lt;iframe&gt;</code>标签在同一个页面暂时不同源的页面<br>通过<code>PostMessage</code>进行页面间的通信  </li><li>反向代理<br>通过反向代理让客户端与服务端保持同步，较为安全  </li></ul><h3 id="Webpack-打包"><a href="#Webpack-打包" class="headerlink" title="Webpack 打包"></a>Webpack 打包</h3><p>目的：将不同类型的源文件编译打包成静态文件</p><ul><li>前端技术纷繁复杂，缺乏统一管理</li><li>大型项目需要模块化  </li><li>对于JSX,TS之类的新技术，需要编译以后才能使用<br>编译器，插件，优化</li></ul><hr><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/667a20d008cf">https://www.jianshu.com/p/667a20d008cf</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript-Hook-基础</title>
    <link href="/post/da48434/"/>
    <url>/post/da48434/</url>
    
    <content type="html"><![CDATA[<h1 id="Hook原理"><a href="#Hook原理" class="headerlink" title="Hook原理"></a>Hook原理</h1><p>假设我们现在有这样一个JS代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">aa,bb</span>)</span>&#123;<br>cc = aa + bb;<br>        <span class="hljs-keyword">return</span>  cc;<br>&#125;<br>test(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><p>我们在console中可以修改这个函数，比还有其它的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _setInterval=<span class="hljs-built_in">setInterval</span>;<br><span class="hljs-built_in">setInterval</span>=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(a.toString().indexOf(<span class="hljs-string">&quot;debugger&quot;</span>)!=-<span class="hljs-number">1</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>_setInterval(a,b);<br>&#125;<br>~~~如让它打印各个参数的输出结果，这就是一个JS Hook<br>~~~javascript<br><span class="hljs-keyword">var</span> _test=test;<br>test=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">aa,bb</span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(aa);<br><span class="hljs-built_in">console</span>.log(bb);<br><span class="hljs-keyword">var</span> result=_test(aa,bb);<br><span class="hljs-built_in">console</span>(result);<br></code></pre></td></tr></table></figure><p>这个函数的注入时机是在函数调用之后，页面加载完毕才注入。但实际上可以在调用地方下断点，在它运行的时候注入JS Hook，在函数被调用之前就进行修改，这也是可以的。</p><p>JS Hook看起来是很简单的，不过我们能够用它来实现很强大的功能，比如修改一些系统函数，如debugger，Function，eval等，这些都是和反调试相关的。</p><p>我们日常拿到的许多数据都是JSON，所以也可以HookJSON.stringfy进行一些操作，这样一来我们就可以在Hook后直接从堆栈中找到调用函数了。</p><p>读者应该已经发现，无论如何Hook，我们总是要把自己的代码注入到网页的环境里边，这个注入的时机选择很重要。<br>可以选择下断点的方式注入，但是有一种更为优雅的方法，那就是编写Chrome拓展插件，插件可以在网页运行之前就对系统函数进行Hook，一些网页的反调试就可以直接步过了</p><h1 id="Hook简单案例"><a href="#Hook简单案例" class="headerlink" title="Hook简单案例"></a>Hook简单案例</h1><p>JS Hook是比较容易实现的，但是对网站的破坏性却比较大<br>所以有些网站会有JS Hook的检测，最常见的就是比对关键函数前后的JS文本，如果不一致就进入循环debugger  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">x,y</span>)</span>&#123;z=x+y;<span class="hljs-keyword">return</span> z;&#125;<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;test+<span class="hljs-string">&quot;&quot;</span>==<span class="hljs-string">&quot;function test(x,y)&#123;z=x+y;return z;&#125;&quot;</span> ? <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;未修改&quot;</span>) :<span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;debugger&quot;</span>)&#125;,<span class="hljs-number">1000</span>);&#125;,<span class="hljs-number">1000</span>);<br>test(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>);<br><span class="hljs-comment">// 这里得到的结果会是 300</span><br></code></pre></td></tr></table></figure><ul><li><a href="#">Post not found: js-函数记录-技巧记录-特性记录 setInterval</a></li><li><a href="#">Post not found: js-函数记录-技巧记录-特性记录 eval</a></li></ul><p>将函数与””相加会使得函数调用toString方法，返回函数自身的字符串类型代码，在通过预设的校验代码就能知道函数是否被修改过。</p><p>想要过掉这种Hook检测，可以修改函数返回的字符串，就能使得检验通过</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">x,y</span>)</span>&#123;z=x+y;<span class="hljs-keyword">return</span> z;&#125;<br><span class="hljs-comment">// 注入</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">x,y</span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello world&quot;</span>;&#125;<br><span class="hljs-comment">// 修改toString使得转字符串与原来的结果相同，避免被反调试</span><br>test.toString=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;function test(x,y)&#123;z=x+y;return z;&#125;&quot;</span>;&#125;;<br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;test+<span class="hljs-string">&quot;&quot;</span>==<span class="hljs-string">&quot;function test(x,y)&#123;z=x+y;return z;&#125;&quot;</span> ? <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;未修改&quot;</span>) :<span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;debugger&quot;</span>)&#125;,<span class="hljs-number">1000</span>);&#125;,<span class="hljs-number">1000</span>);<br>test(<span class="hljs-number">100</span>,<span class="hljs-number">200</span>);<br><span class="hljs-comment">// 这里得到的结果会是 Hello world</span><br></code></pre></td></tr></table></figure><p>当然，还有其它的方法可以解决</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _setInterval=<span class="hljs-built_in">setInterval</span>;<br><span class="hljs-built_in">setInterval</span>=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(a.toString().indexOf(<span class="hljs-string">&quot;debugger&quot;</span>)!=-<span class="hljs-number">1</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br>_setInterval(a,b);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样做相当于在执行setInterval函数前检查了函数是否有debugger；有就不执行setInterval函数  </p><h2 id="Hook对象属性"><a href="#Hook对象属性" class="headerlink" title="Hook对象属性"></a>Hook对象属性</h2><p>我们要想Hook对象属性，需要用到<code>Object.defineProperties</code>或者<code>Object.defineProperty</code>方法，它可以直接在一个对象上修改原有属性或者定义新的属性</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.defineProperties(obj, &#123;<br>    name: &#123;<br>        value: <span class="hljs-string">&#x27;JS Hook&#x27;</span>,<br>        configurable: <span class="hljs-literal">false</span>,<br>    &#125;,<br>    age: &#123;<br>        value: <span class="hljs-number">18</span>,<br>    &#125;<br>&#125;)<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>    value: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>obj对象定义了name属性和age属性，其中name属性定义了不能修改<br>在下面尝试去修改name属性的时候，会报错<br><img src="/Javascript-Hook-%E5%9F%BA%E7%A1%80/20200712034338306.png"></p><p>只要对象生成之后，我们就可以Hook<br>比如下边的Hook，会在每次设置对象参数的时候debugger（虽然这样做完以后，这个值就不会赋成功了）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;name&#x27;</span>, &#123;<br>    set:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-keyword">debugger</span>;<span class="hljs-keyword">return</span> x;&#125;<span class="hljs-comment">//被赋值后断下来</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>对于内置对象属性的Hook，需要在文档加载之前Hook，这时候就需要用到Chrome拓展插件了。<br>比如document.cookie中的各种cookies，<br>要想知道cookies是从哪里生成的，使用Chrome拓展是很方便的，如果要使用断点调试可能比较麻烦一点，我们可以在JS文件头部下断点，在console里边输入如下代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(<span class="hljs-built_in">document</span>,<span class="hljs-string">&quot;cookie&quot;</span>,&#123;<span class="hljs-attr">set</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(x);<span class="hljs-keyword">return</span> x;&#125;&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
      <tag>Hook</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DevTools-Chrome开发者工具</title>
    <link href="/post/4c8db11a/"/>
    <url>/post/4c8db11a/</url>
    
    <content type="html"><![CDATA[<blockquote><p>人人都说Chrome好用，也许我应该放弃Firefox来用用看。  </p></blockquote><h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><a href="https://developers.google.com/web/tools/chrome-devtools/">https://developers.google.com/web/tools/chrome-devtools/</a>  </p><h1 id="开发者工具基础"><a href="#开发者工具基础" class="headerlink" title="开发者工具基础"></a>开发者工具基础</h1><h2 id="打开开发者工具"><a href="#打开开发者工具" class="headerlink" title="打开开发者工具"></a>打开开发者工具</h2><p>因为要调试前端的JS文本，和控制台交互是必不可少的，而且不少网站会在这上边做文章，比如说禁止你的F12或者右键点击等等<br>Chrome控制台打开方法总结：  </p><ul><li>F12；</li><li>CTRL+SHIFT+I；</li><li>在页面右键点击检查；</li><li>浏览器——&gt;更多工具——&gt;开发者工具；</li><li>打开一个空白页面，打开开发者工具，再切换回去要调试的页面；</li></ul><h2 id="调整开发工具位置"><a href="#调整开发工具位置" class="headerlink" title="调整开发工具位置"></a>调整开发工具位置</h2><p>最右边三个点的地方点开，可以调整工具对应浏览器的位置<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708112826512.png">  </p><h2 id="面板简介"><a href="#面板简介" class="headerlink" title="面板简介"></a>面板简介</h2><table><thead><tr><th>面板</th><th>信息</th></tr></thead><tbody><tr><td>Elements元素面板</td><td>检查和调整页面，调试DOM和CSS</td></tr><tr><td>Network网络面板</td><td>调试请求，了解页面静态资源分布，网页性能检测</td></tr><tr><td>Console控制台面板</td><td>调试JavaScript，查看日志，交互式代码调试</td></tr><tr><td>Sources源代码资源面板</td><td>调试JavaScript页面源代码，进行断点调试</td></tr><tr><td>Application应用面板</td><td>查看和调试客户端存储，如Cookie、LocalStorage、SessionStorage</td></tr><tr><td>Performance性能面板</td><td>查看页面性能细节，细粒度对网页载入进行性能优化</td></tr><tr><td>Memory内存面板</td><td>JavaScript CPU分析器，内存堆分析器</td></tr><tr><td>Security安全面板</td><td>查看页面安全及证书问题</td></tr><tr><td>Audis面板</td><td>使用Google Lighthouse辅助性能分析，给出优化建议</td></tr></tbody></table><h2 id="Elements元素面板"><a href="#Elements元素面板" class="headerlink" title="Elements元素面板"></a>Elements元素面板</h2><p>一般来说，我们切换到元素面板，它的所有HTML节点都是闭合的<br>可以选中任意元素，右键点击<code>Expand recursively</code>将其下的所有节点展开。<br>在元素面板里看到的页面源代码其实并非原始代码，而是CSS、HTML、JS综合得到的一个结果。<br>如果想要获取页面源代码，有两种方式：  </p><ul><li>切换到资源Sources面板，选择左边的index文件  </li><li>右键点击查看网页源代码，或快捷键CTRL+U  </li></ul><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708122431758.png"></p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><h3 id="隐藏页面元素"><a href="#隐藏页面元素" class="headerlink" title="隐藏页面元素"></a>隐藏页面元素</h3><p>在元素面板定位到特定元素后按下<code>H</code><br>在相同位置再次按<code>H</code>则会将隐藏的元素显示出来  </p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p><code>CTRL+C</code>  <code>CTRL+V</code><br>也可以选择某个元素后按右键<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708012404908.png">  </p><h3 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h3><p><code>CTRL+Z</code>  </p><h3 id="为元素添加属性"><a href="#为元素添加属性" class="headerlink" title="为元素添加属性"></a>为元素添加属性</h3><p>在元素上右键点击<code>Add attribute</code><br>比如倒计时抓包实际上就是把元素的CSS进行微型修改，我们把进入状态改成激活状态，就能达到抓包效果  </p><h3 id="搜索元素-amp-通过-xpath-css选择器-bs4-获取指定元素"><a href="#搜索元素-amp-通过-xpath-css选择器-bs4-获取指定元素" class="headerlink" title="搜索元素 &amp; 通过 xpath/css选择器/bs4 获取指定元素"></a>搜索元素 &amp; 通过 xpath/css选择器/bs4 获取指定元素</h3><p><code>CTRL+F</code><br>下方会弹出一个编写框，可以在里边填写页面元素，也可以编写CSS选择器/XPATH语法/bs4<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708013737876.png">  </p><h3 id="Event-Listeners选项卡"><a href="#Event-Listeners选项卡" class="headerlink" title="Event Listeners选项卡"></a><code>Event Listeners</code>选项卡</h3><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708011144067.png"><br>在一个元素的右边，我们可以看到一个<code>Event Listeners</code>选项卡<br>这里边是元素绑定的事件，但是这个事件绑定并非很准确  </p><h3 id="DOM断点"><a href="#DOM断点" class="headerlink" title="DOM断点"></a>DOM断点</h3><p>右键点击元素会看到<code>Break on</code>中包含三种断点，分别是子树修改/属性变化/节点被移除时候触发的断点<br>任意选择一个，会在Sources面板的DOM breakpoints里边多出一个断点记录<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708014531683.png">  </p><h2 id="Console控制台面板"><a href="#Console控制台面板" class="headerlink" title="Console控制台面板"></a><code>Console</code>控制台面板</h2><p>你可以在可以在<code>元素面板</code>里边选中某个元素，在控制台里,<code>$0</code>当前选中的节点的引用，<code>$1</code>是对上一次我们选择的节点的引用，一直可以回溯到<code>$4</code><br>实际上就是一个js控制台。想输入代码，调用函数都可以来这里输入  </p><h3 id="有用的函数"><a href="#有用的函数" class="headerlink" title="有用的函数"></a>有用的函数</h3><h4 id="Console-table"><a href="#Console-table" class="headerlink" title="Console.table"></a>Console.table</h4><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200809031430212.png">  </p><h4 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h4><p>作为参数的内容会被弄到系统粘贴面板里，你可以在其它地方粘贴  </p><h4 id=""><a href="#" class="headerlink" title="$_"></a>$_</h4><p>返回最后一次计算的值  </p><h2 id="Sources源代码面板"><a href="#Sources源代码面板" class="headerlink" title="Sources源代码面板"></a><code>Sources</code>源代码面板</h2><h3 id="Page选项卡"><a href="#Page选项卡" class="headerlink" title="Page选项卡"></a><code>Page</code>选项卡</h3><p>放置了网站的资源html、js、css等<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708071247845.png">  </p><h3 id="Overrides"><a href="#Overrides" class="headerlink" title="Overrides"></a><code>Overrides</code></h3><p>本地代理，能将一些资源保存到这里，然后再次请求网页相同资源的时候会在这里找文件来覆盖原网页<br>可用于前端编辑  </p><h3 id="Snippets选项卡"><a href="#Snippets选项卡" class="headerlink" title="Snippets选项卡"></a><code>Snippets</code>选项卡</h3><p>一个代码片段工具<br>新建一个snippet，在里边存放编辑的JS代码<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708071741288.png"><br>这样就可以在<code>console</code>里边使用我们自己的JS代码，比如一些<code>Base64</code>的基本转化或者<code>CryptoJS</code>等，我们就可以直接调用里边的函数了<br>在写完以后，可以在下面点运行，打开控制台进行调试  </p><h3 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h3><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200709124357335.png"></p><h2 id="Network网络面板"><a href="#Network网络面板" class="headerlink" title="Network网络面板"></a><code>Network</code>网络面板</h2><p>网络面板主要是抓取网页数据包<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708072207405.png"><br>可以在Filter中对数据包进行过滤  </p><h3 id="禁用缓存"><a href="#禁用缓存" class="headerlink" title="禁用缓存"></a>禁用缓存</h3><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200709123519953.png">  </p><h3 id="查找请求源"><a href="#查找请求源" class="headerlink" title="查找请求源"></a>查找请求源</h3><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200809022858499.png"><br>单击内容会打开到目标  </p><h3 id="查看依赖关系"><a href="#查看依赖关系" class="headerlink" title="查看依赖关系"></a>查看依赖关系</h3><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200809023213587.png"><br>按住键盘shift键，在包上移动会发现一些颜色变化<br>绿色表示当前包的发起者<br>红色表示当前包依赖于谁  </p><h2 id="Application应用面板"><a href="#Application应用面板" class="headerlink" title="Application应用面板"></a><code>Application</code>应用面板</h2><p>可以在其中的Storage中看待当前页面在数据库中存储了哪些数据<br>里边的Cookies等元素也是可以编辑的<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708072416038.png">  </p><h2 id="Settings设置面板"><a href="#Settings设置面板" class="headerlink" title="Settings设置面板"></a><code>Settings</code>设置面板</h2><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708072637490.png"><br>可以勾选其中Console里的Log XMLHttpRequests，这是一个AJAXHook，当我们发起一个请求它会直接帮我们输出出来  </p><h1 id="Chorme调试技巧"><a href="#Chorme调试技巧" class="headerlink" title="Chorme调试技巧"></a>Chorme调试技巧</h1><h2 id="断点"><a href="#断点" class="headerlink" title="断点"></a>断点</h2><p>任意点击一个堆栈信息进去们可以在<code>Sources面板</code>之中点击序号栏下断点<br>然后点击页面上的例如登录按钮让它触发事件，我们配合右边的<code>Call Stack</code>去查看我们的关键信息到底在什么地方  </p><p><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708112240558.png"><br>在<code>Elements面板</code>找到登录按钮,记录一些元素和属性信息<br>到Sources面板里找到对应位置<br>断点类型有很多种：  </p><ul><li><p><code>XHR断点</code><br>可以复制一下XHR包的URL（全部或部分），在Sources面板中新建<code>XHR Breakpoints</code>就可以在发起网页这个XHR请求的时候断点  <img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708114603831.png"></p></li><li><p><code>Event Listener 下一个事件断点</code><br>比较常用的是<code>Mouse</code>里边的<code>click断点</code>，因为我们要抓的许多加密参数包是点击按钮后才会触发的<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708114854674.png">  </p></li><li><p>无差别断点<br>直接点击相应的序号栏即可<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200708115834789.png">  </p></li><li><p><code>Contional Breakpoint</code> 条件断点<br>当你输入的表达式结果为真就会进行断点</p><ul><li><p>比如<code>password==&#39;123&#39;</code><br>当我们输入的密码是123的时候就会进行断点。这个通常用于有循环的情况，我们只需要查看最后一次结果，这样就可以避免一步步调试进入循环  </p></li><li><p>可以直接输入<code>console.log(password)</code><br>这样虽然不会断下来，但是会有一个输出。这相当于一个console暗桩<br>这样即便是页面一开始加载的参数我们也可以得知，而且避免了断点卡顿。这种断点通常用于滑块验证码，滑块轨迹的每一次输出我们不可能每次移动一次让它卡顿一次，使用console暗桩就可以得到一个打印输出的效果</p></li></ul></li></ul><p>这里的事件断点通常会断在一开始的HTML页面，我们可以一步步深入去了解事件加密。</p><h2 id="监听"><a href="#监听" class="headerlink" title="监听"></a>监听</h2><h3 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h3><p><code>monitorEvents()</code>监听某一类型的事件<br><code>monitorEvents</code>的第一个参数是要监听的对象。如果未提供第二个参数，所有事件都会返回。要指定要监听的事件，传递一个字符串或字符串数组作为第二个参数  </p><ul><li>例子：监听页面body上的点击事件：<br><code>monitorEvents(document.body, &quot;click&quot;);</code><br>  当然，获取元素的方式可以不用js原生的  </li></ul><h3 id="取消监听函数"><a href="#取消监听函数" class="headerlink" title="取消监听函数"></a>取消监听函数</h3><p><code>unmonitorEvents()</code>停止监听<br>要停止监听事件，请调用<code>unmonitorEvents()</code>方法,传递一个停止监视对象的参数  </p><ul><li>例子：停止监听body对象上的事件：<br><code>unmonitorEvents(document.body);</code>  </li></ul><h3 id="监听变量"><a href="#监听变量" class="headerlink" title="监听变量"></a>监听变量</h3><p>使用watch还可以监听变量<br>在Sources面板中有watch栏目，里边可以监听变量何时变化。<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200709125418645.png"><br>比如我们可以添加password加密参数，在断点的配合下一步步深入，直到password数值改变，我们就可以定位到具体的JS加密地点。</p><h1 id="小技巧-骚操作"><a href="#小技巧-骚操作" class="headerlink" title="小技巧/骚操作"></a>小技巧/骚操作</h1><h2 id="生成python爬虫代码"><a href="#生成python爬虫代码" class="headerlink" title="生成python爬虫代码"></a>生成python爬虫代码</h2><ol><li>找到目标数据包复制Curl<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200809022140280.png"></li><li>把Curl导入到postman<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200809022329199.png"><br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200809022358410.png"></li><li>postman 导出目标代码<br><img src="/Chrome%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7/20200809022515060.png"></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Chrome</tag>
      
      <tag>DevTools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS-python</title>
    <link href="/post/233c4197/"/>
    <url>/post/233c4197/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><ol><li><p>安装必要工具 yum-utils<br>功能是管理repository及扩展包的工具 (主要是针对repository)  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install yum-utils<br></code></pre></td></tr></table></figure></li><li><p>使用yum-builddep为Python3构建环境<br>缺失的软件依赖会自动处理  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-builddep python<br></code></pre></td></tr></table></figure></li><li><p>下载源码包  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -O https://www.python.org/ftp/python/3.5.0/Python-3.5.0.tgz<br></code></pre></td></tr></table></figure><p> 要啥版本下啥版本  </p></li><li><p>解压源码包并进入压文件夹</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar xf Python-3.5.0.tgz&gt; 3.7版本需要一个新的包libffi-devel，安装此包之后再次进行编译安装即可。<br><span class="hljs-built_in">cd</span> Python-3.5.0<br></code></pre></td></tr></table></figure></li><li><p>编译，执行，安装</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss">./configure  <br><span class="hljs-built_in">make</span>  <br>sudo <span class="hljs-built_in">make</span> install  <br></code></pre></td></tr></table></figure><blockquote><p>关于<code>ModuleNotFoundError: No module named &#39;_ctypes&#39;</code><br>python3.7版本需要一个新的包<code>libffi-devel</code><br>安装此包之后再次进行编译安装即可  </p></blockquote><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> libffi-devel -y<br></code></pre></td></tr></table></figure><blockquote><p>python3中有个内置模块叫<code>ctypes</code>，它是python3的外部函数库模块，提供了兼容C语言的数据类型，并通过它调用Linux系统下的共享库(Shared library)，此模块需要使用centos7系统中外部函数库(Foreign function library)的开发链接库(头文件和链接库)<br>由于在centos7系统中没有安装外部函数库(libffi)的开发链接库软件包，所以在安装pip的时候就报了<code>ModuleNotFoundError: No module named &#39;_ctypes&#39;</code>的错误  </p></blockquote></li><li><p>测试安装  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3<br></code></pre></td></tr></table></figure><p>进入python shell，并看到是目标版本，则表示成功  </p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>CentOS</tag>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-函数记录-技巧记录-特性记录</title>
    <link href="/post/99a302d5/"/>
    <url>/post/99a302d5/</url>
    
    <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><h3 id="函数说明"><a href="#函数说明" class="headerlink" title="函数说明"></a>函数说明</h3><p><code>sorted(iterable, key=None, reverse=False)</code></p><table><thead><tr><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>iterable</td><td>可迭代对象</td></tr><tr><td>key</td><td>主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</td></tr><tr><td>reverse</td><td>排序规则<br>reverse = True 降序<br>reverse = False 升序（默认）</td></tr></tbody></table><h3 id="用例"><a href="#用例" class="headerlink" title="用例"></a>用例</h3><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">&gt;&gt;&gt;sorted(<span class="hljs-string">[5, 2, 3, 1, 4]</span>)<br><span class="hljs-string">[1, 2, 3, 4, 5]</span>  # 默认为升序<br></code></pre></td></tr></table></figure><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">&gt;&gt;&gt;<span class="hljs-meta">array</span> = [&#123;<span class="hljs-string">&quot;age&quot;</span>:20,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;a&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;age&quot;</span>:25,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;b&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;age&quot;</span>:10,<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;c&quot;</span>&#125;]<br>&gt;&gt;&gt;<span class="hljs-meta">array</span> = sorted(<span class="hljs-meta">array</span>,<span class="hljs-meta">key</span>=lambda <span class="hljs-meta">x</span>:<span class="hljs-meta">x</span>[<span class="hljs-string">&quot;age&quot;</span>])<br>&gt;&gt;&gt;p<span class="hljs-meta">rint(</span><span class="hljs-meta">array</span>)<br>[&#123;<span class="hljs-string">&#x27;age&#x27;</span>: 10, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;c&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;age&#x27;</span>: 20, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>&#125;, &#123;<span class="hljs-string">&#x27;age&#x27;</span>: 25, <span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>&#125;]<br></code></pre></td></tr></table></figure><h2 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h2><h3 id="函数说明-1"><a href="#函数说明-1" class="headerlink" title="函数说明"></a>函数说明</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">zip</span>([iterable, ...])<br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>参数说明</th></tr></thead><tbody><tr><td>iterable</td><td>可迭代对象</td></tr></tbody></table><p>zip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表  </p><p>如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同，利用 * 号操作符，可以将元组解压为列表  </p><h3 id="用例-1"><a href="#用例-1" class="headerlink" title="用例"></a>用例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>&gt;&gt;&gt;b = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]<br>&gt;&gt;&gt;c = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>zipped = <span class="hljs-built_in">zip</span>(a,b)     <span class="hljs-comment"># 打包为元组的列表</span><br>[(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">zip</span>(a,c)              <span class="hljs-comment"># 元素个数与最短的列表一致</span><br>[(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">6</span>)]<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">zip</span>(*zipped)          <span class="hljs-comment"># 与 zip 相反，*zipped 可理解为解压，返回二维矩阵式</span><br>[(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)]<br></code></pre></td></tr></table></figure><h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="生成式"><a href="#生成式" class="headerlink" title="生成式"></a>生成式</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><blockquote><p>案例：遍历生成新数据  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>&gt;&gt;&gt;[i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a]<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：遍历计算生成新数据  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]<br>&gt;&gt;&gt;[i+<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a]<br>[<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><h3 id="带判断"><a href="#带判断" class="headerlink" title="带判断"></a>带判断</h3><p>注意：判断在执行计算之前，如果判断为False，则不进入计算流程，直接忽略    </p><blockquote><p>案例：遍历判断计算生成新数据  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;&gt;&gt;[i+<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> a <span class="hljs-keyword">if</span> i!=<span class="hljs-number">2</span>]<br>[<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><h3 id="双生"><a href="#双生" class="headerlink" title="双生"></a>双生</h3><blockquote><p>案例：遍历两个list，计算生成新数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a, b = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>], [<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>[x+y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> b]<br>[<span class="hljs-string">&#x27;ac&#x27;</span>, <span class="hljs-string">&#x27;ad&#x27;</span>, <span class="hljs-string">&#x27;bc&#x27;</span>, <span class="hljs-string">&#x27;bd&#x27;</span>]<br></code></pre></td></tr></table></figure><p><span></span></p><blockquote><p>案例：遍历两个list，进行判断计算生成新数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a, b = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>], [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>[x+y <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a <span class="hljs-keyword">if</span> x!=<span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> b <span class="hljs-keyword">if</span> y!=<span class="hljs-string">&#x27;e&#x27;</span>]<br>[<span class="hljs-string">&#x27;ad&#x27;</span>, <span class="hljs-string">&#x27;af&#x27;</span>, <span class="hljs-string">&#x27;cd&#x27;</span>, <span class="hljs-string">&#x27;cf&#x27;</span>]<br></code></pre></td></tr></table></figure><h2 id="更美观的print-pprint"><a href="#更美观的print-pprint" class="headerlink" title="更美观的print - pprint"></a>更美观的print - pprint</h2><p><code>print</code>函数能在终端输出一些东西<br>如果输出的内容是一个数组或元组，且其元素类型各不相同，数量又多，看着很难受。此时可以使用 <code>pprint</code>函数 来取代 <code>print</code>函数 </p><p><code>pprint()</code>模块打印出来的数据结构更加完整，每行为一个数据结构，更加方便阅读打印输出结果  </p><blockquote><p>缺点在于使用需要 <code>from pprint import pprint</code></p></blockquote><h2 id="更美观的字符串拼接-format"><a href="#更美观的字符串拼接-format" class="headerlink" title="更美观的字符串拼接 - format"></a>更美观的字符串拼接 - format</h2><p>使用format函数能让print函数看上去更美观，同时不会出现需要转换类型的问题  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;Rem&#x27;</span><br>country = <span class="hljs-string">&#x27;China&#x27;</span><br>print(<span class="hljs-string">&quot;Hi, I&#x27;m &#123;&#125; from &#123;&#125;. &#123;1&#125; &#123;0&#125;&quot;</span>,<span class="hljs-built_in">format</span>(name,country))<br></code></pre></td></tr></table></figure><p>输出结果  </p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">Hi, I<span class="hljs-symbol">&#x27;m</span> <span class="hljs-keyword">Rem</span> from China. China <span class="hljs-keyword">Rem</span><br></code></pre></td></tr></table></figure><h2 id="更好的遍历"><a href="#更好的遍历" class="headerlink" title="更好的遍历"></a>更好的遍历</h2><h3 id="使用enumerate"><a href="#使用enumerate" class="headerlink" title="使用enumerate"></a>使用enumerate</h3><p>如果你希望遍历元素，又不希望使用变量计算索引，可以试试enumerate  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-keyword">for</span> i, x <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(a):<br>    print(i, x)<br>&gt;&gt;&gt;<span class="hljs-number">0</span> a<br>&gt;&gt;&gt;<span class="hljs-number">1</span> b<br>&gt;&gt;&gt;<span class="hljs-number">2</span> c<br></code></pre></td></tr></table></figure><h3 id="使用-表达式"><a href="#使用-表达式" class="headerlink" title="使用{}表达式"></a>使用{}表达式</h3><p>python3.6以上才有的特性  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-string">&#x27;Rem&#x27;</span><br>country = <span class="hljs-string">&#x27;China&#x27;</span><br>age = <span class="hljs-number">18</span><br>print(<span class="hljs-string">&quot;Hi, I&#x27;m &#123;name&#125; from &#123;country&#125;. &#123;age-2&#125; years old&quot;</span>)<br>&gt;&gt;&gt;Hi, I<span class="hljs-string">&#x27;m Rem from China. 16 years old</span><br></code></pre></td></tr></table></figure><h2 id="eval-与-json-loads"><a href="#eval-与-json-loads" class="headerlink" title="eval() 与 json.loads()"></a>eval() 与 json.loads()</h2><p><code>eval()</code>能计算表达式，也能将<code>str</code>转为 <code>python</code>对象<br><code>json.loads()</code>能将str转为 <code>python</code>对象<br>如果只是将写着<code>JSON</code>内容的字符串转为<code>python</code>对象，那么<code>json.loads()</code>的转换速度比<code>eval()</code>大概快十倍  </p><h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><h2 id="Python的GIL"><a href="#Python的GIL" class="headerlink" title="Python的GIL"></a>Python的GIL</h2><h3 id="GIL是什么"><a href="#GIL是什么" class="headerlink" title="GIL是什么"></a>GIL是什么</h3><p>GIL全称Global Interpreter Lock<br>GIL并不是 <code>Python</code> 的特性，它是在实现Python解析器(CPython)时所引入的一个概念。</p><blockquote><p>官方解释：<br>In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.)  </p></blockquote><blockquote><p>个人翻译：<br>在CPython中，GIL是一个用来防止多个线程同时请求同一机器码的互斥锁。CPython的内存管理方式是线程不安全的，所以这个锁是很有必要设置的。  </p></blockquote><h4 id="线程安全与线程不安全"><a href="#线程安全与线程不安全" class="headerlink" title="线程安全与线程不安全"></a>线程安全与线程不安全</h4><ul><li>线程安全<br>指多个线程在执行同一段代码的时候采用加锁机制,使每次的执行结果和单线程执行的结果都是一样的,不存在执行程序时出现意外结果。  </li><li>线程不安全<br>是指不提供加锁机制保护,有可能出现多个线程先后更改数据造成所得到的数据是脏数据。 </li></ul><h3 id="GIL为何存在"><a href="#GIL为何存在" class="headerlink" title="GIL为何存在"></a>GIL为何存在</h3><p>由于物理上得限制，各CPU厂商在核心频率上的比赛已经被多核所取代。<br>为了更有效的利用多核处理器的性能，就出现了多线程的编程方式，而随之带来的就是线程间数据一致性和状态同步的困难。为了有效解决多份缓存之间的数据同步时各厂商花费了不少心思，也不可避免的带来了一定的性能损失。  </p><p><code>Python</code>当然也逃不开，为了利用多核，<code>Python</code>开始支持多线程。而解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁。 于是有了GIL这把超级大锁，而当越来越多的代码库开发者接受了这种设定后，他们开始大量依赖这种特性（即默认python内部对象是thread-safe的，无需在实现时考虑额外的内存锁和同步操作）。  </p><p>慢慢的这种实现方式被发现是蛋疼且低效的。但当大家试图去拆分和去除GIL的时候，发现大量库代码开发者已经重度依赖GIL而非常难以去除了。有多难？做个类比，像MySQL这样的“小项目”为了把Buffer Pool Mutex这把大锁拆分成各个小锁也花了从5.5到5.6再到5.7多个大版为期近5年的时间，并且仍在继续。MySQL这个背后有公司支持且有固定开发团队的产品走的如此艰难，那又更何况Python这样核心开发和代码贡献者高度社区化的团队呢？  </p><p>所以简单的说GIL的存在更多的是历史原因。如果推到重来，多线程的问题依然还是要面对，但是至少会比目前GIL这种方式会更优雅。  </p><h3 id="GIL的影响"><a href="#GIL的影响" class="headerlink" title="GIL的影响"></a>GIL的影响</h3><p>从上文的介绍和官方的定义来看，GIL无疑就是一把全局排他锁。毫无疑问全局锁的存在会对多线程的效率有不小影响。甚至就几乎等于Python是个单线程的程序。 那么读者就会说了，全局锁只要释放的勤快效率也不会差啊。只要在进行耗时的IO操作的时候，能释放GIL，这样也还是可以提升运行效率的嘛。或者说再差也不会比单线程的效率差吧。理论上是这样，而实际上呢？Python比你想的更糟。  </p><p>Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降  </p><h3 id="用-multiprocessing-替代-Thread"><a href="#用-multiprocessing-替代-Thread" class="headerlink" title="用 multiprocessing 替代 Thread"></a>用 multiprocessing 替代 Thread</h3><p><code>multiprocessing</code>库的出现很大程度上是为了弥补<code>thread</code>库因为<code>GIL</code>而低效的缺陷。<br>它完整的复制了一套<code>thread</code>所提供的接口方便迁移。唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。  </p><p>当然multiprocessing也不是万能良药。<br>它的引入会增加程序实现时线程间数据通讯和同步的困难。就拿计数器来举例子，如果我们要多个线程累加同一个变量，对于thread来说，申明一个global变量，用thread.Lock的context包裹住三行就搞定了。而multiprocessing由于进程之间无法看到对方的数据，只能通过在主线程申明一个Queue，put再get或者用share memory的方法。这个额外的实现成本使得本来就非常痛苦的多线程程序编码，变得更加痛苦了。</p><h3 id="所以没救了么？"><a href="#所以没救了么？" class="headerlink" title="所以没救了么？"></a>所以没救了么？</h3><p>当然Python社区也在非常努力的不断改进GIL，甚至是尝试去除GIL。并在各个小版本中有了不少的进步。有兴趣的读者可以扩展阅读这个Slide 另一个改进<code>Reworking the GIL</code>  </p><p>将切换颗粒度从基于opcode计数改成基于时间片计数<br>避免最近一次释放GIL锁的线程再次被立即调度<br>新增线程优先级功能（高优先级线程可以迫使其他线程释放所持有的GIL锁） </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Python GIL其实是功能和性能之间权衡后的产物，它尤其存在的合理性，也有较难改变的客观因素。</p><ul><li>因为GIL的存在，只有IO Bound场景下得多线程会得到较好的性能  </li><li>如果对并行计算性能较高的程序可以考虑把核心部分也成C模块，或者索性用其他语言实现  </li><li>GIL在较长一段时间内将会继续存在，但是会不断对其进行改进  </li></ul><blockquote><p>参考：  </p></blockquote><ul><li><a href="https://www.jianshu.com/p/756c505ab828">https://www.jianshu.com/p/756c505ab828</a>  </li></ul><h2 id="不同目录import"><a href="#不同目录import" class="headerlink" title="不同目录import"></a>不同目录import</h2><p>import 说到底是根据路径导入<br>这个导入路径有多个，可以使用<code>sys.path</code>来查看  </p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-keyword">import</span> sys<br>sys.<span class="hljs-built_in">path</span><br></code></pre></td></tr></table></figure><h3 id="添加sys以处理不同级导入"><a href="#添加sys以处理不同级导入" class="headerlink" title="添加sys以处理不同级导入"></a>添加sys以处理不同级导入</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua">import sys<br>import <span class="hljs-built_in">os</span><br>CURRENT_DIR = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.split(<span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.abspath(__file__))[<span class="hljs-number">0</span>]  # 当前目录<br>config_path = CURRENT_DIR.rsplit(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-number">3</span>)[<span class="hljs-number">0</span>]  # 上三级目录<br>sys.<span class="hljs-built_in">path</span>.append(config_path)<br>from <span class="hljs-built_in">config</span> import param<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;config_path=&#x27;</span>, config_path)<br><span class="hljs-built_in">print</span>(sys.<span class="hljs-built_in">path</span>)<br><span class="hljs-built_in">print</span>(param)<br></code></pre></td></tr></table></figure><h2 id="小整数池"><a href="#小整数池" class="headerlink" title="小整数池"></a>小整数池</h2><p>为避免整数频繁申请和销毁内存空间，<code>Python</code> 定义了一个小整数池 <code>[-5, 256]</code> 这些整数对象是提前建立好的，不会被垃圾回收  </p><p>以下代码请在 <code>终端Python环境</code>下测试，如果你是在IDE中测试，由于 <code>IDE</code> 的影响，效果会有所不同  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>a = -<span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = -<span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b<br><span class="hljs-literal">False</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">256</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">256</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b<br><span class="hljs-literal">True</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">257</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>b = <span class="hljs-number">257</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b<br><span class="hljs-literal">False</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = <span class="hljs-number">257</span>; b = <span class="hljs-number">257</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a <span class="hljs-keyword">is</span> b<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h2 id="字符串驻留-intern"><a href="#字符串驻留-intern" class="headerlink" title="字符串驻留 intern"></a>字符串驻留 intern</h2><p><code>Python</code>解释器中使用了 <code>intern</code>（字符串驻留）的技术来提高字符串效率  </p><blockquote><p>什么是intern机制<br>同样的字符串对象仅仅会保存一份，放在一个字符串储蓄池中，共用。这也决定了字符串必须是不可变对象  </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>s1=<span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s2=<span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s1 <span class="hljs-keyword">is</span> s2<br><span class="hljs-literal">True</span><br><br><span class="hljs-comment"># 如果有空格，默认不启用intern机制</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s1=<span class="hljs-string">&quot;hell o&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s2=<span class="hljs-string">&quot;hell o&quot;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s1 <span class="hljs-keyword">is</span> s2<br><span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 如果一个字符串长度超过20个字符，不启动intern机制</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s1 = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s2 = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">20</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s1 <span class="hljs-keyword">is</span> s2<br><span class="hljs-literal">True</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s1 = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">21</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s2 = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-number">21</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s1 <span class="hljs-keyword">is</span> s2<br><span class="hljs-literal">False</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s1 = <span class="hljs-string">&quot;ab&quot;</span> * <span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s2 = <span class="hljs-string">&quot;ab&quot;</span> * <span class="hljs-number">10</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s1 <span class="hljs-keyword">is</span> s2<br><span class="hljs-literal">True</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>s1 = <span class="hljs-string">&quot;ab&quot;</span> * <span class="hljs-number">11</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s2 = <span class="hljs-string">&quot;ab&quot;</span> * <span class="hljs-number">11</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s1 <span class="hljs-keyword">is</span> s2<br><span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><h2 id="Python-之禅"><a href="#Python-之禅" class="headerlink" title="Python 之禅"></a>Python 之禅</h2><p>当你尝试引入<code>this</code>包  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> this<br></code></pre></td></tr></table></figure><p>你会发现它会输出这样一段话  </p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">The Zen <span class="hljs-keyword">of</span> Python, <span class="hljs-keyword">by</span> Tim Peters<br> <br>Beautiful <span class="hljs-keyword">is</span> better than ugly.<br><span class="hljs-keyword">Explicit</span> <span class="hljs-keyword">is</span> better than implicit.<br>Simple <span class="hljs-keyword">is</span> better than complex.<br>Complex <span class="hljs-keyword">is</span> better than complicated.<br>Flat <span class="hljs-keyword">is</span> better than nested.<br>Sparse <span class="hljs-keyword">is</span> better than dense.<br>Readability counts.<br>Special cases aren<span class="hljs-comment">&#x27;t special enough to break the rules.</span><br>Although practicality beats purity.<br>Errors should never pass silently.<br>Unless explicitly silenced.<br><span class="hljs-keyword">In</span> the face <span class="hljs-keyword">of</span> ambiguity, refuse the temptation <span class="hljs-keyword">to</span> guess.<br>There should be one-- <span class="hljs-keyword">and</span> preferably only one --obvious way <span class="hljs-keyword">to</span> <span class="hljs-keyword">do</span> it.<br>Although that way may <span class="hljs-keyword">not</span> be obvious at first unless you<span class="hljs-comment">&#x27;re Dutch.</span><br>Now <span class="hljs-keyword">is</span> better than never.<br>Although never <span class="hljs-keyword">is</span> often better than *right* now.<br><span class="hljs-keyword">If</span> the implementation <span class="hljs-keyword">is</span> hard <span class="hljs-keyword">to</span> explain, it<span class="hljs-comment">&#x27;s a bad idea.</span><br><span class="hljs-keyword">If</span> the implementation <span class="hljs-keyword">is</span> easy <span class="hljs-keyword">to</span> explain, it may be a good idea.<br>Namespaces are one honking great idea -- <span class="hljs-keyword">let</span><span class="hljs-comment">&#x27;s do more of those!</span><br></code></pre></td></tr></table></figure><p>翻译  </p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">Python之禅 <span class="hljs-keyword">by</span> Tim Peters<br>优美胜于丑陋（Python 以编写优美的代码为目标）<br>明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）<br>简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）<br>复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）<br>扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）<br>间隔胜于紧凑（优美的代码有适当的间隔，不要奢望一行代码解决问题）<br>可读性很重要（优美的代码是可读的）<br>即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）<br> <br>不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写 <span class="hljs-keyword">except</span>:pass 风格的代码）<br> <br>当存在多种可能，不要尝试去猜测<br>而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）<br>虽然这并不容易，因为你不是 Python 之父（这里的 Dutch 是指 Guido ）<br> <br>做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）<br> <br>如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）<br> <br>命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）<br></code></pre></td></tr></table></figure><p>很有意义的文字，不是吗  </p><p>它的源码字符串使用了凯撒加密，有兴趣可以去看<br>定义路径:<code>环境/lib/this.py</code>  </p><h2 id="try-finaly-return-执行问题"><a href="#try-finaly-return-执行问题" class="headerlink" title="try-finaly-return 执行问题"></a>try-finaly-return 执行问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">b</span>():</span><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;A&#x27;</span><br>    <span class="hljs-keyword">finally</span>:<br>        print(<span class="hljs-string">&#x27;B&#x27;</span>)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;C&#x27;</span><br>        <span class="hljs-keyword">finally</span>:<br>            print(<span class="hljs-string">&#x27;D&#x27;</span>)<br>print(b())<br>&gt;&gt;&gt;B<br>&gt;&gt;&gt;D<br>&gt;&gt;&gt;C<br></code></pre></td></tr></table></figure><p>无论是否发生异常，<code>finally</code>子句始终在离开<code>try</code>语句之前执行<br>如果<code>try</code>子句中发生了异常且未由<code>except</code>子句处理（或在<code>except</code>或<code>else</code>子句中发生），则在执行<code>finally</code>子句后重新引发该异常<br>当<code>try</code>语句的任何其他子句通过<code>break</code>，<code>continue</code>或<code>return</code>语句离开时，<code>finally</code>子句也将“在离开的<code>try</code>时候”执行  </p><p>如果一个函数没有 <code>return</code>，会隐式的返回 <code>None</code><br>函数的返回只有一个，如果显式声明了 <code>return</code>，那么会覆盖旧的 <code>return</code>  </p><blockquote><p>参考  </p><ul><li><a href="https://stackoverflow.com/questions/19805654/python-try-finally-block-returns">stackoverflow : python-try-finally-block-returns</a>  </li><li><a href="http://magic.iswbm.com/zh/latest/c01/c01_19.html">http://magic.iswbm.com/zh/latest/c01/c01_19.html</a>  </li></ul></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-在文章里显示的数学公式</title>
    <link href="/post/9a04a193/"/>
    <url>/post/9a04a193/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>hexo</code>默认使用<code>hexo-renderer-marked</code>引擎去渲染网页，它会把利用<code>Markdown</code>语法写的文本去转换为相应的<code>html</code>标签。<br>在利用<code>Markdown</code>写<code>MathJax</code>公式的时候，经常会用到下划线<code>_</code>表示下标，但是下划线<code>_</code>会被<code>hexo</code>的默认引擎<code>hexo-renderer-marked</code>渲染成<code>html</code>中的<code>&lt;em&gt;</code>标签，表示斜体。<br>这样一来，我们写的<code>MathJax</code>公式就被错误渲染了，也就没办法正确显示出来。  </p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="更换-Markdown-渲染器"><a href="#更换-Markdown-渲染器" class="headerlink" title="更换 Markdown 渲染器"></a>更换 Markdown 渲染器</h3><ol><li>卸载原渲染器  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm uninstall hexo-renderer-marked --save<br></code></pre></td></tr></table></figure></li><li>安装新渲染器  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install hexo-renderer-kramed --save<br></code></pre></td></tr></table></figure><h3 id="在编写时启用"><a href="#在编写时启用" class="headerlink" title="在编写时启用"></a>在编写时启用</h3>对于需要用到<code>MathJax</code>公式的文章，要在<code>Front-matter</code>中打开<code>MathJax</code>开关，例如：<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hexo-在文章里显示的数学公式</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2020-06-04 23:32:17</span><br><span class="hljs-attr">mathjax:</span> <span class="hljs-literal">true</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure>需要注意的是，如果主题里整合了这个东西，可能关键词不是<code>mathjax</code>，具体看主题的说明</li></ol><h2 id="MathJax公式语法"><a href="#MathJax公式语法" class="headerlink" title="MathJax公式语法"></a>MathJax公式语法</h2><h3 id="中文文档"><a href="#中文文档" class="headerlink" title="中文文档"></a>中文文档</h3><p><a href="https://mathjax-chinese-doc.readthedocs.io/en/latest/">https://mathjax-chinese-doc.readthedocs.io/en/latest/</a></p><h3 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h3><table><thead><tr><th>符号</th><th>释义</th><th>测试用例</th><th>最终效果</th></tr></thead><tbody><tr><td>^</td><td>上标</td><td>x{yz}=(1+ex){-2xy^w</td><td>$ x{yz}=(1+ex){-2xy^w} $</td></tr><tr><td>_</td><td>下标</td><td>CO_2</td><td>$CO_2$</td></tr><tr><td>\frac{分子}{分母} or 分子 \over 分母</td><td>分数</td><td>f(x,y,z)=3y2z(3+\frac{7x+5}{1+y2})</td><td>$ f(x,y,z)=3y2z(3+\frac{7x+5}{1+y2}) $</td></tr><tr><td>\sqrt[根指数，省略时为2]{被开方数}</td><td>开方</td><td>\sqrt{2}、\sqrt[3]{9}</td><td>$\sqrt{2}、\sqrt[3]{9}$</td></tr><tr><td>\ldots</td><td>与文本底线对齐的省略号</td><td>x_1x_2{\ldots}x_n</td><td>$x_1x_2{\ldots}x_n$</td></tr><tr><td>\cdots</td><td>与文本中线对齐的省略号</td><td>x_1x_2{\cdots}x_n</td><td>$x_1x_2{\cdots}x_n$</td></tr><tr><td>\int_积分下限^积分上限(被积表达式)</td><td>积分</td><td>\int_1^2n{x2}dx</td><td>$ \int_1^2n{x2}dx $</td></tr><tr><td><code>f(x)=\begin&#123;cases&#125;语句1\\语句2\\...\end&#123;cases&#125;</code></td><td>分段函数</td><td><code>f(n)=\begin&#123;cases&#125;n/2, &amp; \text&#123;如果$ x&lt;=2 $&#125;\\3n+1, &amp; \text&#123;如果$ x&gt;2 $&#125;\end&#123;cases&#125;</code></td><td>$$ f(n)=\begin{cases}n/2, &amp; \text{如果$ x&lt;=2 $}\3n+1, &amp; \text{如果$ x&gt;2 $}\end{cases}$$</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Markdown</tag>
      
      <tag>MathJax</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-实现pow(x, n)</title>
    <link href="/post/79ffd911/"/>
    <url>/post/79ffd911/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">示例 <span class="hljs-number">1</span>:<br>输入: <span class="hljs-number">2.00000</span>, <span class="hljs-number">10</span><br>输出: <span class="hljs-number">1024.00000</span><br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">示例 <span class="hljs-number">2</span>:<br>输入: <span class="hljs-number">2.10000</span>, <span class="hljs-number">3</span><br>输出: <span class="hljs-number">9.26100</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile">示例 3:<br><span class="hljs-section">输入: 2.00000, -2</span><br><span class="hljs-section">输出: 0.25000</span><br><span class="hljs-section">解释: 2-2 = 1/22 = 1/4 = 0.25</span><br></code></pre></td></tr></table></figure><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a>自解</h2><p>简单递归，一次次乘，得到结果。</p><h2 id="官方解法-快速幂算法"><a href="#官方解法-快速幂算法" class="headerlink" title="官方解法-快速幂算法"></a>官方解法-快速幂算法</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>假设我们已经得到了 $$x ^ {n / 2}$$ 的结果，现在想要计算 $$x^n$$ 的结果<br>设 A 是 $$x^{n/2}$$ 的结果，我们可以分别根据 n 的奇偶来讨论 $$x ^ n$$   </p><ul><li>如果 n 是偶数，我们可以使用公式 $$(x^n)^2 = x^{2n}$$ 得到 $$x^n = A^2$$  </li><li>如果 n 是奇数，那么 $$A^2 = x^{n-1}$$    </li></ul><p>直观地说，我们需要将另一个 x 和结果相乘，所以 $$x^n = A * A * x$$ 。这种方法可以很容易地用递归实现<br>我们称这个方法为“快速幂（Fast Power）”，因为我们最多只需要 O(log(n)) 次计算就可以得到 $$ x^n $$  </p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fastpow</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">float</span>, n: <span class="hljs-built_in">int</span></span>):</span><br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>: <br>            <span class="hljs-keyword">return</span> x<br>        <span class="hljs-keyword">return</span> self.fastpow(x, n/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span> <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> self.fastpow(x, (n-<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>)**<span class="hljs-number">2</span> * x<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">float</span>, n: <span class="hljs-built_in">int</span></span>) -&gt; float:</span><br>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span>: <br>            x = <span class="hljs-number">1</span>/x<br>            n = -n<br>        <span class="hljs-keyword">elif</span> n == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> self.fastpow(x, n)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
      <tag>快速幂算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-136. 只出现一次的数字</title>
    <link href="/post/4ce479fd/"/>
    <url>/post/4ce479fd/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。不使用额外空间来实现。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">示例 1:<br><span class="hljs-section">输入: [2,2,1]</span><br><span class="hljs-section">输出: 1</span><br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">示例 2:<br><span class="hljs-section">输入: [4,1,2,1,2]</span><br><span class="hljs-section">输出: 4</span><br></code></pre></td></tr></table></figure><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a>自解</h2><p>这次直接自解都写不出了，不用空间完全想不到。</p><h2 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a>官方解法</h2><p>对于这道题，可使用异或运算<code>⊕</code>。异或运算有以下三个性质。  </p><ol><li>任何数和<code>0</code>做异或运算，结果仍然是原来的数，即<code>a⊕0=a</code>  </li><li>任何数和其自身做异或运算，结果是<code>0</code>，即 <code>a⊕a=0</code>  </li><li>异或运算满足交换律和结合律，即<code>a⊕b⊕a</code>=<code>b⊕a⊕a</code>=<code>b⊕(a⊕a)</code>=<code>b⊕0=b</code>  </li></ol><p>假设数组中有<code>2m+1</code>个数，令<code>a1,a2...am</code>为出现两次的<code>m</code>个数，<code>an</code>为出现一次的数。<br><code>根据性质3</code>，数组中的全部元素的异或运算结果总是可以写成如下形式：  </p><center>`(a1⊕a1)⊕(a2⊕a2)⊕⋯⊕(am⊕am)⊕an`</center>根据性质 2 和性质 1，上式可化简和计算得到如下结果：<center>`0⊕0⊕⋯⊕0⊕am+1`=`an`</center>### 代码<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumber</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>]</span>) -&gt; int:</span><br>        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x, y: x ^ y, nums)<br></code></pre></td></tr></table></figure><hr><p><a href="https://leetcode-cn.com/problems/single-number/solution/zhi-chu-xian-yi-ci-de-shu-zi-by-leetcode-solution/">https://leetcode-cn.com/problems/single-number/solution/zhi-chu-xian-yi-ci-de-shu-zi-by-leetcode-solution/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
      <tag>位</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-执行Javascript代码</title>
    <link href="/post/5e6a26f5/"/>
    <url>/post/5e6a26f5/</url>
    
    <content type="html"><![CDATA[<h1 id="python-javascript"><a href="#python-javascript" class="headerlink" title="python javascript"></a>python javascript</h1><h2 id="库"><a href="#库" class="headerlink" title="库"></a>库</h2><ul><li><p>PyV8<br>V8是Google开源<code>Javascript</code>引擎，被使用在Chrome中<br>PyV8是V8引擎的Python包装，可以用来调用V8引擎执行JS代码<br>年久失修，最新版本是2010年的<br>存在内存泄漏的问题  </p></li><li><p>JsPy<br>纯<code>Python</code>实现的<code>Javascript</code>解释器和翻译器<br>issues里有很多bug未修复<br>解释器 性能不高，存在BUG<br>翻译器 对于高度混淆大型<code>Javascript</code>会转换失败，转换出来的代码可读性差，性能不高  </p></li><li><p>PyMiniRacer<br>PyMiniRacer是V8引擎的Python包装，可以用来调用V8引擎执行JS代码<br>继任<code>PyExecJS</code>和<code>PyV8</code>的库  </p></li><li><p>PyExecJS<br>最开始诞生在Ruby中的库，后来被移植到了Python上<br>有多个引擎可选，一般选Node.js,因为比较快<br>执行大型js代码稍慢<br>特殊编码的输入或输出会出现报错，可以将输入输出参数使用Base64编码一下  </p></li><li><p>Selenium<br>浏览器环境<br>Selenium有一个执行js的函数，是一个Web自动化测试工具<br><code>browser.execute_script(js)</code><br>可以运用此函数进行js运行  </p></li><li><p>Pyppeteer<br>浏览器环境<br><code>Puppeteer</code>的Python版本，由第三方开发，是一个Web自动化测试框架<br>原生支持以协程的方式调用，性能比<code>Selenium</code>高<br>对于用<code>Asyncio</code> + <code>Aiohttp</code>写爬虫而言的人可以直接使用</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">await</span> page.evaluate(js, *<span class="hljs-class"><span class="hljs-keyword">data</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>NodeJS<br>执行速度快</p><ul><li>RPC<br>写一个简单的RPC服务接口，然后在python调用nodeJS的RPC服务，拿到结果  </li><li>HTTP API<br>与写后端代码一样，提供一个可执行JS的HTTP API，通过调用API来执行JS获得结果  <blockquote><p>Node.js对象没有浏览器才有的window对象，如果需要使用，可以直接建立对象，也可以使用sjdom这个库<br>window.btoa在nodejs中不存在，可以使用Buffer.from(‘..’).toString(‘base64’)解决</p></blockquote></li></ul></li></ul><h1 id="python-执行-javascript"><a href="#python-执行-javascript" class="headerlink" title="python 执行 javascript"></a>python 执行 javascript</h1><h2 id="PyExecJS"><a href="#PyExecJS" class="headerlink" title="PyExecJS"></a>PyExecJS</h2><p>需要注意，这是单独的js运行，并没有浏览器参数<br>如果js中一些内容引用到了浏览器参数，很可能会报错  </p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><h4 id="安装js运行环境"><a href="#安装js运行环境" class="headerlink" title="安装js运行环境"></a>安装js运行环境</h4><p>推荐安装Node.js  </p><h4 id="配置Node-js"><a href="#配置Node-js" class="headerlink" title="配置Node.js"></a>配置Node.js</h4><h5 id="修改包路径与cache路径"><a href="#修改包路径与cache路径" class="headerlink" title="修改包路径与cache路径"></a>修改包路径与cache路径</h5><p>cmd中输入</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span><span class="hljs-built_in"> prefix </span><span class="hljs-string">&quot;F:\Environment\Node_js\node_global&quot;</span><br>npm<span class="hljs-built_in"> config </span><span class="hljs-builtin-name">set</span> chche <span class="hljs-string">&quot;F:\Environment\Node_js\node_cache&quot;</span><br></code></pre></td></tr></table></figure><h4 id="安装PyExecJS"><a href="#安装PyExecJS" class="headerlink" title="安装PyExecJS"></a>安装PyExecJS</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> pyexecjs<br></code></pre></td></tr></table></figure><h4 id="检验安装是否成功"><a href="#检验安装是否成功" class="headerlink" title="检验安装是否成功"></a>检验安装是否成功</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> execjs<br>print(<span class="hljs-string">&quot;如果装了Node.js, 会显示 Node.js&quot;</span>, execjs.get().name)<br>js_text = <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">function hello_world()&#123;</span><br><span class="hljs-string">    return &quot;Hello World&quot;;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#x27;&#x27;&#x27;</span><br>ctx = execjs.<span class="hljs-built_in">compile</span>(js_text)  <span class="hljs-comment"># 编译js代码</span><br>a = ctx.call(<span class="hljs-string">&#x27;hello_world&#x27;</span>)<br>print(a)<br></code></pre></td></tr></table></figure><p>运行代码，若是正确显示Hello World则成功</p><h3 id="gbk编码问题"><a href="#gbk编码问题" class="headerlink" title="gbk编码问题"></a>gbk编码问题</h3><p><img src="/Python-%E6%89%A7%E8%A1%8CJavascript%E4%BB%A3%E7%A0%81/20200813120730107.png"><br>其默认编码格式是跟随系统的<br>也就是说，windows下如果你不做设定，那么会是<code>gbk</code><br><code>gbk</code>碰到一些奇怪的字符就会不能编码<br>寻找构造函数，将编码默认值设定为<code>utf-8</code><br><img src="/Python-%E6%89%A7%E8%A1%8CJavascript%E4%BB%A3%E7%A0%81/20200813120845387.png"><br>这样实际上是修改了包的源码，在其他系统上跑的话需要多加留意  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Javascript</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Anaconda</title>
    <link href="/post/5c8e05d2/"/>
    <url>/post/5c8e05d2/</url>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h2 id="Centos7"><a href="#Centos7" class="headerlink" title="Centos7"></a>Centos7</h2><p>由于国内去Anaconda官网下载卡到了极点<br>这里用的是国内的镜像<br><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a><br>用浏览器打开，根据需要下载对应版本<br><img src="/Anaconda/20200323112051141.png">  </p><p>下载好了以后在对应的地方  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bash 下载下来的文件的文件名.sh<br></code></pre></td></tr></table></figure><p>接下来按照提示安装  </p><ol><li><p>询问协议<br>首先会问你是否同意协议<br>回答一个yes就是  </p></li><li><p>询问安装路径<br><img src="/Anaconda/20200324123320174.png"><br>我强烈建议你不要按照它默认给的路径安装在root下<br>会出很多问题  </p></li><li><p>询问是否添加环境变量<br><img src="/Anaconda/20200324123620201.png"><br>没什么如果没有什么情况的话，直接用这个默认环境变量也行  </p><blockquote><p>需要注意的是，此处添加环境变量的话会导致<code>tigerVNC</code>出现问题，若需要使用tigerVNC,建议手动设置环境变量  </p></blockquote></li><li><p>询问是否要安装VSCode<br><img src="/Anaconda/20200324123925652.png"><br>根据需要来  </p></li></ol><h2 id="手动添加环境变量"><a href="#手动添加环境变量" class="headerlink" title="手动添加环境变量"></a>手动添加环境变量</h2><ol><li>进入环境变量文件夹  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cd <span class="hljs-regexp">/etc/</span>profile.d<br></code></pre></td></tr></table></figure></li><li>创建环境变量文件  <figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">sudo vim <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Anaconda</span>.</span></span>sh<br></code></pre></td></tr></table></figure></li><li>编写环境变量<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># set Anaconda environment</span><br>PATH=<span class="hljs-variable">$PATH</span><span class="hljs-symbol">:/home/manager/anaconda3/bin</span><br>export PATH<br></code></pre></td></tr></table></figure> 注意对应自己的安装路径，写完<code>:wq</code>保存退出  </li><li>打开新的控制台测试  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda</span><br></code></pre></td></tr></table></figure>看到一堆命令提示就代表成功</li></ol><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="启动GUI"><a href="#启动GUI" class="headerlink" title="启动GUI"></a>启动GUI</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">anaconda-navigator<br></code></pre></td></tr></table></figure><p>并不允许用root账户打开</p><h3 id="更新Anaconda"><a href="#更新Anaconda" class="headerlink" title="更新Anaconda"></a>更新Anaconda</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda update conda<br>conda update anaconda<br></code></pre></td></tr></table></figure><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p><span id="delete_evm"></span></p><ol><li>去除环境变量 <ol><li>在根目录下输入：sudo gedit ~/.bashrc</li><li>在.bashrc文件末尾用#号注释掉之前添加的路径(或直接删除)： <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;/root/anaconda2/bin:<span class="hljs-variable">$PATH</span>&quot;</span></span><br></code></pre></td></tr></table></figure></li><li>使其立即生效，执行：source ~/.bashrc</li><li>关闭终端，重新启动一个终端，不然原终端上还是绑定有anaconda。</li></ol></li><li>删除Anconda安装文件夹</li></ol><h2 id="环境管理"><a href="#环境管理" class="headerlink" title="环境管理"></a>环境管理</h2><h3 id="创建新环境"><a href="#创建新环境" class="headerlink" title="创建新环境"></a>创建新环境</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> create -n 新环境名称 python=<span class="hljs-number">3</span>.<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>python版本号不输入的话就会弄<code>Anaconda</code>里最新的  </p><blockquote><p>如果在env文件夹里找不到python环境，可以试着在创建环境的时候指定一个python版本  </p></blockquote><h3 id="查看已有的环境"><a href="#查看已有的环境" class="headerlink" title="查看已有的环境"></a>查看已有的环境</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">conda</span> <span class="hljs-literal">info</span> -e<br></code></pre></td></tr></table></figure><h3 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">conda <span class="hljs-built_in">activate</span> 环境名<br></code></pre></td></tr></table></figure><h3 id="关闭环境"><a href="#关闭环境" class="headerlink" title="关闭环境"></a>关闭环境</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">conda deactivate</span><br></code></pre></td></tr></table></figure><h3 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h3><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua">conda <span class="hljs-built_in">remove</span> -n 环境名 <span class="hljs-comment">--all</span><br></code></pre></td></tr></table></figure><h3 id="复制环境"><a href="#复制环境" class="headerlink" title="复制环境"></a>复制环境</h3><h4 id="在本机上复制既有环境"><a href="#在本机上复制既有环境" class="headerlink" title="在本机上复制既有环境"></a>在本机上复制既有环境</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">conda create -n 新环境名 --<span class="hljs-keyword">clone</span> <span class="hljs-title">旧环境名</span><br></code></pre></td></tr></table></figure><h3 id="环境重命名"><a href="#环境重命名" class="headerlink" title="环境重命名"></a>环境重命名</h3><p>没有这个功能，如果需要重命名的话，利用复制和删除进行操作</p><h3 id="导出-导入环境"><a href="#导出-导入环境" class="headerlink" title="导出/导入环境"></a>导出/导入环境</h3><h4 id="导出环境"><a href="#导出环境" class="headerlink" title="导出环境"></a>导出环境</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">conda <span class="hljs-keyword">env</span> export &gt; <span class="hljs-keyword">env</span>.yaml<br></code></pre></td></tr></table></figure><p>利用<code>conda env export</code> 导出的是个yaml格式的文件，该文件记录了环境名，软件源地址以及安装包列表  </p><h4 id="导入环境"><a href="#导入环境" class="headerlink" title="导入环境"></a>导入环境</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">conda <span class="hljs-keyword">env</span> create -f <span class="hljs-keyword">env</span>.yaml<br></code></pre></td></tr></table></figure><p>在新的机器中可直接执行上述命令，生成的环境与复制源完全一样（包括环境名），如果想在同一台机器上复制，需要把yaml文件中的环境名修改为一个新的名字，否则会冲突  </p><blockquote><p>实际上，这东西及其不靠谱，因为要是需要的包在Anaconda官网里没有标注，直接就安装不了，报错  </p></blockquote><blockquote><p>建议还是使用老方法安装，在激活环境后通过pip安装</p></blockquote><h4 id="pip-环境转移"><a href="#pip-环境转移" class="headerlink" title="pip 环境转移"></a>pip 环境转移</h4><p>导出依赖到<code>requirements.txt</code><br><code>pip freeze &gt; requirements.txt</code><br>从<code>requirements.txt</code>导入<br><code>pip install -r requirement.txt</code></p><h4 id="pip源"><a href="#pip源" class="headerlink" title="pip源"></a>pip源</h4><ol><li><code>.pip</code>目录下创建一个<code>pip.conf</code>文件  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir ~/.pip<br><span class="hljs-built_in">cd</span> ~/.pip<br>touch pip.conf<br></code></pre></td></tr></table></figure></li><li>编辑 <code>pip.conf</code> 文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim ~/.pip/pip.conf<br></code></pre></td></tr></table></figure>填入源的信息  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">[<span class="hljs-keyword">global</span>] <br><span class="hljs-keyword">index</span>-url = https://pypi.tuna.tsinghua.edu.cn/simple<br>[install]<br><span class="hljs-keyword">trusted</span>-host = https://pypi.tuna.tsinghua.edu.cn  # <span class="hljs-keyword">trusted</span>-host 此参数是为了避免麻烦，否则使用的时候可能会提示不受信任<br></code></pre></td></tr></table></figure>保存修改  </li></ol><h3 id="env目录下没有Python解释器"><a href="#env目录下没有Python解释器" class="headerlink" title="env目录下没有Python解释器"></a>env目录下没有Python解释器</h3><p>如果在创建环境的时候没有指定<code>Python</code>环境版本，那么<code>anaconda/env/环境文件夹</code>下就不会有<code>Python</code>解释器<br>你可以给它装一个解释器  </p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">conda <span class="hljs-keyword">install</span> -n 环境名 python<br></code></pre></td></tr></table></figure><p>虽然这样做就有解释器了，但是这个新的解释器里面并没有以前安装的包<br>所以需要将包目录记录下来重新安装  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Anaconda</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-面试题57. 和为s的两个数字</title>
    <link href="/post/7dbc971/"/>
    <url>/post/7dbc971/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><h3 id="示例-1："><a href="#示例-1：" class="headerlink" title="示例 1："></a>示例 1：</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[2,7,11,15]</span>, target = 9<br>输出：<span class="hljs-comment">[2,7]</span> 或者 <span class="hljs-comment">[7,2]</span><br></code></pre></td></tr></table></figure><h3 id="示例-2："><a href="#示例-2：" class="headerlink" title="示例 2："></a>示例 2：</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[10,26,30,31,47,60]</span>, target = 40<br>输出：<span class="hljs-comment">[10,30]</span> 或者 <span class="hljs-comment">[30,10]</span><br></code></pre></td></tr></table></figure><h4 id="限制："><a href="#限制：" class="headerlink" title="限制："></a>限制：</h4><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>&lt;= nums.length &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span>&lt;= nums[i] &lt;= <span class="hljs-number">10</span>^<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a>自解</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>从后往前，先确定比较大的那个数，这样能较快的减少无用状态<br>由于只有两个数，确定了比较大的数以后，与目标相减一下就能得到结果，判断一下这个结果是否在记录中即可。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; List[int]:</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(nums)-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-keyword">if</span> nums[i] &gt; target:<br>                <span class="hljs-keyword">continue</span><br>            <span class="hljs-keyword">if</span> target-nums[i] <span class="hljs-keyword">in</span> nums:<br>                <span class="hljs-keyword">return</span> nums[i], target-nums[i]<br></code></pre></td></tr></table></figure><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><p>执行用时：192 ms<br>内存消耗：24.9 MB</p><h2 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a>大佬解法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>利用 <code>HashMap</code> 可以通过遍历数组找到数字组合，时间和空间复杂度均为 <code>O(N)</code><br>注意本题的 <code>nums</code> 是 排序数组 ，因此可使用 <code>双指针法</code> 将空间复杂度降低至 <code>O(1)</code></p><h3 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h3><p>初始化： 双指针 <code>i</code>, <code>j</code>分别指向数组 <code>nums</code> 的左右两端 （俗称对撞双指针）<br>循环搜索： 当双指针相遇时跳出；<br>计算和 <code>s = nums[i] + nums[j]</code></p><ul><li>若 <code>s&gt;target</code><br>指针 <code>j</code> 向左移动，即执行 <code>j=j−1</code></li><li>若 <code>s&lt;target</code><br>指针 <code>i</code> 向右移动，即执行 <code>i=i+1</code></li><li>若 <code>s=target</code><br>立即返回数组 <code>[nums[i],nums[j]]</code></li></ul><p>返回空数组，代表无和为<code>target</code>的数字组合。</p><p>正确性证明：</p><blockquote><p>记每个状态为 <code>S(i,j)</code>，即 <code>S(i,j)=nums[i]+nums[j]</code><br>假设 <code>S(i,j)&lt;targetS(i, j)</code>，则执行 <code>i=i+1</code>，即状态切换至 <code>S(i+1,j)</code></p></blockquote><p><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%9857.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/20200518022012071.png"></p><ul><li>状态 <code>S(i,j)</code> 切换至 <code>S(i+1,j)</code> ，则会消去一行元素，相当于 消去了状态集合 <code>&#123;S(i,i+1),S(i,i+2),...,S(i,j−2),S(i,j−1),S(i,j)&#125;</code><br>（由于双指针都是向中间收缩，因此这些状态之后不可能再遇到）。</li><li>由于 <code>nums</code> 是排序数组，因此这些 消去的状态 都一定满足 <code>S(i,j)&lt;target</code>，即这些状态都 不是解 。</li></ul><p>结论： 以上分析已证明 “每次指针 <code>i</code> 的移动操作，都不会导致解的丢失” ，即指针 <code>i</code> 的移动操作是 安全的；同理，对于指针 <code>j</code> 可得出同样推论；因此，此双指针法是正确的。</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span>(<span class="hljs-params">self, nums: List[<span class="hljs-built_in">int</span>], target: <span class="hljs-built_in">int</span></span>) -&gt; List[int]:</span><br>        i, j = <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(nums) - <span class="hljs-number">1</span><br>        <span class="hljs-keyword">while</span> i &lt; j:<br>            s = nums[i] + nums[j]<br>            <span class="hljs-keyword">if</span> s &gt; target: j -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">elif</span> s &lt; target: i += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>: <span class="hljs-keyword">return</span> nums[i], nums[j]<br>        <span class="hljs-keyword">return</span> []<br></code></pre></td></tr></table></figure><h3 id="效率-1"><a href="#效率-1" class="headerlink" title="效率"></a>效率</h3><p>执行用时：148 ms<br>内存消耗：24.8 MB</p><hr><p>来源：</p><ul><li>大佬解法：<br>作者：jyd<br>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/solution/mian-shi-ti-57-he-wei-s-de-liang-ge-shu-zi-shuang-/">https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/solution/mian-shi-ti-57-he-wei-s-de-liang-ge-shu-zi-shuang-/</a></li><li>leecode题目：<br><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/">https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
      <tag>对撞双指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mysql-CentOS</title>
    <link href="/post/56628b65/"/>
    <url>/post/56628b65/</url>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Centos7.4 腾讯云服务器</li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="一、添加yum源"><a href="#一、添加yum源" class="headerlink" title="一、添加yum源"></a>一、添加yum源</h2><ol><li><p>mysql的官网下载yum repo配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://dev.mysql.com/get/mysql57-community-release-el7-9.noarch.rpm<br></code></pre></td></tr></table></figure></li><li><p>安装repo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -ivh mysql57-community-release-el7-9.noarch.rpm<br></code></pre></td></tr></table></figure><h2 id="二、安装"><a href="#二、安装" class="headerlink" title="二、安装"></a>二、安装</h2><h3 id="原生mysql安装"><a href="#原生mysql安装" class="headerlink" title="原生mysql安装"></a>原生mysql安装</h3></li><li><p>yum安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install mysql-server<br></code></pre></td></tr></table></figure></li><li><p>启动mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start mysqld <br></code></pre></td></tr></table></figure></li><li><p>临时密码获取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">grep <span class="hljs-string">&#x27;temporary password&#x27;</span> /var/<span class="hljs-built_in">log</span>/mysqld.log<br></code></pre></td></tr></table></figure></li><li><p>重启mysql</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start mysqld<br></code></pre></td></tr></table></figure></li><li><p>临时登录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p<br></code></pre></td></tr></table></figure><p> 然后输入密码（刚刚获取的临时密码）</p></li><li><p>修改root密码</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ALTER USER <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED BY <span class="hljs-string">&#x27;新的密码&#x27;</span>; <br></code></pre></td></tr></table></figure><p> 设置一个大小写字母，特殊字符，数字都有的，比较长的密码即可</p></li></ol><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><p>首先你需要有<code>Docker</code>环境</p><a href="#">Post not found: CentOS-Docker</a><ol><li><p>拉取镜像  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull mysql <span class="hljs-number">5</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p> 你可以指定版本号，也可以不指定（默认最新版）<br> 拉取完毕后看看是否有了镜像  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker images</span><br></code></pre></td></tr></table></figure></li><li><p>创建容器  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -p <span class="hljs-number">3307</span>:<span class="hljs-number">3306</span> --name mysql -e MYSQL_ROOT_PASSWORD=起始mysql-root用户密码 -d mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><ul><li>–name : 容器名，此处命名为<code>mysql</code>  </li><li>-e：配置信息，此处配置了<code>mysql</code>的<code>root</code>用户登录密码  </li><li>-p端口映射：此处主机 3307端口 到 容器的3306端口  </li><li>-d：镜像名，如果没有指定版本，就不用填写版本信息  </li></ul></li><li><p>建立目录映射(不建议建立)  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">duso docker run -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> --name mysql \<br>-v <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/docker/my</span>sql<span class="hljs-regexp">/conf:/</span>etc/mysql \<br>-v <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/docker/my</span>sql<span class="hljs-regexp">/logs:/</span>var<span class="hljs-regexp">/log/my</span>sql \<br>-v <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/docker/my</span>sql<span class="hljs-regexp">/data:/</span>var<span class="hljs-regexp">/lib/my</span>sql \<br>-e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> \<br>-d mysql:<span class="hljs-number">5.7</span><br></code></pre></td></tr></table></figure><ul><li>-v：主机和容器的目录映射关系，”:”前为主机目录，之后为容器目录  </li></ul></li><li><p>查看容器是否已经正常运行  </p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">docker <span class="hljs-keyword">container</span> <span class="hljs-keyword">ls</span><br></code></pre></td></tr></table></figure><p> 可以看到容器ID，容器的源镜像，启动命令，创建时间，状态，端口映射信息，容器名字</p></li><li><p>连接容器，输入用户/密码,进入mysql  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> mysql bash<br>mysql -u用户名 -p密码<br></code></pre></td></tr></table></figure><h2 id="配置mysql"><a href="#配置mysql" class="headerlink" title="配置mysql"></a>配置mysql</h2><h3 id="开启远程控制"><a href="#开启远程控制" class="headerlink" title="开启远程控制"></a>开启远程控制</h3></li><li><p>登录数据库  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p<br></code></pre></td></tr></table></figure></li><li><p>进去mysql数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use mysql;<br></code></pre></td></tr></table></figure></li><li><p>创建用户(可选操作)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create user &#39;用户名&#39;@&#39;用户的HOST&#39; identified by &#39;密码&#39;;<br></code></pre></td></tr></table></figure><p> 如果想要任意客户端都可以访问的话，给<code>HOST</code>设置一个<code>%</code>即可，也可以输入ip<br> 如果选择创建用户的话后面的步骤就可以跳过了</p></li><li><p>查看user表中的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select Host, User from user;<br></code></pre></td></tr></table></figure><p> 观察显示的数据<code>Host</code>代表许可ip，<code>%</code>代表任意</p></li><li><p>修改访问许可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update user set Host&#x3D;&#39;%&#39; where User&#x3D;&#39;root&#39;;  <br></code></pre></td></tr></table></figure><p> 这里是将<code>root</code>用户修改为任意ip都可以访问</p></li><li><p>刷新权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">flush privileges;<br></code></pre></td></tr></table></figure><h3 id="Navicat连接报错2059"><a href="#Navicat连接报错2059" class="headerlink" title="Navicat连接报错2059"></a>Navicat连接报错2059</h3><p><code>Navicat</code>不支持<code>MySQL</code>新版本的默认加密方式<code>caching_sha2_password</code>导致报错  </p></li><li><p>查看<code>mysql</code>用户信息  </p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> host, <span class="hljs-keyword">user</span>, plugin <span class="hljs-keyword">from</span> mysql.<span class="hljs-keyword">user</span>;<br></code></pre></td></tr></table></figure><p> <img src="/Mysql-CentOS/20200911105251476.png"><br> 可以查看到，其加密方式为<code>caching_sha2_password</code>  </p></li><li><p>修改加密方式  </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;用户名&#x27;</span>@<span class="hljs-string">&#x27;用户的Host&#x27;</span> <span class="hljs-keyword">IDENTIFIED</span> <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;用户的密码&#x27;</span>;<br></code></pre></td></tr></table></figure><p> <code>caching_sha2_password</code>这种加密方式<code>Navicat</code>不支持<br> 将它改为<code>Navicat</code>支持的<code>mysql_native_password</code> </p></li></ol><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h2><ul><li>用户对某个数据库内的所有表 增删改查权限<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span>, <span class="hljs-keyword">insert</span>, <span class="hljs-keyword">update</span>, <span class="hljs-keyword">delete</span> <span class="hljs-keyword">on</span> 数据库名.* <span class="hljs-keyword">to</span> 用户名@<span class="hljs-string">&#x27;用户Host&#x27;</span>  <br></code></pre></td></tr></table></figure></li></ul><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="mysql服务"><a href="#mysql服务" class="headerlink" title="mysql服务"></a>mysql服务</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start mysqld  <span class="hljs-comment"># 启动mysql服务</span><br>systemctl stop mysqld  <span class="hljs-comment"># 关闭mysql服务</span><br>systemctl restart mysqld  <span class="hljs-comment"># 重启 mysql服务</span><br>systemctl status mysqld  <span class="hljs-comment"># 查看mysql服务运行状态</span><br>systemctl <span class="hljs-built_in">enable</span> mysqld   <span class="hljs-comment"># 开机启动mysql</span><br>systemctl <span class="hljs-built_in">disable</span> mysqld    <span class="hljs-comment"># 关闭开机启动mysql</span><br></code></pre></td></tr></table></figure><h2 id="查看mysql版本"><a href="#查看mysql版本" class="headerlink" title="查看mysql版本"></a>查看mysql版本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select version();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCode-IDE</title>
    <link href="/post/e2c5bfe8/"/>
    <url>/post/e2c5bfe8/</url>
    
    <content type="html"><![CDATA[<h1 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h1><p>轻量级，相当于notepad++加强版，很多东西要自己配，各种平台均可用  </p><h2 id="地址"><a href="#地址" class="headerlink" title="地址"></a>地址</h2><p>官方文档：<a href="https://code.visualstudio.com/docs/setup/linux">https://code.visualstudio.com/docs/setup/linux</a><br>下载地址：<a href="https://visualstudio.microsoft.com/zh-hans/">https://visualstudio.microsoft.com/zh-hans/</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>直接使用安装包即可  </p><h3 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h3><p><a href="https://code.visualstudio.com/docs/setup/linux">https://code.visualstudio.com/docs/setup/linux</a><br>已经将 稳定的64位的VSCode放在了yum里了<br>你可以用下面的代码安装秘钥和库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc<br><br>sudo sh -c <span class="hljs-string">&#x27;echo -e &quot;[code]\nname=Visual Studio Code\nbaseurl=https://packages.microsoft.com/yumrepos/vscode\nenabled=1\ngpgcheck=1\ngpgkey=https://packages.microsoft.com/keys/microsoft.asc&quot; &gt; /etc/yum.repos.d/vscode.repo&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>安装方法一：用<code>dnf</code>,更新cache包,安装对应的包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo dnf check-update<br>sudo dnf install code<br></code></pre></td></tr></table></figure></li><li>安装方法二：用<code>yum</code>,更新cache包,安装对应的包<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum check-update<br>sudo yum install code<br></code></pre></td></tr></table></figure>需要注意的是，用<code>yum</code>安装的话，<code>VSCode</code>的版本可能会滞后。</li></ul><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><table><thead><tr><th>键位</th><th>作用</th></tr></thead><tbody><tr><td><code>Ctrl</code> <code>/</code></td><td>注释代码</td></tr><tr><td><code>Ctrl</code> <code>[</code></td><td>代码行向左缩进</td></tr><tr><td><code>Ctrl</code> <code>]</code></td><td>代码行向左缩进</td></tr><tr><td><code>Shift</code> <code>Alt</code> <code>F</code></td><td>代码格式化</td></tr><tr><td><code>Shift</code> <code>F12</code></td><td>找到所有的引用</td></tr><tr><td><code>F11</code></td><td>全屏显示(再次按则恢复)</td></tr><tr><td><code>Ctrl</code> <code>S</code></td><td>保存</td></tr><tr><td><code>F1</code></td><td>打开VSCode命令面板</td></tr></tbody></table><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p><img src="/VSCode/20200429062729159.png"><br>安装插件简单三步：点插件，输入插件名称，点击安装  </p><h3 id="常用插件"><a href="#常用插件" class="headerlink" title="常用插件"></a>常用插件</h3><table><thead><tr><th>插件名</th><th>作用</th></tr></thead><tbody><tr><td>Chinese (Simplified) Language Pack for Visual Studio Code</td><td>界面汉化</td></tr><tr><td>Beautify</td><td>美化javascript, JSON, CSS, Sass，和HTML代码</td></tr><tr><td>GitLens — Git supercharged</td><td>增强git在Visual Studio中的功能</td></tr><tr><td>vscode-icons</td><td>在Visual Studio文件浏览中加入图标，方便识别</td></tr><tr><td>Python</td><td>python运行环境插件</td></tr><tr><td>Import Cost</td><td>可以计算import的消耗</td></tr><tr><td>RegExp Preview and Editor</td><td>正则表达式可视化处理工具</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>VSCode</tag>
      
      <tag>IDE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-基础-Spider内不同级别parse传递参数</title>
    <link href="/post/8eafb108/"/>
    <url>/post/8eafb108/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>并不是每一个网站都将你想要的所有信息放在最内层页面的<br>可能需要在不同层级的请求中获取不同的参数，共同组成最后的<code>item</code>。<br>如果不懂得在不同层级的<code>parse</code>中传递参数，那么最后的<code>item</code>会缺失一些信息。</p><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><p><code>Spider</code>的<code>Request</code>请求经过处理后，最终会返回一个<code>Response</code>，被回调函数<code>callback</code>处理  </p><p>如果想要传递数据，有两种处理方式：  </p><ul><li>在<code>Request</code>中添加<code>meta</code>参数（官方不推荐）  </li><li>使用<code>Request</code>的<code>cb_kwargs</code>属性  </li></ul><h2 id="使用meta参数"><a href="#使用meta参数" class="headerlink" title="使用meta参数"></a>使用meta参数</h2><p>我们可以在<code>Request</code>中添加<code>meta</code>参数，记录需要传递的信息<br><code>meta</code>参数所附带的信息最终会被<code>Response</code>返回<br><code>meta</code>参数可传递 简单类型参数 或 对象类型参数  </p><blockquote><p>案例：使用<code>Request</code>的<code>meta</code>参数传递数据  </p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, response)</span></span><span class="hljs-symbol">:</span><br>    item = MyItem()<br>    item[<span class="hljs-string">&#x27;id&#x27;</span>] = response.xpath(<span class="hljs-string">&#x27;//h1/text()&#x27;</span>).extract()[<span class="hljs-number">0</span>]<br>    <br>    <span class="hljs-keyword">for</span> item_url <span class="hljs-keyword">in</span> <span class="hljs-symbol">item_urls:</span><br>        <span class="hljs-comment"># meta 参数传递</span><br>        <span class="hljs-keyword">yield</span> Request(url=item_url, callback=<span class="hljs-keyword">self</span>.parse_deeper, meta=&#123;<span class="hljs-string">&#x27;item&#x27;</span>: item&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_deeper</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, response)</span></span><span class="hljs-symbol">:</span><br>    <span class="hljs-comment"># 获取meta记录</span><br>    item = response.meta[<span class="hljs-string">&#x27;item&#x27;</span>]<br>    item[<span class="hljs-string">&#x27;name&#x27;</span>] = response.xpath(<span class="hljs-string">&#x27;//p/text()&#x27;</span>).extract()[<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">yield</span> item<br></code></pre></td></tr></table></figure><h2 id="使用Request的cb-kwargs属性"><a href="#使用Request的cb-kwargs属性" class="headerlink" title="使用Request的cb_kwargs属性"></a>使用<code>Request</code>的<code>cb_kwargs</code>属性</h2><p>将需要传递的内容用<code>Request</code>的<code>cb_kwargs</code>属性保存<br>待到下级解析的时候，从参数中获取即可  </p><blockquote><p>案例：使用<code>Request</code>的<code>cb_kwargs</code>属性传递数据  </p></blockquote><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, response)</span></span><span class="hljs-symbol">:</span><br>    request = scrapy.Request(<span class="hljs-string">&#x27;http://www.example.com/index.html&#x27;</span>,<br>                             callback=<span class="hljs-keyword">self</span>.parse_page2,<br>                             cb_kwargs=dict(main_url=response.url))<br>    <span class="hljs-comment"># cb_kwargs增加参数传递</span><br>    request.cb_kwargs[<span class="hljs-string">&#x27;foo&#x27;</span>] = <span class="hljs-string">&#x27;bar&#x27;</span><br>    <span class="hljs-keyword">yield</span> request<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse_page2</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, response, main_url, foo)</span></span>:  <span class="hljs-comment"># 从函数参数中拿到结果</span><br>    <span class="hljs-keyword">yield</span> dict(<br>        main_url=main_url,<br>        other_url=response.url,<br>        foo=foo,<br>    )<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis-Python</title>
    <link href="/post/3b797c47/"/>
    <url>/post/3b797c47/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><h2 id="redis-py"><a href="#redis-py" class="headerlink" title="redis-py"></a>redis-py</h2><p><code>redis</code>包为<code>python</code>连接 <code>Redis</code>键值数据库 提供了接口。</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>github地址：<a href="https://github.com/andymccurdy/redis-py/">https://github.com/andymccurdy/redis-py/</a><br>一些中文函数参考：<a href="https://www.runoob.com/w3cnote/python-redis-intro.html">https://www.runoob.com/w3cnote/python-redis-intro.html</a></p><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p>Python2.7 或 Python3.5+</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install redis<br></code></pre></td></tr></table></figure><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;&gt;&gt; import redis<br>&gt;&gt;&gt; r = redis.Redis(<span class="hljs-attribute">host</span>=<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-attribute">port</span>=6379, <span class="hljs-attribute">db</span>=0)<br>&gt;&gt;&gt; r.<span class="hljs-builtin-name">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br><span class="hljs-literal">True</span><br>&gt;&gt;&gt; r.<span class="hljs-builtin-name">get</span>(<span class="hljs-string">&#x27;foo&#x27;</span>)<br>b<span class="hljs-string">&#x27;bar&#x27;</span><br></code></pre></td></tr></table></figure><p>对<code>python3.x</code>版本，默认情况下，所有的响应都会返回<code>btyes</code>类型数据<br>如果觉得所有的响应都应该被解码，可以在<code>Redis.__init__</code>填入参数<code>decode_responses=True</code>。如此一来，所有的返回都会被解码。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">r = redis.Redis(<span class="hljs-attribute">host</span>=<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-attribute">port</span>=6379, <span class="hljs-attribute">db</span>=0, <span class="hljs-attribute">decode_responses</span>=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h1 id="更多细节"><a href="#更多细节" class="headerlink" title="更多细节"></a>更多细节</h1><h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2><p>在后台，<code>redis-py</code>使用一个连接池去管理 连接到Redis服务的连接<br>默认情况下，你创建的每一个Redis实例都会拥有一个自己的连接池<br>你也可以使用 已创建的连接池实例 来进行连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pool = redis.ConnectionPool(host=<span class="hljs-string">&#x27;localhost&#x27;</span>, port=<span class="hljs-number">6379</span>, db=<span class="hljs-number">0</span>)<br>r = redis.Redis(connection_pool=pool)<br></code></pre></td></tr></table></figure><h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><p><code>ConnectionPools</code>管理一组连接实例<br><code>redis-py</code>提供两种类型的连接</p><ul><li>基于<code>TCP</code>端口的连接，默认</li><li>基于<code>Unix socket</code>文件的连接，需要redis服务器开启</li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&gt;&gt;&gt; r = redis.Redis(<span class="hljs-attribute">unix_socket_path</span>=<span class="hljs-string">&#x27;/tmp/redis.sock&#x27;</span>)<br>&gt;&gt;&gt;<span class="hljs-built_in"> pool </span>= redis.ConnectionPool(<span class="hljs-attribute">connection_class</span>=YourConnectionClass, <span class="hljs-attribute">your_arg</span>=<span class="hljs-string">&#x27;...&#x27;</span>, <span class="hljs-built_in">..</span>.)<br></code></pre></td></tr></table></figure><h2 id="定时连接检查"><a href="#定时连接检查" class="headerlink" title="定时连接检查"></a>定时连接检查</h2><p>当出现了网络问题，会抛出<code>ConnectionError</code>错误<br><code>redis-py</code>提供能定期检查连接的功能<br>你可以传递<code>health_check_interval</code>参数给<code>Redis</code>或者 <code>ConnectionPool</code>类<br><code>health_check_interval</code>参数的值必须是<code>int</code>类型</p><ul><li>0<br>默认值，关闭连接检查</li><li>一个正数整数n<br>连接检查功能启用，每过n秒检查一次连接</li></ul><h2 id="解析器类"><a href="#解析器类" class="headerlink" title="解析器类"></a>解析器类</h2><p>解析器类被用于处理从<code>Redis服务器</code>返回来的响应<br><code>redis-py</code>提供了两种解析器类型:  </p><ul><li>PythonParser  </li><li>HiredisParser  </li></ul><p>默认情况下，<code>redis-py</code>会先尝试使用<code>HiredisParser</code>，要是发现并没有安装，那么会使用<code>PythonParser</code><br>强烈建议你使用<code>HiredisParser</code>。它的解析效率比另外的那个<strong>快十倍以上</strong>。这个速度差距在进行多<code>key</code>查询的时候会更加明显。</p><blockquote><p>Hiredis是由<code>Redis</code>官方团队基于C语言编写的解析库。</p></blockquote><h3 id="Hiredis安装"><a href="#Hiredis安装" class="headerlink" title="Hiredis安装"></a>Hiredis安装</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> hiredis<br></code></pre></td></tr></table></figure><h2 id="响应回调"><a href="#响应回调" class="headerlink" title="响应回调"></a>响应回调</h2><p><code>client</code>类用一组回调 来将<code>Redis</code>响应转换为合适的python类型<br>这些回调定义在<code>Redis</code>客户端里一个叫<code>RESPONSE_CALLBACKS</code>的字典中</p><p>你可以通过<code>set_response_callback</code>方法添加自定义回调<br>这个方法接收两个参数：命令名 和 对应的回调类<br>这种修改方式仅对于被添加的的实例有效，如果你想定义一个全局的回调类，你应该修改<code>RESPONSE_CALLBACKS</code>类字典  </p><p>回调类接受至少一个参数：响应内容，关键字参数作为命令调用时的参数</p><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p><code>Redis</code>实例是线程安全的<br>但是，由于<code>Redis``SELECT</code>命令能选择当前所要使用的<code>database</code>。每次选择<code>database</code>过后。当前选择的<code>database</code>会被保留下来，直到选择另一个<code>database</code>或者关闭连接<br>因此，<code>redis-py</code>没有在客户端实现实现<code>SELECT</code>命令。因为它可能会导致数据库的切换。</p><p>如果你在同一个程序中使用多个<code>Redis``databases</code>，你应该为每一个数据库创建一个单独的实例（或连接池）</p><h2 id="Pipelines"><a href="#Pipelines" class="headerlink" title="Pipelines"></a>Pipelines</h2><p><code>Pipelines</code>是<code>Redis</code>类的一个子类，支持缓存多个命令，然后作为单个请求发送。通过减少TCP请求次数来达到提供性能的目的。<br><code>Pipelines</code>简单使用例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>r = redis.Redis(...)<br><span class="hljs-meta">&gt;&gt;&gt; </span>r.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;bing&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># Use the pipeline() method to create a pipeline instance</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe = r.pipeline()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># The following SET commands are buffered</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe.get(<span class="hljs-string">&#x27;bing&#x27;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># the EXECUTE call sends all buffered commands to the server, returning</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-comment"># a list of responses, one for each command.</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>pipe.execute()<br>[<span class="hljs-literal">True</span>, <span class="hljs-string">b&#x27;baz&#x27;</span>]<br></code></pre></td></tr></table></figure><p><code>Pipelines</code>的实现采用流式<code>API</code>，故而你可以采用以下链式调用的方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pipe.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-string">&#x27;bar&#x27;</span>).sadd(<span class="hljs-string">&#x27;faz&#x27;</span>, <span class="hljs-string">&#x27;baz&#x27;</span>).incr(<span class="hljs-string">&#x27;auto_number&#x27;</span>).execute()<br>[<span class="hljs-literal">True</span>, <span class="hljs-literal">True</span>, <span class="hljs-number">6</span>]<br></code></pre></td></tr></table></figure><p><code>Pipelines</code>默认以原子性(事务)的形式执行所有缓存的命令,你也可以禁用这一行为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>pipe = r.pipeline(transaction=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><p><code>WATCH</code>命令提供了在事务之前检测一个或多个<code>key</code>值的变化。一旦在事务执行之前，某个值发生了变化，那么事务将被取消然后抛出<code>WatchError</code> 异常。<br>利用<code>watch</code>我们可以实现<code>client-side incr</code>命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">with</span> r.pipeline() <span class="hljs-keyword">as</span> pipe:<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">try</span>:<br><span class="hljs-meta">... </span>            <span class="hljs-comment"># put a WATCH on the key that holds our sequence value</span><br><span class="hljs-meta">... </span>            pipe.watch(<span class="hljs-string">&#x27;OUR-SEQUENCE-KEY&#x27;</span>)<br><span class="hljs-meta">... </span>            <span class="hljs-comment"># after WATCHing, the pipeline is put into immediate execution</span><br><span class="hljs-meta">... </span>            <span class="hljs-comment"># mode until we tell it to start buffering commands again.</span><br><span class="hljs-meta">... </span>            <span class="hljs-comment"># this allows us to get the current value of our sequence</span><br><span class="hljs-meta">... </span>            current_value = pipe.get(<span class="hljs-string">&#x27;OUR-SEQUENCE-KEY&#x27;</span>)<br><span class="hljs-meta">... </span>            next_value = <span class="hljs-built_in">int</span>(current_value) + <span class="hljs-number">1</span><br><span class="hljs-meta">... </span>            <span class="hljs-comment"># now we can put the pipeline back into buffered mode with MULTI</span><br><span class="hljs-meta">... </span>            pipe.multi()<br><span class="hljs-meta">... </span>            pipe.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;OUR-SEQUENCE-KEY&#x27;</span>, next_value)<br><span class="hljs-meta">... </span>            <span class="hljs-comment"># and finally, execute the pipeline (the set command)</span><br><span class="hljs-meta">... </span>            pipe.execute()<br><span class="hljs-meta">... </span>            <span class="hljs-comment"># if a WatchError wasn&#x27;t raised during execution, everything</span><br><span class="hljs-meta">... </span>            <span class="hljs-comment"># we just did happened atomically.</span><br><span class="hljs-meta">... </span>            <span class="hljs-keyword">break</span><br><span class="hljs-meta">... </span>       <span class="hljs-keyword">except</span> WatchError:<br><span class="hljs-meta">... </span>            <span class="hljs-comment"># another client must have changed &#x27;OUR-SEQUENCE-KEY&#x27; between</span><br><span class="hljs-meta">... </span>            <span class="hljs-comment"># the time we started WATCHing it and the pipeline&#x27;s execution.</span><br><span class="hljs-meta">... </span>            <span class="hljs-comment"># our best bet is to just retry.</span><br><span class="hljs-meta">... </span>            <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure><p>有一个非常方便的方法<code>transaction</code>方法来简化这一操作：它包含<code>handling and retrying watch errors</code>的样板代码。第一参数为<code>callable</code>(这个<code>callable</code>只能接受一个<code>Pipeline</code>参数),及多个需要被<code>WATCH</code>的<code>keys</code></p><figure class="highlight python-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python-repl"><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">client_side_incr</span>(<span class="hljs-params">pipe</span>):</span></span><br><span class="hljs-meta">...</span> <span class="python">    current_value = pipe.get(<span class="hljs-string">&#x27;OUR-SEQUENCE-KEY&#x27;</span>)</span><br><span class="hljs-meta">...</span> <span class="python">    next_value = <span class="hljs-built_in">int</span>(current_value) + <span class="hljs-number">1</span></span><br><span class="hljs-meta">...</span> <span class="python">    pipe.multi()</span><br><span class="hljs-meta">...</span> <span class="python">    pipe.<span class="hljs-built_in">set</span>(<span class="hljs-string">&#x27;OUR-SEQUENCE-KEY&#x27;</span>, next_value)</span><br><span class="hljs-meta">&gt;&gt;&gt;</span><br><span class="hljs-meta">&gt;&gt;&gt;</span> <span class="python">r.transaction(client_side_incr, <span class="hljs-string">&#x27;OUR-SEQUENCE-KEY&#x27;</span>)</span><br>[True]<br></code></pre></td></tr></table></figure><hr><h1 id="暂未翻译剩余部分比较多"><a href="#暂未翻译剩余部分比较多" class="headerlink" title="暂未翻译剩余部分比较多"></a>暂未翻译剩余部分比较多</h1><p>详见github文档</p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-Request回调函数未调用</title>
    <link href="/post/5b35a369/"/>
    <url>/post/5b35a369/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 在Spider.parse()中</span><br>scrapy.Request(url, headers=self.header, callback=self.parse_detail)<br></code></pre></td></tr></table></figure><p>调试的时候，发现回调函数<code>parse_detail</code>没有被调用<br>出现这个问题的原因是，<code>url</code>被<code>Spider Middleware</code>中间件过滤掉了<br>默认中间件会过滤掉那些不在<code>allowed_domains</code>列表中的请求<code>request</code>  </p><p>两种方法能够使 requests 不被过滤: </p><ol><li>在 allowed_domains 中加入 url </li><li>在 scrapy.Request() 函数中将参数 dont_filter=True 设置为 True</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-博客文章内部跳转</title>
    <link href="/post/8e73e9cb/"/>
    <url>/post/8e73e9cb/</url>
    
    <content type="html"><![CDATA[<figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">post_link</span> 文章文件名（不要后缀） 文章标题（可选） %&#125;</span><br></code></pre></td></tr></table></figure><p>如文章文件名为Hello-World.md：</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">post_link</span> Hello-World %&#125;</span><br><span class="hljs-template-tag">&#123;% <span class="hljs-name">post_link</span> Hello-World 你好世界 %&#125;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-Reids-爬虫</title>
    <link href="/post/21d8017d/"/>
    <url>/post/21d8017d/</url>
    
    <content type="html"><![CDATA[<h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Scrapy</code>本身并不支持分布式。要做分布式爬虫，就需要借助<code>Scrapy-Redis</code>组件。<br>这个组件利用了Redis可以分布式的功能，使得<code>Scrapy</code>能够进行分布式爬取，提高爬虫效率。</p><blockquote><p><strong>分布式爬虫的优点</strong>：<br>　可以充分利用多台机器的IP，带宽，CPU等资源<br><strong>分布式爬虫的问题</strong>：<br>　如何保证不会出现重复爬取。<br>　如何正确的将数据整合到一起。</p></blockquote><h1 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h1><p><img src="/Scrapy-Reids-%E7%88%AC%E8%99%AB/1.png"></p><ol><li><code>Engine</code>从<code>Spider</code>中得到第一个<code>Requests</code>进行爬取</li><li><code>ENGIN</code>将<code>Request</code>放入<code>SCHEDULER</code>调度器，并且获取下个<code>Request</code></li><li>为保证不会进行重复爬取，<code>SCHEDULER</code>调度器<code>Requests</code>发送去<code>Redis</code></li><li>若<code>Redis</code>中无爬虫记录，返回<code>Requests</code>到<code>SCHEDULER</code>调度器</li><li><code>SCHEDULER</code>将<code>Requests</code>返回给<code>ENGINE</code>（因为ENGING进行任务调度）</li><li><code>ENGINE</code>发送<code>Requests</code>到<code>Downoader</code>，通过<code>Downloader Middlewares</code> 进行处理（这一步进行Http请求，返回<code>response</code>）</li><li>通过<code>Downloader Middleware</code>进行资源下载(就是html信息)，如果下载完成，通过<code>Dowloader</code>生成一个<code>Resonse</code>并且发送给ENGINE</li><li><code>ENGINE</code> 从<code>DOWNLOADER</code>接收 <code>Resonse</code>,并将<code>Resonse</code>发送给<code>Spider</code>进行处理。<code>Spider</code>通过<code>Spider Middleware</code>进行处理<code>Response</code></li><li><code>Spider</code>处理<code>Response</code> 并且返回<code>items</code>和新的<code>Requests</code>给<code>ENGINE</code>,这部分处理通过<code>Spilder Middleware</code>进行处理</li><li><code>ENGINE</code> 从<code>Spider</code>接收 <code>items</code>,并将<code>items</code>发送给<code>Item Pipeline</code>进行处理</li><li><code>Item Pipeline</code>将<code>items</code>发送给<code>redis</code>保存下来</li></ol><h2 id="一般部署"><a href="#一般部署" class="headerlink" title="一般部署"></a>一般部署</h2><p><img src="/Scrapy-Reids-%E7%88%AC%E8%99%AB/20200417102349957.png"></p><blockquote><p>Redis服务器：<br>　内存要大，只用作记录爬取下来的数据和URL去重<br>爬虫服务器：<br>　执行爬虫代码，进行爬取，获取数据发送给Redis服务器</p></blockquote><h1 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h1><p>github地址:<a href="https://github.com/rmax/scrapy-redis">https://github.com/rmax/scrapy-redis</a><br>文档及其简单，只给了基础设置和一个例子项目。</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install scrapy-redis<br></code></pre></td></tr></table></figure><h2 id="setting"><a href="#setting" class="headerlink" title="setting"></a>setting</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Enables scheduling storing requests queue in redis.</span><br>SCHEDULER = <span class="hljs-string">&quot;scrapy_redis.scheduler.Scheduler&quot;</span><br><br><span class="hljs-comment"># Ensure all spiders share same duplicates filter through redis.</span><br>DUPEFILTER_CLASS = <span class="hljs-string">&quot;scrapy_redis.dupefilter.RFPDupeFilter&quot;</span><br><br><span class="hljs-comment"># Default requests serializer is pickle, but it can be changed to any module</span><br><span class="hljs-comment"># with loads and dumps functions. Note that pickle is not compatible between</span><br><span class="hljs-comment"># python versions.</span><br><span class="hljs-comment"># Caveat: In python 3.x, the serializer must return strings keys and support</span><br><span class="hljs-comment"># bytes as values. Because of this reason the json or msgpack module will not</span><br><span class="hljs-comment"># work by default. In python 2.x there is no such issue and you can use</span><br><span class="hljs-comment"># &#x27;json&#x27; or &#x27;msgpack&#x27; as serializers.</span><br><span class="hljs-comment">#SCHEDULER_SERIALIZER = &quot;scrapy_redis.picklecompat&quot;</span><br><br><span class="hljs-comment"># Don&#x27;t cleanup redis queues, allows to pause/resume crawls.</span><br><span class="hljs-comment">#SCHEDULER_PERSIST = True</span><br><br><span class="hljs-comment"># Schedule requests using a priority queue. (default)</span><br><span class="hljs-comment">#SCHEDULER_QUEUE_CLASS = &#x27;scrapy_redis.queue.PriorityQueue&#x27;</span><br><br><span class="hljs-comment"># Alternative queues.</span><br><span class="hljs-comment">#SCHEDULER_QUEUE_CLASS = &#x27;scrapy_redis.queue.FifoQueue&#x27;</span><br><span class="hljs-comment">#SCHEDULER_QUEUE_CLASS = &#x27;scrapy_redis.queue.LifoQueue&#x27;</span><br><br><span class="hljs-comment"># Max idle time to prevent the spider from being closed when distributed crawling.</span><br><span class="hljs-comment"># This only works if queue class is SpiderQueue or SpiderStack,</span><br><span class="hljs-comment"># and may also block the same time when your spider start at the first time (because the queue is empty).</span><br><span class="hljs-comment">#SCHEDULER_IDLE_BEFORE_CLOSE = 10</span><br><br><span class="hljs-comment"># Store scraped item in redis for post-processing.</span><br>ITEM_PIPELINES = &#123;<br>    <span class="hljs-string">&#x27;scrapy_redis.pipelines.RedisPipeline&#x27;</span>: <span class="hljs-number">300</span><br>&#125;<br><br><span class="hljs-comment"># The item pipeline serializes and stores the items in this redis key.</span><br><span class="hljs-comment">#REDIS_ITEMS_KEY = &#x27;%(spider)s:items&#x27;</span><br><br><span class="hljs-comment"># The items serializer is by default ScrapyJSONEncoder. You can use any</span><br><span class="hljs-comment"># importable path to a callable object.</span><br><span class="hljs-comment">#REDIS_ITEMS_SERIALIZER = &#x27;json.dumps&#x27;</span><br><br><span class="hljs-comment"># Specify the host and port to use when connecting to Redis (optional).</span><br><span class="hljs-comment">#REDIS_HOST = &#x27;localhost&#x27;</span><br><span class="hljs-comment">#REDIS_PORT = 6379</span><br><br><span class="hljs-comment"># Specify the full Redis URL for connecting (optional).</span><br><span class="hljs-comment"># If set, this takes precedence over the REDIS_HOST and REDIS_PORT settings.</span><br><span class="hljs-comment">#REDIS_URL = &#x27;redis://user:pass@hostname:9001&#x27;</span><br><br><span class="hljs-comment"># Custom redis client parameters (i.e.: socket timeout, etc.)</span><br><span class="hljs-comment">#REDIS_PARAMS  = &#123;&#125;</span><br><span class="hljs-comment"># Use custom redis client class.</span><br><span class="hljs-comment">#REDIS_PARAMS[&#x27;redis_cls&#x27;] = &#x27;myproject.RedisClient&#x27;</span><br><br><span class="hljs-comment"># If True, it uses redis&#x27; ``SPOP`` operation. You have to use the ``SADD``</span><br><span class="hljs-comment"># command to add URLs to the redis queue. This could be useful if you</span><br><span class="hljs-comment"># want to avoid duplicates in your start urls list and the order of</span><br><span class="hljs-comment"># processing does not matter.</span><br><span class="hljs-comment">#REDIS_START_URLS_AS_SET = False</span><br><br><span class="hljs-comment"># Default start urls key for RedisSpider and RedisCrawlSpider.</span><br><span class="hljs-comment">#REDIS_START_URLS_KEY = &#x27;%(name)s:start_urls&#x27;</span><br><br><span class="hljs-comment"># Use other encoding than utf-8 for redis.</span><br><span class="hljs-comment">#REDIS_ENCODING = &#x27;latin1&#x27;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>Scrapy</tag>
      
      <tag>Scrapy-Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis</title>
    <link href="/post/bae4ff13/"/>
    <url>/post/bae4ff13/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis文档"><a href="#Redis文档" class="headerlink" title="Redis文档"></a>Redis文档</h1><p>官方网站：<a href="https://redis.io/">https://redis.io/</a></p><h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis是一个开源的使用ANSI C语言编写、<strong>遵守BSD协议</strong>、支持网络、可基于内存亦可持久化的日志型、<strong>Key-Value数据库</strong>，并提供多种语言的API。</p><h3 id="什么是BSD开源协议"><a href="#什么是BSD开源协议" class="headerlink" title="什么是BSD开源协议"></a>什么是BSD开源协议</h3><p>一个给予使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p><h3 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h3><p>NoSQL，泛指非关系型的数据库<br>传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题:</p><ul><li>高并发读写</li><li>海量数据的高效存储访问需求</li><li>高可扩展性和和高可用性需求</li></ul><p>NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题。 </p><h4 id="NoSQL类别"><a href="#NoSQL类别" class="headerlink" title="NoSQL类别"></a>NoSQL类别</h4><table><thead><tr><th>NoSQL类别</th><th>相关产品</th><th>典型应用</th><th>数据类型</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>Key-Value存储数据库</td><td>Tokyo Cabinet/Tyrant, Redis, Voldemort</td><td>内容缓存，处理大量数据的高访负载</td><td>键值对</td><td>快速查询</td><td>存储的数据缺少结构化</td></tr><tr><td>列存储数据库</td><td>Cassandra, HBase, Riak</td><td>分布式的文件系统</td><td>以列簇式存储，将同意列数据存在一起</td><td>查询速度快，可扩展性强，更容易进行分布式扩展</td><td>功能相对局限</td></tr><tr><td>文档型数据库</td><td>CouchDB, MongoDB</td><td>Web应用</td><td>一系列键值对（与Key-Value类似，Value是结构化的）</td><td>数据结构要求不严</td><td>查询性能不高，缺乏统一的查询语法</td></tr><tr><td>图形数据库</td><td>Neo4j, InfoGrid, Infinite Graph</td><td>社交网络</td><td>图结构</td><td>利用图结构相关算法</td><td>需要对整个图做计算才能得出结果，不容易做分布式的集群方案</td></tr></tbody></table><h2 id="Redis特点"><a href="#Redis特点" class="headerlink" title="Redis特点"></a>Redis特点</h2><ul><li>性能极高<br>Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li>丰富的数据类型<br>Redis支持的类型 String, List, Hash, Set 及 Ordered Set 数据类型操作。</li><li>原子<br>Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li>丰富的特性<br>Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li><li>高速读写<br>使用自己实现的分离器，代码量很短，没有lock(MySQL),因此效率高。</li></ul><p>Redis是一个简单的，高效的，分布式的，基于内存的缓存工具。<br>架设好服务器后，通过网络连接（类似数据库），提供Key－Value式缓存服务。<br>简单，是Redis突出的特色。<br>简单可以保证核心功能的稳定和优异。 </p><h2 id="Redis总结"><a href="#Redis总结" class="headerlink" title="Redis总结"></a>Redis总结</h2><p>redis单个key 存入512M大小<br>redis支持多种类型的数据结构(string,list,hash.set.zset)<br>redis 是单线程   原子性<br>redis可以持久化  因为使用了 RDB和AOF机制<br>redis支持集群   而且redis 支持库(0-15) 16个库<br>redis 还可以做消息队列  比如聊天室  IM </p><p>企业级开发中: 可以用作数据库、缓存(热点数据（经常会被查询，但是不经常被修改或者删除的数据)和消息中间件等大部分功能。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol><li>丰富的数据结构  </li><li>高速读写<br>redis使用自己实现的分离器，代码量很短，没有使用lock（MySQL），因此效率非常高。</li></ol><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol><li>持久化<br>Redis直接将数据存储到内存中，要将数据保存到磁盘上，Redis可以使用两种方式实现持久化过程。定时快照（snapshot）：每隔一段时间将整个数据库写到磁盘上，每次均是写全部数据，代价非常高。第二种方式基于语句追加（aof）：只追踪变化的数据，但是追加的log可能过大，同时所有的操作均重新执行一遍，回复速度慢。 </li><li>耗内存<br>占用内存过高。 </li></ol><h1 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h1><h2 id="一般安装"><a href="#一般安装" class="headerlink" title="一般安装"></a>一般安装</h2><h3 id="安装gcc语言编译环境"><a href="#安装gcc语言编译环境" class="headerlink" title="安装gcc语言编译环境"></a>安装gcc语言编译环境</h3><p>Redis是C语言开发，下载的源码需要编译，编译依赖gcc环境</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install gcc automake autoconf libtool make <br></code></pre></td></tr></table></figure><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><ol><li>下载源码<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget http://download.redis.io/releases/redis-5.0.8.tar.gz<br></code></pre></td></tr></table></figure> 建议官网获取下载地址</li><li>解压<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar zxvf redis-5.0.8.tar.gz<br></code></pre></td></tr></table></figure></li><li>进入解压出来的目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> redis-5.0.8<br></code></pre></td></tr></table></figure> 注意版本导致的文件夹名称不同</li><li>编译<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure> 看到它说<code>It&#39;s a good idea to run &#39;make test&#39; ;) </code>就代表成了</li><li>安装到指定目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make PREFIX=/usr/<span class="hljs-built_in">local</span>/redis install<br></code></pre></td></tr></table></figure> 这里安装到了<code>/usr/local/redis</code></li></ol><h2 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h2><ol><li><p>拉取镜像  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull redis</span><br></code></pre></td></tr></table></figure></li><li><p>查看是否拉取成功  </p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker images</span><br></code></pre></td></tr></table></figure></li><li><p>创建设置文件夹</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir -p etc<span class="hljs-regexp">/docker/</span>redis/conf<br>mkdir -p etc<span class="hljs-regexp">/docker/</span>redis/data<br></code></pre></td></tr></table></figure><p> 一个用于映射设置，一个用于映射数据  </p></li><li><p>创建配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">vim etc<span class="hljs-regexp">/docker/</span>redis<span class="hljs-regexp">/conf/</span>redis.conf<br></code></pre></td></tr></table></figure><p> 写入redis配置并保存，<a href="http://download.redis.io/redis-stable/redis.conf">官方默认配置文件</a><br> 下载完以后可以自行修改配置  </p></li><li><p>运行容器  </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -itd --name redis -p <span class="hljs-number">6378</span>:<span class="hljs-number">6379</span>  -v <span class="hljs-regexp">/etc/</span>docker<span class="hljs-regexp">/redis/</span>conf<span class="hljs-regexp">/redis.conf:/</span>etc<span class="hljs-regexp">/redis/</span>redis.conf  -v <span class="hljs-regexp">/etc/</span>docker<span class="hljs-regexp">/redis/</span>data:/data  redis  --requirepass <span class="hljs-number">65535</span> --appendonly yes  <br></code></pre></td></tr></table></figure><ul><li>–name redis<br>容器名设置为redis  </li><li>-p 6378:6379<br>映射容器服务的 6379 端口到宿主机的 6378 端口。外部可以直接通过宿主机ip:6378 访问到 Redis 的服务  </li><li>-v /docker/redis/redis.conf:/etc/redis/redis.conf<br>映射配置文件  </li><li>-v /docker/redis/data:/data<br>映射数据目录</li><li>–requirepass 65535<br>设置访问密码为65535</li><li>–appendonly yes<br>开启数据持久化</li></ul></li><li><p>访问控制台  </p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">docker exec -<span class="hljs-keyword">it</span> redis redis-cli<br></code></pre></td></tr></table></figure><p> 如果设置了账户密码  </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">docker exec -<span class="hljs-keyword">it</span> redis redis-cli -<span class="hljs-keyword">a</span> your_password<br></code></pre></td></tr></table></figure><p>根据自己设置的信息来更改命令</p></li></ol><h1 id="Redis基础"><a href="#Redis基础" class="headerlink" title="Redis基础"></a>Redis基础</h1><h2 id="Redis基本操作"><a href="#Redis基本操作" class="headerlink" title="Redis基本操作"></a>Redis基本操作</h2><h3 id="启动Redis服务端"><a href="#启动Redis服务端" class="headerlink" title="启动Redis服务端"></a>启动Redis服务端</h3><ol><li>来到安装目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/redis<br></code></pre></td></tr></table></figure></li><li>启动Redis服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/redis <br>./bin/redis-server<br></code></pre></td></tr></table></figure><img src="/Redis/20200413104109125.png"><br>看到这个蛋糕，就说明你启动成功了</li></ol><h3 id="关闭服务端"><a href="#关闭服务端" class="headerlink" title="关闭服务端"></a>关闭服务端</h3><ul><li>杀进程方式<br>会造成数据丢失<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">ps -ef | <span class="hljs-keyword">grep</span> -i redis  <span class="hljs-comment"># 查询redis进程</span><br><span class="hljs-keyword">kill</span> -<span class="hljs-number">9</span> PID <span class="hljs-comment"># 通过进程id杀进程</span><br></code></pre></td></tr></table></figure></li><li>正常关闭方式<br>客户端执行<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">shutdown</span><br></code></pre></td></tr></table></figure><h3 id="启动客户端"><a href="#启动客户端" class="headerlink" title="启动客户端"></a>启动客户端</h3></li></ul><ol><li>来到安装目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/redis<br></code></pre></td></tr></table></figure></li><li>启动Redis客户端<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./bin/redis-cli<br></code></pre></td></tr></table></figure>命令参考：<code>redis-cli –h IP地址 –p 端口 -a 密码</code> </li></ol><h3 id="退出客户端"><a href="#退出客户端" class="headerlink" title="退出客户端"></a>退出客户端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">键盘上按 Ctrl+C<br></code></pre></td></tr></table></figure><h3 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h3><blockquote><p>必须设置密码, 注意防火墙的问题</p></blockquote><p>RedisDesktopManager(收费)：<a href="https://github.com/uglide/RedisDesktopManager">https://github.com/uglide/RedisDesktopManager</a><br>AnotherRedisDesktopManager(免费)：<br><a href="https://github.com/qishibo/AnotherRedisDesktopManager/">https://github.com/qishibo/AnotherRedisDesktopManager/</a></p><h2 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h2><p>Redis定义了很多默认配置<br>但一般我们都会通过手动配置完成<br>Redis的配置文件位于根目录下，文件名为<code>reids.conf</code></p><h3 id="配置文件复制"><a href="#配置文件复制" class="headerlink" title="配置文件复制"></a>配置文件复制</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cp redis-5.0.8/redis.conf /usr/<span class="hljs-built_in">local</span>/redis/<br></code></pre></td></tr></table></figure><p>将配置文件从解压目录，复制到安装目录下</p><h3 id="redis-conf-配置文件详解"><a href="#redis-conf-配置文件详解" class="headerlink" title="redis.conf 配置文件详解"></a>redis.conf 配置文件详解</h3><ul><li><p><strong>绑定的主机地址</strong></p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">bind</span> <span class="hljs-number">127.0.0.1</span><br></code></pre></td></tr></table></figure><blockquote><p>想要什么ip能连上来，那就绑定好了</p></blockquote></li><li><p><strong>是否为守护进程</strong></p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">daemonize</span> <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><blockquote><p>Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程<br>守护进程：在后台运行并且不受任何终端控制的进程。<br>你用终端打开一个进程，终端被你关了。<br>　如进程为<code>非守护进程</code>，进程会被清除。<br>　如进程为<code>守护进程</code>，则在你关闭终端后，会继续运行。</p></blockquote></li><li><p>指定pidfile路径</p>  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">pidfile <span class="hljs-regexp">/var/</span>run/redis.pid<br></code></pre></td></tr></table></figure><blockquote><p>当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件</p></blockquote></li><li><p><strong>指定Redis监听端口</strong></p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">port</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><blockquote><p>默认端口为6379<br>为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字</p></blockquote></li><li><p>当客户端闲置多长时间后关闭连接</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">timeout</span> <span class="hljs-number">300</span><br></code></pre></td></tr></table></figure><blockquote><p>如果指定为0，表示关闭该功能</p></blockquote></li><li><p>指定日志记录级别</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">loglevel verbose</span><br></code></pre></td></tr></table></figure><blockquote><p>Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p></blockquote></li><li><p>日志记录方式，默认为标准输出</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">logfile <span class="hljs-built_in">stdout</span><br></code></pre></td></tr></table></figure><blockquote><p>如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null</p></blockquote></li><li><p>设置数据库的数量，默认数据库为0</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">databases</span> <span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><blockquote><p>可以使用<code>SELECT &lt;dbid&gt;</code>命令在连接上指定数据库id<br>id是从0开始的</p></blockquote></li><li><p><strong>指定在多长时间内，有多少次更新操作，就将数据同步到数据文件</strong></p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>  # <span class="hljs-number">900</span>秒（<span class="hljs-number">15</span>分钟）内有<span class="hljs-number">1</span>个更改<br><span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span>  # <span class="hljs-number">300</span>秒（<span class="hljs-number">5</span>分钟）内有<span class="hljs-number">10</span>个更改<br><span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span>  # <span class="hljs-number">60</span>秒内有<span class="hljs-number">10000</span>个更改<br></code></pre></td></tr></table></figure><blockquote><p>可以多个条件配合<br><code>save &lt;seconds&gt; &lt;changes&gt;</code><br>由于东西都存在内存里，断电数据全没，需要定时保存<br>Redis默认配置文件中设置了三个条件</p></blockquote></li><li><p>指定存储至本地数据库时是否压缩数据</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rdbcompression</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><blockquote><p>默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</p></blockquote></li><li><p><strong>指定本地数据库文件名</strong></p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">dbfilename</span> <span class="hljs-selector-tag">dump</span><span class="hljs-selector-class">.rdb</span><br></code></pre></td></tr></table></figure><blockquote><p>默认值为dump.rdb<br>在你关闭Redis的时候，数据会被存到这个文件里</p></blockquote></li><li><p>指定本地数据库存放目录</p>  <figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">dir</span> ./<br></code></pre></td></tr></table></figure><blockquote><p>默认是当前目录</p></blockquote></li><li><p>设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">slaveof <span class="hljs-tag">&lt;<span class="hljs-name">masterip</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">masterport</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>当master服务设置了密码保护时，slav服务连接master的密码</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">masterauth <span class="hljs-tag">&lt;<span class="hljs-name">master-password</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><strong>设置Redis连接密码</strong></p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">requirepass foobared</span><br></code></pre></td></tr></table></figure><blockquote><p>如果配置了连接密码，客户端在连接Redis时需要通过<code>AUTH &lt;password&gt;</code>命令提供密码，默认关闭(无密码)</p></blockquote></li><li><p>设置同一时间最大客户端连接数</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">maxclients</span> <span class="hljs-number">128</span><br></code></pre></td></tr></table></figure><blockquote><p>默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数<br>如果设置 maxclients 0，表示不作限制。<br>当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</p></blockquote></li><li><p>指定Redis最大内存限制</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">maxmemory <span class="hljs-tag">&lt;<span class="hljs-name">bytes</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</p></blockquote></li><li><p>是否在每次更新操作后进行日志记录</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">appendonly</span> <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><blockquote><p>Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no</p></blockquote></li><li><p>指定更新日志文件名</p>  <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">appendfilename</span> <span class="hljs-selector-tag">appendonly</span><span class="hljs-selector-class">.aof</span><br></code></pre></td></tr></table></figure><blockquote><p>默认为appendonly.aof</p></blockquote></li><li><p>指定更新日志条件</p>  <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">appendfsync everysec</span><br></code></pre></td></tr></table></figure><blockquote><p>共有3个可选值：<br>  no：表示等操作系统进行数据缓存同步到磁盘（快）<br>  always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）<br>  everysec：表示每秒同步一次（折中，默认值）</p></blockquote></li><li><p>指定是否启用虚拟内存机制</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">vm-enabled</span> <span class="hljs-literal">no</span><br></code></pre></td></tr></table></figure><blockquote><p>默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中</p></blockquote></li><li><p>虚拟内存文件路径</p>  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">vm-swap-<span class="hljs-keyword">file</span> <span class="hljs-regexp">/tmp/</span>redis.swap<br></code></pre></td></tr></table></figure><blockquote><p>默认值为/tmp/redis.swap，不可多个Redis实例共享</p></blockquote></li><li><p>将所有大于vm-max-memory的数据存入虚拟内存</p>  <figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mel">vm-<span class="hljs-keyword">max</span>-<span class="hljs-keyword">memory</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><blockquote><p>无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0</p></blockquote></li><li><p>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vm</span>-page-size <span class="hljs-number">32</span><br></code></pre></td></tr></table></figure></li><li><p>设置swap文件中的page数量</p>  <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">vm</span>-pages <span class="hljs-number">134217728</span><br></code></pre></td></tr></table></figure><blockquote><p>由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。</p></blockquote></li><li><p>设置访问swap文件的线程数</p>  <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vm</span>-<span class="hljs-built_in">max</span>-threads <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><blockquote><p>最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4</p></blockquote></li><li><p>设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">glueoutputbuf</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure></li><li><p>指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">hash</span>-<span class="hljs-built_in">max</span>-zipmap-entries <span class="hljs-number">64</span><br><span class="hljs-built_in">hash</span>-<span class="hljs-built_in">max</span>-zipmap-value <span class="hljs-number">512</span><br></code></pre></td></tr></table></figure></li><li><p>指定是否激活重置哈希</p>  <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">activerehashing</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><blockquote><p>默认为开启（后面在介绍Redis的哈希算法时具体介绍）</p></blockquote></li><li><p>指定包含其它的配置文件</p>  <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">include</span> /<span class="hljs-type">path</span>/<span class="hljs-keyword">to</span>/<span class="hljs-keyword">local</span>.conf<br></code></pre></td></tr></table></figure><blockquote><p>可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</p></blockquote></li></ul><h3 id="最基本自定义配置文件"><a href="#最基本自定义配置文件" class="headerlink" title="最基本自定义配置文件"></a>最基本自定义配置文件</h3><ol><li><p>进入对应的安装目录 /usr/local/redis</p></li><li><p>启动守护进程</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">daemonize</span> <span class="hljs-literal">no</span> <span class="hljs-string">-&gt;</span> <span class="hljs-string">daemonize</span> <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure></li><li><p>允许本机以外的主机访问</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">bind</span> <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">01</span> -&gt; # bind <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">01</span> <br></code></pre></td></tr></table></figure><p> 若是要特定的ip才能访问，也可以设置。</p></li><li><p>设置密码</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">requirepass</span> 设置密码 设置数据库密码<br></code></pre></td></tr></table></figure><blockquote><p>Redis速度很快，在一台好的服务器里，一个外部用户能进行150000次/秒 的密码尝试，这意味着你需要设置好密码来防止暴力破解。</p></blockquote></li><li><p>用自己的配置文件启动<br>Redis根目录下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/bin/</span>redis-server ./redis.conf<br></code></pre></td></tr></table></figure><p>注意配置文件路径的问题，这里设置的是当前路径下的reids.conf配置文件</p></li></ol><h2 id="Redis内存维护策略"><a href="#Redis内存维护策略" class="headerlink" title="Redis内存维护策略"></a>Redis内存维护策略</h2><p>redis作为优秀的中间缓存件，时常会存储大量的数据，即使采取了集群部署来动态扩容，也应该即使的整理内存，维持系统性能。</p><h3 id="在redis中有两种解决方案，"><a href="#在redis中有两种解决方案，" class="headerlink" title="在redis中有两种解决方案，"></a>在redis中有两种解决方案，</h3><h4 id="数据设置超时时间"><a href="#数据设置超时时间" class="headerlink" title="数据设置超时时间"></a>数据设置超时时间</h4><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">expire <span class="hljs-keyword">key</span> time(以秒为单位)  <span class="hljs-meta"># 最常用方式</span><br>setex(<span class="hljs-built_in">String</span> <span class="hljs-keyword">key</span>, int seconds, <span class="hljs-built_in">String</span> value)  <span class="hljs-meta"># 字符串独有方式</span><br></code></pre></td></tr></table></figure><ul><li>除了字符串有自己独有设置过期时间的方式外，其他方法都需要依靠expire方法来设置过期时间</li><li>如果没有设置时间，那么换成永不过期</li><li>如果设置了过期时间，只有又想让缓存永不过期，使用persist key</li></ul><h4 id="采用LRU算法动态将不用的数据删除"><a href="#采用LRU算法动态将不用的数据删除" class="headerlink" title="采用LRU算法动态将不用的数据删除"></a>采用LRU算法动态将不用的数据删除</h4><blockquote><p>LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。</p></blockquote><ol><li><strong>volatile-lru</strong>：设定超时时间的数据中,删除最不常使用的数据.</li><li><strong>allkeys-lru</strong>：查询所有的key中最近最不常使用的数据进行删除，这是应用最广泛的策略.</li><li>volatile-random：在已经设定了超时的数据中随机删除.</li><li>allkeys-random：查询所有的key,之后随机删除.</li><li>volatile-ttl：查询全部设定超时时间的数据,之后排序,将马上将要过期的数据进行删除操作.</li><li>noeviction：如果设置为该属性,则不会进行删除操作,如果内存溢出则报错返回.<ul><li>volatile-lfu：从所有配置了过期时间的键中驱逐使用频率最少的键</li><li>allkeys-lfu：从所有键中驱逐使用频率最少的键</li></ul></li></ol><h2 id="Redis命令"><a href="#Redis命令" class="headerlink" title="Redis命令"></a>Redis命令</h2><p>Redis命令 用于在 Redis 上执行操作</p><blockquote><p>Redis支持数据类型：String（字符串），hash（哈希），list(列表)，set(集合)，zset(sortedset)(有序集合)……</p></blockquote><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="key管理"><a href="#key管理" class="headerlink" title="key管理"></a>key管理</h4><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul><li><code>del &lt;key_name&gt;</code><br>删除<code>key</code></li></ul><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><ul><li><code>rename &lt;key_name&gt; &lt;new_key_name&gt;</code><br>重命名<code>key</code>为<code>new_key</code></li><li><code>MOVE &lt;key_name&gt; &lt;db&gt;</code><br>将当前数据库的key移动到给定的数据库db中</li></ul><h5 id="查询相关"><a href="#查询相关" class="headerlink" title="查询相关"></a>查询相关</h5><ul><li><code>keys *</code><br>返回所有满足条件的<code>key</code><br>可以模糊匹配，比如<code>keys aaa*</code> 代表abc开头的所有<code>key</code><br>通配符:<br>　<code>*</code>：代表所有<br>　<code>?</code>: 代表一个字符</li><li><code>exists &lt;key_name&gt;</code><br>是否存在指定<code>key</code>，存在返回1，不存在返回0</li><li><code>type &lt;key_name&gt;</code><br>返回key对应的值存储的数据类型</li></ul><h5 id="过期时间相关"><a href="#过期时间相关" class="headerlink" title="过期时间相关"></a>过期时间相关</h5><ul><li><code>expire &lt;key_name&gt; &lt;second&gt;</code><br>设置某个key的过期时间，时间单位为 秒</li><li><code>PEXPIRE &lt;key_name&gt; &lt;millisecond&gt;</code><br>设置某个key的过期时间，时间单位为 毫秒</li><li><code>ttl &lt;key_name&gt;</code><br>查看剩余时间，返回key剩余生存时间，时间单位为 秒<br>当<code>key</code>不存在，返回-2<br>当<code>key</code>存在，但没有设置过期时间时，返回-1</li><li><code>pttl &lt;key_name&gt;</code><br>查看剩余时间，返回<code>key</code>剩余生存时间，时间单位为 毫秒</li><li><code>persist &lt;key_name&gt;</code><br>取消过期时间</li></ul><h1 id="key命名规范"><a href="#key命名规范" class="headerlink" title="key命名规范"></a>key命名规范</h1><p>单个<code>key</code>只允许存入512M</p><ul><li>一般用<code>:</code>来分隔信息<br>例如 <code>学校:班级:学号</code>  </li><li>不要太长，不要太短<br>太长消耗内存，也降低查找效率，太短可读性会降低  </li><li>同一个项目中，key要有统一的命名模式</li><li>建议全部大写<br>注意是会区分大小写的</li></ul><blockquote><p>参考：</p></blockquote><ol><li>第一段放置项目名或缩写</li><li>第二段把表名转换为key前缀</li><li>第三段放置用于区分区<code>key</code>的字段, 对应<code>mysql</code>中的主键的列名</li><li>第四段放置主键值</li></ol><h1 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h1><h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><h3 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h3><p>String类型是最基本的数据类型，一个键最大能存512MB<br>String数据结构是简单的key-value类型，value值不仅可以是String，也可以是数字，是包含很多种类型的特殊类型<br>String类型是二进制安全的，可以包含任何数据</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>保存字符串<br>保存图片<br>统计数量（点赞数，浏览数之类）</p><blockquote><p>其自增自减指令具有原子操作的特性，而且redis性能很好</p></blockquote><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><ul><li><code>set &lt;key_name&gt; &lt;value&gt;</code><br>设置值。同一key多次赋值会覆盖，无视类型</li><li><code>mget &lt;key_name1&gt; &lt;value1&gt; &lt;key_name2&gt;.....</code><br>一次性设置多个值</li><li><code>setnx &lt;key_name&gt; &lt;value&gt;</code><br>设置值。分布式锁的方案之一<br>　如果<code>key</code>不存在，则设值并返回1<br>　如果<code>key</code>存在，则不设值并返回0</li><li><code>setnx &lt;key_name&gt; &lt;life_time&gt; &lt;value&gt;</code><br>设置值。并设置过期时间，单位秒</li></ul><h4 id="取值"><a href="#取值" class="headerlink" title="取值"></a>取值</h4><ul><li><code>get &lt;key_name&gt;</code><br>获取指定<code>key</code>的值<br>　若不存在，返回<code>nil</code>。<br>　若key的值不是字符串类型，返回一个错误</li><li><code>mget &lt;key_name1&gt; &lt;key_name2&gt; &lt;key_name3&gt;.....</code><br>获取多个<code>key</code>的值</li><li><code>getrange &lt;key_name&gt; &lt;start&gt; &lt;end&gt;</code><br>获取存储在指定<code>key</code>中的字符串的子串。<br>字符截取范围有<code>start</code>和<code>end</code>两个偏移量决定（包括其本身）<br>相当于数组下标切片</li><li><code>getbit &lt;key_name&gt; offset</code><br>获取存储在指定<code>key</code>中的字符串的指定偏移量上的bit</li><li><code>getset &lt;key_name&gt; &lt;value&gt;</code><br>设定<code>key</code>的值，并返回<code>key</code>的旧值<br>当<code>key</code>不存在时，返回<code>nil</code></li><li><code>strlen &lt;key_name&gt;</code><br>获取<code>key</code>所存储的字符串值的长度</li></ul><h4 id="删除-1"><a href="#删除-1" class="headerlink" title="删除"></a>删除</h4><ul><li><code>del &lt;key_name&gt;</code><br>删除<code>key</code></li></ul><h4 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h4><ul><li><code>append &lt;key_name&gt; &lt;value&gt;</code><br>将value追加到指定key的末尾<br>若不存在，则为之赋值</li></ul><h4 id="自增-自减"><a href="#自增-自减" class="headerlink" title="自增/自减"></a>自增/自减</h4><p>使用自增或自减，键值必须为数字类型，否则报错</p><ul><li><code>incr &lt;key_name&gt;</code><br>将<code>key</code>中存储的数字值加1<br>若<code>key</code>不存在，那么<code>key</code>的值初始化为0，然后再执行incr操作</li><li><code>decr &lt;key_name&gt;</code><br>将<code>key</code>中存储的数字值减1</li><li><code>incrby &lt;key_name&gt; &lt;int_step&gt;</code><br>将<code>key</code>中存储的数字值加<code>int_step</code></li><li><code>decrby &lt;key_name&gt; &lt;int_step&gt;</code><br>将<code>key</code>中存储的数字值减<code>int_step</code></li></ul><h2 id="Hash类型"><a href="#Hash类型" class="headerlink" title="Hash类型"></a>Hash类型</h2><p><code>Hash</code>类型的键值存放的是<code>field</code>（域）和<code>value</code>（值）的映射表</p><blockquote><p>没错，套娃的感觉</p></blockquote><p>Hash特别适合用于存储对象的信息<br>相比于将对象类型存储在String类型中，存储在Hash类型中能节约更多的内存空间<br>每个Hash能存储2^32-1键值对</p><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><p>存储一个对象<br>Hash是最接近关系型数据库结构的数据类型。</p><blockquote><p>为什么不用String存储一个对象？<br>存储对象最重要是通过id找到对象。</p><ul><li>若是在key中增加id的信息</li><li>当对象的字段变多，因为存储/传递<code>key</code>中的id所消耗的资源会变多。</li><li>若是在key的值单纯为拼接了很多信息的String</li><li>每次更改，查询都需要进行 序列化或反序列化（指字符串转为对象 或 对象转为字符串），浪费资源。</li><li>查询时一返回就返回整个字符串，浪费资源。</li><li>修改时会将整个字符串锁住，无法访问信息，浪费资源。</li></ul></blockquote><h3 id="Hash命令"><a href="#Hash命令" class="headerlink" title="Hash命令"></a>Hash命令</h3><h4 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h4><ul><li><code>hset &lt;key_name&gt; &lt;field&gt; &lt;value&gt;</code><br>指定key,存放<code>field</code>-<code>value</code></li><li><code>hmset &lt;key_name&gt; &lt;field_1&gt; &lt;value_1&gt; &lt;field_2&gt; &lt;value_2&gt;......</code><br>同时设置多个<code>field</code>-<code>value</code></li><li><code>hsetnx &lt;key_name&gt; &lt;field&gt; &lt;value&gt;</code><br>只在字段<code>field</code>不存在时，设置<code>Hash</code>字段的值</li></ul><h4 id="取值-1"><a href="#取值-1" class="headerlink" title="取值"></a>取值</h4><ul><li><code>hget &lt;key_name&gt; &lt;field&gt;</code><br>获取存储在<code>Hash</code>中的指，并根据<code>Field</code>得到<code>value</code></li><li><code>hmget &lt;key_name&gt; &lt;field_1&gt; &lt;field_2&gt; &lt;field_3&gt;.......</code><br>获取存储在<code>Hash</code>中的指，并根据多个<code>Field</code>得到多个<code>value</code></li><li><code>hgetall &lt;key_name&gt;</code><br>返回<code>Hash</code>中所有的字段</li><li><code>hlen &lt;key_name&gt;</code><br>返回<code>Hash</code>中字段的数量</li><li><code>hexists &lt;key_name&gt; &lt;field&gt;</code><br>查看<code>Hash</code>中的指定<code>Field</code>是否存在</li></ul><h4 id="删除-2"><a href="#删除-2" class="headerlink" title="删除"></a>删除</h4><ul><li><code>del &lt;key_name&gt;</code><br>删除<code>key</code></li><li><code>hdel &lt;key_name&gt; &lt;field_1&gt; &lt;field_2&gt;......</code><br>删除<code>key</code>中的一些field</li></ul><h4 id="自增、自减"><a href="#自增、自减" class="headerlink" title="自增、自减"></a>自增、自减</h4><ul><li><code>hincrby &lt;key_name&gt; &lt;field&gt; &lt;int_step&gt;</code><br>为对应<code>key</code>的对应<code>field</code>字段加上<code>int</code>类型增量<code>int_step</code></li><li><code>hincrbyfloat &lt;key_name&gt; &lt;field&gt; &lt;float_step&gt;</code><br>为对应<code>key</code>的对应<code>field</code>字段加上<code>float</code>类型增量<code>float_step</code></li></ul><h2 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h2><p>链表结构集合。<br>既可以作为队列，也可以作为栈</p><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><p>数据量大的数据删减<br>任务队列</p><h3 id="List命令"><a href="#List命令" class="headerlink" title="List命令"></a>List命令</h3><h4 id="赋值-2"><a href="#赋值-2" class="headerlink" title="赋值"></a>赋值</h4><ul><li><code>lpush &lt;key_name&gt; &lt;value_1&gt; &lt;value_2&gt;......</code><br>将一个或多个值插入到列表左侧</li><li><code>rpush &lt;key_name&gt; &lt;value_1&gt; &lt;value_2&gt;......</code><br>将一个或多个值插入到列表右侧</li><li><code>lpushx &lt;key_name&gt; &lt;value&gt;</code><br>将一个或多个值插入到列表左侧，若列表不存在，操作无效。</li><li><code>rpushx &lt;key_name&gt; &lt;value&gt;</code><br>将一个或多个值插入到列表右侧，若列表不存在，操作无效。</li></ul><h4 id="取值-2"><a href="#取值-2" class="headerlink" title="取值"></a>取值</h4><ul><li><code>llen &lt;key_name&gt;</code><br>获取列表长度</li><li><code>lindex &lt;key_name&gt; &lt;index&gt;</code><br>通过索引获取列表中的指定元素</li><li><code>lrange &lt;key_name&gt; &lt;start&gt; &lt;end&gt;</code><br>通过索引范围获取列表中的元素</li></ul><h4 id="删除-3"><a href="#删除-3" class="headerlink" title="删除"></a>删除</h4><ul><li><code>del &lt;key_name&gt;</code><br>删除<code>key</code></li><li><code>lpop &lt;key_name&gt;</code><br>删除并返回列表左侧第一个元素</li><li><code>rpop &lt;key_name&gt;</code><br>删除并返回列表右侧第一个元素</li><li><code>blpop &lt;key_name&gt; &lt;timeout&gt;</code><br>删除并返回列表左侧第一个元素，若当前<code>List</code>中没有元素，那么会阻塞列表，直到等待超时 或 发现可弹出元素为之<blockquote><p>若timeout不设置，那么会永久等待</p></blockquote></li><li><code>brpop &lt;key_name&gt; &lt;timeout&gt;</code><br>删除并返回列表右侧第一个元素，若当前<code>List</code>中没有元素，那么会阻塞列表，直到等待超时 或 发现可弹出元素为之<br>若<code>timeout</code>不设置，那么会永久等待</li><li><code>ltrim &lt;key_name&gt; &lt;int_start&gt; &lt;int_stop&gt;</code><br>让列表只保留<code>int_start</code>与<code>int_stop</code>区间内的元素，区间外的元素删除</li></ul><h4 id="修改-1"><a href="#修改-1" class="headerlink" title="修改"></a>修改</h4><ul><li><code>lset &lt;key_name&gt; &lt;index&gt; &lt;value&gt;</code><br>通过索引设置<code>List</code>元素的值</li><li><code>linsert &lt;key_name&gt; before|after &lt;element&gt; &lt;value&gt;</code><br>在指定key对应的列表元素的 前或后 插入一个值<br><code>element</code>为值，并非序号</li><li><code>rpoplpush &lt;key_name_1&gt; &lt;key_name_2&gt;</code><br>将<code>key_name_1</code>对应列表最右侧元素弹出,并添加到<code>key_name_2</code>对应列表最左侧<br>可以指定相同的<code>key</code>，形成列表循环</li><li><code>brpoplpush &lt;key_name_1&gt; &lt;key_name_2&gt; timeout</code><br>从<code>key_name_1</code>对应列表最右侧弹出一个值，将弹出的值插入<code>key_name_2</code>对应列表的最左侧。<br>若列表没有元素会阻塞列表直到超时或发现可弹元素为止</li></ul><h2 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h2><p><code>Set</code>类型是<code>String</code>类型的无序集合<br>每一个集合成员是唯一的，不会也不能出现重复的数据<br>集合中最多能有 2^32 -1 个成员（约40亿）</p><h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><p>需要用到差，并，交这种运算的地方<br>避免重复</p><h3 id="Set命令"><a href="#Set命令" class="headerlink" title="Set命令"></a>Set命令</h3><h4 id="赋值-3"><a href="#赋值-3" class="headerlink" title="赋值"></a>赋值</h4><ul><li><code>sadd &lt;key_name&gt; &lt;menber_1&gt; &lt;menber_2&gt; ......</code><br>向集合添加一个或多个成员</li></ul><h4 id="取值-3"><a href="#取值-3" class="headerlink" title="取值"></a>取值</h4><ul><li><code>scard &lt;key_name&gt;</code><br>获取集合的成员数</li><li><code>smembers &lt;key_name&gt;</code><br>返回集合的所有成员</li><li><code>sismember &lt;key_name&gt; &lt;member&gt;</code><br>判断<code>member</code>是否为<code>key</code>集合的成员</li><li><code>srandmamber &lt;key_name&gt; &lt;int_count&gt;</code><br>返回<code>int_count</code>个结合中的元素</li></ul><h4 id="删除-4"><a href="#删除-4" class="headerlink" title="删除"></a>删除</h4><ul><li><code>del &lt;key_name&gt;</code><br>删除<code>key</code></li><li><code>srem &lt;key_name&gt; &lt;menber_1&gt; &lt;menber_2&gt; ......</code><br>删除集合中的一个或多个成员</li><li><code>spop &lt;key_name&gt; &lt;int_count&gt;</code><br>移除并返回集合中的<code>int_count</code>个随机元素</li><li><code>smove &lt;key_name_1&gt; &lt;key_name_2&gt; &lt;member&gt;</code><br>将成员<code>menber</code>从<code>key_name_1</code>集合移动到<code>key_name_2</code>集合中去</li></ul><h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><h5 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h5><ul><li><code>sdiff &lt;key_name_1&gt; &lt;key_name_2&gt; ......</code><br>返回给定所有集合的差集</li><li><code>sdiffstore &lt;final_key_name&gt; &lt;key_name_1&gt; &lt;key_name_2&gt;......</code><br>返回给定的集合的差集，并保存在<code>final_key_name</code>中</li></ul><h5 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h5><ul><li><code>sinter &lt;key_name_1&gt; &lt;key_name_2&gt; ......</code><br>返回给定所有集合的交集</li><li><code>sinterstore &lt;final_key_name&gt; &lt;key_name_1&gt; &lt;key_name_2&gt;......</code><br>返回给定的集合的交集，并保存在<code>final_key_name</code>中</li></ul><h5 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h5><ul><li><code>sunion &lt;key_name_1&gt; &lt;key_name_2&gt; ......</code><br>返回给定所有集合的并集</li><li><code>sunionstore &lt;final_key_name&gt; &lt;key_name_1&gt; &lt;key_name_2&gt;......</code><br>返回给定的集合的并集，并保存在<code>final_key_name</code>中</li></ul><h2 id="ZSet类型"><a href="#ZSet类型" class="headerlink" title="ZSet类型"></a>ZSet类型</h2><p>有序集合<br>每一个元素都会关联一个<code>double</code>类型的分数，<code>Redis</code>通过记录的分数来对集合进行 <code>从小到大</code> 的排序<br>与<code>Set</code>类型一样，同一个集合内，不允许出现重复元素<br>分数允许重复<br>最多成员数为<code>2^32 -1</code>（约40亿）</p><h3 id="场景-4"><a href="#场景-4" class="headerlink" title="场景"></a>场景</h3><p>排行榜</p><h3 id="Set命令-1"><a href="#Set命令-1" class="headerlink" title="Set命令"></a>Set命令</h3><h4 id="赋值-4"><a href="#赋值-4" class="headerlink" title="赋值"></a>赋值</h4><ul><li><code>zadd &lt;key_name&gt; &lt;socre_1&gt; &lt;score_1&gt; &lt;socre_2&gt; &lt;score_2&gt;......</code><br>向有序集合添加一个或多个成员，或更新已存在成员的分数</li></ul><h4 id="取值-4"><a href="#取值-4" class="headerlink" title="取值"></a>取值</h4><ul><li><code>zcard &lt;key_name&gt;</code><br>获取有序集合成员数</li><li><code>zcount &lt;key_name&gt; &lt;min&gt; &lt;max&gt;</code><br>计算在有序集合中，分数处于<code>min</code>与<code>max</code>之间的成员数</li><li><code>zrank &lt;key_name&gt; &lt;menber&gt;</code><br>返回有序集合中指定<code>menber</code>的索引</li><li><code>zrange &lt;key_name&gt; &lt;start&gt; &lt;stop&gt;</code><br>返回有序集合指定 索引区间 内的成员(低到高)<br>若<code>start=0 stop=-1</code>则为所有</li><li><code>zrevrange &lt;key_name&gt; &lt;start&gt; &lt;stop&gt;</code><br>返回有序集合指定 索引区间 内的成员(高到低)</li><li><code>zrangebyscore &lt;key_name&gt; &lt;min&gt; &lt;max&gt;</code><br>返回有序集合指定 分数区间 内的成员(低到高)</li><li><code>zrevrangebyscore &lt;key_name&gt; &lt;max&gt; &lt;min&gt;</code><br>返回有序集合指定 分数区间 内的成员(高到低)</li></ul><h4 id="删除-5"><a href="#删除-5" class="headerlink" title="删除"></a>删除</h4><ul><li><code>del &lt;key_name&gt;</code><br>删除<code>key</code></li><li><code>zrem &lt;key_name&gt; &lt;member_1&gt; &lt;member_2&gt;</code><br>删除有序集合中的一个或多个成员</li><li><code>zremrangebyrank &lt;key_name&gt; &lt;start&gt; &lt;stop&gt;</code><br>删除有序集合中给定的 排名区间 的所有成员（第一名为0，从低到高） </li><li><code>zremrangebyscore &lt;key_name&gt; &lt;min&gt; &lt;max&gt;</code><br>删除有序集合中给定的 分数区间 的所有成员（第一名为0，从低到高） </li></ul><h4 id="自增"><a href="#自增" class="headerlink" title="自增"></a>自增</h4><ul><li><code>zincrby &lt;key_name&gt; &lt;increment&gt; &lt;member&gt;</code><br>增加<code>menber</code>元素分数<code>increment</code>点</li></ul><h2 id="HyperLogLog类型"><a href="#HyperLogLog类型" class="headerlink" title="HyperLogLog类型"></a>HyperLogLog类型</h2><p>用来做基数统计</p><blockquote><p><strong>什么是基数</strong><br>数据集{1, 3,5, 7, 5, 1, 9} 的 基数集为{1, 3, 5, 7, 9}</p></blockquote><ul><li>在输入袁术的数量或体积非常非常大时，计算基数所需的空间总是固定的，并且很小。</li><li>每个<code>HyperLogLog</code>只需要 12KB内存 ，可以计算接近2^64个不同元素的基数</li><li>核心是基数估计算法，最终数值会有一定误差</li><li> <strong><code>HyperLogLog</code> 只会根据输入的元素来计算基数，并不会存储元素本身</strong></li></ul><h3 id="场景-5"><a href="#场景-5" class="headerlink" title="场景"></a>场景</h3><p>数据量大的数据统计<br>注意，如果数据量小，反而会浪费空间</p><h3 id="HyperLogLog命令"><a href="#HyperLogLog命令" class="headerlink" title="HyperLogLog命令"></a>HyperLogLog命令</h3><ul><li><code>pfadd &lt;key_name&gt; &lt;element_1&gt; &lt;element_2&gt;</code><br>添加指定元素到<code>HyperLogLog</code>中</li><li><code>pfcount &lt;key_name_1&gt; &lt;key_name_2&gt;</code><br>返回给定的<code>HyperLogLog</code>基数估算值</li><li><code>pfmerge &lt;key_name_1&gt; &lt;key_name_2&gt; &lt;key_name_2&gt;</code><br>将多个<code>HyperLogLog</code>合并到<code>key_name_1</code>中</li></ul><h1 id="发布订阅-pub-sub"><a href="#发布订阅-pub-sub" class="headerlink" title="发布订阅(pub/sub)"></a>发布订阅(pub/sub)</h1><p><code>Redis</code>发布订阅(pub/sub)是一种消息通信模式<br>发送者(pub)发送消息，订阅者(sub)接受消息<br>客户端可以订阅任意数量的频道  </p><p>三个客户端订阅<code>频道channel1</code><br><img src="/Redis/20200826121324114.png"><br>订阅了以后，有新的消息来的话会通过<code>PUBLISH</code>命令发送给<code>频道channel1</code>  </p><h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="订阅"><a href="#订阅" class="headerlink" title="订阅"></a>订阅</h3><ul><li><code>SUBSCRIBE channel [channel1.....]</code><br>订阅给定的一个或多个频道  </li><li><code>PSUBSCRIBE pattern [pattern]</code><br>订阅一个或多个符合给定模式的频道  </li></ul><h3 id="消息发布"><a href="#消息发布" class="headerlink" title="消息发布"></a>消息发布</h3><ul><li><code>PBULISH channel1 message</code><br>将消息发布到指定频道  </li></ul><h3 id="退订"><a href="#退订" class="headerlink" title="退订"></a>退订</h3><ul><li><code>UNSUBSCRIBE [channel....]</code><br>退订给定的频道  </li><li><code>PUNSUBSCRIBE [pattern]</code><br>退订给定模式的频道  </li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>博客订阅，微信公众号订阅，新闻订阅等  </p><h1 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h1><p>数据库是由一个整数索引标识的，而不是数据库名称<br>默认情况下链接到数据库0<br>你可以自己在配置文件下设置数据库数量  </p><h2 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><code>select 数据库索引数</code><br>切换数据库  </li><li><code>move key 目标数据库索引数</code><br>移动数据到另一个库中  </li><li><code>flushdb</code><br>清空当前数据库所有的key  </li><li><code>flushall</code><br>清空整个Redis数据库所有key  </li></ul><h1 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h1><p>Redis事务可以一次执行多个命令(单独步骤中执行一组命令)  </p><blockquote><p>批量操作在发送EXEC命令前被放入队列缓存<br>收到EXEC命令后，进入事务执行，事务中的任意命令执行失败，其余命令依然执行<br>事务进行过程中，客户端提交的命令不会插入到事务执行命令序列中  </p></blockquote><p>Redis会将一个事务中的所有命令序列化，然后按顺序执行<br>执行中不会被其他命令插入，不允许加塞行为<br>并没有回滚机制  </p><h2 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h2><p><code>DISCARD</code><br>取消事务<br><code>EXEC</code><br>执行所有事务块内的命令<br><code>MULTI</code><br>标记一个事务块的开始<br><code>UNWATCH</code><br>取消WATCH命令对所有key的监视<br><code>WATCH key [key.....]</code><br>监视一个或多个Key，如果这些key被改动，那么事务将被打断  </p><h2 id="事务流程"><a href="#事务流程" class="headerlink" title="事务流程"></a>事务流程</h2><ol><li>开始事务</li><li>命令入队</li><li>执行事务</li></ol><h3 id="示例1-A向B转50元"><a href="#示例1-A向B转50元" class="headerlink" title="示例1 A向B转50元"></a>示例1 A向B转50元</h3><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">multi <span class="hljs-comment"> // 事务开始</span><br><span class="hljs-built_in">get</span> account:<span class="hljs-keyword">a</span> <span class="hljs-comment"> // 获取a账户金额</span><br>incrby account:b <span class="hljs-number">50</span> <span class="hljs-comment"> // b账户增加50元</span><br>decrby account:<span class="hljs-keyword">a</span> <span class="hljs-number">50</span> <span class="hljs-comment"> // a账户减少50元</span><br><span class="hljs-built_in">get</span> account:<span class="hljs-keyword">a</span> <span class="hljs-comment"> // 得到a账户余额</span><br><span class="hljs-built_in">get</span> account:b <span class="hljs-comment"> // 得到b账户余额</span><br>exec <span class="hljs-comment"> // 执行队列</span><br></code></pre></td></tr></table></figure><h3 id="示例2-DISCARD放弃队列运行"><a href="#示例2-DISCARD放弃队列运行" class="headerlink" title="示例2 DISCARD放弃队列运行"></a>示例2 DISCARD放弃队列运行</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams">multi  <span class="hljs-comment">// 事务开始</span><br><span class="hljs-keyword">set</span> aa <span class="hljs-comment">123</span><br>get <span class="hljs-comment">aa</span><br>discard<br></code></pre></td></tr></table></figure><p>实际上什么都不会执行，事务将命令传入，并没有执行就解散了队列  </p><h3 id="示例3-事务错误处理"><a href="#示例3-事务错误处理" class="headerlink" title="示例3 事务错误处理"></a>示例3 事务错误处理</h3><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams">multi<br><span class="hljs-keyword">set</span> aa <span class="hljs-comment">hello</span><br>get <span class="hljs-comment">aa</span><br>incr <span class="hljs-comment">aa</span><br>exec<br></code></pre></td></tr></table></figure><p>如果某个命令报错，则有报错的命令不会被执行，其他命令照样执行，且不会回滚  </p><h3 id="示例4-事务的WATCH"><a href="#示例4-事务的WATCH" class="headerlink" title="示例4 事务的WATCH"></a>示例4 事务的WATCH</h3><p>某一账户在事务内进行操作，在提交事务前，另一个进程对账户进行操作  </p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">watch <span class="hljs-keyword">a</span> <span class="hljs-comment"> // 开启监视，如果目标在事务开启前被改动，则打断事务（不会执行）</span><br>multi<br><span class="hljs-built_in">get</span> <span class="hljs-keyword">a</span><br>incr <span class="hljs-keyword">a</span><br>exec <span class="hljs-comment"> // 执行事务</span><br></code></pre></td></tr></table></figure><h2 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h2><p>想要保证一组命令执行过程中不被其它命令插入<br>原子性<br>诸如商品秒杀之类的  </p><h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><p>持久化：把内存的数据写到磁盘中去，防止服务器宕机后数据丢失<br>Redis提供了两种持久化方式</p><ul><li>RDB(默认)</li><li>AOF</li></ul><h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><p>Redis DataBase的缩写<br>功能是rdbSave（生成RDB文件到磁盘）和rdbLoad（从RDB文件中载入内存）两个函数<br><img src="/Redis/20200826021359970.png"></p><p>优点：快照保存速度快，还原也快<br>缺点：需要占用内存  </p><p>快照条件 见配置<code>redis.conf</code>文件  </p><h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p>Append-only file的缩写<br>这种方式，会将每一个收到的命令写到文件中（默认为appendoly.aof），redis重启后，会通过重新执行文件中的命令来重建数据库内容<br><img src="/Redis/20200826021821245.png">  </p><p>每当执行任务或函数时，flushAppendOnlyFile函数都会被调用，这个函数执行以下两个工作aof写入保存<br>WRITE:判断条件，将aof_buf中的缓存写入到AOF文件<br>SAVE：根据条件，调用fsync或fdatasync函数，将AOF文件保存到磁盘中  </p><h1 id="实时同步-异步同步"><a href="#实时同步-异步同步" class="headerlink" title="实时同步-异步同步"></a>实时同步-异步同步</h1><h2 id="实时同步"><a href="#实时同步" class="headerlink" title="实时同步"></a>实时同步</h2><p>对于一致性要求高的，应采用实时同步方案  </p><ul><li>查询缓存查询不到再从DB查询，查询到后，顺便将数据保存到缓存  </li><li>更新数据到缓存时，先更新数据库，缓存中的数据设置过期  </li></ul><h2 id="异步队列"><a href="#异步队列" class="headerlink" title="异步队列"></a>异步队列</h2><p>对于并发高的，可采用异步队列的方式同步<br>东西不直接存到数据库中，而是存到中间件队列里，等数据库什么时候有空了，在从队列里处理数据<br>能实现的中间件比较多：ActiveMQ, RabbitMQ, ZeroMQ, Kafaka  </p><h2 id="UDF自定义函数"><a href="#UDF自定义函数" class="headerlink" title="UDF自定义函数"></a>UDF自定义函数</h2><p>面对mysql接口编程，利用触发器进行缓存同步<br>学习成本高  </p><h1 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h1><p>查询一个不存在的数据。由于缓存时不命中，需要从数据库查询，查不到数据则不写入缓存。这将导致这个不存在的数据每次请求都要查两次，查完缓存查数据库，造成缓存穿透  </p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p><img src="/Redis/20200826051659831.png"><br>布隆过滤器是一种数据结构<br>对所有可能查询的参数以hash形式存储，当用户想要查询的时候，使用布隆过滤器发现不在集合中，就直接丢弃，不再对持久层查询<br><img src="/Redis/20200826052744906.png">  </p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>数据命中不高  </li><li>数据相对固定，实时性低  </li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>代码维护  </li><li>一定的缓存空间</li></ul><h3 id="缓存空对象"><a href="#缓存空对象" class="headerlink" title="缓存空对象"></a>缓存空对象</h3><p><img src="/Redis/20200826051652448.png"><br>持久层查询不到就缓存空结果<br>查询时,先判断缓存中是否存在(exists(key)),如果有直接返回空，没有则查询后返回  </p><blockquote><p>注意insert时需要清除查询的key，否则就算数据库有值，也只查不到   </p></blockquote><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>数据命中不高  </li><li>数据频繁变化，实时性高  </li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>存了空值，要浪费很多的缓存空间  </li><li>对于需要保持一致性的业务会有影响  </li></ul><h1 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h1><p>缓存集中大量失效时，引发大量的数据库查询<br><img src="/Redis/20200826052939263.png">  </p><h2 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="redis高可用"><a href="#redis高可用" class="headerlink" title="redis高可用"></a>redis高可用</h3><p>这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是搭建的集群  </p><h3 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h3><p>这个解决方案的思想是，在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待  </p><h3 id="数据预热"><a href="#数据预热" class="headerlink" title="数据预热"></a>数据预热</h3><p>数据加热的含义就是在正式部署之前，把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀   </p><h1 id="热点key"><a href="#热点key" class="headerlink" title="热点key"></a>热点key</h1><p>某个key有大量线程访问，其失效的瞬间，有大量线程来构建缓存，造成后端负载加大，甚至可能会让系统崩溃<br><img src="/Redis/20200826053525250.png">  </p><h2 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="互斥锁-mutex-key"><a href="#互斥锁-mutex-key" class="headerlink" title="互斥锁(mutex key)"></a>互斥锁(mutex key)</h3><p>只让一个线程构建缓存，其他线程等待构建缓存的线程执行<br><img src="/Redis/20200826053631821.png">  </p><h3 id="缓存时间设置"><a href="#缓存时间设置" class="headerlink" title="缓存时间设置"></a>缓存时间设置</h3><p>不会失效就不会有问题，时间长点也会让发生频率降低  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-Splash-爬虫-同时返回图片与网页</title>
    <link href="/post/71ce616a/"/>
    <url>/post/71ce616a/</url>
    
    <content type="html"><![CDATA[<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>Splash 3.4.1</li><li>Scrapy-Splash 0.7.2</li><li>Windows10 专业版</li></ul><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>Splash如何同时返回html与图片</p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>在用<code>Scrapy</code>爬取网站时发现网页是一个动态渲染的画面<br>于是使用<code>Splash</code>爬取，查看png预览图，发现<code>Splash</code>已经得到正确的结果<br><img src="/Scrapy-Splash-%E7%88%AC%E8%99%AB-%E5%90%8C%E6%97%B6%E8%BF%94%E5%9B%9E%E5%9B%BE%E7%89%87%E4%B8%8E%E7%BD%91%E9%A1%B5/20200413055848348.png"><br><code>Scrapy-Splash</code>返回的 html 里也发现了对应的图片标签与路径<br>但直接通过图片路径来获取图片失败，提示为权限不足<br><img src="/Scrapy-Splash-%E7%88%AC%E8%99%AB-%E5%90%8C%E6%97%B6%E8%BF%94%E5%9B%9E%E5%9B%BE%E7%89%87%E4%B8%8E%E7%BD%91%E9%A1%B5/20200413055808053.png"></p><h1 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在Splash获取到的预览画面中，图片已经正确的被渲染<br>那么只要让Splash同时返回图片和网页的数据就可以解决问题</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="更改Scrapy-Splash的lua代码参数"><a href="#更改Scrapy-Splash的lua代码参数" class="headerlink" title="更改Scrapy-Splash的lua代码参数"></a>更改<code>Scrapy-Splash</code>的<code>lua</code>代码参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">splash_lua_script = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">function main(splash, args)</span><br><span class="hljs-string">    assert(splash:go(args.url))</span><br><span class="hljs-string">    assert(splash:wait(0.5))</span><br><span class="hljs-string">    local preview_picture = splash:select(&#x27;#slick-slide00 img&#x27;)</span><br><span class="hljs-string">    return &#123;</span><br><span class="hljs-string">        html = splash:html(),</span><br><span class="hljs-string">        png = preview_picture:png(),</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    end</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>Splash只能通过使用 CSS 的方式来获取元素<br>这段代码的过程：获取网页，等待0.5s，通过CSS获取图片元素，并最终返回图片元素的截图</p><h3 id="Scrapy-Splash请求提交"><a href="#Scrapy-Splash请求提交" class="headerlink" title="Scrapy-Splash请求提交"></a>Scrapy-Splash请求提交</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">yield</span> SplashRequest(<br>    url=title_url,<br>    callback=self.parse_title_page,<br>    endpoint=<span class="hljs-string">&#x27;execute&#x27;</span>,<br>    args=&#123;<br>        <span class="hljs-string">&#x27;lua_source&#x27;</span>: splash_lua_script,<br>        <span class="hljs-string">&#x27;images&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span><br>    &#125;<br>)<br></code></pre></td></tr></table></figure><p>使用方法和在<code>Scrapy</code>里提交普通的<code>Request</code>一致。</p><p>需要注意的是<code>endpoint</code>这个参数<br>Scrapy-Splash有三种返回的Response类型类型：  </p><table><thead><tr><th>实际返回类型</th><th>内容格式</th><th><code>endpoint</code>值</th></tr></thead><tbody><tr><td>SplashResponse</td><td>binary</td><td>render.png</td></tr><tr><td>SplashTextResponse</td><td>text</td><td>render.html</td></tr><tr><td>SplashJsonResponse</td><td>json</td><td>render.json或execute</td></tr></tbody></table><p>由于我希望同时返回图片和网页<br>若使用<code>render.png</code>则返回的二进制数据无法分开网页和图片<br>若使用<code>render.html</code>则压根不返回图片。<br>于是这里使用<code>execute</code></p><h3 id="回调函数中处理图片"><a href="#回调函数中处理图片" class="headerlink" title="回调函数中处理图片"></a>回调函数中处理图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br>base64.b64decode(response.data[<span class="hljs-string">&#x27;png&#x27;</span>])<br></code></pre></td></tr></table></figure><p>使用<code>execute</code>后，返回的内容会是<code>json</code>，返回的图片会被记录为字符串。<br>为了将字符串转变回图片，需要使用<code>base64</code>转换会图片。</p>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>Scrapy</tag>
      
      <tag>Splash</tag>
      
      <tag>Scrapy-Splash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-Splash-爬虫</title>
    <link href="/post/b06c579/"/>
    <url>/post/b06c579/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a><strong>信息</strong></h2><p>Scrapy的Splash插件<br>github地址：<a href="https://github.com/scrapy-plugins/scrapy-splash">https://github.com/scrapy-plugins/scrapy-splash</a><br>这个插件只是让Scrapy使用Splash服务而已<br>如果没人给你提供Splash服务，那么你需要自己弄</p><a href="/post/11f87120/" title="Splash-js渲染-爬虫">Splash-js渲染-爬虫</a><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a><strong>流程</strong></h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><p>pip install scrapy-splash</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a><strong>配置</strong></h3><ol><li><p>在<code>settings.py</code>中添加<code>Splash</code>地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">SPLASH_URL = <span class="hljs-string">&#x27;http://192.168.59.103:8050&#x27;</span><br></code></pre></td></tr></table></figure><p> 根据ip来，要是本地就localhost:8050</p></li><li><p>在<code>settings.py</code>中配置<code>Downloader</code>中间件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">DOWNLOADER_MIDDLEWARES = &#123;<br>    <span class="hljs-string">&#x27;scrapy_splash.SplashCookiesMiddleware&#x27;</span>: <span class="hljs-number">723</span>,<br>    <span class="hljs-string">&#x27;scrapy_splash.SplashMiddleware&#x27;</span>: <span class="hljs-number">725</span>,      <span class="hljs-string">&#x27;scrapy.downloadermiddlewares.httpcompression.HttpCompressionMiddleware&#x27;</span>: <span class="hljs-number">810</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启用Spider中间件<code>SplashDeduplicateArgsMiddleware</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">SPIDER_MIDDLEWARES = &#123;<br>    <span class="hljs-string">&#x27;scrapy_splash.SplashDeduplicateArgsMiddleware&#x27;</span>: <span class="hljs-number">100</span>,<br>&#125;<br></code></pre></td></tr></table></figure><p> 这个功能需要<code>cache_args</code>支持。<br>它能通过不保存 重复的Splash参数 节约磁盘空间<br>若Splash版本2.1+，它能通过 不重复发送Splash参数 节约带宽</p></li><li><p>设置去重类<code>DUPEFILTER_CLASS</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">DUPEFILTER_CLASS = <span class="hljs-string">&#x27;scrapy_splash.SplashAwareDupeFilter&#x27;</span><br></code></pre></td></tr></table></figure></li><li><p>如果你使用HTTP cache，那么要定义一个缓存后端</p><p> scrapy-splash提供一个<code>scrapy.contrib.httpcache.FilesystemCacheStorage</code>子类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">HTTPCACHE_STORAGE = <span class="hljs-string">&#x27;scrapy_splash.SplashAwareFSCacheStorage&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">yield</span> SplashRequest(url, self.parse_result, callback <span class="hljs-comment">#任务完成之后对应的回调函数</span><br>    <span class="hljs-comment">#args设置的是端点API的参数，关于API参数问题，请参考: `Splash HTTP API &lt;./api.html&gt;`_</span><br>    args=&#123;<br>        <span class="hljs-comment"># 可选参数，表示spalsh在执行完成之后会等待一段时间后返回</span><br>        <span class="hljs-string">&#x27;wait&#x27;</span>: <span class="hljs-number">0.5</span>,<br>        <span class="hljs-comment">#url是一个必须的参数，表明将要对哪个url进行请求</span><br>        <span class="hljs-string">&#x27;url&#x27;</span> : <span class="hljs-string">&quot;http://www.example.com&quot;</span>,<br>        <span class="hljs-comment">#http_method:表示Splash将向目标url发送何种请求</span><br>        <span class="hljs-string">&#x27;http_method&#x27;</span>: <span class="hljs-string">&#x27;GET&#x27;</span><br>        <span class="hljs-comment"># &#x27;body&#x27; 用于POST请求，作为请求的请求体</span><br>        <span class="hljs-comment"># &#x27;lua_source&#x27; 如果需要执行lua脚本，那么这个参数表示对应lua脚本的字符串</span><br>    &#125;,<br>    endpoint=<span class="hljs-string">&#x27;render.json&#x27;</span>, <span class="hljs-comment"># optional; default is render.html</span><br>    splash_url=<span class="hljs-string">&#x27;&lt;url&gt;&#x27;</span>,     <span class="hljs-comment"># optional; overrides SPLASH_URL</span><br>    slot_policy=scrapy_splash.SlotPolicy.PER_DOMAIN,  <span class="hljs-comment"># optional,</span><br>    <span class="hljs-comment"># &quot;meta&quot; 是一个用来向回调函数传入参数的方式，在回调函数中的response.meta中可以取到这个地方传入的参数</span><br>)<br></code></pre></td></tr></table></figure><p>如果在splash中使用lua脚本，那么args中的内容会通过main函数的 splash.args 参数传入，其余的内容会通过第二个 参数 args 传入。<br>比如下面有一个简单的用户登录的例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python">lua_script= <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">function main(splash, args)</span><br><span class="hljs-string"></span><br><span class="hljs-string">local ok, reason = splash:go(args.url)</span><br><span class="hljs-string">user_name = args.user_name</span><br><span class="hljs-string">user_passwd = args.user_passwd</span><br><span class="hljs-string">user_text = splash:select(&quot;#email&quot;)</span><br><span class="hljs-string">pass_text = splash:select(&quot;#pass&quot;)</span><br><span class="hljs-string">login_btn = splash:select(&quot;#loginbutton&quot;)</span><br><span class="hljs-string">if (user_text and pass_text and login_btn) then</span><br><span class="hljs-string">    user_text:send_text(user_name)</span><br><span class="hljs-string">    pass_text:send_text(user_passwd)</span><br><span class="hljs-string">    login_btn:mouse_click(&#123;&#125;)</span><br><span class="hljs-string">end</span><br><span class="hljs-string"></span><br><span class="hljs-string">splash:wait(math.random(5, 10))</span><br><span class="hljs-string">return &#123;</span><br><span class="hljs-string">    url = splash:url(),</span><br><span class="hljs-string">    cookies = splash:get_cookies(),</span><br><span class="hljs-string">    headers = splash.args.headers,</span><br><span class="hljs-string"> &#125;</span><br><span class="hljs-string">end&#x27;&#x27;&#x27;</span><br><br><span class="hljs-keyword">yield</span> SplashRequest(<br>    url=self.login_url,<br>    endpoint=<span class="hljs-string">&quot;execute&quot;</span>,<br>    args=&#123;<br>        <span class="hljs-string">&quot;wait&quot;</span>: <span class="hljs-number">30</span>,<br>        <span class="hljs-string">&quot;lua_source&quot;</span>: lua_script,<br>        <span class="hljs-string">&quot;user_name&quot;</span>: <span class="hljs-string">&quot;xxxx&quot;</span>,  <span class="hljs-comment"># 在Lua脚本中这个参数可用通过args.user_name取得</span><br>        <span class="hljs-string">&quot;user_passwd&quot;</span>: <span class="hljs-string">&quot;xxxx&quot;</span>,<br>    &#125;,<br>    meta = &#123;<span class="hljs-string">&quot;user_name&quot;</span> : <span class="hljs-string">&quot;xxxx&quot;</span>&#125;,<br>    callback=self.after_login,<br>    errback=self.error_parse,<br>)<br></code></pre></td></tr></table></figure><p>上述代码提交了一个Splash的请求，在脚本中首先获取用户名和密码的输入框元素和对应的提交按钮元素，接着填入用户名和 密码，最后点击提交并返回对应的cookie。 回调函数 after_login 的代码如下:</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">after_login</span>(<span class="hljs-params">self, response</span>):</span><br>    <span class="hljs-comment">#首先根据一定条件判断登录是否成功</span><br>    self.login_user = response.meta[<span class="hljs-string">&quot;user_name&quot;</span>] <span class="hljs-comment"># 保存当前登录用户</span><br>    self.cookie = response.data[<span class="hljs-string">&quot;cookies&quot;</span>]  <span class="hljs-comment"># 保存cookie</span><br></code></pre></td></tr></table></figure><p>在回调函数中，可以通过<code>response.data</code>来获取<code>lua</code>脚本中返回的内容，而对应的HTML代码的获取方式与使用传统的<code>Request</code>方式 相同。</p><p>另外在回调函数中可以通过<code>response.meta</code>来获取<code>Request</code>中<code>meta</code>传入的参数。</p><p>上述示例演示了如何使用<code>SplashRequest</code>来像<code>Splash</code>发送渲染请求，以及如何在回调函数中获取lua脚本中的返回、 以及如何在回调函数中获取lua脚本中的返回、如何向回调函数传递参数。</p><p>当然您也可以使用常规的<code>scrapy.Request</code>来向<code>Splash</code>发送请求，发送的示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">yield</span> scrapy.Request(url, self.parse_result, meta=&#123;<br>    <span class="hljs-string">&#x27;splash&#x27;</span>: &#123;<br>        <span class="hljs-string">&#x27;args&#x27;</span>: &#123;<br>            <span class="hljs-comment"># 在此处设置端点API的参数</span><br>            <span class="hljs-string">&#x27;html&#x27;</span>: <span class="hljs-number">1</span>,<br>            <span class="hljs-string">&#x27;png&#x27;</span>: <span class="hljs-number">1</span>,<br><br>            <span class="hljs-comment"># &#x27;url&#x27; is prefilled from request url</span><br>            <span class="hljs-comment"># &#x27;http_method&#x27; is set to &#x27;POST&#x27; for POST requests</span><br>            <span class="hljs-comment"># &#x27;body&#x27; is set to request body for POST requests</span><br>        &#125;,<br><br>        <span class="hljs-comment"># optional parameters</span><br>        <span class="hljs-string">&#x27;endpoint&#x27;</span>: <span class="hljs-string">&#x27;render.json&#x27;</span>,  <span class="hljs-comment"># optional; default is render.json</span><br>        <span class="hljs-string">&#x27;splash_url&#x27;</span>: <span class="hljs-string">&#x27;&lt;url&gt;&#x27;</span>,      <span class="hljs-comment"># optional; overrides SPLASH_URL</span><br>        <span class="hljs-string">&#x27;slot_policy&#x27;</span>: scrapy_splash.SlotPolicy.PER_DOMAIN,<br>        <span class="hljs-string">&#x27;splash_headers&#x27;</span>: &#123;&#125;,       <span class="hljs-comment"># optional; a dict with headers sent to Splash</span><br>        <span class="hljs-string">&#x27;dont_process_response&#x27;</span>: <span class="hljs-literal">True</span>, <span class="hljs-comment"># optional, default is False</span><br>        <span class="hljs-string">&#x27;dont_send_headers&#x27;</span>: <span class="hljs-literal">True</span>,  <span class="hljs-comment"># optional, default is False</span><br>        <span class="hljs-string">&#x27;magic_response&#x27;</span>: <span class="hljs-literal">False</span>,    <span class="hljs-comment"># optional, default is True</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>splash 参数中的内容是用于splash的，使用这个参数表明我们希望向splash发送渲染请求。</p><p>最终它们会被组织成 request.meta[‘splash’] 。在scrapy处理这些请求的时候根据这个来确定是否创建spalsh的 中间件，最终请求会被中间件以HTTP API的方式转发到splash中  </p><p><code>splash</code>中各个参数的作用如下:</p><ul><li><p>meta[‘splash’][‘args’] 是最终发送到splash HTTP API的参数</p><ul><li>url 表示目标站点的url</li><li>http_method 表示向url发送的HTTP的请求方式</li><li>body 是采用POST方式发送请求时，请求体的内容</li></ul></li><li><p>meta[‘splash’][‘cache_args’] 表示将要被作为缓冲的参数的列表字符串，以分号分隔</p></li><li><p>meta[‘splash’][‘endpoint’] 表示对应的端点</p></li><li><p>meta[‘splash’][‘splash_url’] 与settings文件中的 SPLASH_URL 作用相同，但是会优先采用这里的设置</p></li><li><p>meta[‘splash’][‘splash_headers’] 即将发送到splash服务器上的请求头信息，注意，这里它不是最终发送到对应站点的请求头信息</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>Scrapy</tag>
      
      <tag>Splash</tag>
      
      <tag>Scrapy-Splash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器软件分类与常用服务器软件</title>
    <link href="/post/2257bb18/"/>
    <url>/post/2257bb18/</url>
    
    <content type="html"><![CDATA[<h2 id="按动静服务分"><a href="#按动静服务分" class="headerlink" title="按动静服务分"></a>按动静服务分</h2><ul><li>静态服务：主要提供静态资源，不同用户访问到的资源相同</li><li>动态服务：提供动态服务，不同用户访问到的资源不同</li></ul><h2 id="服务器的几个叫法："><a href="#服务器的几个叫法：" class="headerlink" title="服务器的几个叫法："></a>服务器的几个叫法：</h2><ul><li>web服务器：广义上来说，就是响应用户的需求，提供服务，当下所有的服务器软件都可以称之为web服务器软件</li><li>HTTP服务器(静态服务)：使用HTTP协议传输资源，提供服务</li><li>应用服务器(动态服务)：一个特定应用的承载容器</li></ul><h2 id="常见的轻量级服务器软件："><a href="#常见的轻量级服务器软件：" class="headerlink" title="常见的轻量级服务器软件："></a>常见的轻量级服务器软件：</h2><ul><li> <code>Nginx</code>：典型的静态服务器，可做反向代理、负载均衡，一般放在最前面直面用户，和后端Tomcat打配合；纯C写的，性能贼高、内存消耗极少、稳定性也相当好，互联网公司重度使用</li><li> <code>Tengine</code>：阿里出品，基于Nginx服务器做的改造(加强和封装)，对大流量场景做了很多高级功能，性能、稳定性优秀</li><li> <code>Apache http server</code>：也是静态服务器，但是不如Nginx</li><li> <code>IIS</code>：微软开发，只能用在Windows下，具有应用服务器能力的http服务器</li><li> <code>Tomcat</code>：Apache出品，典型的应用服务器软件，符合Servlet标准的应用容器，也可以提供http服务，但一般不会作为http服务器；是Spring Boot框架默认的内置服务器</li><li> <code>Jetty</code>：跟Tomcat是一个性质的东西，符合Servlet标准的应用容器，也是Spring Boot框架支持的服务器，但不是默认的</li><li> <code>Undertow</code>：红帽子出品，跟Tomcat、Jetty一样也是Spring Boot框架支持的服务器，但不是默认的；高并发时性能优于Tomcat、Jetty</li></ul><h2 id="几款商用重量级的服务器软件："><a href="#几款商用重量级的服务器软件：" class="headerlink" title="几款商用重量级的服务器软件："></a>几款商用重量级的服务器软件：</h2><ul><li><code>JBoss</code>(从8版开始更名为<code>WildFly</code>)：不仅是Servlet应用容器，更是EJB的应用容器，整套JavaEE框架部署的解决方案</li><li> <code>WebLogic</code>：Oracle公司出品，用于部署企业级JavaEE应用，全能型，几乎支持JavaEE所有的应用规范</li><li> <code>WebSphere</code>：IBM公司出品，支持更多JavaEE的应用规范的综合应用服务器</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy-基础</title>
    <link href="/post/5c6a28/"/>
    <url>/post/5c6a28/</url>
    
    <content type="html"><![CDATA[<h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a><strong>链接</strong></h2><p>官网：<a href="https://scrapy.org/">https://scrapy.org/</a><br>官方文档：<a href="https://docs.scrapy.org/en/latest/">https://docs.scrapy.org/en/latest/</a><br>翻译文档：<a href="https://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/overview.html">https://scrapy-chs.readthedocs.io/zh_CN/1.0/intro/overview.html</a></p><h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a><strong>信息</strong></h2><p>特点：入门快，扩展性强<br>内建CSS选择器和XPath表达式<br>基于IPython shell<br><img src="/Scrapy%E5%9F%BA%E7%A1%80/20200407124348251.png"></p><h3 id="Scrapy主要组件"><a href="#Scrapy主要组件" class="headerlink" title="Scrapy主要组件"></a><strong>Scrapy主要组件</strong></h3><ul><li><strong>引擎(Scrapy)</strong><br>  <em>用来处理整个系统的数据流处理, 触发事务(框架核心)</em></li><li><strong>调度器(Scheduler)</strong><br>  <em>用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址</em></li><li><strong>下载器(Downloader)</strong><br>  <em>用于下载网页内容, 并将网页内容返回给蜘蛛(Scrapy下载器是建立在twisted这个高效的异步模型上的)</em></li><li><strong>爬虫(Spiders)</strong><br>  <em>爬虫是主要干活的, 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。用户也可以从中提取出链接,让Scrapy继续抓取下一个页面</em></li><li><strong>项目管道(Pipeline)</strong><br>  <em>负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。</em></li><li><strong>下载器中间件(Downloader Middlewares)</strong><br>  <em>位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。</em></li><li><strong>爬虫中间件(Spider Middlewares)</strong><br>  <em>介于Scrapy引擎和爬虫之间的框架，主要工作是处理蜘蛛的响应输入和请求输出。</em></li><li><strong>调度中间件(Scheduler Middewares)</strong><br>  <em>介于Scrapy引擎和调度之间的中间件，从Scrapy引擎发送到调度的请求和响应。</em></li></ul><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a><strong>运行流程</strong></h3><ol><li>Engine从Spider中得到第一个Requests进行爬取</li><li>ENGIN将Request放入SCHEDULER调度器，并且获取下个Request</li><li>SCHEDULER将Requests返回给ENGINE（因为ENGING进行任务调度）</li><li>ENGINE发送Requests到Downoader，通过Downloader Middlewares 进行处理（这一步进行Http请求，返回response）</li><li>通过Downloader Middleware进行资源下载(就是html信息)，如果下载完成，通过Dowloader生成一个Resonse并且发送给ENGINE</li><li>ENGINE 从DOWNLOADER接收 Resonse,并将Resonse发送给Spider进行处理。Spider通过Spider Middleware进行处理Response</li><li>Spider处理Response 并且返回items和新的Requests给ENGINE,这部分处理通过Spilder Middleware进行处理</li><li>Engine发送items到item Pipelines 然后 发送 Request到Scheduler 并且 获取下个Request进行处理</li><li>重复第一个步骤进行处理。</li></ol><h3 id="基本代码流程"><a href="#基本代码流程" class="headerlink" title="基本代码流程"></a><strong>基本代码流程</strong></h3><p>编写item，编写spider与setting，编写pipeline</p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a><strong>基础操作</strong></h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install Scrapy<br></code></pre></td></tr></table></figure><p>若是希望使用<code>Scrapy shell</code>的话，需要留意<code>python环境变量</code>的问题</p><h4 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a><strong>创建项目</strong></h4><p>选定一个文件夹，打开控制台。输入指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">scrapy startproject tutorial<br></code></pre></td></tr></table></figure><p>命令会创建tutorial目录，并在里面生成一些文件</p><ul><li><code>scrapy.cfg</code>: 项目的配置文件</li><li><code>tutorial/</code>: 该项目的python模块。之后您将在此加入代码</li><li><code>tutorial/items.py</code>: 项目中的item文件</li><li><code>tutorial/pipelines.py</code>: 项目中的pipelines文件</li><li><code>tutorial/settings.py</code>: 项目的设置文件</li><li><code>tutorial/spiders/</code>: 放置spider代码的目录</li></ul><h4 id="定义Item"><a href="#定义Item" class="headerlink" title="定义Item"></a><strong>定义Item</strong></h4><p><code>Item</code> 是保存爬取到的数据的容器。<br>其使用方法和 python字典 类似， 并且提供了额外保护机制来避免拼写错误导致的未定义字段错误。</p><p>根据需要 爬取的网页 获取到的数据对<code>Item</code>进行建模。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TutorialItem</span>(<span class="hljs-params">scrapy.Item</span>):</span><br>    identification = scrapy.Field()<br>    name = scrapy.Field()<br></code></pre></td></tr></table></figure><p>这里定义了一个<code>Item 类</code>，类中包含两个属性  </p><h4 id="编写Spider"><a href="#编写Spider" class="headerlink" title="编写Spider"></a><strong>编写Spider</strong></h4><p>Spider是用户编写用于从单个网站(或者一些网站)爬取数据的类。</p><p>其包含了一个用于下载的初始URL，如何跟进网页中的链接以及如何分析页面中的内容， 提取生成 item 的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> scrapy<br><span class="hljs-keyword">from</span> tutorial.items <span class="hljs-keyword">import</span> TutorialItem<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BingSpider</span>(<span class="hljs-params">scrapy.spiders.Spider</span>):</span><br>    name = <span class="hljs-string">&quot;first&quot;</span><br>    allowed_domains = [<span class="hljs-string">&quot;bing.com&quot;</span>]<br>    start_urls = [<span class="hljs-string">&quot;https://cn.bing.com/&quot;</span>]<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">self, response</span>):</span><br>        item = TutorialItem()<br>        item[<span class="hljs-string">&quot;identification&quot;</span>] = response.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;b_footerItems&quot;]//text()&#x27;</span>).extract()<br>        item[<span class="hljs-string">&quot;name&quot;</span>] = response.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;sbox&quot;]//text()&#x27;</span>).extract()<br>        <span class="hljs-keyword">yield</span> item<br></code></pre></td></tr></table></figure><ul><li><p>关于定义本身<br>为了创建一个<code>Spider</code>，您必须继承<code>scrapy.spiders.Spider</code>类， 且定义一些属性:</p><ul><li><code>name</code>: 用于区别<code>Spider</code>。 该名字必须是唯一的，您不可以为不同的<code>Spider</code>设定相同的名字。</li><li><code>start_urls</code>: 包含了<code>Spider</code>在启动时进行爬取的<code>url</code>列表。 因此，第一个被获取到的页面将是其中之一。 后续的URL则从初始的URL获取到的数据中提取。</li><li><code>parse()</code> 是<code>Spider</code>的一个方法。 被调用时，每个 初始URL 完成下载后生成的<code>Response</code>对象将会作为唯一的参数传递给该函数。 该方法负责解析返回的数据(response data)，提取数据(生成<code>item</code>)以及生成需要进一步处理的URL的 <code>Request</code>对象。</li></ul></li><li><p>获取html中的数据<br><code>Scrapy</code>使用基于<code>XPath</code>和<code>CSS选择器</code>的机制<code>Scrapy Selectors</code>来选取Html中的元素。<br><code>Scrapy Selectors</code>的四种基本方法</p><ul><li>xpath(): 传入xpath表达式，返回该表达式所对应的所有节点的selector list列表 。</li><li>css(): 传入CSS表达式，返回该表达式所对应的所有节点的selector list列表.</li><li>extract(): 序列化该节点为unicode字符串并返回list。</li><li>re(): 根据传入的正则表达式对数据进行提取，返回unicode字符串list列表。</li></ul></li></ul><blockquote><p>如果想要记录整个编码后的网页可以这样做</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.body</span><span class="hljs-selector-class">.decode</span>(<span class="hljs-selector-tag">response</span><span class="hljs-selector-class">.encoding</span>)<br></code></pre></td></tr></table></figure><h4 id="进行爬取"><a href="#进行爬取" class="headerlink" title="进行爬取"></a><strong>进行爬取</strong></h4><p>进入项目的根目录，执行下列命令启动<code>Spider</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scrapy crawl first<br></code></pre></td></tr></table></figure><p>这里的 first 对应着<code>Spider</code>中定义的<code>name</code><br>在控制台里你会看到一些详细的输出信息。<br>过程：</p><ol><li><code>Scrapy</code>为<code>Spider</code>的 <code>start_urls</code> 属性中的每个URL创建了 <code>scrapy.Request</code> 对象，并将 <code>parse</code> 方法作为回调函数(callback)赋值给了<code>Request</code>。</li><li>Request对象经过调度，执行生成 <code>scrapy.http.Response</code> 对象并送回给<code>Spider parse()</code> 方法。</li></ol><h4 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a><strong>保存数据</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">scrapy crawl first -o items.json<br></code></pre></td></tr></table></figure><p>该命令将采用<code>JSON</code>格式对爬取的数据进行序列化，生成 <code>items.json</code> 文件。<br>在类似本篇教程里这样小规模的项目中，这种存储方式已经足够。<br>如果需要对爬取到的<code>item</code>做更多更为复杂的操作，您可以编写 <code>Item Pipeline</code> 。<br>类似于我们在创建项目时对<code>Item</code>做的，用于您编写自己的 <code>tutorial/pipelines.py</code> 也被创建。<br>不过如果您仅仅想要保存<code>item</code>，您不需要实现任何的<code>pipeline</code>  </p>]]></content>
    
    
    
    <tags>
      
      <tag>Scrapy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git-基础</title>
    <link href="/post/69c3279c/"/>
    <url>/post/69c3279c/</url>
    
    <content type="html"><![CDATA[<h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://git-scm.com/download">https://git-scm.com/download</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol start="0"><li>安装依赖的东西<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel nss  gcc perl-ExtUtils-MakeMaker <br><br></code></pre></td></tr></table></figure></li><li>下载安装包<br> 在一个地方打开控制台，然后下载安装包<br> 这里我下载一个2.9.5版本的git   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.9.5.tar.xz <br></code></pre></td></tr></table></figure></li><li>解压，并去到解压出来的目录下   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">tar xf git-2.9.5.tar.xz <br><span class="hljs-built_in">cd</span> git-2.9.5<br></code></pre></td></tr></table></figure></li><li>编译，安装   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">make prefix=/usr/<span class="hljs-built_in">local</span>/git all<br>make prefix=/usr/<span class="hljs-built_in">local</span>/git install<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export PATH=<span class="hljs-variable">$PATH</span>:/usr/local/git/bin&quot;</span> &gt;&gt; /etc/bashrc<br><span class="hljs-built_in">source</span> /etc/bashrc<br></code></pre></td></tr></table></figure></li><li>配置<br> 安装完了以后需要配置用户名和邮箱<br> 注意与github账户一致   <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;Name&quot;</span><br>git config --global user.email  <span class="hljs-string">&quot;E-mail&quot;</span><br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git remote <span class="hljs-keyword">add</span><span class="bash"> origin 添加远程仓库的SSH</span><br></code></pre></td></tr></table></figure><h3 id="推送到github-master-节点"><a href="#推送到github-master-节点" class="headerlink" title="推送到github master 节点"></a>推送到github master 节点</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">git <span class="hljs-built_in">push</span> <span class="hljs-built_in">origin</span> master<br></code></pre></td></tr></table></figure><h3 id="查看git版本"><a href="#查看git版本" class="headerlink" title="查看git版本"></a>查看git版本</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">git <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="更新git工具"><a href="#更新git工具" class="headerlink" title="更新git工具"></a>更新git工具</h3><h4 id="CentOS"><a href="#CentOS" class="headerlink" title="CentOS"></a>CentOS</h4><ol><li>centos7 添加源<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">yum install http:<span class="hljs-regexp">//</span>opensource.wandisco.com<span class="hljs-regexp">/centos/</span><span class="hljs-number">7</span><span class="hljs-regexp">/git/</span>x86_64/wandisco-git-release-<span class="hljs-number">7</span>-<span class="hljs-number">2</span>.noarch.rpm<br></code></pre></td></tr></table></figure></li><li>更新git工具<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yum update git</span><br></code></pre></td></tr></table></figure><h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4>git版本在2.17.1之前用<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git update</span><br></code></pre></td></tr></table></figure>在2.17.1之后用<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git update-git-for-windows</span><br></code></pre></td></tr></table></figure>若是版本非常低，则需要自己去官网下载安装包  </li></ol><h2 id="Github-SSH-Key"><a href="#Github-SSH-Key" class="headerlink" title="Github SSH Key"></a>Github SSH Key</h2><p>GitHub配置SSH Key的目的是为了帮助我们在通过git提交代码是，不需要繁琐的验证过程，简化操作流程  </p><ul><li>centos  <ol><li>创建SSH key  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ssh-keygen -t rsa -C <span class="hljs-string">&quot;Github邮箱&quot;</span><br></code></pre></td></tr></table></figure></li><li>拷贝ssh-rsa头  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> ~/.ssh  <span class="hljs-comment"># 来到SSH目录</span><br>ls  <span class="hljs-comment"># 查看创建的SSH key</span><br>cat id_rsa.pub <span class="hljs-comment"># 查看某个SSH key的头</span><br></code></pre></td></tr></table></figure><img src="/Git-%E5%9F%BA%E7%A1%80/20200331033744081.png"><br>在查看到以后，将它完整的复制下来  </li><li>Git Hub添加SSH Key<br><img src="/Git-%E5%9F%BA%E7%A1%80/20200331033843357.png"><br><img src="/Git-%E5%9F%BA%E7%A1%80/20200331033924152.png"><br>取个名字，将 <code>ssh-rsa</code> 头复制进去就完成了  </li></ol></li></ul><hr><p>参考：<br><a href="https://blog.csdn.net/u013778905/article/details/83501204">https://blog.csdn.net/u013778905/article/details/83501204</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS-xfce-中文输入法</title>
    <link href="/post/49efdfc2/"/>
    <url>/post/49efdfc2/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7 腾讯云服务器</li></ul><h2 id="显示输入框"><a href="#显示输入框" class="headerlink" title="显示输入框"></a><strong>显示输入框</strong></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">ibus-setup<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>xfce</tag>
      
      <tag>输入法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-121-买卖股票的最佳时机</title>
    <link href="/post/901a48fa/"/>
    <url>/post/901a48fa/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。<br>注意：你不能在买入股票前卖出股票。</p><p>示例 1:<br>　　输入: [7,1,5,3,6,4]<br>　　输出: 5<br>　　解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>　　注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p><p>示例 2:<br>　　输入: [7,6,4,3,1]<br>　　输出: 0<br>　　解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a><strong>自解</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices: List[<span class="hljs-built_in">int</span>]</span>) -&gt; int:</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> prices:<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>        min_befor = prices[<span class="hljs-number">0</span>]<br>        max_profit = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> prices:<br>            <span class="hljs-comment">#  记下当前位置之前最少的数</span><br>            min_befor = <span class="hljs-built_in">min</span>(i, min_befor)<br>            <span class="hljs-comment">#  如果过去最低点买入，今天卖出的话会不会超过最大的利润记录，会则更新记录</span><br>            max_profit = <span class="hljs-built_in">max</span>(max_profit, i-min_befor)<br>        <span class="hljs-keyword">return</span> max_profit<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><h2 id="官方思路"><a href="#官方思路" class="headerlink" title="官方思路"></a><strong>官方思路</strong></h2><p>动态规划一般分为一维、二维、多维（使用状态压缩），对应形式为 <code>dp(i)</code>、<code>dp(i)(j)</code>、二进制<code>dp(i)(j)</code>。</p><ol><li><p>动态规划做题步骤  </p><ul><li>明确 <code>dp(i)</code> 应该表示什么（二维情况：<code>dp(i)(j)</code>）；</li><li>根据 <code>dp(i)</code> 和 <code>dp(i−1)</code> 的关系得出状态转移方程；</li><li>确定初始条件，如 <code>dp(0)</code>。</li></ul></li><li><p>本题思路<br>其实方法一的思路不是凭空想象的，而是由动态规划的思想演变而来。这里介绍一维动态规划思想。<br><code>dp[i]</code>表示前 <code>i</code> 天的最大利润，因为我们始终要使利润最大化，则：<br>　　　　　　　　<code>dp[i]=max(dp[i−1],  prices[i]−minprice)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span>(<span class="hljs-params">self, prices: List[<span class="hljs-built_in">int</span>]</span>) -&gt; int:</span><br>        n = <span class="hljs-built_in">len</span>(prices)<br>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-comment"># 边界条件</span><br>        dp = [<span class="hljs-number">0</span>] * n<br>        minprice = prices[<span class="hljs-number">0</span>] <br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, n):<br>            minprice = <span class="hljs-built_in">min</span>(minprice, prices[i])<br>            dp[i] = <span class="hljs-built_in">max</span>(dp[i - <span class="hljs-number">1</span>], prices[i] - minprice)<br>        <span class="hljs-keyword">return</span> dp[-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Splash-js渲染-爬虫</title>
    <link href="/post/11f87120/"/>
    <url>/post/11f87120/</url>
    
    <content type="html"><![CDATA[<h2 id="Splash是什么？"><a href="#Splash是什么？" class="headerlink" title="Splash是什么？"></a><strong>Splash是什么？</strong></h2><p>Splash是一个javascript渲染服务。<br>它是一个带有HTTP API的轻量级Web浏览器，使用Twisted和QT5在Python 3中实现。<br>QT反应器用于使服务完全异步，允许通过QT主循环利用webkit并发。<br>是Scrapy推荐使用的javascript渲染<br>能起到和web driver相似的功能。<br>只能在 <strong>Linux</strong> 与 <strong>Mac</strong> 系统下安装</p><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a><strong>文档</strong></h2><p>官方文档：<a href="https://splash.readthedocs.io/en/latest/install.html">https://splash.readthedocs.io/en/latest/install.html</a><br>网友中文文档：<a href="https://splash-cn-doc.readthedocs.io/zh_CN/latest/scrapy-splash-toturial.html">https://splash-cn-doc.readthedocs.io/zh_CN/latest/scrapy-splash-toturial.html</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h2><p>此服务需要<code>Docker</code>才能安装  </p><ol><li><p>安装Docker<br>需求：Docker版本≥17  </p></li><li><p>拉取splash  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker pull scrapinghub/splash<br></code></pre></td></tr></table></figure></li><li><p>启动  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker run -itd -p 8050:8050 scrapinghub/splash<br></code></pre></td></tr></table></figure><blockquote><p>有些时候docker会抽风，无法连接，重启一下<code>docker</code>就好<code>service docker restart</code><br>  要是觉得太麻烦，可以在启动时添加启动参数</p><pre><code><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-builtin-name">run</span> -p 8050:8050 <span class="hljs-attribute">--restart</span>=always -d scrapinghub/splash<br></code></pre></td></tr></table></figure></code></pre><ul><li>-d 后台运行</li><li>–restart=always 崩溃后自动重新启动</li></ul></blockquote></li><li><p>测试服务<br>浏览器中输入网址<code>http://localhost:8050/</code><br><img src="/Splash-js%E6%B8%B2%E6%9F%93-%E7%88%AC%E8%99%AB/20200324060126796.png"><br>若是见到欢迎界面，那么久成了  </p></li></ol><p>运行好了以后，要是防火墙做好了设置，服务器外也能通过<code>ip:端口</code>的形式在浏览器访问到了</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a><strong>入门</strong></h2><h3 id="首页"><a href="#首页" class="headerlink" title="首页"></a><strong>首页</strong></h3><p><img src="/Splash-js%E6%B8%B2%E6%9F%93-%E7%88%AC%E8%99%AB/20200324060126796.png"><br>在首页看到的界面里的代码时<code>Lua</code>语言代码<br><img src="/Splash-js%E6%B8%B2%E6%9F%93-%E7%88%AC%E8%99%AB/20200324061037245.png"><br>点击Render来渲染指定的网页，并返回结果</p><h3 id="Splash提供的http接口"><a href="#Splash提供的http接口" class="headerlink" title="Splash提供的http接口"></a><strong>Splash提供的http接口</strong></h3><p><img src="/Splash-js%E6%B8%B2%E6%9F%93-%E7%88%AC%E8%99%AB/20200324062843769.png"></p><table><thead><tr><th>信息</th><th>意义</th></tr></thead><tbody><tr><td>url</td><td>restful风格url</br>对于抓取网页，最重要的是<code>render.html</code></br>虽然这个演示中并没有</br>一般来说请求类似这样</br><a href="http://localhost:8050/render.html%EF%BC%9Furl=http://www.baidu.com/&amp;timeout=30.0&amp;wait=0.5">http://localhost:8050/render.html？url=http://www.baidu.com/&amp;timeout=30.0&amp;wait=0.5</a> </br>参数解读：</br>url：请求的地址</br>* timeout：选填，超时时间</br>* wait：选填，页面加载完毕后，等待的时间</td></tr><tr><td>png</td><td>渲染效果截图</td></tr><tr><td>HAR</td><td>HTTP Archive format:用来记录浏览器加载网页时所消耗的时间的工具。</br>记录每一个HTTP请求发出直到收到完整的HTTP响应中间所耗费的时间，可以迅速帮助我们知道是哪些HTTP请求没有得到及时的回复，从而进行更一步的排查。</td></tr><tr><td>html</td><td>网页html</td></tr></tbody></table><h4 id="通过shell进行"><a href="#通过shell进行" class="headerlink" title="通过shell进行"></a><strong>通过shell进行</strong></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&#x27;http://localhost:8050/render.html？url=http://www.baidu.com/&amp;timeout=30.0&amp;wait=0.5&#x27;</span><br></code></pre></td></tr></table></figure><p>效果就类似于<code>get</code>请求一般，返回来的<code>html</code>是已经渲染好了的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl <span class="hljs-string">&#x27;http://localhost:8050/render.html？url=http://www.baidu.com/&amp;timeout=30.0&amp;wait=0.5&#x27;</span> -X POST<br></code></pre></td></tr></table></figure><p>如果要发送<code>post</code>请求的话，这样就可以了。</p><h4 id="通过python进行"><a href="#通过python进行" class="headerlink" title="通过python进行"></a><strong>通过python进行</strong></h4><p>使用方法很简单，就是像普通的请求那样请求本地的Splash即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">url = <span class="hljs-string">&#x27;http://localhost:8050/render.html？url=http://www.baidu.com/&amp;timeout=30.0&amp;wait=0.5&#x27;</span><br>response = request.get(url)<br>print(response.text)    <br></code></pre></td></tr></table></figure><p>使用<code>Scrapy</code>的话，有专门的<code>Scrapy</code>插件:<code>Scrapy-splash</code></p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a><strong>更多</strong></h2><p>其实<code>splash</code>不止于渲染，能实现一些浏览器一般的操作，诸如鼠标点击，键盘输入都不在话下。<br>不过，要想实现这些，就需要编写<code>lua</code>代码来实现。<br>可以在python中写好<code>lua</code>代码，通过参数传递过去。</p>]]></content>
    
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>Splash</tag>
      
      <tag>js渲染</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker-容器-基础</title>
    <link href="/post/721103b4/"/>
    <url>/post/721103b4/</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Centos7 腾讯云服务器</li></ul><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p><a href="https://docs.docker.com/install/linux/docker-ce/centos/">https://docs.docker.com/install/linux/docker-ce/centos/</a></p><h2 id="Docker的优点"><a href="#Docker的优点" class="headerlink" title="Docker的优点"></a>Docker的优点</h2><h3 id="快速，一致地交付您的应用程序"><a href="#快速，一致地交付您的应用程序" class="headerlink" title="快速，一致地交付您的应用程序"></a>快速，一致地交付您的应用程序</h3><p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p><ul><li>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。</li><li>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。</li><li>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。</li><li>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</li></ul><h3 id="响应式部署和扩展"><a href="#响应式部署和扩展" class="headerlink" title="响应式部署和扩展"></a>响应式部署和扩展</h3><p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p><p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p><h3 id="在同一硬件上运行更多工作负载"><a href="#在同一硬件上运行更多工作负载" class="headerlink" title="在同一硬件上运行更多工作负载"></a>在同一硬件上运行更多工作负载</h3><p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p><h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><p>Docker 包括三个基本概念:</p><ul><li>镜像（Image）<br>Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li>容器（Container）<br>镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。</li><li>仓库（Repository）<br>仓库可看成一个代码控制中心，用来保存镜像。  </li></ul><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程API来管理和创建Docker容器。  </p><p>Docker 容器通过 Docker 镜像来创建。</p><p>容器与镜像的关系类似于面向对象编程中的对象与类。</p><table><thead><tr><th>Docker</th><th>面向对象</th></tr></thead><tbody><tr><td>容器</td><td>对象</td></tr><tr><td>镜像</td><td>类</td></tr></tbody></table><p><img src="/Docker-%E5%AE%B9%E5%99%A8-%E5%9F%BA%E7%A1%80/20200703121310312.png"></p><table><thead><tr><th>概念</th><th>说明</th></tr></thead><tbody><tr><td>Docker 镜像(Images)</td><td>Docker 镜像是用于创建 Docker 容器的模板，比如 Ubuntu 系统。</td></tr><tr><td>Docker 容器(Container)</td><td>容器是独立运行的一个或一组应用，是镜像运行时的实体。</td></tr><tr><td>Docker 客户端(Client)</td><td>Docker 客户端通过命令行或者其他工具使用 Docker SDK (<a href="https://docs.docker.com/develop/sdk/">https://docs.docker.com/develop/sdk/</a>) 与 Docker 的守护进程通信。</td></tr><tr><td>Docker 主机(Host)</td><td>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</td></tr><tr><td>Docker Registry</td><td>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。<br>Docker Hub(<a href="https://hub.docker.com/">https://hub.docker.com</a>) 提供了庞大的镜像集合供使用。<br>一个 Docker Registry 中可以包含多个仓库（Repository）；每个仓库可以包含多个标签（Tag）；每个标签对应一个镜像。通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过<code> &lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</td></tr><tr><td>Docker Machine</td><td>Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</td></tr></tbody></table><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><code>Docker CE</code> 即社区免费版<br><code>Docker EE</code> 即企业版，强调安全，但需付费使用<br>此处为<code>Docker CE</code></p><h3 id="安装的前提条件"><a href="#安装的前提条件" class="headerlink" title="安装的前提条件"></a>安装的前提条件</h3><p>CentOS7 发行版 64位<br>内核版本3.10以上  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">uname -r  <span class="hljs-comment"># 查询内核版本</span><br></code></pre></td></tr></table></figure><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h3><ol><li><strong>卸载旧版本</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-engine<br></code></pre></td></tr></table></figure></li><li><strong>安装必要的包</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install -y yum-utils \<br>  device-mapper-persistent-data \<br>  lvm2<br></code></pre></td></tr></table></figure></li><li><strong>设置可靠的存储库</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum-config-manager \<br>    --add-repo \<br>    https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure></li><li><strong>安装Docker-ce</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y docker-ce<br></code></pre></td></tr></table></figure></li><li><strong>安装Docker-ce</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start docker<br></code></pre></td></tr></table></figure></li><li><strong>测试运行 hello-world</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run hello-world<br></code></pre></td></tr></table></figure> 由于本地没有hello-world这个镜像，所以会下载一个hello-world的镜像，并在容器内运行，看到以上界面说明Docker已经成功安装</li></ol><h2 id="将docker修改为国内镜像源"><a href="#将docker修改为国内镜像源" class="headerlink" title="将docker修改为国内镜像源"></a><strong>将docker修改为国内镜像源</strong></h2><p>国内<code>pull</code>很慢, 需要更换镜像源<br>这里我将镜像源更改为阿里云的</p><ol><li>打开/创建配置文件<br>没有这个文件就创建<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/docker/daemon.json<br></code></pre></td></tr></table></figure></li><li>修改文件<br>文件中添加下面参数<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://9cpn8tt6.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure> 保存退出</li><li>重启Docker服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo service docker restart<br></code></pre></td></tr></table></figure><h3 id="可选的国内加速地址"><a href="#可选的国内加速地址" class="headerlink" title="可选的国内加速地址"></a>可选的国内加速地址</h3>你应该稍微测试一下能不能用，毕竟这东西不时出问题。</li></ol><table><thead><tr><th>镜像信息</th><th>内容</th></tr></thead><tbody><tr><td>Docker中国区官方镜像</td><td><a href="https://registry.docker-cn.com/">https://registry.docker-cn.com</a></td></tr><tr><td>网易</td><td><a href="http://hub-mirror.c.163.com/">http://hub-mirror.c.163.com</a></td></tr><tr><td>ustc</td><td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>中国科技大学</td><td><a href="https://docker.mirrors.ustc.edu.cn/">https://docker.mirrors.ustc.edu.cn</a></td></tr><tr><td>阿里云容器</td><td><a href="https://cr.console.aliyun.com/">https://cr.console.aliyun.com/</a> </br>首页点击“创建我的容器镜像”  得到一个专属的镜像加速地址</td></tr></tbody></table><h2 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h2><h3 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h3><table><thead><tr><th>参数</th><th>简写</th><th>意义</th></tr></thead><tbody><tr><td>–detach</td><td>-d</td><td>在后台运行容器，并且打印容器id</td></tr><tr><td>–interactive</td><td>-i</td><td>即使没有连接，也要保持标准输入保持打开状态，一般与 -t 连用</td></tr><tr><td>–tty</td><td>-t</td><td>分配一个伪tty，一般与 -i 连用</td></tr></tbody></table><p><code>-i</code> <code>-t</code> <code>-d</code> 可以简写为<code>-itd</code></p><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><h3 id="删除Docker-ce"><a href="#删除Docker-ce" class="headerlink" title="删除Docker-ce"></a>删除Docker-ce</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove -y docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-selinux \<br>                  docker-engine-selinux \<br>                  docker-engine<br>rm -rf /var/lib/docker<br></code></pre></td></tr></table></figure><h3 id="查看Docker版本"><a href="#查看Docker版本" class="headerlink" title="查看Docker版本"></a>查看Docker版本</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker --version<br></code></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="Cannot-connect-to-the-Docker-daemon-at-unix-var-run-docker-sock-Is-the-docker-daemon-running"><a href="#Cannot-connect-to-the-Docker-daemon-at-unix-var-run-docker-sock-Is-the-docker-daemon-running" class="headerlink" title="Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?"></a><strong>Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl daemon-reload<br>systemctl restart docker.service<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>容器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-中等-365-水壶问题</title>
    <link href="/post/3f4c2772/"/>
    <url>/post/3f4c2772/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>　　有两个容量分别为 x升 和 y升 的水壶以及无限多的水。请判断能否通过使用这两个水壶，从而可以得到恰好 z升 的水？<br>　　如果可以，最后请用以上水壶中的一或两个来盛放取得的 z升 水。<br>　　你允许：<br>　　　　装满任意一个水壶<br>　　　　清空任意一个水壶<br>　　　　从一个水壶向另外一个水壶倒水，直到装满或者倒空</p><p>示例 1: (From the famous “Die Hard” example)<br>　　输入: x = 3, y = 5, z = 4<br>　　输出: True</p><p>示例 2:<br>　　输入: x = 2, y = 6, z = 5<br>　　输出: False</p><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a><strong>自解</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">canMeasureWater</span>(<span class="hljs-params">self, x: <span class="hljs-built_in">int</span>, y: <span class="hljs-built_in">int</span>, z: <span class="hljs-built_in">int</span></span>) -&gt; bool:</span><br>        statues = <span class="hljs-built_in">set</span>()<br>        stack = &#123;(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>)&#125;<br><br>        <span class="hljs-keyword">while</span> stack:<br>            now_x, now_y = stack.pop()<br><br>            <span class="hljs-keyword">if</span> now_x==z <span class="hljs-keyword">or</span> now_y==z <span class="hljs-keyword">or</span> now_x+now_y==z:<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br><br>            <span class="hljs-keyword">if</span> (now_x, now_y) <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> statues:<br>                statues.add((now_x, now_y))<br><br>                <span class="hljs-comment"># 倒光其中一个</span><br>                stack.add((<span class="hljs-number">0</span>, now_y))<br>                stack.add((now_x, <span class="hljs-number">0</span>))<br>                <span class="hljs-comment"># 装满其中一个</span><br>                stack.add((x, now_y))<br>                stack.add((now_x, y))<br>                <span class="hljs-comment"># 一个倒入另一个, 判断是否会超出容量</span><br>                <span class="hljs-comment"># 全入y</span><br>                <span class="hljs-keyword">if</span> now_x+now_y &lt; y:<br>                    stack.add((<span class="hljs-number">0</span>, now_x+now_y))<br>                <span class="hljs-keyword">else</span>:<br>                    now_x = now_x - (y - now_y)<br>                    stack.add((now_x, y))<br>                <span class="hljs-comment"># 全入x</span><br>                <span class="hljs-keyword">if</span> now_x+now_y &lt; x:<br>                    stack.add((now_x+now_y, <span class="hljs-number">0</span>))<br>                <span class="hljs-keyword">else</span>:<br>                    now_y = now_y - (x - now_x)<br>                    stack.add((x, now_y))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>运用set(集合)不会有重复元素的功能。<br>通过深度优先的方法迭代获得结果。<br>O(xy)</p><h2 id="数学解法"><a href="#数学解法" class="headerlink" title="数学解法"></a><strong>数学解法</strong></h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>这是一道关于<code>数论</code>的题目，确切地说是关于<code>裴蜀定理</code>（英语：Bézout’s identity）的题目。<br><a href="https://baike.baidu.com/item/%E8%A3%B4%E8%9C%80%E5%AE%9A%E7%90%86/5186593?fromtitle=%E8%B4%9D%E7%A5%96%E5%AE%9A%E7%90%86">裴蜀定理</a></p><p>　　我们认为，每次操作只会让桶里的水总量增加<code>x</code>，增加 <code>y</code>，减少<code>x</code>，或者减少<code>y</code>。  </p><p>　　你可能认为这有问题：如果往一个不满的桶里放水，或者把它排空呢？那变化量不就不是<code>x</code>或者<code>y</code>了吗？接下来我们来解释这一点：</p><ul><li>首先要清楚，在题目所给的操作下，两个桶不可能同时有水且不满。因为观察所有题目中的操作，操作的结果都至少有一个桶是空的或者满的</li><li>其次，对一个不满的桶加水是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于直接从初始状态给这个桶加满水；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态分别给两个桶加满；  </li><li>再次，把一个不满的桶里面的水倒掉是没有意义的。因为如果另一个桶是空的，那么这个操作的结果等价于回到初始状态；而如果另一个桶是满的，那么这个操作的结果等价于从初始状态直接给另一个桶倒满。</li></ul><p>　　因此，我们可以认为每次操作只会给水的总量带来 <code>x</code> 或者 <code>y</code> 的变化量。因此我们的目标可以改写成：找到一对整数 <code>a,ba</code>，使得</p><p><code>ax+by=z</code></p><p>而只要满足 <code>z≤x+y</code>，且这样的 <code>a,b</code> 存在，那么我们的目标就是可以达成的。这是因为：</p><ul><li>若 a≥0,b≥0，那么显然可以达成目标。</li><li>若 a&lt;0，那么可以进行以下操作：<ol><li>往 <code>y</code> 壶倒水；</li><li>把 <code>y</code> 壶的水倒入 <code>x</code> 壶；</li><li>如果 <code>y</code> 壶不为空，那么 <code>x</code> 壶肯定是满的，把 x 壶倒空，然后再把 <code>y</code> 壶的水倒入 <code>x</code> 壶。</li><li>重复以上操作直至某一步时 <code>x</code> 壶进行了 <code>a</code> 次倒空操作，<code>y</code> 壶进行了 <code>b</code> 次倒水操作。</li></ol></li><li>若 b&lt;0，方法同上，x 与 y 互换。</li></ul><p>而贝祖定理告诉我们，<code>ax+by=z</code> 有解当且仅当 <code>z</code> 是 <code>x,y</code> 的最大公约数的倍数。因此我们只需要找到 <code>x,y</code> 的最大公约数并判断 <code>z</code> 是否是它的倍数即可。</p><hr><p>参考：</p><ul><li><a href="https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/">https://leetcode-cn.com/problems/water-and-jug-problem/solution/shui-hu-wen-ti-by-leetcode-solution/</a></li><li><a href="https://www.youtube.com/watch?v=0Oef3MHYEC0">https://www.youtube.com/watch?v=0Oef3MHYEC0</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>裴蜀定理</tag>
      
      <tag>贝祖定理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-206. 反转链表</title>
    <link href="/post/44a5a6a1/"/>
    <url>/post/44a5a6a1/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>反转一个单链表。<br>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><br><span class="hljs-comment"># class ListNode:</span><br><span class="hljs-comment">#     def __init__(self, x):</span><br><span class="hljs-comment">#         self.val = x</span><br><span class="hljs-comment">#         self.next = None</span><br></code></pre></td></tr></table></figure><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a><strong>自解</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span>(<span class="hljs-params">self, head: ListNode</span>) -&gt; ListNode:</span><br>        pre, tai = <span class="hljs-literal">None</span>, head<br>        <span class="hljs-keyword">while</span> tai:<br>            temp = tai.<span class="hljs-built_in">next</span> <span class="hljs-comment"># 记下下一个节点备用</span><br><br>            tai.<span class="hljs-built_in">next</span> = pre<br>            pre = tai<br>            tai = temp<br>        <span class="hljs-keyword">return</span> pre<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>简单迭代，只要每次覆盖next之前记录下来就没问题了。<br>O(n)</p><h2 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a><strong>大佬解法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseList</span>(<span class="hljs-params">self, head</span>):</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">:type head: ListNode</span><br><span class="hljs-string">:rtype: ListNode</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-comment"># 递归终止条件是当前为空，或者下一个节点为空</span><br><span class="hljs-keyword">if</span>(head==<span class="hljs-literal">None</span> <span class="hljs-keyword">or</span> head.<span class="hljs-built_in">next</span>==<span class="hljs-literal">None</span>):<br><span class="hljs-keyword">return</span> head<br><span class="hljs-comment"># 这里的cur就是最后一个节点</span><br>cur = self.reverseList(head.<span class="hljs-built_in">next</span>)<br><span class="hljs-comment"># 这里请配合动画演示理解</span><br><span class="hljs-comment"># 如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5</span><br><span class="hljs-comment"># 而head是4，head的下一个是5，下下一个是空</span><br><span class="hljs-comment"># 所以head.next.next 就是5-&gt;4</span><br>head.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = head<br><span class="hljs-comment"># 防止链表循环，需要将head.next设置为空</span><br>head.<span class="hljs-built_in">next</span> = <span class="hljs-literal">None</span><br><span class="hljs-comment"># 每层递归函数都返回cur，也就是最后一个节点</span><br><span class="hljs-keyword">return</span> cur<br></code></pre></td></tr></table></figure><p><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-206.-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/%E9%80%92%E5%BD%92.gif"></p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>这题有个很骚气的递归解法，递归解法很不好理解，这里最好配合代码和动画一起理解。<br>递归的两个条件：</p><p>终止条件是当前节点或者下一个节点==null<br>    在函数内部，改变节点的指向，也就是 head 的下一个节点指向 head 递归函数那句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">head.<span class="hljs-built_in">next</span>.<span class="hljs-built_in">next</span> = head<br></code></pre></td></tr></table></figure><p>很不好理解，其实就是 head 的下一个节点指向head。<br>递归函数中每次返回的 cur 其实只最后一个节点，在递归函数内部，改变的是当前节点的指向。<br>动画演示如下：</p><hr><p>参考：<br><a href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a><br><a href="https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/">https://leetcode-cn.com/problems/reverse-linked-list/solution/dong-hua-yan-shi-206-fan-zhuan-lian-biao-by-user74/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-面试题 10.01. 合并排序的数组</title>
    <link href="/post/4951caca/"/>
    <url>/post/4951caca/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>给定两个排序后的数组 A 和 B，其中 A 的末端有足够的缓冲空间容纳 B。 编写一个方法，将 B 合并入 A 并排序。</p><p>初始化 A 和 B 的元素数量分别为 m 和 n。</p><p>示例:<br>　　输入:<br>　　　　A = [1,2,3,0,0,0], m = 3<br>　　　　B = [2,5,6],       n = 3<br>输出: [1,2,2,3,5,6]</p><p>说明:<br>　　A.length == n + m</p><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a><strong>自解</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">self, A: List[<span class="hljs-built_in">int</span>], m: <span class="hljs-built_in">int</span>, B: List[<span class="hljs-built_in">int</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        Do not return anything, modify A in-place instead.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(m+n-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>):<br>            <span class="hljs-comment"># 快速结束条件</span><br>            <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> m == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>                    A[i] = B[i]<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-comment"># A与B中最后的数比较，较大的塞最后</span><br>            <span class="hljs-keyword">if</span> A[m-<span class="hljs-number">1</span>] &gt; B[n-<span class="hljs-number">1</span>]:<br>                A[a] = A[m-<span class="hljs-number">1</span>]<br>                A[m-<span class="hljs-number">1</span>] = <span class="hljs-number">0</span><br>                m = m-<span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                A[a] = B[n-<span class="hljs-number">1</span>]<br>                n = n - <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>思路：每次比较两数组最后有效的数，大的放后面。</p><h2 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a><strong>大佬解法</strong></h2><p>这一次我的思路居然和大佬的一样…..<br><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%98-10.01.-%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84/20200316035302605.gif"></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><strong>完整代码</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span>(<span class="hljs-params">self, A: List[<span class="hljs-built_in">int</span>], m: <span class="hljs-built_in">int</span>, B: List[<span class="hljs-built_in">int</span>], n: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        idx1 = m - <span class="hljs-number">1</span><br>        idx2 = n - <span class="hljs-number">1</span><br>        cur = m + n - <span class="hljs-number">1</span> <span class="hljs-comment"># 添加 cur 指针追踪位置</span><br>        <span class="hljs-keyword">while</span> idx1 &gt; -<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> idx2 &gt; -<span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># print(A)</span><br>            <span class="hljs-keyword">if</span> A[idx1] &lt; B[idx2]:<br>                A[cur] = B[idx2]<br>                cur -= <span class="hljs-number">1</span><br>                idx2 -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                A[cur] = A[idx1]<br>                cur -= <span class="hljs-number">1</span><br>                idx1 -= <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> idx2 != -<span class="hljs-number">1</span>: A[:idx2 + <span class="hljs-number">1</span>] = B[:idx2 + <span class="hljs-number">1</span>] <span class="hljs-comment"># 比较完B还有剩下的，全填到A前面即可</span><br>        <span class="hljs-keyword">return</span> A<br></code></pre></td></tr></table></figure><hr><p>参考：<br><a href="https://leetcode-cn.com/problems/sorted-merge-lcci/solution/tu-jie-shuang-zhi-zhen-yuan-di-xiu-gai-by-z1m/">https://leetcode-cn.com/problems/sorted-merge-lcci/solution/tu-jie-shuang-zhi-zhen-yuan-di-xiu-gai-by-z1m/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
      <tag>合并排序的数组</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署-CentOS-VNC-tigervnc</title>
    <link href="/post/68a5bdc6/"/>
    <url>/post/68a5bdc6/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7.2 腾讯云服务器</li></ul><h2 id="VNC简介"><a href="#VNC简介" class="headerlink" title="VNC简介"></a><strong>VNC简介</strong></h2><p>VNC由Olivetti &amp; Oracle研究室所開發，此研究室在1999年併入美國電話電報公司（AT&amp;T）。AT&amp;T於2002年中止了此研究室的運作，並把VNC以GPL釋出。<br>由於VNC以GPL授權，衍生出了幾個VNC軟體：</p><table><thead><tr><th>VNC类型</th><th>信息</th></tr></thead><tbody><tr><td>RealVNC</td><td>由VNC團隊部份成員開發，分為全功能商業版及免費版。</td></tr><tr><td>TightVNC</td><td>強調節省頻寬使用</td></tr><tr><td>UltraVNC</td><td>加入了TightVNC的部份程式及加強效能的圖型映射驅動程式，並結合Active Directory及NTLM的帳號密碼認證，但僅有Windows版本。</td></tr><tr><td>Vine Viewer</td><td>MacOSX的VNC用戶端</td></tr></tbody></table><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a><strong>官方文档</strong></h2><p><a href="https://tigervnc.org/">官方首页</a><br>在首页下面有配置相关的文档<br>[TigerVNC的官方github Wiki](<a href="https://github.com/TigerVNC/tigervnc/wiki">https://github.com/TigerVNC/tigervnc/wiki</a><br><a href="https://tigervnc.org/doc/vncconfig.html">https://tigervnc.org/doc/vncconfig.html</a>)</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong>操作</strong></h2><h3 id="部署服务器端"><a href="#部署服务器端" class="headerlink" title="部署服务器端"></a><strong>部署服务器端</strong></h3><h4 id="TightVNC安装与配置"><a href="#TightVNC安装与配置" class="headerlink" title="TightVNC安装与配置"></a><strong>TightVNC安装与配置</strong></h4><ol><li><strong>检查是否安装VNC</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rpm -q tigervnc tigervnc-server<br></code></pre></td></tr></table></figure></li><li><strong>安装X-Window</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum groupinstall <span class="hljs-string">&quot;X Window System&quot;</span><br></code></pre></td></tr></table></figure></li><li><strong>安装VNC</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install tigervnc-server -y <br></code></pre></td></tr></table></figure></li><li><strong>更改启动设置</strong></li><li>打开启动设置配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /root/.vnc/xstartup<br></code></pre></td></tr></table></figure></li><li>将配置文件的内容替换为以下下内容<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br><span class="hljs-comment">#Uncomment the following two lines for normal desktop:</span><br><span class="hljs-built_in">unset</span> SESSION_MANAGER<br><span class="hljs-comment">#exec /etc/X11/xinit/xinitrc</span><br>[ -x /etc/vnc/xstartup ] &amp;&amp; <span class="hljs-built_in">exec</span> /etc/vnc/xstartup<br>[ -r <span class="hljs-variable">$HOME</span>/.Xresources ] &amp;&amp; xrdb KaTeX parse error: Expected <span class="hljs-string">&#x27;EOF&#x27;</span>, got <span class="hljs-string">&#x27;&amp;&#x27;</span> at position 59: …config -iconic &amp;̲ <span class="hljs-comment">#xterm -geome…VNCDESKTOP Desktop&quot;&amp;</span><br><span class="hljs-comment">#twm &amp;</span><br>startxfce4 &amp;<br></code></pre></td></tr></table></figure></li><li><strong>配置VNC</strong><ol><li><strong>打开配置文件</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/systemd/system/vncserver@\:1.service<br></code></pre></td></tr></table></figure></li><li><strong>根据文件里的提示修改一些配置</strong><br><img src="/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-CentOS-VNC-tigervnc/20200313124928499.png"><br>这里给出一个xfce的简单配置<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[Unit]</span><br><span class="hljs-attr">Description</span>=Remote desktop service (VNC)<br><span class="hljs-attr">After</span>=syslog.target network.target<br><br><span class="hljs-section">[Service]</span><br><span class="hljs-attr">Type</span>=simple<br><br><span class="hljs-comment"># Clean any existing files in /tmp/.X11-unix environment</span><br><span class="hljs-attr">ExecStartPre</span>=/bin/sh -c <span class="hljs-string">&#x27;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&#x27;</span><br><span class="hljs-attr">ExecStart</span>=/usr/sbin/runuser -l root -c <span class="hljs-string">&quot;/usr/bin/vncserver %i&quot;</span><br><span class="hljs-attr">PIDFile</span>=/root/.vnc/%H%i.pid<br><span class="hljs-attr">ExecStop</span>=/bin/sh -c <span class="hljs-string">&#x27;/usr/bin/vncserver -kill %i &gt; /dev/null 2&gt;&amp;1 || :&#x27;</span><br><br><span class="hljs-section">[Install]</span><br><span class="hljs-attr">WantedBy</span>=multi-user.target<br></code></pre></td></tr></table></figure>实际上，如果你有多个用户想用vnc就要配置多份配置</li></ol></li><li>系统重新加载配置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl daemon-reload<br></code></pre></td></tr></table></figure></li><li>为VNC配置密码<br>这个密码是使用VNC客户端链接服务器时所使用的密码<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vncpasswd /etc/vncpasswd<br></code></pre></td></tr></table></figure></li><li>启动VNC服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start vncserver@\:1.service<br></code></pre></td></tr></table></figure></li><li>设置VNC服务开机启动<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> vncserver@\:1.service<br></code></pre></td></tr></table></figure><h4 id="设置防火墙"><a href="#设置防火墙" class="headerlink" title="设置防火墙"></a><strong>设置防火墙</strong></h4>VNC的运行端口是基于配置的。<br>VNC的默认端口是<code>5900</code><br>我在上面配置了<code>vncserver@:1.service</code><br>那么这个配置的 VNC 会运行在 <code>5900</code> + <code>1</code> = <code>5901</code> 端口<br>输入代码在防火墙中开启 对应端口的TCP连接即可。<a href="/post/67dbc8e6/" title="服务器部署-CentOS-firewall-防火墙">服务器部署-CentOS-firewall-防火墙</a></li></ol><h4 id="常用VNC命令"><a href="#常用VNC命令" class="headerlink" title="常用VNC命令"></a><strong>常用VNC命令</strong></h4><ol><li>运行一个VNC服务<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vncserver :服务号码<br></code></pre></td></tr></table></figure></li><li>查看正在运行的VNC服务进程<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vncserver -list<br></code></pre></td></tr></table></figure></li><li>关闭某个VNC服务进程<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vncserver -<span class="hljs-built_in">kill</span> :VNC服务号<br></code></pre></td></tr></table></figure><h3 id="用户端"><a href="#用户端" class="headerlink" title="用户端"></a><strong>用户端</strong></h3><h4 id="下载客户端"><a href="#下载客户端" class="headerlink" title="下载客户端"></a><strong>下载客户端</strong></h4>这个Tiger VNC Viewer的github页<br><a href="https://github.com/TigerVNC/tigervnc/releases">https://github.com/TigerVNC/tigervnc/releases</a><br>软件下载的网页不挂梯子的话卡的不行，基本不可能下载下来。</li></ol><h4 id="连接服务器"><a href="#连接服务器" class="headerlink" title="连接服务器"></a><strong>连接服务器</strong></h4><p>输入地址和VNC服务号码即可。<br>形如：<code>服务器ip:VNC配置防火墙端口号</code><br>例如：<code>192.168.1.1:5901</code><br>成功连接后会要求输入VNC密码<br>输入正确后就能连上了</p><h2 id="更多操作"><a href="#更多操作" class="headerlink" title="更多操作"></a><strong>更多操作</strong></h2><h3 id="修改TigerVNC默认端口"><a href="#修改TigerVNC默认端口" class="headerlink" title="修改TigerVNC默认端口"></a><strong>修改TigerVNC默认端口</strong></h3><ol><li>打开源码文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /usr/bin/vncserver<br></code></pre></td></tr></table></figure></li><li>在文中找到端口内容<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">vncPort = <span class="hljs-number">5900</span> + $displayNumber<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">bind</span>(S, <span class="hljs-keyword">pack</span>(<span class="hljs-string">&#x27;S n x12&#x27;</span>, $AF_INET, <span class="hljs-number">5900</span> + $n))) &#123; <br></code></pre></td></tr></table></figure></li><li>修改端口内容<br>这里我把默认的<code>5900</code>端口改成了<code>15900</code>端口<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl">vncPort = <span class="hljs-number">15900</span> + $displayNumber<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">bind</span>(S, <span class="hljs-keyword">pack</span>(<span class="hljs-string">&#x27;S n x12&#x27;</span>, $AF_INET, <span class="hljs-number">15900</span> + $n))) &#123; <br></code></pre></td></tr></table></figure>需要注意的是，端口改了，防火墙设置也要改，连接时用的端口号也要改。<br>由于RealVNC viewer没有手动设置端口的功能，只能从默认端口登入。所以上面我给的是TigerVNC viewer。</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a><strong>问题</strong></h2><p>会与Anconda发生冲突，如果设置了环境变量的话</p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>VNC</tag>
      
      <tag>tigervnc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署-CentOS-图形界面</title>
    <link href="/post/4d03d9bb/"/>
    <url>/post/4d03d9bb/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7.2 腾讯云服务器</li></ul><h2 id="图形界面该如何选择"><a href="#图形界面该如何选择" class="headerlink" title="图形界面该如何选择"></a><strong>图形界面该如何选择</strong></h2><table><thead><tr><th>桌面环境/窗口管理器</th><th>RAM used</th><th>% CPU used</th><th>类型</th></tr></thead><tbody><tr><td>KDE 4.6</td><td>363 MB</td><td>4 %</td><td>桌面环境</td></tr><tr><td>Unity</td><td>271 MB</td><td>14%</td><td>桌面环境(shell)</td></tr><tr><td>GNOME 2</td><td>191 MB</td><td>1 %</td><td>桌面环境</td></tr><tr><td>GNOME 3</td><td>193 MB</td><td>10%</td><td>桌面环境</td></tr><tr><td>XFCE 4.8</td><td>144 MB</td><td>10 %</td><td>桌面环境</td></tr><tr><td>LXDE</td><td>85 MB</td><td>10 %</td><td>桌面环境</td></tr><tr><td>2019年数据,来自网络。</td><td></td><td></td><td></td></tr></tbody></table><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong>操作</strong></h2><h3 id="1-安装epel源"><a href="#1-安装epel源" class="headerlink" title="1. 安装epel源"></a><strong>1. 安装epel源</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install epel-release<br></code></pre></td></tr></table></figure><h3 id="2-安装桌面协议”X-Window-system”"><a href="#2-安装桌面协议”X-Window-system”" class="headerlink" title="2. 安装桌面协议”X Window system”"></a><strong>2. 安装桌面协议”X Window system”</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum groupinstall <span class="hljs-string">&quot;X Window system&quot;</span><br></code></pre></td></tr></table></figure><h3 id="3-安装一个GUI"><a href="#3-安装一个GUI" class="headerlink" title="3. 安装一个GUI"></a><strong>3. 安装一个GUI</strong></h3><p>其实有很多种选择，一般在xfce和GNOME中选一个来安装    </p><h4 id="xfce"><a href="#xfce" class="headerlink" title="xfce"></a>xfce</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum groupinstall xfce<br></code></pre></td></tr></table></figure><h4 id="GNOME"><a href="#GNOME" class="headerlink" title="GNOME"></a>GNOME</h4><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">yum</span> groupinstall <span class="hljs-string">&quot;GNOME Desktop&quot;</span> <span class="hljs-string">&quot;Graphical Administration Tools&quot;</span> <br></code></pre></td></tr></table></figure><h3 id="4-设置运行级别"><a href="#4-设置运行级别" class="headerlink" title="4. 设置运行级别"></a><strong>4. 设置运行级别</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo systemctl set-default graphical.target<br></code></pre></td></tr></table></figure><h3 id="5-查看运行级别"><a href="#5-查看运行级别" class="headerlink" title="5. 查看运行级别"></a><strong>5. 查看运行级别</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">runlevel   返回当前运行级别<br></code></pre></td></tr></table></figure><table><thead><tr><th></th><th></th><th></th></tr></thead><tbody><tr><td>0</td><td>runlevel1.target/poweroff.target</td><td>关机</td></tr><tr><td>1</td><td>runlevel1.target, rescue.target</td><td>单用户模式</td></tr><tr><td>2,4</td><td>runlevel2.target, runlevel4.target, multi-user.target</td><td>用户定义/域特定运行级别。默认等同于 3。</td></tr><tr><td>3</td><td>runlevel3.target, multi-user.target</td><td>多用户，非图形化。用户可以通过多个控制台或网络登录。</td></tr><tr><td>5</td><td>runlevel5.target, graphical.target</td><td>多用户，图形化。通常为所有运行级别 3 的服务外加图形化登录。</td></tr><tr><td>6</td><td>runlevel6.target, reboot.target</td><td>重启</td></tr><tr><td>emergency</td><td>emergency.target</td><td>紧急Shell</td></tr></tbody></table><h2 id="附言"><a href="#附言" class="headerlink" title="附言"></a><strong>附言</strong></h2><p>装上了图形界面，运行了，也不代表你能看到。<br>你需要用一些支持图形界面的连接方式连上服务器才能看到图形界面。<br>如：VNC, XDMCP之类的</p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>xfce</tag>
      
      <tag>图形界面</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS-Chrome</title>
    <link href="/post/799278f5/"/>
    <url>/post/799278f5/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7.4 腾讯云服务器</li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong>操作</strong></h2><ol><li>添加源<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo wget http://repo.fdzh.org/chrome/google-chrome-mirrors.repo -P /etc/yum.repos.d/<br></code></pre></td></tr></table></figure></li><li>安装Chrome<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo yum install google-chrome-stable<br></code></pre></td></tr></table></figure></li><li>为Chrome添加启动参数<ol><li>vim打开设置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim  /usr/share/applications/google-chrome.desktop<br></code></pre></td></tr></table></figure></li><li>修改设置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Exec=/usr/bin/google-chrome-stable %U<br></code></pre></td></tr></table></figure>↓修改为↓<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Exec=/usr/bin/google-chrome-stable %U --no-sandbox<br></code></pre></td></tr></table></figure></li><li>退出，保存。</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>Chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS-yum</title>
    <link href="/post/b43bef47/"/>
    <url>/post/b43bef47/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7.2 腾讯云服务器</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a><strong>常用命令</strong></h2><ol><li>安装、卸载、更新软件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install 软件名称  <span class="hljs-comment"># 安装</span><br>yum remove 软件名称  <span class="hljs-comment"># 卸载</span><br>yum update 软件名称  <span class="hljs-comment"># 更新</span><br>yum update  <span class="hljs-comment"># 更新所有软件命令</span><br></code></pre></td></tr></table></figure></li><li>清理<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove 包名  <span class="hljs-comment"># 删除软件包</span><br>yum clean packages  <span class="hljs-comment"># 清除缓存目录下的软件包</span><br>yum clean headers  <span class="hljs-comment"># 清除缓存目录下的 headers</span><br>yum clean oldheaders  <span class="hljs-comment"># 清除缓存目录下旧的 headers</span><br></code></pre></td></tr></table></figure></li><li>查看信息<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum list  <span class="hljs-comment"># 列出所有可安装的软件包</span><br>yum list updates  <span class="hljs-comment"># 列出所有可更新的软件包</span><br>yum list installed  <span class="hljs-comment"># 列出所有已安装的软件包</span><br><br>yum info updates  <span class="hljs-comment"># 列出所有可更新的软件包信息</span><br>yum info installed  <span class="hljs-comment"># 列出所有已安裝的软件包信息</span><br></code></pre></td></tr></table></figure><h2 id="不常用命令"><a href="#不常用命令" class="headerlink" title="不常用命令"></a><strong>不常用命令</strong></h2><table><thead><tr><th>命令参数</th><th>信息</th></tr></thead><tbody><tr><td>makecache</td><td>创建元数据缓存</td></tr><tr><td>deplist</td><td>列出软件包的依赖关系</td></tr><tr><td>erase</td><td>从系统中移除一个或多个软件包</td></tr><tr><td>groupinfo</td><td>显示组的详细信息</td></tr><tr><td>groupinstall</td><td>向系统中安装一组软件包</td></tr><tr><td>grouplist</td><td>列出可安装的组</td></tr><tr><td>groupremove</td><td>从系统中移除一组软件包</td></tr><tr><td>help</td><td>显示用法信息</td></tr><tr><td>info</td><td>显示关于软件包或组的详细信息</td></tr><tr><td>provides</td><td>查找提供指定内容的软件包</td></tr><tr><td>reinstall</td><td>覆盖安装一个包</td></tr><tr><td>repolist</td><td>显示已配置的仓库</td></tr><tr><td>resolvedep</td><td>判断哪个包提供了指定的依赖</td></tr><tr><td>search</td><td>在软件包详细信息中搜索指定字符串</td></tr><tr><td>version</td><td>yum版本信息</td></tr></tbody></table></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署-CentOS-中文乱码-utf-8</title>
    <link href="/post/2b4c0931/"/>
    <url>/post/2b4c0931/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7.2 腾讯云服务器</li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a><strong>操作</strong></h2><h3 id="1-安装中文字库"><a href="#1-安装中文字库" class="headerlink" title="1. 安装中文字库"></a><strong>1. 安装中文字库</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum groupinstall <span class="hljs-string">&quot;fonts&quot;</span> -y<br></code></pre></td></tr></table></figure><h3 id="2-查看中文字库"><a href="#2-查看中文字库" class="headerlink" title="2. 查看中文字库"></a><strong>2. 查看中文字库</strong></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">locale -a | grep <span class="hljs-string">&quot;zh_CN&quot;</span>  <br></code></pre></td></tr></table></figure><p>命令意义：列出所有可用的公共语言环境的名称，然后筛选中文</p><p>如果安装正确的话，会有如下项：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">zh_CN</span><br><span class="hljs-selector-tag">zh_CN</span><span class="hljs-selector-class">.gb18030</span><br><span class="hljs-selector-tag">zh_CN</span><span class="hljs-selector-class">.gb2312</span><br><span class="hljs-selector-tag">zh_CN</span><span class="hljs-selector-class">.gbk</span><br><span class="hljs-selector-tag">zh_CN</span><span class="hljs-selector-class">.utf8</span><br></code></pre></td></tr></table></figure><p>每项结果的含义：{语言代号}_{国家代号}.{字符集}<br>自此，中文显示会变得正常。<br>但系统的语言环境是英文，所以显示的都是英文信息。</p><h3 id="3-重启系统"><a href="#3-重启系统" class="headerlink" title="3. 重启系统"></a><strong>3. 重启系统</strong></h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">reboot</span><br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong>其他</strong></h2><h3 id="修改系统语言环境"><a href="#修改系统语言环境" class="headerlink" title="修改系统语言环境"></a><strong>修改系统语言环境</strong></h3><p>个人其实不建议作这种修改。</p><h4 id="修改方法"><a href="#修改方法" class="headerlink" title="修改方法"></a>修改方法</h4><p>这里将环境改为 <code>zh_CN.UTF-8</code><br>如果直接 <code>zh_CN</code>，会出现乱码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">localectl set-locale LANG=zh_CN.UTF-8<br></code></pre></td></tr></table></figure><h4 id="重启后验证是否修改成功"><a href="#重启后验证是否修改成功" class="headerlink" title="重启后验证是否修改成功"></a>重启后验证是否修改成功</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">date<br></code></pre></td></tr></table></figure><p>返回的日期是中文的，说明成功。</p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>中文乱码</tag>
      
      <tag>utf-8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS-EPEL-源</title>
    <link href="/post/22732f7a/"/>
    <url>/post/22732f7a/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7.2 腾讯云服务器</li><li>EPEL7</li></ul><h3 id="什么是EPEL"><a href="#什么是EPEL" class="headerlink" title="什么是EPEL?"></a><strong>什么是EPEL?</strong><span id='WhatIsEPEL'></span></h3><p>　　EPEL的全称叫 Extra Packages for Enterprise Linux 。EPEL是由 Fedora 社区打造，为 RHEL 及衍生发行版如 CentOS、Scientific Linux 等提供高质量软件包的项目。<br>　　<strong>装上了 EPEL之后，就相当于添加了一个第三方源。</strong><br>　　如果你知道rpmfusion.org的话，拿 rpmfusion 做比较还是很恰当的。rpmfusion 主要为桌面发行版提供大量rpm包，而EPEL则为服务器版本提供大量的rpm包，而且大多数rpm包在官方 repository 中是找不到的。EPEL绝大多数rpm包要比官方repository 的rpm包版本要来得新。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a><strong>过程</strong></h2><ol><li>安装 EPEL<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install epel-release<br></code></pre></td></tr></table></figure></li><li>更新源<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum clean all &amp;&amp; yum makecache<br></code></pre></td></tr></table></figure><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a><strong>其它</strong></h2><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3></li><li>卸载本体<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum remove epel-release<br></code></pre></td></tr></table></figure></li><li>清空epel目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rm -rf /var/cache/yum/x86_64/7/epel/<br></code></pre></td></tr></table></figure>注意到有一个叫 7 的目录，这代表着是EPEL7的记录。<br>如果你试图卸载其它版本，那么是其它数字。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>EPEL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署-CentOS-基本安全设置</title>
    <link href="/post/db527ca6/"/>
    <url>/post/db527ca6/</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Centos7.2 腾讯云服务器</li></ul><h2 id="基本信息确认"><a href="#基本信息确认" class="headerlink" title="基本信息确认"></a>基本信息确认</h2><h3 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h3><ul><li>连接服务器的各类型密码不应低于8位（建议20位）  </li><li>密码字符涵盖类型越多越好。数字、英文大写、小写、特殊字符  </li></ul><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="一、修改主机名"><a href="#一、修改主机名" class="headerlink" title="一、修改主机名"></a>一、修改主机名</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hostnamectl set-hostname  主机名<br></code></pre></td></tr></table></figure><h3 id="二、创建新用户，禁用root登录"><a href="#二、创建新用户，禁用root登录" class="headerlink" title="二、创建新用户，禁用root登录"></a>二、创建新用户，禁用root登录</h3><p>禁用在SSH中直接使用root用户登录。<br>想要获取服务器所有权限，需要先用普通用户登录成功后，再进行root用户的登录获取。<br>使得他人更难接触root用户的难度增加，服务器更安全。</p><h4 id="1-新建用户"><a href="#1-新建用户" class="headerlink" title="1. 新建用户"></a>1. 新建用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">adduser 用户名  <span class="hljs-comment"># 新建用户</span><br>passwd 用户名  <span class="hljs-comment"># 为新用户设置密码</span><br></code></pre></td></tr></table></figure><p><a href="#WhatIsadduser">Linux adduser命令是啥？</a>　<a href="#WhatIspasswd">Linux passwd命令是啥？</a></p><h4 id="2-创建doc文件夹"><a href="#2-创建doc文件夹" class="headerlink" title="2. 创建doc文件夹"></a>2. 创建doc文件夹</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mkdir  /opt/doc<br></code></pre></td></tr></table></figure><p><a href="#WhatIsmkdir">Linux passwd命令是啥？</a></p><h4 id="3-为新用户分配doc目录权限"><a href="#3-为新用户分配doc目录权限" class="headerlink" title="3. 为新用户分配doc目录权限"></a>3. 为新用户分配doc目录权限</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">chown  用户名   /opt/doc<br>chmod  755   /opt/doc<br></code></pre></td></tr></table></figure><p><a href="#WhatIschown">Linux chown命令是啥？</a>　<a href="#WhatIschmod">Linux chmod命令是啥？</a></p><h4 id="4-SSH禁止使用root用户登录"><a href="#4-SSH禁止使用root用户登录" class="headerlink" title="4. SSH禁止使用root用户登录"></a>4. SSH禁止使用root用户登录</h4><ol><li>打开ssh配置文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure></li><li>找到对应项并设置为no<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">PermitRootLogin no<br></code></pre></td></tr></table></figure></li><li>重新启动SSH服务以应用设置<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service sshd restart<br></code></pre></td></tr></table></figure><h4 id="5-测试root用户登录"><a href="#5-测试root用户登录" class="headerlink" title="5. 测试root用户登录"></a>5. 测试root用户登录</h4>测试看看，是不是通过root用户无法直接登录了。<br>要是登录不了，说明成功了。</li></ol><h3 id="三、修改SSH端口"><a href="#三、修改SSH端口" class="headerlink" title="三、修改SSH端口"></a>三、修改SSH端口</h3><p>SSH端口不为22<br>使得黑客需要扫描很多的端口才能发现真的SSH端口，浪费黑客的时间。</p><h4 id="1-修改SSH配置文件"><a href="#1-修改SSH配置文件" class="headerlink" title="1. 修改SSH配置文件"></a>1. 修改SSH配置文件</h4><ol><li><p>打开配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure></li><li><p>找到 #Port 22 并做修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#Port 22</span><br></code></pre></td></tr></table></figure><p> 修改为↓</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Port 22 <span class="hljs-comment"># 将旧端口也取消注释保留，使得两端口暂时并存，以防操作失误导致无法连接服务器。</span><br>Port 51369 <span class="hljs-comment"># 新起一行，设置新的SSH端口。注意别与已用端冲突。</span><br></code></pre></td></tr></table></figure><h4 id="2-修改修改SELinux"><a href="#2-修改修改SELinux" class="headerlink" title="2. 修改修改SELinux"></a>2. 修改修改SELinux</h4></li><li><p>安装semanage（已安装的可以跳过）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install policycoreutils-python.x86_64<br></code></pre></td></tr></table></figure></li><li><p>添加51369端口到 SELinux</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">semanage port -a -t ssh_port_t -p tcp 51369<br></code></pre></td></tr></table></figure></li><li><p>查看当前SElinux 允许的ssh端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">semanage port -l | grep ssh<br></code></pre></td></tr></table></figure><p> 成果添加端口的话会有两个端口<br> ssh_port_t tcp 51369, 22</p></li><li><p>重新启动SSH服务以应用设置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart sshd.service<br></code></pre></td></tr></table></figure><h4 id="3-防火墙-安全组-开放对应端口"><a href="#3-防火墙-安全组-开放对应端口" class="headerlink" title="3. 防火墙/安全组 开放对应端口"></a>3. 防火墙/安全组 开放对应端口</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">firewall-cmd --permanent --zone=public --add-port=51369/tcp <br></code></pre></td></tr></table></figure><h4 id="4-尝试通过51369端口SSH登录服务器"><a href="#4-尝试通过51369端口SSH登录服务器" class="headerlink" title="4.尝试通过51369端口SSH登录服务器"></a>4.尝试通过51369端口SSH登录服务器</h4><h4 id="5-在SSH配置文件中删除22端口"><a href="#5-在SSH配置文件中删除22端口" class="headerlink" title="5.在SSH配置文件中删除22端口"></a>5.在SSH配置文件中删除22端口</h4></li><li><p>打开配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure></li><li><p>找到第一步被去掉注释符号的 Port 22 并删除</p></li></ol><h3 id="四、定期检查"><a href="#四、定期检查" class="headerlink" title="四、定期检查"></a><strong>四、定期检查</strong></h3><h4 id="1-定期检查进程"><a href="#1-定期检查进程" class="headerlink" title="1. 定期检查进程"></a>1. 定期检查进程</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">top<br></code></pre></td></tr></table></figure><p>top命令在centos下检查有没有占用很大又名字奇怪的进程。</p><h4 id="2-定期检查近期试图登陆"><a href="#2-定期检查近期试图登陆" class="headerlink" title="2. 定期检查近期试图登陆"></a>2. 定期检查近期试图登陆</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">lastb  <span class="hljs-comment"># 显示最近没有登录成功的信息</span><br>last  <span class="hljs-comment"># 显示最近登陆成功的ip地址</span><br></code></pre></td></tr></table></figure><h4 id="3-定期检查有没有不合理的命令"><a href="#3-定期检查有没有不合理的命令" class="headerlink" title="3. 定期检查有没有不合理的命令"></a>3. 定期检查有没有不合理的命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">history</span>  <span class="hljs-comment"># 显示最近的命令输入</span><br></code></pre></td></tr></table></figure><p>查询下有没有近期不合理的命令。</p><hr><h2 id="更多服务器安全设置参考https-blog-csdn-net-scorpio3k-article-details-48678661-depth-1-utm-source-distribute-pc-relevant-none-task-amp-utm-source-distribute-pc-relevant-none-task"><a href="#更多服务器安全设置参考https-blog-csdn-net-scorpio3k-article-details-48678661-depth-1-utm-source-distribute-pc-relevant-none-task-amp-utm-source-distribute-pc-relevant-none-task" class="headerlink" title="更多服务器安全设置参考https://blog.csdn.net/scorpio3k/article/details/48678661?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task"></a>更多服务器安全设置参考<a href="https://blog.csdn.net/scorpio3k/article/details/48678661?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task">https://blog.csdn.net/scorpio3k/article/details/48678661?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></h2><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a><strong>附录</strong></h2><h3 id="Linux-adduser命令"><a href="#Linux-adduser命令" class="headerlink" title="Linux adduser命令"></a>Linux adduser命令<span id='WhatIsadduser'></span></h3><p>用于新增使用者帐号或更新预设的使用者资料。<br>adduser 与 useradd 指令为同一指令（经由符号连结 symbolic link）。<br>使用权限：系统管理员。<br><a href="https://www.runoob.com/linux/linux-comm-adduser.html">命令与参数详细</a></p><h3 id="Linux-passwd"><a href="#Linux-passwd" class="headerlink" title="Linux passwd"></a>Linux passwd<span id='WhatIspasswd'></span></h3><p>更改使用者的密码。<br><a href="https://www.runoob.com/linux/linux-comm-passwd.html">命令与参数详细</a></p><h3 id="Linux-mkdir"><a href="#Linux-mkdir" class="headerlink" title="Linux mkdir"></a>Linux mkdir<span id='WhatIsmkdir'></span></h3><p>用于建立目录。<br><a href="https://www.runoob.com/linux/linux-comm-mkdir.html">命令与参数详细</a></p><h3 id="Linux-chmod"><a href="#Linux-chmod" class="headerlink" title="Linux chmod"></a>Linux chmod<span id='WhatIschmod'></span></h3><p>Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。<br>利用 chmod 可以藉以控制文件如何被他人所调用。<br>使用权限 : 所有使用者<br><a href="https://www.runoob.com/linux/linux-comm-chmod.html">命令与参数详细</a></p><h3 id="Linux-chown"><a href="#Linux-chown" class="headerlink" title="Linux chown"></a>Linux chown<span id='WhatIschown'></span></h3><p>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。<br>利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。<br>一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限把自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。<br><a href="https://www.runoob.com/linux/linux-comm-chown.html">命令与参数详细</a></p><hr><p>参考：<br><a href="https://blog.csdn.net/qinglingLS/article/details/86755722">https://blog.csdn.net/qinglingLS/article/details/86755722</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>服务器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器部署-CentOS-firewall-防火墙</title>
    <link href="/post/67dbc8e6/"/>
    <url>/post/67dbc8e6/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>Centos7.2 腾讯云服务器</li><li>Win 10 专业版 本地</li><li>XShell 6.0.0031</li></ul><h2 id="防火墙的作用"><a href="#防火墙的作用" class="headerlink" title="防火墙的作用"></a><strong>防火墙的作用</strong></h2><ul><li>复杂来说：<br>防火墙技术是通过有机结合各类用于安全管理与筛选的软件和硬件设备，帮助计算机网络于其内、外网之间构建一道相对隔绝的保护屏障。</li><li>简单来说<br>关掉家里没必要打开的窗户，以防小偷或者销售人员进来打扰。</li></ul><h2 id="防火墙须知要点"><a href="#防火墙须知要点" class="headerlink" title="防火墙须知要点"></a><strong>防火墙须知要点</strong></h2><h3 id="防火墙许可"><a href="#防火墙许可" class="headerlink" title="防火墙许可"></a><strong>防火墙许可</strong></h3><p>防火墙许可有三种：</p><ul><li>Allow：允许。</li><li>Deny：无视请求。</li><li>Reject：拒绝请求，并告诉发过来的家伙，我拒绝了你。</li><li>Limit：指定特定IP，拒绝它的访问。</li></ul><h3 id="防火墙方向"><a href="#防火墙方向" class="headerlink" title="防火墙方向"></a><strong>防火墙方向</strong></h3><p>防火墙不仅可以对进来的数据进行限制。也能对出去的数据进行限制。</p><h3 id="常用防火墙设置信息"><a href="#常用防火墙设置信息" class="headerlink" title="常用防火墙设置信息"></a><strong>常用防火墙设置信息</strong></h3><table><thead><tr><th>协议:端口</th><th>信息</th></tr></thead><tbody><tr><td>TCP:22</td><td>Linux SSH登录</td></tr><tr><td>TCP:80</td><td>Web服务HTTP</td></tr><tr><td>TCP:443</td><td>Web服务HTTPS</td></tr><tr><td>TCP:3306</td><td>MySQL服务</td></tr></tbody></table><h2 id="常用防火墙设置命令"><a href="#常用防火墙设置命令" class="headerlink" title="常用防火墙设置命令"></a><strong>常用防火墙设置命令</strong></h2><h3 id="firewall服务"><a href="#firewall服务" class="headerlink" title="firewall服务"></a>firewall服务</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl status firewalld  <span class="hljs-comment"># 查看firewall service状态</span><br>systemctl disable firewalld.service  <span class="hljs-comment"># 禁用防火墙</span><br>service firewalld <span class="hljs-literal">start</span>  <span class="hljs-comment"># 开启firewall service服务</span><br>service firewalld restart  <span class="hljs-comment"># 重启firewall service服务</span><br>service firewalld <span class="hljs-literal">stop</span>  <span class="hljs-comment"># 关闭firewall service服务</span><br></code></pre></td></tr></table></figure><h3 id="firewall"><a href="#firewall" class="headerlink" title="firewall"></a>firewall</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --reload  <span class="hljs-comment"># 重启防火墙</span></span><br></code></pre></td></tr></table></figure><p>需要注意的是，对规则修改以后，需要重启防火墙才会生效。</p><h4 id="firewall查询"><a href="#firewall查询" class="headerlink" title="firewall查询"></a>firewall查询</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --state     <span class="hljs-comment"># 查看firewall的状态</span></span><br>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --list-all   <span class="hljs-comment"># 查看防火墙规则</span></span><br>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --query-port=8080/tcp  <span class="hljs-comment"># 查询8080端口是否开放TCP</span></span><br></code></pre></td></tr></table></figure><h4 id="firewall修改"><a href="#firewall修改" class="headerlink" title="firewall修改"></a>firewall修改</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --permanent --remove-port=8080/tcp  <span class="hljs-comment"># 移除8080端口TCP规则</span></span><br>firewall-<span class="hljs-keyword">cmd</span><span class="bash"> --permanent --add-port=9527/tcp  <span class="hljs-comment"># 添加9527端口TCP规则</span></span><br><br><span class="hljs-comment"># 参数解释</span><br><span class="hljs-comment">#  firwall-cmd：是Linux提供的操作firewall的一个工具；</span><br><span class="hljs-comment">#  --permanent：表示设置为持久；</span><br><span class="hljs-comment">#  --add-port：标识添加的端口；</span><br></code></pre></td></tr></table></figure><h2 id="安全组-设置在前面的-防火墙"><a href="#安全组-设置在前面的-防火墙" class="headerlink" title="安全组 设置在前面的 防火墙"></a><strong>安全组 设置在前面的 防火墙</strong></h2><p>现在很多云都有设立在服务器之前的防火墙。<br>他们一般被称为<code>安全组</code>。<br><img src="/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-CentOS-firewall-%E9%98%B2%E7%81%AB%E5%A2%99/20200308043435990.png"><br>这是腾讯云默认的安全组，允许所有Ip和端口的访问。<br><img src="/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-CentOS-firewall-%E9%98%B2%E7%81%AB%E5%A2%99/20200308043627336.png"><br>你可以根据自己的需要在这上面通过GUI设置一些规则，内容几乎和服务器的防火墙完全相同。<br><img src="/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2-CentOS-firewall-%E9%98%B2%E7%81%AB%E5%A2%99/20200308053129012.png"><br>需要注意的是，安全组 和 服务器自身的防火墙 是相互独立的。<br>也就是说，如果你 在服务器里开放了一个原本没有开放的端口，那么在应用的安全组里也需要开放相同的端口才能正常访问。</p>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
      <tag>CentOS</tag>
      
      <tag>防火墙</tag>
      
      <tag>firewall</tag>
      
      <tag>安全组</tag>
      
      <tag>服务器安全</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-面试题59 - II. 队列的最大值</title>
    <link href="/post/2a6c49ca/"/>
    <url>/post/2a6c49ca/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值.<br>要求函数max_value、push_back 和 pop_front 的时间复杂度都是O(1)。<br>若队列为空，pop_front 和 max_value 需要返回 -1<br>示例 1：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: <br>[<span class="hljs-string">&quot;MaxQueue&quot;</span>,<span class="hljs-string">&quot;push_back&quot;</span>,<span class="hljs-string">&quot;push_back&quot;</span>,<span class="hljs-string">&quot;max_value&quot;</span>,<span class="hljs-string">&quot;pop_front&quot;</span>,<span class="hljs-string">&quot;max_value&quot;</span>]<br>[[],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[],[],[]]<br>输出: [null,null,null,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs prolog">输入: <br>[<span class="hljs-string">&quot;MaxQueue&quot;</span>,<span class="hljs-string">&quot;pop_front&quot;</span>,<span class="hljs-string">&quot;max_value&quot;</span>]<br>[[],[],[]]<br>输出: [null,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>]<br></code></pre></td></tr></table></figure><p>限制：<br>&emsp; 1 &lt;= push_back,pop_front,max_value的总操作数 &lt;= 10000<br>&emsp; 1 &lt;= value &lt;= 10^5</p><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a><strong>自解</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        self.queue = <span class="hljs-built_in">list</span>()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_value</span>(<span class="hljs-params">self</span>) -&gt; int:</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(self.queue) <span class="hljs-keyword">if</span> self.queue <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push_back</span>(<span class="hljs-params">self, value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-keyword">None</span>:</span><br>        self.queue.insert(<span class="hljs-number">0</span>,value)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop_front</span>(<span class="hljs-params">self</span>) -&gt; int:</span><br>        <span class="hljs-keyword">return</span> self.queue.pop() <span class="hljs-keyword">if</span> self.queue <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>没有留意题目的O(1)要求，看到了别人的评论才知道。<br>list.max() 时间复杂度为O(n)，不符合要求。</p><h2 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a><strong>大佬解法</strong></h2><h3 id="思考过程"><a href="#思考过程" class="headerlink" title="思考过程"></a><strong>思考过程</strong></h3><p>要想在<code>O(1)</code>时间内做到取出最大值，我们可以想到，能否用一个<code>cur_max</code>的变量，来记录并且比较每一次新入队的<code>value</code>。<br>这个想法是极好的，但是如果队列是<code>[4,3]</code>这个样子，<code>cur_max</code>只会记下4是最大的，当调用一次<code>pop_front()</code>后，此时队列为<code>[3]</code>，而<code>cur_max</code>没有变化，所以单个变量记录最大值行不通。</p><p>进一步地我们可以想到，一个变量不行，那我直接用一个辅助队列记录值OK不OK呢？</p><p>答案是OK的。我们让辅助队列的数从大到小排列好，要找最大值直接返回辅助队列的头部即可，同时这也是<code>O(1)</code>时间复杂度的操作，完美契合题意。下面详细讲讲辅助队列怎么能够实现这个操作。</p><h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a><strong>详细步骤</strong></h3><p>我们先初始化两个队列：<br>原始队列que = []，帮助我们记录原始数值。<br>辅助队列sort_que = []，帮助我们对原始数值进行排序。</p><p>对于原始队列<code>que</code>，来一个就装一个，走一个就放一个，没啥好担心的。</p><p>重点是这个辅助队列<code>sort_que</code>。<br>第一个问题：<code>sort_que</code>里面怎么排序？</p><p>要回答这个问题，我们首先要知道，队列的性质是先进先出。</p><p>假设原始队列是<code>[1,2]</code>，那么先走的那一位是队列里面的1。我们的<code>sort_que</code>的头部理应为2，因为原始队列<code>[1,2]</code>的最大值是2。即使对原始队列<code>[1,2]</code>调用<code>pop_front</code>造成1的离开，最大值依然是2，此时，我们仍然需要保持<code>sort_que</code>的头部仍是2。</p><p>这个要求，就衍生出了sort_que队列的怎么排序了，请看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">while</span> sort_que <span class="hljs-keyword">and</span> sort_que[-<span class="hljs-number">1</span>] &lt; value:<br>    sort_que.pop()<br>self.sort_que.append(value)<br></code></pre></td></tr></table></figure><p>这就是说，如果<code>sort_que</code>不为空，并且<code>sort_que</code>的最后一位元素小于当前入队元素<code>value</code>的话，直接把最后一位元素弹走，直到<code>sort_que</code>为空，或<code>sort_que</code>的最后一位元素大于等于<code>value</code>。这就保证了，<code>sort_que</code>的头部总是原始队列que的最大值~<br>第二个问题：原始队列<code>que</code>发生<code>pop_front</code>时<code>sort_que</code>该怎么变动？</p><p>这个其实比较简单，当<code>que</code>弹出的数恰好等于<code>sort_que</code>的头部元素时，咱把<code>sort_que</code>的头部也跟着弹出就好。请看代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">res = que.pop(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> res == sort_que[<span class="hljs-number">0</span>]:<br>    sort_que.pop(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p>我们这里的que和sort_que假设是Python中的list形式，用pop(0)的方法可以弹出list的第一个元素，但这个的时间复杂度是<code>O(n)</code>，这一点要注意。<br><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%9859---II.-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/20200307122705425.png"><br>Python中的deque可以对<code>pop(0)</code>，就是<code>popleft()</code>实现<code>O(1)</code>的时间复杂度。<br><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%9859---II.-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/20200307122946910.png"></p><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a><strong>完整代码</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxQueue</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> deque<br>        self.que = deque()<br>        self.sort_que = deque()   <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">max_value</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.sort_que[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> self.sort_que <span class="hljs-keyword">else</span> -<span class="hljs-number">1</span>   <br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">push_back</span>(<span class="hljs-params">self, value</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :type value: int</span><br><span class="hljs-string">        :rtype: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        self.que.append(value)<br>        <span class="hljs-keyword">while</span> self.sort_que <span class="hljs-keyword">and</span> self.sort_que[-<span class="hljs-number">1</span>] &lt; value:<br>            self.sort_que.pop()<br>        self.sort_que.append(value)<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pop_front</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        :rtype: int</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.que: <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span><br>        res = self.que.popleft()<br>        <span class="hljs-keyword">if</span> res == self.sort_que[<span class="hljs-number">0</span>]:<br>            self.sort_que.popleft()<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><hr><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof</a><br>作者：quantumdriver<br>链接：<a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/python-xiang-jie-wei-he-tian-jia-fu-zhu-dui-lie-ji/">https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof/solution/python-xiang-jie-wei-he-tian-jia-fu-zhu-dui-lie-ji/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-面试题57 - II. 和为s的连续正数序列</title>
    <link href="/post/311370dd/"/>
    <url>/post/311370dd/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。<br>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。<br>示例 1：<br>&emsp; 输入：target = 9<br>&emsp; 输出：[[2,3,4],[4,5]]<br>示例 2：<br>&emsp; 输入：target = 15<br>&emsp; 输出：[[1,2,3,4,5],[4,5,6],[7,8]]<br>限制：<br>    1 &lt;= target &lt;= 10^5</p><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a><strong>自解</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findContinuousSequence</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span></span>) -&gt; List[List[int]]:</span><br>    resoult = <span class="hljs-built_in">list</span>()<br>    <span class="hljs-keyword">for</span> left <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, target):<br>        right = left<br>        sum_ = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">while</span> sum_ &lt; target:<br>            right = right+<span class="hljs-number">1</span><br>            sum_ = <span class="hljs-built_in">sum</span>(<span class="hljs-built_in">range</span>(left, right))<br>            <span class="hljs-keyword">if</span> sum_ == target:<br>                resoult.append(<span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(left,right)))<br>    <span class="hljs-keyword">return</span> resoult<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>逐个数字遍历，窗口逐个变大。找到相等记录。</p><h2 id="大佬解法"><a href="#大佬解法" class="headerlink" title="大佬解法"></a><strong>大佬解法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findContinuousSequence</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span></span>) -&gt; List[List[int]]:</span><br>    i = <span class="hljs-number">1</span> <span class="hljs-comment"># 滑动窗口的左边界</span><br>    j = <span class="hljs-number">1</span> <span class="hljs-comment"># 滑动窗口的右边界</span><br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span> <span class="hljs-comment"># 滑动窗口中数字的和</span><br>    res = []<br><br>    <span class="hljs-keyword">while</span> i &lt;= target // <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">sum</span> &lt; target:<br>            <span class="hljs-comment"># 右边界向右移动</span><br>            <span class="hljs-built_in">sum</span> += j<br>            j += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">elif</span> <span class="hljs-built_in">sum</span> &gt; target:<br>            <span class="hljs-comment"># 左边界向右移动</span><br>            <span class="hljs-built_in">sum</span> -= i<br>            i += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 记录结果</span><br>            arr = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(i, j))<br>            res.append(arr)<br>            <span class="hljs-comment"># 左边界向右移动</span><br>            <span class="hljs-built_in">sum</span> -= i<br>            i += <span class="hljs-number">1</span><br><br>    <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a><strong>思路</strong></h3><h4 id="什么是滑动窗口"><a href="#什么是滑动窗口" class="headerlink" title="什么是滑动窗口"></a><strong>什么是滑动窗口</strong></h4><p>滑动窗口可以看成数组中框起来的一个部分。在一些数组类题目中，我们可以用滑动窗口来观察可能的候选结果。当滑动窗口从数组的左边滑到了右边，我们就可以从所有的候选结果中找到最优的结果。<br>对于这道题来说，数组就是正整数序列 [1,2,3,…,n]。我们设滑动窗口的左边界为 i，右边界为 j，则滑动窗口框起来的是一个左闭右开区间 [i,j)[i, j)[i,j)。注意，为了编程的方便，滑动窗口一般表示成一个左闭右开区间。在一开始，i=1, j=1 ,滑动窗口位于序列的最左侧，窗口大小为零。<br><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%9857---II.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/20200306021159040.png"><br>滑动窗口的重要性质是：<strong>窗口的左边界和右边界永远只能向右移动</strong>，而不能向左移动。这是为了保证滑动窗口的时间复杂度是 O(n)。如果左右边界向左移动的话，这叫做“回溯”，算法的时间复杂度就可能不止 O(n)。</p><p>在这道题中，我们关注的是滑动窗口中所有数的和。<br>当滑动窗口的右边界向右移动时，也就是 j = j + 1，窗口中多了一个数字 j，窗口的和也就要加上 j。<br>当滑动窗口的左边界向右移动时，也就是 i = i + 1，窗口中少了一个数字 i，窗口的和也就要减去 i。<br><strong>滑动窗口只有 右边界向右移动（扩大窗口） 和 左边界向右移动（缩小窗口）</strong> 两个操作，所以实际上非常简单。</p><h4 id="如何用滑动窗口解这道题"><a href="#如何用滑动窗口解这道题" class="headerlink" title="如何用滑动窗口解这道题"></a><strong>如何用滑动窗口解这道题</strong></h4><p>要用滑动窗口解这道题，我们要回答两个问题：<br>&emsp; 第一个问题，窗口何时扩大，何时缩小？<br>&emsp; 第二个问题，滑动窗口能找到全部的解吗？</p><h5 id="第一个问题，窗口何时扩大，何时缩小？"><a href="#第一个问题，窗口何时扩大，何时缩小？" class="headerlink" title="第一个问题，窗口何时扩大，何时缩小？"></a><strong>第一个问题，窗口何时扩大，何时缩小？</strong></h5><p>&emsp; 当窗口的和小于 target 的时候，窗口的和需要增加，所以要扩大窗口，窗口的右边界向右移动<br>&emsp; 当窗口的和大于 target 的时候，窗口的和需要减少，所以要缩小窗口，窗口的左边界向右移动<br>&emsp; 当窗口的和恰好等于 target 的时候，我们需要记录此时的结果。设此时的窗口为 [i,j)，那么我们已经找到了一个 i 开头的序列，也是唯一一个 i 开头的序列，接下来需要找 i+1 开头的序列，所以窗口的左边界要向右移动</p><h5 id="第二个问题，滑动窗口能找到全部的解吗？"><a href="#第二个问题，滑动窗口能找到全部的解吗？" class="headerlink" title="第二个问题，滑动窗口能找到全部的解吗？"></a><strong>第二个问题，滑动窗口能找到全部的解吗？</strong></h5><p><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%9857---II.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/20200306111214452.png"><br>&emsp; 我们一开始要找的是 1 开头的序列，只要窗口的和小于 target，窗口的右边界会一直向右移动。<br>&emsp; 假设 1+2+⋯+8 小于 target，再加上一个 9 之后， 发现 1+2+⋯+8+9 又大于 target 了。这说明 1 开头的序列找不到解。此时滑动窗口的最右元素是 9。</p><p>接下来，我们需要找 2 开头的序列，我们发现，2+⋯+8&lt;1+2+⋯+8&lt;target。这说明 2 开头的序列至少要加到 9。那么，我们只需要把原先 1<del>9 的滑动窗口的左边界向右移动，变成 2</del>9 的滑动窗口，然后继续寻找。而右边界完全不需要向左移动。</p><p>以此类推，滑动窗口的左右边界都不需要向左移动，所以这道题用滑动窗口一定可以得到所有的解。时间复杂度是 O(n)O(n)O(n)。</p><p>注：这道题当前可以用等差数列的求和公式来计算滑动窗口的和。不过我这里没有使用求和公式，是为了展示更通用的解题思路。实际上，把题目中的正整数序列换成任意的递增整数序列，这个方法都可以解。</p><h2 id="真·大佬解法"><a href="#真·大佬解法" class="headerlink" title="真·大佬解法"></a><strong>真·大佬解法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findContinuousSequence</span>(<span class="hljs-params">self, target: <span class="hljs-built_in">int</span></span>) -&gt; List[List[int]]:</span><br>        res = []<br>        <span class="hljs-keyword">for</span> n <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">2</span>, target+<span class="hljs-number">1</span>):<br>            temp = target - n*(n-<span class="hljs-number">1</span>)//<span class="hljs-number">2</span><br>            <span class="hljs-keyword">if</span> temp &lt;= <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> temp % n:<br>                a_1 = temp // n<br>                res.append([a_1 + i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)])<br>        <span class="hljs-keyword">return</span> res[::-<span class="hljs-number">1</span>]<br></code></pre></td></tr></table></figure><p>O(√target)</p><p>解题思路<br>一个以 a1 为首项，以 1 为公差，以 n 为项数的等差数列的和为 target<br><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%9857---II.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/20200306112539983.png"><br>转化为<br><img src="/LeetCode%E6%97%A5%E5%B8%B8-%E7%AE%80%E5%8D%95-%E9%9D%A2%E8%AF%95%E9%A2%9857---II.-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/20200306112557880.png"><br>目标是找出所有满足条件的 n、a1 对，<br>思路是对 n 从 2 开始遍历（题目要求最少是 222 个数），验证 a1 是否为正整数。<br>有一个问题是 n 遍历到多少呢？<br>其实不需要特地去算 n 的上限，随着 n 的递增，a1 递减，当 a1&lt;=0 时跳出循环即可。</p><hr><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof</a><br>作者：nettee<br>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shi-yao-shi-hua-dong-chuang-kou-yi-ji-ru-he-yong-h/">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shi-yao-shi-hua-dong-chuang-kou-yi-ji-ru-he-yong-h/</a><br>作者：erik_chen<br>链接：<a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shu-xue-wen-ti-shu-xue-jie-jue-by-erik_chen/">https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/solution/shu-xue-wen-ti-shu-xue-jie-jue-by-erik_chen/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode日常-简单-20-有效的括号</title>
    <link href="/post/f21acc01/"/>
    <url>/post/f21acc01/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a><strong>题目</strong></h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。<br>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li></ul><p>注意空字符串可被认为是有效字符串。</p><h2 id="自解"><a href="#自解" class="headerlink" title="自解"></a><strong>自解</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">self, s: <span class="hljs-built_in">str</span></span>) -&gt; bool:</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-string">&quot;()&quot;</span> <span class="hljs-keyword">in</span> s <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;&#123;&#125;&quot;</span><span class="hljs-keyword">in</span> s <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;[]&quot;</span><span class="hljs-keyword">in</span> s:<br>        s = s.replace(<span class="hljs-string">&quot;()&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>        s = s.replace(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>        s = s.replace(<span class="hljs-string">&quot;[]&quot;</span>,<span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> s<br></code></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>如果是合理的字符组合（不为空）。<br>那么这个字符串只有两种情况：</p><ul><li>字符串长度&gt;0, 且必定存在必定存在子串’{}’或’()’或’[]’<br>  这种情况下，对子串’{}’或’()’或’[]’进行去除，能得到缩小了的同问题。<br>  不断重复去除的过程最终能使字符串长度==0.</li><li>字符串长度==0</li></ul><p>时间复杂度：O(n²)</p><h2 id="官方解法"><a href="#官方解法" class="headerlink" title="官方解法"></a><strong>官方解法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isValid</span>(<span class="hljs-params">self, s</span>):</span><br>        <span class="hljs-comment"># 设置一个堆栈跟踪开括号</span><br>        stack = []<br><br>        <span class="hljs-comment"># 哈希表 记录对应关系。这使得代码看起来非常干净。</span><br>        <span class="hljs-comment"># 也使得增加更多类型的括号更容易</span><br>        mapping = &#123;<span class="hljs-string">&quot;)&quot;</span>: <span class="hljs-string">&quot;(&quot;</span>, <span class="hljs-string">&quot;&#125;&quot;</span>: <span class="hljs-string">&quot;&#123;&quot;</span>, <span class="hljs-string">&quot;]&quot;</span>: <span class="hljs-string">&quot;[&quot;</span>&#125;<br><br>        <span class="hljs-comment"># 遍历每个字符</span><br>        <span class="hljs-keyword">for</span> char <span class="hljs-keyword">in</span> s:<br>            <span class="hljs-comment"># 如果是闭括号</span><br>            <span class="hljs-keyword">if</span> char <span class="hljs-keyword">in</span> mapping:<br>                <span class="hljs-comment"># 如果栈非空，弹出最顶层元素</span><br>                <span class="hljs-comment"># 否则将虚值&quot;#&quot;赋值给top_element</span><br>                top_element = stack.pop() <span class="hljs-keyword">if</span> stack <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;#&#x27;</span><br>                <span class="hljs-comment"># 根据哈希表获取对应符号，如不符合对应，返回False</span><br>                <span class="hljs-keyword">if</span> mapping[char] != top_element:<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 是开括号，压入栈中</span><br>                stack.append(char)<br><br>        <span class="hljs-comment"># 如果在最后，栈是空的，那么匹配正确。</span><br>        <span class="hljs-comment"># 如果栈不是空的，是出现了开括号多于闭括号的情况，如((()</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> stack<br></code></pre></td></tr></table></figure><p>时间复杂度：O(n)O(n)O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1)O(1)O(1) 的推入和弹出操作。</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a><strong>算法</strong></h3><ol><li>初始化栈 S。</li><li>一次处理表达式的每个括号。</li><li>如果遇到开括号，我们只需将其推到栈上即可。这意味着我们将稍后处理它，让我们简单地转到前面的 子表达式。</li><li>如果我们遇到一个闭括号，那么我们检查栈顶的元素。如果栈顶的元素是一个 相同类型的 左括号，那么我们将它从栈中弹出并继续处理。否则，这意味着表达式无效。</li><li>如果到最后我们剩下的栈中仍然有元素，那么这意味着表达式无效。</li></ol><hr><p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/valid-parentheses">https://leetcode-cn.com/problems/valid-parentheses</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>LeetCode</tag>
      
      <tag>简单</tag>
      
      <tag>栈</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL记录</title>
    <link href="/post/e1a4d6bf/"/>
    <url>/post/e1a4d6bf/</url>
    
    <content type="html"><![CDATA[<h1 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h1><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 列名称 <span class="hljs-keyword">FROM</span> 表名称<br></code></pre></td></tr></table></figure><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name (列<span class="hljs-number">1</span>, 列<span class="hljs-number">2</span>,...) <span class="hljs-keyword">VALUES</span> (值<span class="hljs-number">1</span>, 值<span class="hljs-number">2</span>,....)<br></code></pre></td></tr></table></figure><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> 表名称 <span class="hljs-keyword">WHERE</span> 列名称 = 值<br></code></pre></td></tr></table></figure><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">UPDATE</span> 表名称 <span class="hljs-keyword">SET</span> 列名称 = 新值 <span class="hljs-keyword">WHERE</span> 列名称 = 某值<br></code></pre></td></tr></table></figure><h1 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h1><h2 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h2><h3 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">IF</span><span class="hljs-params">(判断语句, 判断结果为True时的返回值, 判断结果为False时的返回值)</span></span><br></code></pre></td></tr></table></figure><ul><li>返回值为数字值或字符串值  </li></ul><blockquote><p>案例：将salary表中的记录性别进行更变<br><img src="/SQL%E8%AE%B0%E5%BD%95/20200902114505313.png">  </p></blockquote><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams">update salary <span class="hljs-keyword">set</span> <br>    sex <span class="hljs-comment">= IF(sex=</span><span class="hljs-comment">&#x27;f&#x27;</span><span class="hljs-comment">,</span><span class="hljs-comment">&#x27;m&#x27;</span><span class="hljs-comment">,</span><span class="hljs-comment">&#x27;f&#x27;</span><span class="hljs-comment">)</span>;<br></code></pre></td></tr></table></figure><h3 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h3><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">CASE</span> 判断目标 <span class="hljs-keyword">WHEN</span> 所期望的值 <span class="hljs-keyword">THEN</span> 目标是期望值时所执行内容 <span class="hljs-keyword">ELSE</span> 目标不是期望值时所执行内容 <span class="hljs-keyword">END</span><br></code></pre></td></tr></table></figure><ul><li>如果没有ELSE 部分，则返回值为 NULL</li></ul><blockquote><p>案例：将salary表中的记录性别进行更变<br><img src="/SQL%E8%AE%B0%E5%BD%95/20200902114505313.png">  </p></blockquote><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">UPDATE</span> salary<br><span class="hljs-keyword">SET</span><br>    sex = <span class="hljs-keyword">CASE</span> sex<br>        <span class="hljs-keyword">WHEN</span> <span class="hljs-string">&#x27;m&#x27;</span> <span class="hljs-keyword">THEN</span> <span class="hljs-string">&#x27;f&#x27;</span><br>        <span class="hljs-keyword">ELSE</span> <span class="hljs-string">&#x27;m&#x27;</span><br>    <span class="hljs-keyword">END</span>;<br></code></pre></td></tr></table></figure><h1 id="多表"><a href="#多表" class="headerlink" title="多表"></a>多表</h1><h2 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>     column_name<br><span class="hljs-keyword">FROM</span> Table_name1  <span class="hljs-keyword">JOIN</span> Table_name2 <br>     <span class="hljs-keyword">ON</span> 连接条件<br></code></pre></td></tr></table></figure><ul><li>符合连接条件的内容才会连接  </li></ul><blockquote><p>案例<br>Employee 表包含所有员工，他们的经理也属于员工。每个员工都有一个 Id，此外还有一列对应员工的经理的 Id<br>Employee 表<br><img src="/SQL%E8%AE%B0%E5%BD%95/20200903010508843.png"><br>编写一个 SQL 查询，该查询可以获取收入超过他们经理的员工的姓名   </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>     a.NAME <span class="hljs-keyword">AS</span> Employee<br><span class="hljs-keyword">FROM</span> Employee <span class="hljs-keyword">AS</span> a <span class="hljs-keyword">JOIN</span> Employee <span class="hljs-keyword">AS</span> b<br>     <span class="hljs-keyword">ON</span> a.ManagerId = b.Id <span class="hljs-keyword">AND</span> a.Salary &gt; b.Salary<br><br></code></pre></td></tr></table></figure><ul><li>INNER JOIN：如果表中有至少一个匹配，则返回行</li><li>LEFT JOIN：即使右表中没有匹配，也从左表返回所有的行</li><li>RIGHT JOIN：即使左表中没有匹配，也从右表返回所有的行</li><li>FULL JOIN：只要其中一个表中存在匹配，则返回行</li></ul><h3 id="LEFT-JOIN"><a href="#LEFT-JOIN" class="headerlink" title="LEFT JOIN"></a>LEFT JOIN</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column_name(s)<br><span class="hljs-keyword">FROM</span> table_name1<br><span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> table_name2 <br><span class="hljs-keyword">ON</span> table_name1.column_name=table_name2.column_name<br></code></pre></td></tr></table></figure><ul><li>即使右表中没有匹配，也从左表返回所有的行</li></ul><blockquote><p>案例<br>查询两个表提供的FirstName, LastName, City, State<br>Person表<br><img src="/SQL%E8%AE%B0%E5%BD%95/20200903121741885.png"><br>　PersonId 是主键  </p></blockquote><blockquote><p>Address表<br><img src="/SQL%E8%AE%B0%E5%BD%95/20200903121900913.png"></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> FirstName, LastName, City, State <br><span class="hljs-keyword">from</span> Person <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> Address <span class="hljs-keyword">on</span> Person.PersonId = Address.PersonId;<br></code></pre></td></tr></table></figure><h1 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h1><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">column_name</span>, <span class="hljs-built_in">column_name</span><br><span class="hljs-keyword">FROM</span> <span class="hljs-built_in">table_name</span><br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 用作排序的列名, 第二个用作排序的列名 <span class="hljs-keyword">ASC</span>|<span class="hljs-keyword">DESC</span>;<br></code></pre></td></tr></table></figure><ul><li>升序<code>ASC</code> |  降序<code>DESC</code>  </li></ul><blockquote><p>案例<br>编写一个 SQL查询，找出所有影片描述为非 boring (不无聊) 的并且 id 为奇数 的影片，结果请按等级 rating 排列<br>cinema表<br><img src="/SQL%E8%AE%B0%E5%BD%95/20200903123854198.png">  </p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> cinema <br><span class="hljs-keyword">where</span> <span class="hljs-keyword">mod</span>(<span class="hljs-keyword">id</span>, <span class="hljs-number">2</span>)=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> description != <span class="hljs-string">&quot;boring&quot;</span>  <br><span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> rating <span class="hljs-keyword">DESC</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HexoEditor-Hexo-编辑文章</title>
    <link href="/post/2adc9a5f/"/>
    <url>/post/2adc9a5f/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是一款为 <code>Hexo</code> 做了优化的 <code>Markdown</code> 编辑器。<br>使用 <code>Electron</code> 做框架, 修改自 <code>Moeditor</code>。<br>为更好的去为 <code>Hexo</code> 下的博客更好的去书写内容而造。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p><a href="https://github.com/zhuzhuyule/HexoEditor/releases">https://github.com/zhuzhuyule/HexoEditor/releases</a><br>下载对应的系统版本的安装包安装即可。</p><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>先打开软件的菜单<br><img src="/HexoEditor-Hexo-%E7%BC%96%E8%BE%91%E6%96%87%E7%AB%A0/20200228115836813.png"><br>打开软件的设置<br><img src="/HexoEditor-Hexo-%E7%BC%96%E8%BE%91%E6%96%87%E7%AB%A0/20200228115917978.png"><br>在配置中设置好<code>Hexo</code>的信息<br><img src="/HexoEditor-Hexo-%E7%BC%96%E8%BE%91%E6%96%87%E7%AB%A0/20200228115943222.png"><br>在编写好内容后，在页面点击鼠标右键，即可显示一些hexo相关的操作项目。<br><img src="/HexoEditor-Hexo-%E7%BC%96%E8%BE%91%E6%96%87%E7%AB%A0/20200229120204467.png"><br>但实测下来，通过这种方式执行Hexo相关的操作速度比较慢，比直接在命令行里输入对应的指令慢几倍。</p><hr><p>Github地址：<a href="https://github.com/zhuzhuyule/HexoEditor">https://github.com/zhuzhuyule/HexoEditor</a><br>中文文档：<a href="https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/cn/README.md">https://github.com/zhuzhuyule/HexoEditor/blob/master/doc/cn/README.md</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>npm</tag>
      
      <tag>Blog</tag>
      
      <tag>HexoEditor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-toc插件-恢复Markdown失效的toc</title>
    <link href="/post/473a65e7/"/>
    <url>/post/473a65e7/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h2><p>总所周知，<code>toc</code> 被用于在<code>markdown</code>文件中自动生成目录。<br>而在某次 npm 更新后，hexo中的 markdown 文件的toc失效了<br>所以如果你如果希望继续使用 <code>toc</code>，就需要安装这个插件了  </p><blockquote><p><strong>注意：如果使用的主题已经拥有显示目录的能力，那么不建议安装</strong>  </p></blockquote><h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a><strong>使用方法</strong></h2><h3 id="1-安装hexo-toc"><a href="#1-安装hexo-toc" class="headerlink" title="1. 安装hexo-toc"></a><strong>1. 安装hexo-toc</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">npm <span class="hljs-keyword">install</span> hexo-toc <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><h3 id="2-在-config-yml文件中添加参数"><a href="#2-在-config-yml文件中添加参数" class="headerlink" title="2. 在_config.yml文件中添加参数"></a><strong>2. 在<code>_config.yml</code>文件中添加参数</strong></h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">toc:</span><br>  <span class="hljs-attr">maxdepth:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">class:</span> <span class="hljs-string">toc</span><br>  <span class="hljs-attr">slugify:</span> <span class="hljs-string">transliteration</span><br>  <span class="hljs-attr">decodeEntities:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">anchor:</span><br>    <span class="hljs-attr">position:</span> <span class="hljs-string">after</span><br>    <span class="hljs-attr">symbol:</span> <span class="hljs-string">&#x27;#&#x27;</span><br>    <span class="hljs-attr">style:</span> <span class="hljs-string">header-anchor</span><br></code></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>意义</th></tr></thead><tbody><tr><td>maxdepth</td><td>允许的最大节点深度，必填</td></tr><tr><td>class</td><td>toc的CSS样式设置（默认值是<code>false</code>）</td></tr><tr><td>slugify</td><td>选择你想要的slugify方法，目前只有<code>uslug</code>（默认）和<code>transliteration</code>两种</td></tr><tr><td>decodeEntities</td><td>是否要编译内容，具体<a href="https://github.com/bubkoo/hexo-toc/pull/15">看这</a></td></tr><tr><td>anchor</td><td>锚点相关的内容，默认是<code>false</code></td></tr><tr><td>position</td><td>锚点相对于标题的位置设置，可选<code>before</code>或<code>after</code>(默认)</td></tr><tr><td>symbol</td><td>锚点的代表字符（默认是<code>#</code>）</td></tr><tr><td>style</td><td>锚点的CSS样式类，默认是<code>header-anchor</code></td></tr></tbody></table><h3 id="3-在markdown文档中使用toc"><a href="#3-在markdown文档中使用toc" class="headerlink" title="3. 在markdown文档中使用toc"></a><strong>3. 在markdown文档中使用<code>toc</code></strong></h3><p>在需要使用到toc的地方输入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- toc --&gt;</span><br></code></pre></td></tr></table></figure><hr><p>Hexo-toc Github：<a href="https://github.com/bubkoo/hexo-toc">https://github.com/bubkoo/hexo-toc</a></p><hr><p>参考：<br><a href="https://imys.net/20150514/hexo-toc.html">https://imys.net/20150514/hexo-toc.html</a><br><a href="https://www.colabug.com/2018/1022/4979695/">https://www.colabug.com/2018/1022/4979695/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>npm</tag>
      
      <tag>Blog</tag>
      
      <tag>Hexo-toc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo-Github-建立自己的博客</title>
    <link href="/post/46c185af/"/>
    <url>/post/46c185af/</url>
    
    <content type="html"><![CDATA[<!-- toc --><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a><strong>环境</strong></h2><ul><li>win10 专业版</li><li>git环境</li><li>npm环境</li></ul><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a><strong>条件</strong></h2><p>github账户（拥有SSH秘钥）</p><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a><strong>使用步骤</strong></h2><h3 id="1-在github上创建一个仓库"><a href="#1-在github上创建一个仓库" class="headerlink" title="1. 在github上创建一个仓库"></a><strong>1. 在github上创建一个仓库</strong></h3><h3 id="2-安装hexo"><a href="#2-安装hexo" class="headerlink" title="2. 安装hexo"></a><strong>2. 安装hexo</strong></h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> -g hexo<br></code></pre></td></tr></table></figure><h3 id="3-初始化hexo"><a href="#3-初始化hexo" class="headerlink" title="3. 初始化hexo"></a><strong>3. 初始化hexo</strong></h3><p>在一个你想要存放博客的文件的地方打开CMD</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>命令执行后会生成很多的文件，暂时无需理会，继续于CMD中输入</p><h3 id="4-第一次测试"><a href="#4-第一次测试" class="headerlink" title="4. 第一次测试"></a><strong>4. 第一次测试</strong></h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span> <br><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p>在最后一个命令输入完后，会提示一个地址。<br>你可以将这个地址输入到浏览器中，在浏览器中查看当前博客的样子。</p><h3 id="5-下载主题"><a href="#5-下载主题" class="headerlink" title="5. 下载主题"></a><strong>5. 下载主题</strong></h3><p>官方自带的博客样式并不是我所喜欢的，你可以在各种样式不同的主题中选择一种你喜欢的。<br>各类主题浏览：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>在主题的浏览页，你会看到作者留下的 这个主题的 安装代码。<br>类似于这种：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git clone https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/Shen-Yu/</span>hexo-theme-ayer.git themes/ayer<br></code></pre></td></tr></table></figure><p>将这个码输入到CMD中，系统会从作者的 仓库里将主题克隆下来。<br>等待git工作完毕后，再次在CMD中输入命令测试效果。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span> <br><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><h3 id="6-设置配置文件"><a href="#6-设置配置文件" class="headerlink" title="6. 设置配置文件"></a><strong>6. 设置配置文件</strong></h3><p>在hexo的根目录，会有一个<code>_config.yml</code>文件。<br>你可以用诸如 notepad++ 之类文档工具打开。<br>打开以后找到deploy项进行修改。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">deploy</span><br></code></pre></td></tr></table></figure><p>:-: ↓</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">deploy</span>:<br>  <span class="hljs-attribute">type</span>: <span class="hljs-string">&#x27;git&#x27;</span><br>  <span class="hljs-attribute">repository</span>: 在github中创建的仓库的ssh<br>  <span class="hljs-attribute">branch</span>: master<br></code></pre></td></tr></table></figure><p>类似的，找到 url 项与 root项 进行修改。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">url:</span> <span class="hljs-attr">http:</span><span class="hljs-comment">//yoursite.com</span><br><span class="hljs-attr">root:</span> <br></code></pre></td></tr></table></figure><p>:-: ↓</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs groovy"><span class="hljs-attr">url:</span> <span class="hljs-attr">http:</span><span class="hljs-comment">//yoursite.com/创建的仓库的名称</span><br><span class="hljs-attr">root:</span> <span class="hljs-regexp">/创建的仓库的名称/</span><br></code></pre></td></tr></table></figure><p>保存修改后的文件。</p><h3 id="7-安装git插件"><a href="#7-安装git插件" class="headerlink" title="7. 安装git插件"></a><strong>7. 安装git插件</strong></h3><p>在CMD中输入</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npm <span class="hljs-keyword">install</span> hexo-deployer-git<br></code></pre></td></tr></table></figure><h3 id="8-上传到github"><a href="#8-上传到github" class="headerlink" title="8. 上传到github"></a><strong>8. 上传到github</strong></h3><p>在CMD中输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><p>将文件上传到 github 仓库中</p><h3 id="9-github设置展示"><a href="#9-github设置展示" class="headerlink" title="9. github设置展示"></a><strong>9. github设置展示</strong></h3><p>在github仓库页面，进入仓库设置页面。<br><img src="/Hexo-Github-%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/20200228070314638.png"><br>在仓库设置页面中找到  GitHub Pages 项，将页面设置为基于 master 节点<br><img src="/Hexo-Github-%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/20200228070434020.png"><br>会到仓库首页，找到environment项<br><img src="/Hexo-Github-%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/20200228070446150.png"><br>在其中查看博客。</p><h3 id="10-博客参数修改"><a href="#10-博客参数修改" class="headerlink" title="10. 博客参数修改"></a><strong>10. 博客参数修改</strong></h3><p>参考主题作者的文档。再修改参数之后，再次上传即可<br>这份文档一般在 <code>/hexo目录/theme/主题名字/_config.yml</code></p><hr><p>Hexo官方文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p><h2 id="额外的技巧"><a href="#额外的技巧" class="headerlink" title="额外的技巧"></a><strong>额外的技巧</strong></h2><h3 id="每次发布后需要在github上重新域名的解决方法"><a href="#每次发布后需要在github上重新域名的解决方法" class="headerlink" title="每次发布后需要在github上重新域名的解决方法"></a><strong>每次发布后需要在github上重新域名的解决方法</strong></h3><p><code>博客目录/source/</code>下用新建一个txt文件。<br>打开编辑后，写下你的域名，如：<br><img src="/Hexo-Github-%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/20200308041542247.png"><br>保存后，将文件名改为CNAME即可（不需要扩展名）。<br><img src="/Hexo-Github-%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/20200308041624052.png"></p><h2 id="一键发布到github的脚本"><a href="#一键发布到github的脚本" class="headerlink" title="一键发布到github的脚本"></a><strong>一键发布到github的脚本</strong></h2><p>实际上只是建立一个批处理命令文件罢了<br>能节约不少时间，搞搞也无妨</p><ol><li>在博客目录下建立一个txt文件</li><li>打开新建的txt文件，写入<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">hexo clean <span class="hljs-variable">&amp;&amp;</span> hexo g <span class="hljs-variable">&amp;&amp;</span> hexo d<br>pause<br></code></pre></td></tr></table></figure></li><li>保存，然后将后缀名改为.bat<br>文件名你可以自己改，不影响的</li></ol><p>以后要发布到Github就打开这个批处理脚本就好了</p><hr><p>参考：<br><a href="https://segmentfault.com/a/1190000017986794">https://segmentfault.com/a/1190000017986794</a><br><a href="https://www.cnblogs.com/SUNYZBlog/p/10772712.html">https://www.cnblogs.com/SUNYZBlog/p/10772712.html</a><br><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>npm</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
