

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="自娱自乐">
  <meta name="author" content="EvilRecluse">
  <meta name="keywords" content="">
  <title>Vim-文本编辑器-摆脱鼠标提高开发效率 - EvilRecluse</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":true,"baidu":"https://hm.baidu.com/hm.js?758d4ab1e944598b8ead03bb4eb143a5","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Chaotic Record</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Vim-文本编辑器-摆脱鼠标提高开发效率">
              
            </span>

            
              <div class="mt-3">
  
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.6k 字
    </span>
  

  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Vim-文本编辑器-摆脱鼠标提高开发效率</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年3月10日 下午
                
              </p>
            
            <div class="markdown-body">
              <h1 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h1><p><code>Vim</code>是从<code>vi</code>发展出来的一个文本编辑器。其代码补完、编译及错误跳转等方便编程的功能特别丰富，是在开放源代码方式下发行的自由软件  </p>
<p>对于大多数用户来说，<code>Vim</code>有着一个比较陡峭的学习曲线<br>这意味着开始学习的时候可能会进展缓慢，但是一旦掌握一些基本操作之后，能大幅度提高编辑效率  </p>
<h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p><code>vim</code>的使用平台有很多，几乎每个<code>Linux</code>系统都会自带一个<code>vim</code>  </p>
<p>此处以 <code>VSCode</code> + <code>vim</code>插件 进行学习<br><code>VSCode</code>搜索插件<code>vim</code>安装<br>在插件页可以找到其 <code>setting.json</code> 默认配置<br><img src="/Vim-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8-%E6%91%86%E8%84%B1%E9%BC%A0%E6%A0%87%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/20210202114212912.png" srcset="/img/loading.gif"><br>将其添加到 <code>setting.json</code> 即可弯沉给配置<br>在完成配置后，编辑 <code>VSCode</code> 内的文档会变成<code>vim</code>编辑的形式<br>可以在状态栏中查看到现在的模式<br><img src="/Vim-%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8-%E6%91%86%E8%84%B1%E9%BC%A0%E6%A0%87%E6%8F%90%E9%AB%98%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87/20210202033715325.png" srcset="/img/loading.gif">  </p>
<h1 id="Vim-语法"><a href="#Vim-语法" class="headerlink" title="Vim 语法"></a>Vim 语法</h1><p>这章将是最重要的一章，一旦你理解了Vim命令的语法结构，你将能够和 Vim “说话”<br>注意，在这一章中当我讨论 Vim 语言时，我讨论并不是 Vimscript (Vim自带的插件编写和自定义设置的语言)，这里讨论的是 Vim 中 normal 模式的下的命令的通用规则  </p>
<h2 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h2><p>你只需要知道一个Vim语言的语法规则：  </p>
<figure class="highlight nginx"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs nginx"><span class="hljs-attribute">verb</span> + noun <span class="hljs-comment"># 动词 + 名词</span><br></code></pre></div></td></tr></table></figure>
<p>这就类似与在英语中的祈使句：</p>
<ul>
<li>Eat(verb) a donut(noun)</li>
<li>Kick(verb) a ball(noun)</li>
<li>Learn(verb) the Vim Editor(noun)</li>
</ul>
<p>现在你需要的就是用Vim中基本的动词和名字来建立你的词汇表</p>
<h2 id="词汇表"><a href="#词汇表" class="headerlink" title="词汇表"></a>词汇表</h2><h3 id="名词-动作-Motion"><a href="#名词-动作-Motion" class="headerlink" title="名词(动作 Motion)"></a>名词(动作 Motion)</h3><p>我们这里将动作作为名词，动作用来在Vim中到处移动，他们也是Vim中的名词<br>下面列出了一些常见的动作的例子：</p>
<table>
<thead>
<tr>
<th>名词/动作</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>h</td>
<td>左</td>
</tr>
<tr>
<td>j</td>
<td>下</td>
</tr>
<tr>
<td>k</td>
<td>上</td>
</tr>
<tr>
<td>l</td>
<td>右</td>
</tr>
<tr>
<td>w</td>
<td>向前移动到下一个单词的开头</td>
</tr>
<tr>
<td>}</td>
<td>跳转到下一个段落</td>
</tr>
<tr>
<td>$</td>
<td>跳转到当前行的末尾</td>
</tr>
</tbody></table>
<p>在之后的章节你将学习更多的关于<strong>动作</strong>的内容，所以如果你不理解上面这些动作也不必担心  </p>
<h3 id="动词-操作符-Operator"><a href="#动词-操作符-Operator" class="headerlink" title="动词(操作符 Operator)"></a>动词(操作符 Operator)</h3><p>根据<code>:h operator</code>，Vim 共有 16个<strong>操作符</strong>，学习常用的这3个操作符在80%的情况下就已经够用了  </p>
<table>
<thead>
<tr>
<th>操作符</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>y</td>
<td>yank(复制)</td>
</tr>
<tr>
<td>d</td>
<td>delete(删除)</td>
</tr>
<tr>
<td>c</td>
<td>change 删除文本，将删除的文本存到寄存器中，进入插入模式</td>
</tr>
</tbody></table>
<p>现在你已经知道了基本的动词和名词，我们来用一下我们的语法规则。假设你有下面这段文本：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> learn = <span class="hljs-string">&quot;Vim&quot;</span>;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>复制当前位置到行尾的所有内容：<code>y$</code>  </li>
<li>删除当前位置到下一个单词的开头：<code>dw</code>  </li>
<li>修改当前位置到这个段落的结尾：<code>c&#125;</code>  </li>
</ul>
<p><strong>动作</strong>也接受数字作为参数，如果你需要向上移动3行，你可以用3k代替按3次k  </p>
<ul>
<li>向左拷贝2个字符：<code>y2h</code>  </li>
<li>删除后两个单词：<code>d2w</code>  </li>
<li>修改后面两行：<code>c2j</code><br>目前，也许需要想很久才能完成一个简单的命令，不过刚开始时都是这样，经历过类似的挣扎的阶段后速度就会快起来   </li>
</ul>
<p>作为补充，行级的<strong>操作符</strong>在文本编辑中和其他的<strong>操作符</strong>一样，Vim 允许你通过按两次命令执行行级的操作<br>例如dd，yy，cc来执行删除，复制或修改整个行  </p>
<p>目前为止还没有结束，Vim 有另一种类型的名词：文本对象(text object)  </p>
<h3 id="更多名词-文本对象"><a href="#更多名词-文本对象" class="headerlink" title="更多名词(文本对象)"></a>更多名词(文本对象)</h3><p>想象一下你现在正在某个被括号包围的文本中例如 <code>(hello Vim)</code>，你现在想要删掉括号中的所有内容，你会怎样快速的完成它？是否有一种方法能够把括号中内容作为整体删除呢？  </p>
<p>答案是有的。文本通常是结构化的，特别是代码经常被放置在小括号、中括号、大括号、引号等当中。Vim提供了一种处理这种结构的文本对象的方法  </p>
<p>文本对象可以被<strong>操作符</strong>使用，这里有两类文本对象：</p>
<figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus"><span class="hljs-selector-tag">i</span> + <span class="hljs-selector-tag">object</span>  内部文本对象<br><span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">object</span>  外部文本对象<br></code></pre></div></td></tr></table></figure>
<p><strong>内部文本对象</strong>选中的部分不包含包围文本对象的空白或括号等，<strong>外部文本对象</strong>则包括了包围内容的空白或括号等对象<br>外部对象总是比内部对象选中的内容更多，因此如果你的光标位于一对括号内部  </p>
<p>例：(<code>hello Vim</code>)    </p>
<ul>
<li>删除括号内部的内容但保留括号：<code>di(</code>  </li>
<li>删除括号以及内部的内容：<code>da(</code>  </li>
</ul>
<p>例：假设你有这样一段<code>Javascript</code>的函数，你的光标停留在”Hello”上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hello = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Hello Vim&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<ul>
<li>删除整个”Hello Vim”：<code>di(</code>  </li>
<li>删除整个函数(被{}包含)：<code>di&#123;</code>  </li>
<li>删除”Hello”这个词：<code>diw</code>  </li>
</ul>
<p>文本对象很强大因为你可以在一个位置指向不同的对象，能够删除一对括号、函数体或整个单词的文本对象中的内容<br>此外，当你看到 <code>di(</code>，<code>di&#123;</code>和<code>diw</code>时，你也可以很好的意识到他们表示的是什么  </p>
<p>例：假设你有这样一些<code>html</code>的标签的文本  </p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Header1<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph1<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Paragraph2<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>如果你的光标位于”Header1”文本上：  </p>
<ul>
<li>删除<code>Header1</code>：dit  </li>
<li>删除<code>&lt;h1&gt;Header1&lt;/h1&gt;</code>：dat  </li>
</ul>
<p>如果你的光标在”div”文本上：  </p>
<ul>
<li>删除h1和所有p标签的行：dit  </li>
<li>删除所有文本：dat  </li>
<li>删除”div”：di&lt;<br>下面列举的一些通常见到的文本对象：  </li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>w</td>
<td>一个单词</td>
</tr>
<tr>
<td>p</td>
<td>一个段落</td>
</tr>
<tr>
<td>s</td>
<td>一个句子</td>
</tr>
<tr>
<td>(或)</td>
<td>一对()</td>
</tr>
<tr>
<td>{或}</td>
<td>一对{}</td>
</tr>
<tr>
<td>[或]</td>
<td>一对[]</td>
</tr>
<tr>
<td>&lt;或&gt;</td>
<td>一对&lt;&gt;</td>
</tr>
<tr>
<td>t</td>
<td>XML标签</td>
</tr>
<tr>
<td>“</td>
<td>一对””</td>
</tr>
<tr>
<td>‘</td>
<td>一对’’</td>
</tr>
<tr>
<td>`</td>
<td>一对``</td>
</tr>
<tr>
<td>你可以通过<code>:h text-objects</code>了解更多</td>
<td></td>
</tr>
</tbody></table>
<h2 id="结合性和语法"><a href="#结合性和语法" class="headerlink" title="结合性和语法"></a>结合性和语法</h2><p>在学习 Vim 的语法之后，让我们来讨论一下 Vim 中的结合性以及为什么在文本编辑器中这是一个强大的功能  </p>
<p>结合性意味着你有很多可以组合起来完成更复杂命令的普通命令，就像你在编程中可以通过一些简单的抽象建立更复杂的抽象，在 Vim 中你可以通过简单的命令的组合执行更复杂的命令<br>Vim 语法正是 Vim 中命令的可结合性的体现  </p>
<p>Vim 的结合性最强大之处体现在它和外部程序结合时，Vim 有一个<strong>过滤操作符</strong><code>!</code>可以用外部程序过滤我们的文本  </p>
<p>例：你有下面这段混乱的文本，用tab格式化的更好看的一些  </p>
<figure class="highlight coq"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs coq">Id|<span class="hljs-type">Name</span>|<span class="hljs-type">Cuteness</span><br><span class="hljs-number">01</span>|<span class="hljs-type">Puppy</span>|<span class="hljs-type">Very</span><br><span class="hljs-number">02</span>|<span class="hljs-type">Kitten</span>|<span class="hljs-type">Ok</span><br><span class="hljs-number">03</span>|<span class="hljs-type">Bunny</span>|<span class="hljs-type">Ok</span><br></code></pre></div></td></tr></table></figure>
<p>这件事情通过 Vim命令不太容易完成，但是你可以通过终端提供的命令 column 很快的完成它<br>当你的光标位于<code>Id</code>上时，运行<code>!&#125;column -t -s &quot;|&quot;</code>，你的文本就变得整齐了许多  </p>
<figure class="highlight rust"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs rust">Id  Name    Cuteness<br><span class="hljs-number">01</span>  Puppy   Very<br><span class="hljs-number">02</span>  Kitten  <span class="hljs-literal">Ok</span><br><span class="hljs-number">03</span>  Bunny   <span class="hljs-literal">Ok</span><br></code></pre></div></td></tr></table></figure>
<p>让我们分解一下上面那条命令，动词是!(过滤操作符)，名词是}(到下一个段落)。过滤操作符<code>!</code>接受终端命令作为另一个参数，因此我把<code>column -t -s &quot;|&quot;</code>传给它。我不想详细描述<code>column</code>是如何工作的，但是总之它格式化了文本  </p>
<p>假设你不止想格式化你的文本，还想只展示Ok结尾的行，你知道awk命令可以做这件事情，那么你可以这样做  </p>
<figure class="highlight dart"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs dart">!&#125;column -t -s <span class="hljs-string">&quot;|&quot;</span> | awk <span class="hljs-string">&#x27;NR &gt; 1 &amp;&amp; /Ok/&#123;print <span class="hljs-subst">$0</span>&#125;&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>结果如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">02 </span> Kitten  Ok<br><span class="hljs-symbol">03 </span> Bunny   Ok<br></code></pre></div></td></tr></table></figure>
<p>这就是 Vim的结合性的强大之处。你知道的<strong>操作符</strong>，<strong>动作</strong>，终端命令越多，你组建复杂操作的能力成倍增长  </p>
<p>假设你只知道:  </p>
<ul>
<li>四个动作：<code>w</code>, <code>$</code>, <code>&#125;</code>,<code>G</code>  </li>
<li>删除操作符(<code>d</code>)  </li>
</ul>
<p>你可以做8件事：按四种方式移动(<code>w</code>, <code>$</code>, <code>&#125;</code>, <code>G</code>)和删除4种文本对象(<code>dw</code>, <code>d$</code>, <code>d&#125;</code>, <code>dG</code>)  </p>
<p>如果有一天你学习了小写变大写的<strong>操作符</strong>(<code>gU</code>)，你的 Vim 工具箱中多的不是1种工具，而是4种：<code>gUw</code>, <code>gU$</code>, <code>gU&#125;</code>, <code>gUG</code>。现在你的 Vim工具箱中就有12种工具了  </p>
<p>使用 Vim这种能够组合的工具，所有你知道的东西都可以被串起来完成更复杂的操作。你知道的越多，你就越强大  </p>
<p>这种具有结合性的行为也正符合Unix的哲学：一个命令做好一件事<br><strong>动作</strong>只需要做一件事：前往X<br><strong>操作符</strong>只需要做一件事：完成Y<br>通过结合一个操作符和一个动作，你就获得了YX：在X上完成Y  </p>
<p>甚至，<strong>动作</strong>和<strong>操作符</strong>都是可拓展的，你可以自己创造动作和操作符去丰富你的 Vim工具箱，<code>Vim-textobj-user</code>有一系列自定义的文本对象  </p>
<p>另外，如果你不知道刚才使用的<code>column</code>和<code>awk</code>命令也没有关系，重要的是 Vim可以和终端命令很好的结合起来  </p>
<h1 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h1><p>学习光标移动以及如何高效的使用<br>记住，这一章所讲的并不是 Vim 的全部移动命令，目标是介绍有用的移动来快速提高效率<br>如果你需要学习更多的移动命令，查看<code>:h motion.txt</code>  </p>
<h2 id="上下左右步进移动"><a href="#上下左右步进移动" class="headerlink" title="上下左右步进移动"></a>上下左右步进移动</h2><p>最基本的移动单元是上下左右移动一个字符  </p>
<table>
<thead>
<tr>
<th>方向</th>
<th>左</th>
<th>下</th>
<th>右</th>
<th>上</th>
</tr>
</thead>
<tbody><tr>
<td>键位</td>
<td>h</td>
<td>j</td>
<td>k</td>
<td>l</td>
</tr>
</tbody></table>
<blockquote>
<p>为什么Vim使用hjkl进行移动?<br>实际上是历史原因。因为 <code>Bill Joy</code>写 <code>VI</code>(VIM前身)用的 <code>Lear-Siegler ADM-3A</code>终端没有方向键，而是把<code>hjkl</code>当做方向键  </p>
</blockquote>
<p>常用情景：  </p>
<ul>
<li>从一个单词的一个部分移动到另一个部分，使用<code>h</code>或<code>l</code>  </li>
<li>在可见的范围内上下移动几行，我会使用j和k  </li>
</ul>
<p>对于其它的场景，实际上会有更好的方法  </p>
<h2 id="对步进移动-计数"><a href="#对步进移动-计数" class="headerlink" title="对步进移动 计数"></a>对步进移动 计数</h2><p>实际上，可以指定步进数量来达到指定目的<br>语法：  </p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">[计数] [步进移动]<br></code></pre></div></td></tr></table></figure>
<p>如果你想向右移动9个字符，你可以使用9l来代替按9次<code>l</code><br>当你学到了更多的动作时，你都可以试试给定计数参数  </p>
<h2 id="单词导航"><a href="#单词导航" class="headerlink" title="单词导航"></a>单词导航</h2><table>
<thead>
<tr>
<th>导航</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>w</td>
<td>移动到下一个单词的开头</td>
</tr>
<tr>
<td>W</td>
<td>移动到下一个词组的开头</td>
</tr>
<tr>
<td>e</td>
<td>移动到下一个单词的结尾</td>
</tr>
<tr>
<td>E</td>
<td>移动到下一个词组的结尾</td>
</tr>
<tr>
<td>b</td>
<td>移动到前一个单词的开头</td>
</tr>
<tr>
<td>B</td>
<td>移动到前一个词组的开头</td>
</tr>
<tr>
<td>ge</td>
<td>移动到前一个单词的结尾</td>
</tr>
<tr>
<td>gE</td>
<td>移动到前一个词组的结尾</td>
</tr>
</tbody></table>
<p>词组和单词到底有什么相同和不同呢？<br>单词和词组都按照非空字符被分割，一个单词指的是一个只包含<code>a-z</code>、<code>A-Z</code>、<code>0-9</code>字符串，一个词组指的是一个包含除了空字符(包括空格，tab，EOL)以外的字符的字符串  </p>
<p>可以通过<code>:h word</code>和<code>:h WORD</code>了解更多  </p>
<p>例如，假如你有下面这段内容：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hello = <span class="hljs-string">&quot;world&quot;</span>;<br></code></pre></div></td></tr></table></figure>
<p>当你光标位于这行的开头时，你可以通过l走到行尾，但是你需要按21下，使用w，你需要6下，使用W只需要4下。 单词和词组都是短距离移动的很好的选择  </p>
<h2 id="当前行导航"><a href="#当前行导航" class="headerlink" title="当前行导航"></a>当前行导航</h2><table>
<thead>
<tr>
<th>导航</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td><code>0</code></td>
<td>跳到本行第一个字符</td>
</tr>
<tr>
<td><code>^</code></td>
<td>跳到本行第一个非空字符</td>
</tr>
<tr>
<td><code>g_</code></td>
<td>跳到本行最后一个非空字符</td>
</tr>
<tr>
<td><code>$</code></td>
<td>跳到本行最后一个字符</td>
</tr>
<tr>
<td><code>n|</code></td>
<td>跳到本行第n列</td>
</tr>
<tr>
<td><code>f&#123;chars&#125;</code></td>
<td>在同一行向后搜索第一个<code>&#123;chars&#125;</code>匹配</td>
</tr>
<tr>
<td><code>F&#123;chars&#125;</code></td>
<td>在同一行向前搜索第一个<code>&#123;chars&#125;</code>匹配</td>
</tr>
<tr>
<td><code>t&#123;chars&#125;</code></td>
<td>在同一行向后搜索第一个<code>&#123;chars&#125;</code>匹配，并停在匹配前</td>
</tr>
<tr>
<td><code>T&#123;chars&#125;</code></td>
<td>在同一行向前搜索第一个<code>&#123;chars&#125;</code>匹配，并停在匹配前</td>
</tr>
<tr>
<td><code>;</code></td>
<td>在同一行重复最近一次搜索</td>
</tr>
<tr>
<td><code>,</code></td>
<td>在同一行向相反方向重复最近一次搜索</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> hello = <span class="hljs-string">&quot;world&quot;</span>;<br></code></pre></div></td></tr></table></figure>
<p>当你的光标位于行的开头时，你可以通过按一次键<code>$</code>去往行尾的最后一个字符<code>;</code>。 如果想去往<code>world</code>中的<code>w</code>，你可以使用<code>fw</code><br>一个建议是，在行内目标附近通过寻找重复出现最少的字母例如<code>j</code>，<code>x</code>，<code>z</code>来前往行中的该位置更快  </p>
<h2 id="句子和段落导航"><a href="#句子和段落导航" class="headerlink" title="句子和段落导航"></a>句子和段落导航</h2><p>首先我们来聊聊句子。 一个句子的定义是以.!?和跟着的一个换行符或空格，tab结尾的<br>你可以通过)和(跳到下一个和上一个句子  </p>
<table>
<thead>
<tr>
<th>导航</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>(</td>
<td>跳到前一个句子</td>
</tr>
<tr>
<td>)</td>
<td>跳到下一个句子</td>
</tr>
</tbody></table>
<p>让我们来看一些例子，你觉得哪些字段是句子哪些不是? 可以尝试在 Vim 中用<code>(</code>和<code>)</code>感受一下  </p>
<figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">I am a sentence. I am another sentence because I <span class="hljs-keyword">end</span> <span class="hljs-keyword">with</span> a period. I am still a sentence when ending <span class="hljs-keyword">with</span> an exclamation point! What <span class="hljs-keyword">about</span> question mark? I am <span class="hljs-keyword">not</span> quite a sentence because <span class="hljs-keyword">of</span> <span class="hljs-keyword">the</span> hyphen - <span class="hljs-keyword">and</span> neither semicolon ; nor colon :<br><br>There <span class="hljs-keyword">is</span> an empty line <span class="hljs-keyword">above</span> <span class="hljs-keyword">me</span>.<br></code></pre></div></td></tr></table></figure>
<p>另外，如果你的 Vim 中遇到了无法将一个以<code>.</code>结尾的字段并且后面跟着一个空行的这种情况判断为一个句子的问题，你可能处于 compatible的模式。运行<code>:set nocompatible</code> 可以修复  </p>
<p>在<code>Vi</code>中，一个句子是以两个空格结尾的，你应该总是保持的<code>nocompatible</code>的设置  </p>
<p>一个段落可以从一个空行之后开始，也可以从段落选项中字符对所指定的段落宏的每个集合开始  </p>
<table>
<thead>
<tr>
<th>导航</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>{</td>
<td>跳转到上一个段落</td>
</tr>
<tr>
<td>}</td>
<td>跳转到下一个段落</td>
</tr>
</tbody></table>
<p>如果你不知道什么是段落宏，不用担心，重要的是一个段落总是以一个空行开始和结尾， 在大多数时候总是对的  </p>
<p>例: 你可以尝试着使用<code>&#125;</code>和<code>&#123;</code>进行导航，也可以试一试<code>(``)</code>这样的句子导航  </p>
<figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">Hello. How are you? I am great, thanks!<br>Vim <span class="hljs-keyword">is</span> awesome.<br>It may <span class="hljs-keyword">not</span> easy <span class="hljs-keyword">to</span> learn <span class="hljs-keyword">it</span> <span class="hljs-keyword">at</span> <span class="hljs-keyword">first</span>...- <span class="hljs-keyword">but</span> we are <span class="hljs-keyword">in</span> this together. Good luck!<br><br>Hello again.<br><br>Try <span class="hljs-keyword">to</span> move <span class="hljs-keyword">around</span> <span class="hljs-keyword">with</span> ), (, &#125;, <span class="hljs-keyword">and</span> &#123;. Feel how they work.<br>You got this.<br></code></pre></div></td></tr></table></figure>
<p>你可以通过<code>:h setence</code>和<code>:h paragraph</code>了解更多  </p>
<h2 id="匹配导航"><a href="#匹配导航" class="headerlink" title="匹配导航"></a>匹配导航</h2><p>程序员经常编辑含有代码的文件，这种文件内容会包含大量的小括号，中括号和大括号，并且可能会把你搞迷糊你当前到底在哪对括号里<br>许多编程语言都用到了小括号，中括号和大括号，你可能会迷失于其中。 如果你在它们中的某一对括号中，你可以通过%跳到q其中一个括号或另一个上(如果存在)。 你也可以通过这种方法弄清你是否各个括号都成对匹配了  </p>
<table>
<thead>
<tr>
<th>导航</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>%</td>
<td>导航到匹配的 <code>()</code>, <code>[]</code>, <code>&#123;&#125;</code></td>
</tr>
</tbody></table>
<p>可以使用类似 <code>vim-rainbow</code> 这样的可视化指示插件来作为<code>%</code>的补充。 通过<code>:h %</code>了解更多  </p>
<h2 id="行号导航"><a href="#行号导航" class="headerlink" title="行号导航"></a>行号导航</h2><p>有时你不知道你想去的位置的具体行号，但是知道它大概在整个文件的 70% 左右的位置，你可以使用70%跳过去，可以使用50%跳到文件的中间  </p>
<table>
<thead>
<tr>
<th>导航</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>gg</td>
<td>跳转到第一行</td>
</tr>
<tr>
<td>G</td>
<td>跳转到最后一行</td>
</tr>
<tr>
<td>nG</td>
<td>跳转到第n行</td>
</tr>
<tr>
<td>n%</td>
<td>跳到文件的n%</td>
</tr>
<tr>
<td>另外，如果你想看文件总行数，可以用<code>CTRL-g</code>查看</td>
<td></td>
</tr>
</tbody></table>
<h2 id="窗格导航"><a href="#窗格导航" class="headerlink" title="窗格导航"></a>窗格导航</h2><p>为了移动到当前窗格的顶部，中间，底部，你可以使用<code>H</code>，<code>M</code>和<code>L</code>  </p>
<p>你也可以给<code>H</code>和<code>L</code>传一个数字前缀<br>如果你输入<code>10H</code>你会跳转到窗格顶部往下数 10行的位置，如果你输入<code>3L</code>，你会跳转到距离当前窗格的底部一行向上数3行的位置  </p>
<table>
<thead>
<tr>
<th>导航</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>H</td>
<td>跳转到屏幕的顶部</td>
</tr>
<tr>
<td>M</td>
<td>跳转到屏幕的中间</td>
</tr>
<tr>
<td>L</td>
<td>跳转到屏幕的底部</td>
</tr>
<tr>
<td>nH</td>
<td>跳转到距离顶部n行的位置</td>
</tr>
<tr>
<td>nL</td>
<td>跳转到距离底部n行的位置</td>
</tr>
</tbody></table>
<h2 id="滚动"><a href="#滚动" class="headerlink" title="滚动"></a>滚动</h2><table>
<thead>
<tr>
<th>导航</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl-e</td>
<td>向下滚动一行</td>
</tr>
<tr>
<td>Ctrl-d</td>
<td>向下滚动半屏</td>
</tr>
<tr>
<td>Ctrl-f</td>
<td>向下滚动一屏</td>
</tr>
<tr>
<td>Ctrl-y</td>
<td>向上滚动一行</td>
</tr>
<tr>
<td>Ctrl-u</td>
<td>向上滚动半屏</td>
</tr>
<tr>
<td>Ctrl-b</td>
<td>向上滚动一屏</td>
</tr>
</tbody></table>
<p>你也可以相对当前行进行滚动</p>
<table>
<thead>
<tr>
<th>导航</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>zt</td>
<td>将当前行置于屏幕顶部附近</td>
</tr>
<tr>
<td>zz</td>
<td>将当前行置于屏幕中央</td>
</tr>
<tr>
<td>zt</td>
<td>将当前行置于屏幕底部</td>
</tr>
</tbody></table>
<h2 id="搜索导航"><a href="#搜索导航" class="headerlink" title="搜索导航"></a>搜索导航</h2><p>通常，你已经知道这个文件中有一个字段，你可以通过搜索导航非常快速的定位你的目标  </p>
<table>
<thead>
<tr>
<th>导航</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>/</td>
<td>向后搜索一个匹配</td>
</tr>
<tr>
<td>?</td>
<td>向前搜素一个匹配</td>
</tr>
<tr>
<td>n</td>
<td>重复上一次搜索(和上一次方向相同)</td>
</tr>
<tr>
<td>N</td>
<td>重复上一次搜索(和上一次方向相反)</td>
</tr>
</tbody></table>
<p>假设你有一下文本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> one = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">let</span> two = <span class="hljs-number">2</span>;<br>one = <span class="hljs-string">&quot;01&quot;</span>;<br>one = <span class="hljs-string">&quot;one&quot;</span>;<br><span class="hljs-keyword">let</span> onetwo = <span class="hljs-number">12</span>;<br></code></pre></div></td></tr></table></figure>
<p>可以通过<code>/let</code>搜索<code>let</code>，然后通过n快速的重复搜索下一个<code>let</code>，如果需要向相反方向搜索，可以使用<code>N</code><br>如果你用<code>?let</code>搜索，会得到一个向前的搜索，这时你使用<code>n</code>，它会继续向前搜索，就和<code>?</code>的方向一致。(<code>N</code>将会向后搜索<code>let</code>)  </p>
<p>你可以通过<code>:set hlsearch</code>设置搜索高亮。 这样，当你搜索<code>/let</code>，它将高亮文件中所有匹配的字段<br>另外，如果你通过<code>:set incsearch</code>设置了增量搜索，它将在你输入时不断匹配的输入的内容<br>默认情况下，匹配的字段会一直高亮到你搜索另一个字段，这有时候很烦人，如果你希望取消高亮，可以使用<code>:nohlsearch</code>  </p>
<p>如果经常使用这个功能，可以设置一个映射：  </p>
<figure class="highlight elixir"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs elixir">nnoremap &lt;esc&gt;&lt;esc&gt; <span class="hljs-symbol">:noh&lt;return&gt;&lt;esc&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>你可以通过<code>*</code>快速的向下搜索光标下的文本，通过<code>#</code>快速向前搜索光标下的文本<br>如果你的光标位于一个字符串<code>one</code>上，按下<code>*</code>相当于<code>/\&lt;one\&gt;</code>。 <code>/\&lt;one\&gt;</code>中的<code>\&lt;</code>和<code>\&gt;</code>表示整词匹配，使得一个更长的包含<code>one</code>的单词不会被匹配上，也就是说它会匹配<code>one</code>，但不会匹配<code>onetwo</code><br>如果你的光标在<code>one</code>上并且你想向后搜索完全或部分匹配的单词，例如<code>one</code>和<code>onetwo</code>，你可以用<code>g*</code>替代<code>*</code>  </p>
<table>
<thead>
<tr>
<th>导航</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>向后查找光标所在的完整单词</td>
</tr>
<tr>
<td>#</td>
<td>向前查找光标所在的完整单词</td>
</tr>
<tr>
<td>g*</td>
<td>向后搜索光标所在的单词</td>
</tr>
<tr>
<td>g#</td>
<td>向前搜索光标所在的单词</td>
</tr>
</tbody></table>
<h2 id="位置标记"><a href="#位置标记" class="headerlink" title="位置标记"></a>位置标记</h2><p>可以通过标记保存当前位置并在之后回到这个位置，就像文本编辑中的书签  </p>
<table>
<thead>
<tr>
<th>导航</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>ma</td>
<td>用a标签标记一个位置</td>
</tr>
<tr>
<td>`a</td>
<td>精确回到a标签的位置(行和列)</td>
</tr>
<tr>
<td>‘a</td>
<td>跳转到a标签的行</td>
</tr>
</tbody></table>
<p><code>a-z</code>的标签和<code>A-Z</code>的标签存在一个区别，小写字母是局部标签，大写字母是全局标签(也称文件标记)  </p>
<p>我们首先说说局部标记。 每个<code>buffer</code>可以有自己的一套局部标记，如果打开了两个文件，我可以在第一个文件中设置标记<code>a</code>(ma)，然后在另一个文件中设置另一个标记<code>a</code>(ma)  </p>
<p>不像你可以在每个buffer中设置一套局部标签，你只能设置一套全局标签。 如果你在 myFile.txt 中设置了标签<code>mA</code>，下一次你在另一个文件中设置<code>mA</code>时，<code>A</code>标签的位置会被覆盖。 全局标签有一个好处就是，即使你在不同的项目红，你也可以跳转到任何一个全局标签上，全局标签可以帮助你在文件间切换  </p>
<p>使用<code>:marks</code>查看所有标签，你也许会注意到除了<code>a-z</code>,<code>A-Z</code>以外还有别的标签，其中有一些例如：</p>
<table>
<thead>
<tr>
<th>导航</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>“</td>
<td>在当前buffer中跳转回到上一次跳转前的最后一行</td>
</tr>
<tr>
<td>``</td>
<td>在当前buffer中跳转回到上一次跳转前的最后一个位置</td>
</tr>
<tr>
<td>`[</td>
<td>跳转到上一次修改或拷贝的文本的开头</td>
</tr>
<tr>
<td>`]</td>
<td>跳转到上一次修改或拷贝的文本的结尾</td>
</tr>
<tr>
<td>`&lt;</td>
<td>跳转到最近一次可视模式下选择的部分的开头</td>
</tr>
<tr>
<td>`&gt;</td>
<td>跳转到最近一次可视模式下选择的部分的结尾</td>
</tr>
<tr>
<td>`0</td>
<td>跳转到退出Vim前编辑的最后一个文件</td>
</tr>
</tbody></table>
<p>除了上面列举的，还有更多标记，我不会在这一一列举因为我觉得它们很少用到，不过如果你很好奇，你可以通过<code>: marks</code>查看  </p>
<h2 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h2><p>最后，我们聊聊Vim中的跳转你通过任意的移动可以在不同文件中或者同一个的文件的不同部分间跳转。 然而并不是所有的移动都被认为是一个跳转。 使用j向下移动一行就不被看做一个跳转，即使你使用10j向下移动10行，也不是一个跳转。 但是你通过10G去往第10行被算作一个跳转。</p>
<table>
<thead>
<tr>
<th>导航</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>‘</td>
<td>跳转到标记的行</td>
</tr>
<tr>
<td>`</td>
<td>跳转到标记的位置(行和列)</td>
</tr>
<tr>
<td>G</td>
<td>跳转到行</td>
</tr>
<tr>
<td>/</td>
<td>向后搜索</td>
</tr>
<tr>
<td>?</td>
<td>向前搜索</td>
</tr>
<tr>
<td>n</td>
<td>重复上一次搜索，相同方向</td>
</tr>
<tr>
<td>N</td>
<td>重复上一次搜索，相反方向</td>
</tr>
<tr>
<td>%</td>
<td>查找匹配</td>
</tr>
<tr>
<td>(</td>
<td>跳转上一个句子</td>
</tr>
<tr>
<td>)</td>
<td>跳转下一个句子</td>
</tr>
<tr>
<td>{</td>
<td>跳转上一个段落</td>
</tr>
<tr>
<td>}</td>
<td>跳转下一个段落</td>
</tr>
<tr>
<td>L</td>
<td>跳转到当前屏幕的最后一行</td>
</tr>
<tr>
<td>M</td>
<td>跳转到当前屏幕的中间</td>
</tr>
<tr>
<td>H</td>
<td>跳转到当前屏幕的第一行</td>
</tr>
<tr>
<td>[[</td>
<td>跳转到上一个小节</td>
</tr>
<tr>
<td>]]</td>
<td>跳转到下一个小节</td>
</tr>
<tr>
<td>:s</td>
<td>替换</td>
</tr>
<tr>
<td>:tag</td>
<td>跳转到tag定义</td>
</tr>
</tbody></table>
<p>不建议把上面这个列表记下来，一个大致的规则是，任何大于一个单词或超过当前行导航的移动都可能是一个跳转。 Vim 保留了你移动前位置的记录，你可以通过<code>:jumps</code>查看这个列表，如果想了解更多，可以查看<code>:h jump-motions</code>  </p>
<p>为什么跳转有呢? 因为你可以在跳转列表中通过 Ctrl-o 和 Ctrl-i 在记录之间向上或向下跳转到对应位置<br>实际上是可以在不同文件中进行跳转的  </p>
<h1 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h1><p>输入模式是大部分文本编辑器的默认模式，在这个模式下，所敲即所得  </p>
<h2 id="进入输入模式"><a href="#进入输入模式" class="headerlink" title="进入输入模式"></a>进入输入模式</h2><p>我们有很多方式从普通模式进入输入模式，下面列举出了其中的一些方法  </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>i</td>
<td>从光标之前的位置开始输入文本</td>
</tr>
<tr>
<td>I</td>
<td>从当前行第一个非空字符之前的位置之前开始输入文本</td>
</tr>
<tr>
<td>a</td>
<td>在光标之后的位置追加文本</td>
</tr>
<tr>
<td>A</td>
<td>在当前行的末尾追加文本</td>
</tr>
<tr>
<td>o</td>
<td>在光标位置下方新起一行并开始输入文本</td>
</tr>
<tr>
<td>O</td>
<td>在光标位置的上方新起一行并开始输入文本</td>
</tr>
<tr>
<td>s</td>
<td>删除当前光标位置的字符并开始输入文本</td>
</tr>
<tr>
<td>S</td>
<td>删除当前行并开始输入文本</td>
</tr>
<tr>
<td>gi</td>
<td>从当前缓冲区上次结束输入模式的地方开始输入文本</td>
</tr>
<tr>
<td>gI</td>
<td>在当前行的第一列的位置开始输入文本</td>
</tr>
</tbody></table>
<p>值得注意的是这些命令的小写/大写模式，每一个小写命令都有一个与之对应的大写命令<br>如果你是初学者，不用担心记不住以上整个命令列表，可以从 <code>i</code> 和 <code>a</code>两条命令开始，这两条命令足够在入门阶段使用了，之后再逐渐地掌握更多其他的命令  </p>
<h2 id="退出输入模式的方法"><a href="#退出输入模式的方法" class="headerlink" title="退出输入模式的方法"></a>退出输入模式的方法</h2><p>下面列出了一些从输入模式退出到普通模式的方法：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td><esc></td>
<td>退出输入模式进入普通模式</td>
</tr>
<tr>
<td>Ctrl-[</td>
<td>退出输入模式进入普通模式</td>
</tr>
<tr>
<td>Ctrl-c</td>
<td>与 Ctrl-[ 和 <esc>功能相同, 但是不检查缩写</td>
</tr>
</tbody></table>
<p>Vim用户中常见的习惯是用以下的配置方法在输入模式中把<code>esc</code>映射到<code>jj</code>或者<code>jk</code>  </p>
<figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim"><span class="hljs-keyword">inoremap</span> jj <span class="hljs-symbol">&lt;esc&gt;</span><br><span class="hljs-keyword">inoremap</span> jk <span class="hljs-symbol">&lt;esc&gt;</span><br></code></pre></div></td></tr></table></figure>

<h2 id="重复输入模式"><a href="#重复输入模式" class="headerlink" title="重复输入模式"></a>重复输入模式</h2><p>你可以在进入输入模式之前传递一个计数参数. 比如：</p>
<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-number">10i</span><br></code></pre></div></td></tr></table></figure>
<p>如果你输入 <code>hello world!</code> 然后退出输入模式， Vim 将重复这段文本10次。这个方法对任意一种进入输入模式的方式都有效（如：<code>10I</code>, <code>11a</code>, <code>12o</code>）</p>
<h2 id="在输入模式中删除大块文本"><a href="#在输入模式中删除大块文本" class="headerlink" title="在输入模式中删除大块文本"></a>在输入模式中删除大块文本</h2><p>当你输入过程中出现一些输入错误时，一直重复地用<code>backspace</code>来删除的话会非常地繁琐<br>更为合理的做法是切换到普通模式并使用d来删除错误<br>或者，你能用以下命令在输入模式下就删除一个或者多个字符：  </p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl-h</td>
<td>删除一个字符</td>
</tr>
<tr>
<td>Ctrl-w</td>
<td>删除一个单词</td>
</tr>
<tr>
<td>Ctrl-u</td>
<td>删除一整行</td>
</tr>
</tbody></table>
<p>此外，这些快捷键也支持在 命令行模式 和 Ex模式 中使用  </p>
<h2 id="用寄存器进行输入"><a href="#用寄存器进行输入" class="headerlink" title="用寄存器进行输入"></a>用寄存器进行输入</h2><p>寄存器就像是内存里的暂存器一样，可供存储和取出文本<br>在输入模式下，可以使用快捷键 Ctrl-r 加上寄存器的标识来从任何有标识的寄存器输入文本<br>有很多标识可供使用，但是在这一章节中你只需要知道以（a-z)命名的寄存器是可以使用的就足够了  </p>
<p>让我们在一个具体的例子中展示寄存器的用法，首先你需要复制一个单词到寄存器a中，这一步可以用以下这条命令来完成：  </p>
<figure class="highlight 1c"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs 1c"><span class="hljs-string">&quot;ayiw</span><br></code></pre></div></td></tr></table></figure>
<ul>
<li><code>&quot;a</code> 告诉Vim你下一个动作的目标地址是寄存器a  </li>
<li><code>yiw</code> 复制一个内词（inner word），可以回顾Vim语法章节查看具体语法<br>现在 寄存器a 存放着你刚复制的单词。在输入模式中，使用以下的快捷键来粘贴存放在寄存器a中文本  <figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">Ctrl-r a</span><br></code></pre></div></td></tr></table></figure>
Vim 中存在很多种类型的寄存器，后面的章节会介绍更多他们的细节  </li>
</ul>
<h2 id="页面滚动"><a href="#页面滚动" class="headerlink" title="页面滚动"></a>页面滚动</h2><p>在输入模式下，如果你使用快捷键 Ctrl-x 进入 <strong>Ctrl-x子模式</strong>，你可以进行一些额外操作，页面滚动正是其中之一  </p>
<figure class="highlight gml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gml">Ctrl-<span class="hljs-symbol">x</span> Ctrl-<span class="hljs-symbol">y</span>    向上滚动页面<br>Ctrl-<span class="hljs-symbol">x</span> Ctrl-e    向下滚动页面<br></code></pre></div></td></tr></table></figure>

<h2 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h2><p>Vim 在进入 Ctrl-x子模式 后，有一个自带的自动补全功能。<br>尽管它不如 intellisense 或 者其他的语言服务器协议（LSP）一样好用，但是也算是一个锦上添花的内置功能了  </p>
<p>下面列出了一些适合入门时学习的自动补全命令：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl-x Ctrl-l</td>
<td>补全一整行</td>
</tr>
<tr>
<td>Ctrl-x Ctrl-n</td>
<td>从当前文件中补全文本</td>
</tr>
<tr>
<td>Ctrl-x Ctrl-i</td>
<td>从引用（include）的文件中补全文本</td>
</tr>
<tr>
<td>Ctrl-x Ctrl-f</td>
<td>补全一个文件名</td>
</tr>
</tbody></table>
<p>当你出发自动补全时，Vim 会显示一个选项弹窗，可以使用  Ctrl-n 和 Ctrl-p 来分别向上和向下浏览选项  </p>
<p>Vim也提供了两条不需要进入Ctrl-x模式就能使用的命令：  </p>
<table>
<thead>
<tr>
<th>快捷键</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl-n</td>
<td>使用下一个匹配的单词进行补全</td>
</tr>
<tr>
<td>Ctrl-p</td>
<td>使用上一个匹配的单词进行补全</td>
</tr>
</tbody></table>
<p>通常 Vim会关注所有缓冲区（buffer）中的文本作为自动补全的文本来源<br>如果你打开了一个缓冲区，其中一行是<code>Chocolate donuts are the best</code></p>
<ul>
<li>当你输入”Choco”然后使用快捷键Ctrl-x Ctrl-l， Vim会进行匹配并输出这一整行的文本  </li>
<li>当你输入”Choco”然后使用快捷键Ctrl-p，Vim会进行匹配并输出”Chocolate”这个单词  </li>
</ul>
<p>Vim 的自动补全是一个相当大的话题，以上只是冰山一角，想要进一步学习的话可以使用<code>:h ins-completion</code>命令进行查看  </p>
<h2 id="执行普通模式下的命令"><a href="#执行普通模式下的命令" class="headerlink" title="执行普通模式下的命令"></a>执行普通模式下的命令</h2><p>在输入模式下， 如果你按下 Ctrl-o，你就会进入到 <strong>insert-normal</strong>（输入-普通）子模式<br>如果你关注一下左下角的模式指示器，通常你将看到<code>-- INSERT --</code> ，但是按下 Ctrl-o 后就会变为<code>-- (insert) --</code><br>在这一模式下，你可以执行一条普通模式的命令，比如你可以做以下这些事  </p>
<p><strong>设置居中以及跳转</strong>  </p>
<table>
<thead>
<tr>
<th>命令</th>
<th>信息</th>
</tr>
</thead>
<tbody><tr>
<td>Ctrl-o zz</td>
<td>居中窗口</td>
</tr>
<tr>
<td>Ctrl-o H/M/L</td>
<td>跳转到窗口的顶部/中部/底部</td>
</tr>
<tr>
<td>Ctrl-o ‘a</td>
<td>跳转到标志’a处</td>
</tr>
</tbody></table>
<p><strong>重复文本</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Ctrl</span>-o <span class="hljs-number">100</span>ihello    输入 <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-number">100</span> 次<br></code></pre></div></td></tr></table></figure>
<p><strong>执行终端命令</strong>  </p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs erlang-repl">Ctrl-o !! curl https://google.com    运行curl命令<br>Ctrl-o !! pwd                        运行pwd命令<br></code></pre></div></td></tr></table></figure>
<p><strong>快速删除</strong></p>
<figure class="highlight mathematica"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-variable">Ctrl</span><span class="hljs-operator">-</span><span class="hljs-variable">o</span> <span class="hljs-variable">dtz</span>    从当前位置开始删除文本，直到遇到字母<span class="hljs-string">&quot;z&quot;</span><br><span class="hljs-variable">Ctrl</span><span class="hljs-operator">-</span><span class="hljs-variable">o</span> <span class="hljs-built_in">D</span>      从当前位置开始删除文本，直到行末<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>寄语：<br>如果你和我一样是从其他文本编辑器转到Vim的，你或许也会觉得一直待在输入模式下很有诱惑力，但是我强烈反对你在没有输入文本时，却仍然待在输入模式下。应该养成当你的双手没有在输入时，就退出到普通模式的好习惯。<br>当你需要进行输入时，先问问自己将要输入的文本是否已经存在。如果存在的话，试着复制或者移动这段文本而不是手动输入它。再问问自己是不是非得进入输入模式，试试能不能尽可能地使用自动补全来进行输入。尽量避免重复输入同一个单词  </p>
</blockquote>
<h1 id="点命令"><a href="#点命令" class="headerlink" title="点命令"></a>点命令</h1><p>在编辑文本时，我们应该尽可能地避免重复的动作<br>本章学习如何使用点命令来重放上一个修改操作。点命令是最简单的命令，然而又是减少重复操作最为有用的命令  </p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>正如这个命令的名字一样，你可以通过按下<code>.</code>键来使用点命令  </p>
<p>比如，如果你想将下面文本中的所有<code>let</code>替换为<code>const</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> one = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-keyword">let</span> two = <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-keyword">let</span> three = <span class="hljs-string">&quot;3&quot;</span>;<br></code></pre></div></td></tr></table></figure>
<ol>
<li>使用<code>/let</code>来进行匹配  </li>
<li>使用<code>cwconst&lt;esc&gt;</code>来将<code>let</code>替换成<code>const</code>  </li>
<li>使用n来找到下一个匹配的位置。</li>
<li>最后，使用点命令(.)来重复之前的操作。持续地使用<code>n .</code> <code>n .</code>直到每一个匹配的词都被替换  </li>
</ol>
<p>在这个例子里面，点命令重复的是<code>cwconst&lt;esc&gt;</code>这一串命令，它能够帮你将需要8次输入的命令简化到只需要敲击一次键盘  </p>
<h2 id="什么才算是修改操作？"><a href="#什么才算是修改操作？" class="headerlink" title="什么才算是修改操作？"></a>什么才算是修改操作？</h2><p>如果你查看点命令的定义的话(<code>:h .</code>),文档中说点命令会重复上一个修改操作，那么什么才算是一个修改操作呢？  </p>
<p>当你使用普通模式下的命令来更新（添加，修改或者删除）当前缓冲区中的内容时，你就是在执行一个修改操作了<br>其中的例外是使用命令行命令进行的修改（以<code>：</code>开头的命令），这些命令不算作修改操作  </p>
<p>在第一个例子中，你看到的<code>cwconst&lt;esc&gt;</code>就是一个修改操作<br>现在假设你有以下这么一个句子：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey"><span class="hljs-built_in">pancake,</span> potatoes, fruit-juice,<br></code></pre></div></td></tr></table></figure>
<p>我们来删除从这行开始的位置到第一个逗号出现的位置。你可以使用<code>df</code>,来完成这个操作,使用<code>.</code>来重复两次直到你将整个句子删除  </p>
<p>让我们再来试试另一个例子：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs autohotkey"><span class="hljs-built_in">pancake,</span> potatoes, fruit-juice,<br></code></pre></div></td></tr></table></figure>
<p>这一次你只需要删除所有的逗号，不包括逗号前面的词。我们可以使用<code>f</code>,来找到第一个逗号，再使用<code>x</code>来删除光标下的字符。然后使用用.来重复两次，很简单对不对？等等！这样做行不通(只会重复删除光标下的一个字符，而不是删除逗号)！为什么会这样呢？  </p>
<p>在Vim里，修改操作是不包括移动操作（motions）的，因为动作不会更新缓冲区的内容。当你运行<code>f,x</code>，你实际上是在执行两个独立的操作：<code>f,</code>命令只移动光标，而<code>x</code>更新缓冲区的内容，只有后者算作修改动作。和之前例子中的<code>df</code>,进行一下对比的话，你会发现<code>df</code>,中的<code>f</code>,告诉删除操作d哪里需要删除，是整个删除命令<code>df</code>,的一部分  </p>
<p>让我们想想办法完成这个任务。在你运行<code>f</code>,并执行<code>x</code>来删除第一个逗号后，使用<code>;</code>来继续匹配<code>f</code>的下一个目标（下一个逗号）。之后再使用<code>.</code>来重复修改操作，删除光标下的字符。重复<code>; .</code> <code>; .</code>直到所有的逗号都被删除。完整的命令即为<code>f,x;.;.。</code>  </p>
<p>再来试试下一个例子：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">pancake</span><br><span class="hljs-attribute">potatoes</span><br><span class="hljs-attribute">fruit-juice</span><br></code></pre></div></td></tr></table></figure>
<p>我们的目标是给每一行的结尾加上逗号。从第一行开始，我们执行命令<code>A,&lt;esc&gt;j</code>来给结尾加上逗号并移动到下一行。现在我们知道了<code>j</code>是不算作修改操作的，只有<code>A,</code>算作修改操作。你可以使用<code>j .</code> <code>j .</code> 来移动并重复修改操作。完整的命令是<code>A,&lt;esc&gt;j</code>  </p>
<p>从你按下输入命令（<code>A</code>）开始到你退出输入模式（）之间的所有输入都算作是一整个修改操作<br>Vim 不仅允许你控制需要添加的文本的内容，还允许你控制在什么位置添加文本<br>你可以在选择在这些位置进行输入：光标位置前（<code>i</code>）,光标位置之后（<code>a</code>）,在下方插入一行（<code>o</code>），在上方插入一行（<code>O</code>），在当前行的末尾(<code>A</code>),或者在当前行的开始位置(<code>I</code>)<br>如果你想复习一下相关内容的话，可以看看输入模式（Insert Mode）这一章节</p>
<h2 id="重复多行修改操作"><a href="#重复多行修改操作" class="headerlink" title="重复多行修改操作"></a>重复多行修改操作</h2><p>假设你有如下的文本：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> one = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-keyword">let</span> two = <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-keyword">let</span> three = <span class="hljs-string">&quot;3&quot;</span>;<br><span class="hljs-keyword">const</span> foo = <span class="hljs-string">&quot;bar&quot;</span>;<br><span class="hljs-keyword">let</span> four = <span class="hljs-string">&quot;4&quot;</span>;<br><span class="hljs-keyword">let</span> five = <span class="hljs-string">&quot;5&quot;</span>;<br><span class="hljs-keyword">let</span> six = <span class="hljs-string">&quot;6&quot;</span>;<br><span class="hljs-keyword">let</span> seven = <span class="hljs-string">&quot;7&quot;</span>;<br><span class="hljs-keyword">let</span> eight = <span class="hljs-string">&quot;8&quot;</span>;<br><span class="hljs-keyword">let</span> nine = <span class="hljs-string">&quot;9&quot;</span>;<br></code></pre></div></td></tr></table></figure>
<p>目标是删除除了含有<code>foo</code>那一行的其他所有行  </p>
<ol>
<li>首先，使用<code>d2j</code>删除前三行  </li>
<li>之后跳过<code>foo</code>这一行<code>j</code>，在其下一行使用点命令<code>.</code>两次来删除剩下的六行。完整的命令是<code>d2jj..</code>  </li>
</ol>
<p>这里的修改操作是<code>d2j</code>，<code>2j</code>不是一个移动操作，而是整个删除命令的一部分  </p>
<p>我们再来看看下一个例子：  </p>
<figure class="highlight ebnf"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ebnf"><span class="hljs-attribute">zlet zzone</span> = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-attribute">zlet zztwo</span> = <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-attribute">zlet zzthree</span> = <span class="hljs-string">&quot;3&quot;</span>;<br><span class="hljs-attribute">let four</span> = <span class="hljs-string">&quot;4&quot;</span>;<br></code></pre></div></td></tr></table></figure>
<p>目标是删除所有的<code>z</code><br>首先，在块可视化模式下使用<code>Ctrl-vjj</code>来选中前三行的第一个<code>z</code>字母。如果你对块可视化模式不熟悉的话也不用担心，我会在下一章节中进行介绍<br>在选中前三行的第一个<code>z</code>后，使用<code>d</code>来删除它们。接着用<code>w</code>移动到下一个<code>z</code>字母上，使用<code>..</code>重复两次之前选中加删除的动作。完整的命令为<code>Ctrl-vjjdw..</code>  </p>
<p>你删除一列上的三个<code>z</code>的操作(<code>Ctrl-vjjd</code>)被看做一整个修改操作  可视化模式中的选择操作可以用来选中多行，作为修改动作的一部分  </p>
<h2 id="在修改中包含移动操作"><a href="#在修改中包含移动操作" class="headerlink" title="在修改中包含移动操作"></a>在修改中包含移动操作</h2><p>让我们来重新回顾一下本章中的第一个例子。这个例子中我们使用了<code>/letcwconst&lt;esc&gt;</code>紧接着<code>n .</code> <code>n .</code>将下面的文本中的’let’都替换成了’const’  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> one = <span class="hljs-string">&quot;1&quot;</span>;<br><span class="hljs-keyword">let</span> two = <span class="hljs-string">&quot;2&quot;</span>;<br><span class="hljs-keyword">let</span> three = <span class="hljs-string">&quot;3&quot;</span>;<br></code></pre></div></td></tr></table></figure>
<p>其实还有更快的方法来完成整个操作。在删除的时候，并不使用<code>w</code>,而是使用<code>gn</code>  </p>
<p><code>gn</code>是向前搜索和上一个搜索的模式（本例中为<code>/let</code>）匹配的位置，并且自动对匹配的文本进行可视化模式下的选取的移动操作。想要对下一个匹配的位置进行替换的话，你不再需要先移动在重复修改操作（<code>n .</code> <code>n .</code>），而是简单地使用<code>. .</code>就能完成。你不需要再进行移动操作了，因为找到下一个匹配的位置并进行选中成为了修改操作的一部分了。完整的命令为<code>/letdgn..</code></p>
<p>当你在编辑文本时，应该时刻关注像<code>gn</code>命令这种能一下子做好几件事的移动操作  </p>
<blockquote>
<p>寄语:<br>点命令的强大之处在于使用仅仅1次键盘敲击代替好几次敲击<br>对于<code>x</code>这种只需一次敲击键盘就能完成的修改操作来说，点命令或许不会带来什么收益。但是如果你的上一个修改操作是像<code>cgnconst&lt;esc&gt;</code>这种复杂命令的话，使用点命令来替代就有非常可观的收益了<br>在进行编辑时，思考一下你正将进行的操作是否是可以重复的<br>举个例子，如果我需要删除接下来的三个单词，是使用<code>d3w</code>更划算，还是<code>dw</code>再使用<code>.</code>两次更划算？之后还会不会再进行删除操作？如果是这样的话，使用<code>dw</code>好几次确实比<code>d3w</code>更加合理，因为<code>dw</code>更加有复用性。在编辑时应该养成“修改操作驱动”的观念  </p>
</blockquote>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><hr>
<p>参考：  </p>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/RecluseXU/Learn-Vim_zh_cn">https://github.com/RecluseXU/Learn-Vim_zh_cn</a></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Vim/">Vim</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/361f44ce/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">javascript-浏览器环境模拟</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/e8b7be43/">
                        <span class="hidden-mobile">Javascript-基础-2</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        粤ICP备2020127796号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44010502001787"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon"/>
            
            <span>粤公网安备 44010502001787号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?758d4ab1e944598b8ead03bb4eb143a5";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
