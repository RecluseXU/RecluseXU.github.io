

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="自娱自乐">
  <meta name="author" content="EvilRecluse">
  <meta name="keywords" content="">
  <title>Javascript-基础-2 - EvilRecluse</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":true,"baidu":"https://hm.baidu.com/hm.js?758d4ab1e944598b8ead03bb4eb143a5","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Chaotic Record</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Javascript-基础-2">
              
            </span>

            
              <div class="mt-3">
  
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      64.9k 字
    </span>
  

  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Javascript-基础-2</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年1月27日 上午
                
              </p>
            
            <div class="markdown-body">
              <h1 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h1><h2 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><code>Javascript</code> 原生提供<code>Object</code>对象（注意起首的<code>O</code>是大写），本章介绍该对象原生的各种方法  </p>
<p><code>Javacript</code> 的所有其他对象都继承自<code>Object</code>对象，即那些对象都是<code>Object</code>的实例  </p>
<p><code>Object</code>对象的原生方法分成两类：<code>Object</code>本身的方法与<code>Object</code>的实例方法  </p>
<p><strong>（1）<code>Object</code>对象本身的方法</strong>  </p>
<p>所谓“本身的方法”就是直接定义在<code>Object</code>对象的方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.print = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>&#123; <span class="hljs-built_in">console</span>.log(o) &#125;;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>print</code>方法就是直接定义在<code>Object</code>对象上  </p>
<p><strong>（2）<code>Object</code>的实例方法</strong>  </p>
<p>所谓实例方法就是定义在<code>Object</code>原型对象<code>Object.prototype</code>上的方法。它可以被<code>Object</code>实例直接使用  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.print = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>obj.print() <span class="hljs-comment">// Object</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Object.prototype</code>定义了一个<code>print</code>方法，然后生成一个<code>Object</code>的实例<code>obj</code>。<code>obj</code>直接继承了<code>Object.prototype</code>的属性和方法，可以直接使用<code>obj.print</code>调用<code>print</code>方法。也就是说，<code>obj</code>对象的<code>print</code>方法实质上就是调用<code>Object.prototype.print</code>方法  </p>
<p>凡是定义在<code>Object.prototype</code>对象上面的属性和方法，将被所有实例对象共享  </p>
<p>以下先介绍<code>Object</code>作为函数的用法，然后再介绍<code>Object</code>对象的原生方法，分成对象自身的方法（又称为“静态方法”）和实例方法两部分  </p>
<h3 id="Object"><a href="#Object" class="headerlink" title="Object()"></a>Object()</h3><p><code>Object</code>本身是一个函数，可以当作工具方法使用，将任意值转为对象。这个方法常用于保证某个值一定是对象  </p>
<p>如果参数为空（或者为<code>undefined</code>和<code>null</code>），<code>Object()</code>返回一个空对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>();<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(<span class="hljs-literal">undefined</span>);<br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(<span class="hljs-literal">null</span>);<br><br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的含义，是将<code>undefined</code>和<code>null</code>转为对象，结果得到了一个空对象<code>obj</code>  </p>
<p><code>instanceof</code>运算符用来验证，一个对象是否为指定的构造函数的实例。<code>obj instanceof Object</code>返回<code>true</code>，就表示<code>obj</code>对象是<code>Object</code>的实例  </p>
<p>如果参数是原始类型的值，<code>Object</code>方法将其转为对应的包装对象的实例  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(<span class="hljs-number">1</span>);<br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(<span class="hljs-literal">true</span>);<br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Boolean</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Object</code>函数的参数是各种原始类型的值，转换成对象就是原始类型值对应的包装对象  </p>
<p>如果<code>Object</code>方法的参数是一个对象，它总是返回该对象，即不用转换  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(arr); <span class="hljs-comment">// 返回原数组</span><br>obj === arr <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">var</span> value = &#123;&#125;;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(value) <span class="hljs-comment">// 返回原对象</span><br>obj === value <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>(fn); <span class="hljs-comment">// 返回原函数</span><br>obj === fn <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>利用这一点，可以写一个判断变量是否为对象的函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isObject</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> value === <span class="hljs-built_in">Object</span>(value);<br>&#125;<br><br>isObject([]) <span class="hljs-comment">// true</span><br>isObject(<span class="hljs-literal">true</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>


<h3 id="Object-构造函数"><a href="#Object-构造函数" class="headerlink" title="Object 构造函数"></a>Object 构造函数</h3><p><code>Object</code>不仅可以当作工具函数使用，还可以当作构造函数使用，即前面可以使用<code>new</code>命令  </p>
<p><code>Object</code>构造函数的首要用途，是直接通过它来生成新对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>注意，通过<code>var obj = new Object()</code>的写法生成新对象，与字面量的写法<code>var obj = &#123;&#125;</code>是等价的。或者说，后者只是前者的一种简便写法  </p>
</blockquote>
<p><code>Object</code>构造函数的用法与工具方法很相似，几乎一模一样  </p>
<p>使用时，可以接受一个参数，如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(o1);<br>o1 === o2 <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(<span class="hljs-number">123</span>);<br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>虽然用法相似，但是<code>Object(value)</code>与<code>new Object(value)</code>两者的语义是不同的，<code>Object(value)</code>表示将<code>value</code>转成一个对象，<code>new Object(value)</code>则表示新生成一个对象，它的值是<code>value</code>。</p>
<h3 id="Object-的静态方法"><a href="#Object-的静态方法" class="headerlink" title="Object 的静态方法"></a>Object 的静态方法</h3><p>所谓“静态方法”，是指部署在<code>Object</code>对象自身的方法  </p>
<h4 id="Object-keys-，Object-getOwnPropertyNames"><a href="#Object-keys-，Object-getOwnPropertyNames" class="headerlink" title="Object.keys()，Object.getOwnPropertyNames()"></a>Object.keys()，Object.getOwnPropertyNames()</h4><p><code>Object.keys</code>方法和<code>Object.getOwnPropertyNames</code>方法都用来遍历对象的属性  </p>
<p><code>Object.keys</code>方法的参数是一个对象，返回一个数组。该数组的成员都是该对象自身的（而不是继承的）所有属性名  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p1: <span class="hljs-number">123</span>,<br>  p2: <span class="hljs-number">456</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.keys(obj) <span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p><code>Object.getOwnPropertyNames</code>方法与<code>Object.keys</code>类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名   </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p1: <span class="hljs-number">123</span>,<br>  p2: <span class="hljs-number">456</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj) <span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>对于一般的对象来说，<code>Object.keys()</code>和<code>Object.getOwnPropertyNames()</code>返回的结果是一样的。只有涉及不可枚举属性时，才会有不一样的结果。<code>Object.keys</code>方法只返回可枚举的属性，<code>Object.getOwnPropertyNames</code>方法还返回不可枚举的属性名  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;World&#x27;</span>];<br><br><span class="hljs-built_in">Object</span>.keys(a) <span class="hljs-comment">// [&quot;0&quot;, &quot;1&quot;]</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(a) <span class="hljs-comment">// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，数组的<code>length</code>属性是不可枚举的属性，所以只出现在<code>Object.getOwnPropertyNames</code>方法的返回结果中  </p>
<p>由于<code> Javascript</code> 没有提供计算对象属性个数的方法，所以可以用这两个方法代替  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p1: <span class="hljs-number">123</span>,<br>  p2: <span class="hljs-number">456</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.keys(obj).length <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj).length <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>一般情况下，几乎总是使用<code>Object.keys</code>方法，遍历对象的属性  </p>
<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p>除了上面提到的两个方法，<code>Object</code>还有不少其他静态方法，将在后文逐一详细介绍  </p>
<p><strong>（1）对象属性模型的相关方法</strong></p>
<ul>
<li><code>Object.getOwnPropertyDescriptor()</code>：获取某个属性的描述对象  </li>
<li><code>Object.defineProperty()</code>：通过描述对象，定义某个属性  </li>
<li><code>Object.defineProperties()</code>：通过描述对象，定义多个属性  </li>
</ul>
<p><strong>（2）控制对象状态的方法</strong></p>
<ul>
<li><code>Object.preventExtensions()</code>：防止对象扩展  </li>
<li><code>Object.isExtensible()</code>：判断对象是否可扩展  </li>
<li><code>Object.seal()</code>：禁止对象配置  </li>
<li><code>Object.isSealed()</code>：判断一个对象是否可配置  </li>
<li><code>Object.freeze()</code>：冻结一个对象  </li>
<li><code>Object.isFrozen()</code>：判断一个对象是否被冻结  </li>
</ul>
<p><strong>（3）原型链相关方法</strong></p>
<ul>
<li><code>Object.create()</code>：该方法可以指定原型对象和属性，返回一个新的对象  </li>
<li><code>Object.getPrototypeOf()</code>：获取对象的<code>Prototype</code>对象  </li>
</ul>
<h3 id="Object-的实例方法"><a href="#Object-的实例方法" class="headerlink" title="Object 的实例方法"></a>Object 的实例方法</h3><p>除了静态方法，还有不少方法定义在<code>Object.prototype</code>对象。它们称为实例方法，所有<code>Object</code>的实例对象都继承了这些方法  </p>
<p><code>Object</code>实例对象的方法，主要有以下六个  </p>
<ul>
<li><code>Object.prototype.valueOf()</code>：返回当前对象对应的值  </li>
<li><code>Object.prototype.toString()</code>：返回当前对象对应的字符串形式  </li>
<li><code>Object.prototype.toLocaleString()</code>：返回当前对象对应的本地字符串形式  </li>
<li><code>Object.prototype.hasOwnProperty()</code>：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性  </li>
<li><code>Object.prototype.isPrototypeOf()</code>：判断当前对象是否为另一个对象的原型  </li>
<li><code>Object.prototype.propertyIsEnumerable()</code>：判断某个属性是否可枚举   </li>
</ul>
<h4 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf()"></a>Object.prototype.valueOf()</h4><p><code>valueOf</code>方法的作用是返回一个对象的“值”，默认情况下返回对象本身  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>obj.valueOf() === obj <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码比较<code>obj.valueOf()</code>与<code>obj</code>本身，两者是一样的  </p>
<p><code>valueOf</code>方法的主要用途是，<code>Javascript</code> 自动类型转换时会默认调用这个方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-number">1</span> + obj <span class="hljs-comment">// &quot;1[object Object]&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码将对象<code>obj</code>与数字<code>1</code>相加，这时 <code>Javascript</code> 就会默认调用<code>valueOf()</code>方法，求出<code>obj</code>的值再与<code>1</code>相加。所以，如果自定义<code>valueOf</code>方法，就可以得到想要的结果  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>obj.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>&#125;;<br><br><span class="hljs-number">1</span> + obj <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码自定义了<code>obj</code>对象的<code>valueOf</code>方法，于是<code>1 + obj</code>就得到了<code>3</code>  </p>
<p>这种方法就相当于用自定义的<code>obj.valueOf</code>，覆盖<code>Object.prototype.valueOf</code>  </p>
<h4 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a>Object.prototype.toString()</h4><p><code>toString</code>方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>o1.toString() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br><span class="hljs-keyword">var</span> o2 = &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>&#125;;<br>o2.toString() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，对于一个对象调用<code>toString</code>方法，会返回字符串<code>[object Object]</code>，该字符串说明对象的类型  </p>
<p>字符串<code>[object Object]</code>本身没有太大的用处，但是通过自定义<code>toString</code>方法，可以让对象在自动类型转换时，得到想要的字符串形式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br>obj.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span>;<br>&#125;;<br><br>obj + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-string">&#x27;world&#x27;</span> <span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，当对象用于字符串加法时，会自动调用<code>toString</code>方法。由于自定义了<code>toString</code>方法，所以返回字符串<code>hello world</code>  </p>
<p>数组、字符串、函数、Date 对象都分别部署了自定义的<code>toString</code>方法，覆盖了<code>Object.prototype.toString</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].toString() <span class="hljs-comment">// &quot;1,2,3&quot;</span><br><br><span class="hljs-string">&#x27;123&#x27;</span>.toString() <span class="hljs-comment">// &quot;123&quot;</span><br><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;<br>&#125;).toString()<br><span class="hljs-comment">// &quot;function () &#123;</span><br><span class="hljs-comment">//   return 123;</span><br><span class="hljs-comment">// &#125;&quot;</span><br><br>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()).toString()<br><span class="hljs-comment">// &quot;Tue May 10 2016 09:11:31 GMT+0800 (CST)&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，数组、字符串、函数、Date 对象调用<code>toString</code>方法，并不会返回<code>[object Object]</code>，因为它们都自定义了<code>toString</code>方法，覆盖原始方法  </p>
<h4 id="toString-的应用：判断数据类型"><a href="#toString-的应用：判断数据类型" class="headerlink" title="toString() 的应用：判断数据类型"></a>toString() 的应用：判断数据类型</h4><p><code>Object.prototype.toString</code>方法返回对象的类型字符串，因此可以用来判断一个值的类型  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.toString() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码调用空对象的<code>toString</code>方法，结果返回一个字符串<code>object Object</code>，其中第二个<code>Object</code>表示该值的构造函数。这是一个十分有用的判断数据类型的方法  </p>
<p>由于实例对象可能会自定义<code>toString</code>方法，覆盖掉<code>Object.prototype.toString</code>方法，所以为了得到类型字符串，最好直接使用<code>Object.prototype.toString</code>方法。通过函数的<code>call</code>方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.toString.call(value)<br></code></pre></div></td></tr></table></figure>
<p>上面代码表示对<code>value</code>这个值调用<code>Object.prototype.toString</code>方法  </p>
<p>不同数据类型的<code>Object.prototype.toString</code>方法返回值如下  </p>
<ul>
<li>数值：返回<code>[object Number]</code>  </li>
<li>字符串：返回<code>[object String]</code>  </li>
<li>布尔值：返回<code>[object Boolean]</code>  </li>
<li>undefined：返回<code>[object Undefined]</code>  </li>
<li>null：返回<code>[object Null]</code>  </li>
<li>数组：返回<code>[object Array]</code> </li>
<li>arguments 对象：返回<code>[object Arguments]</code>  </li>
<li>函数：返回<code>[object Function]</code>  </li>
<li>Error 对象：返回<code>[object Error]</code>  </li>
<li>Date 对象：返回<code>[object Date]</code>  </li>
<li>RegExp 对象：返回<code>[object RegExp]</code>  </li>
<li>其他对象：返回<code>[object Object]</code>  </li>
</ul>
<p>这就是说，<code>Object.prototype.toString</code>可以看出一个值到底是什么类型  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;[object Number]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// &quot;[object String]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>) <span class="hljs-comment">// &quot;[object Boolean]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// &quot;[object Undefined]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>) <span class="hljs-comment">// &quot;[object Null]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">Math</span>) <span class="hljs-comment">// &quot;[object Math]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call(&#123;&#125;) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-built_in">Object</span>.prototype.toString.call([]) <span class="hljs-comment">// &quot;[object Array]&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>利用这个特性，可以写出一个比<code>typeof</code>运算符更准确的类型判断函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> type = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> s = <span class="hljs-built_in">Object</span>.prototype.toString.call(o);<br>  <span class="hljs-keyword">return</span> s.match(<span class="hljs-regexp">/\[object (.*?)\]/</span>)[<span class="hljs-number">1</span>].toLowerCase();<br>&#125;;<br><br>type(&#123;&#125;); <span class="hljs-comment">// &quot;object&quot;</span><br>type([]); <span class="hljs-comment">// &quot;array&quot;</span><br>type(<span class="hljs-number">5</span>); <span class="hljs-comment">// &quot;number&quot;</span><br>type(<span class="hljs-literal">null</span>); <span class="hljs-comment">// &quot;null&quot;</span><br>type(); <span class="hljs-comment">// &quot;undefined&quot;</span><br>type(<span class="hljs-regexp">/abcd/</span>); <span class="hljs-comment">// &quot;regex&quot;</span><br>type(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()); <span class="hljs-comment">// &quot;date&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>在上面这个<code>type</code>函数的基础上，还可以加上专门判断某种类型数据的方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> type = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> s = <span class="hljs-built_in">Object</span>.prototype.toString.call(o);<br>  <span class="hljs-keyword">return</span> s.match(<span class="hljs-regexp">/\[object (.*?)\]/</span>)[<span class="hljs-number">1</span>].toLowerCase();<br>&#125;;<br><br>[<span class="hljs-string">&#x27;Null&#x27;</span>,<br> <span class="hljs-string">&#x27;Undefined&#x27;</span>,<br> <span class="hljs-string">&#x27;Object&#x27;</span>,<br> <span class="hljs-string">&#x27;Array&#x27;</span>,<br> <span class="hljs-string">&#x27;String&#x27;</span>,<br> <span class="hljs-string">&#x27;Number&#x27;</span>,<br> <span class="hljs-string">&#x27;Boolean&#x27;</span>,<br> <span class="hljs-string">&#x27;Function&#x27;</span>,<br> <span class="hljs-string">&#x27;RegExp&#x27;</span><br>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">t</span>) </span>&#123;<br>  type[<span class="hljs-string">&#x27;is&#x27;</span> + t] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> type(o) === t.toLowerCase();<br>  &#125;;<br>&#125;);<br><br>type.isObject(&#123;&#125;) <span class="hljs-comment">// true</span><br>type.isNumber(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// true</span><br>type.isRegExp(<span class="hljs-regexp">/abc/</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>


<h4 id="Object-prototype-toLocaleString"><a href="#Object-prototype-toLocaleString" class="headerlink" title="Object.prototype.toLocaleString()"></a>Object.prototype.toLocaleString()</h4><p><code>Object.prototype.toLocaleString</code>方法与<code>toString</code>的返回结果相同，也是返回一个值的字符串形式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.toString(obj) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br>obj.toLocaleString(obj) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>这个方法的主要作用是留出一个接口，让各种不同的对象实现自己版本的<code>toLocaleString</code>，用来返回针对某些地域的特定的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Henry Norman Bethune&#x27;</span>;<br>  &#125;,<br>  toLocaleString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;白求恩&#x27;</span>;<br>  &#125;<br>&#125;;<br><br>person.toString() <span class="hljs-comment">// Henry Norman Bethune</span><br>person.toLocaleString() <span class="hljs-comment">// 白求恩</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>toString()</code>方法返回对象的一般字符串形式，<code>toLocaleString()</code>方法返回本地的字符串形式  </p>
<p>目前，主要有三个对象自定义了<code>toLocaleString</code>方法  </p>
<ul>
<li>Array.prototype.toLocaleString()</li>
<li>Number.prototype.toLocaleString()</li>
<li>Date.prototype.toLocaleString()</li>
</ul>
<p>举例来说，日期的实例对象的<code>toString</code>和<code>toLocaleString</code>返回值就不一样，而且<code>toLocaleString</code>的返回值跟用户设定的所在地域相关  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>date.toString() <span class="hljs-comment">// &quot;Tue Jan 01 2018 12:01:33 GMT+0800 (CST)&quot;</span><br>date.toLocaleString() <span class="hljs-comment">// &quot;1/01/2018, 12:01:33 PM&quot;</span><br></code></pre></div></td></tr></table></figure>


<h4 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h4><p><code>Object.prototype.hasOwnProperty</code>方法接受一个字符串作为参数，返回一个布尔值，表示该实例对象自身是否具有该属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-number">123</span><br>&#125;;<br><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;p&#x27;</span>) <span class="hljs-comment">// true</span><br>obj.hasOwnProperty(<span class="hljs-string">&#x27;toString&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>自身具有<code>p</code>属性，所以返回<code>true</code>。<code>toString</code>属性是继承的，所以返回<code>false</code>  </p>
<h2 id="属性描述对象"><a href="#属性描述对象" class="headerlink" title="属性描述对象"></a>属性描述对象</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p><code>Javascript</code> 提供了一个内部数据结构，用来描述对象的属性，控制它的行为，比如该属性是否可写、可遍历等等  </p>
<p>这个内部数据结构称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息  </p>
<p>下面是属性描述对象的一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;<br>  value: <span class="hljs-number">123</span>,<br>  writable: <span class="hljs-literal">false</span>,<br>  enumerable: <span class="hljs-literal">true</span>,<br>  configurable: <span class="hljs-literal">false</span>,<br>  get: <span class="hljs-literal">undefined</span>,<br>  set: <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>属性描述对象提供6个元属性。</p>
<ol>
<li><p><code>value</code><br><code>value</code>是该属性的属性值，默认为<code>undefined</code>  </p>
</li>
<li><p><code>writable</code><br><code>writable</code>是一个布尔值，表示属性值（value）是否可改变（即是否可写），默认为<code>true</code>  </p>
</li>
<li><p><code>enumerable</code><br><code>enumerable</code>是一个布尔值，表示该属性是否可遍历，默认为<code>true</code>。如果设为<code>false</code>，会使得某些操作（比如<code>for...in</code>循环、<code>Object.keys()</code>）跳过该属性  </p>
</li>
<li><p><code>configurable</code><br> <code>configurable</code>是一个布尔值，表示可配置性，默认为<code>true</code>。如果设为<code>false</code>，将阻止某些操作改写该属性，比如无法删除该属性，也不得改变该属性的属性描述对象（<code>value</code>属性除外）  </p>
<p>也就是说，<code>configurable</code>属性控制了属性描述对象的可写性  </p>
</li>
<li><p><code>get</code><br> <code>get</code>是一个函数，表示该属性的取值函数（getter），默认为<code>undefined</code>  </p>
</li>
<li><p><code>set</code><br> <code>set</code>是一个函数，表示该属性的存值函数（setter），默认为<code>undefined</code>  </p>
</li>
</ol>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="Object-getOwnPropertyDescriptor"><a href="#Object-getOwnPropertyDescriptor" class="headerlink" title="Object.getOwnPropertyDescriptor()"></a>Object.getOwnPropertyDescriptor()</h4><p><code>Object.getOwnPropertyDescriptor()</code>方法可以获取属性描述对象  </p>
<p>它的第一个参数是目标对象，第二个参数是一个字符串，对应目标对象的某个属性名  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;p&#x27;</span>)<br><span class="hljs-comment">// Object &#123; value: &quot;a&quot;,</span><br><span class="hljs-comment">//   writable: true,</span><br><span class="hljs-comment">//   enumerable: true,</span><br><span class="hljs-comment">//   configurable: true</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Object.getOwnPropertyDescriptor()</code>方法获取<code>obj.p</code>的属性描述对象  </p>
<p>注意，<code>Object.getOwnPropertyDescriptor()</code>方法只能用于对象自身的属性，不能用于继承的属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;toString&#x27;</span>)<br><span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>toString</code>是<code>obj</code>对象继承的属性，<code>Object.getOwnPropertyDescriptor()</code>无法获取  </p>
<h4 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h4><p><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperties(&#123;&#125;, &#123;<br>  p1: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> &#125;,<br>  p2: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">false</span> &#125;<br>&#125;);<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj)<br><span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj.p1</code>是可遍历的，<code>obj.p2</code>是不可遍历的。<code>Object.getOwnPropertyNames</code>会将它们都返回。</p>
<p>这跟<code>Object.keys</code>的行为不同，<code>Object.keys</code>只返回对象自身的可遍历属性的全部属性名  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.keys([]) <span class="hljs-comment">// []</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames([]) <span class="hljs-comment">// [ &#x27;length&#x27; ]</span><br><br><span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">Object</span>.prototype) <span class="hljs-comment">// []</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyNames(<span class="hljs-built_in">Object</span>.prototype)<br><span class="hljs-comment">// [&#x27;hasOwnProperty&#x27;,</span><br><span class="hljs-comment">//  &#x27;valueOf&#x27;,</span><br><span class="hljs-comment">//  &#x27;constructor&#x27;,</span><br><span class="hljs-comment">//  &#x27;toLocaleString&#x27;,</span><br><span class="hljs-comment">//  &#x27;isPrototypeOf&#x27;,</span><br><span class="hljs-comment">//  &#x27;propertyIsEnumerable&#x27;,</span><br><span class="hljs-comment">//  &#x27;toString&#x27;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，数组自身的<code>length</code>属性是不可遍历的，<code>Object.keys</code>不会返回该属性。第二个例子的<code>Object.prototype</code>也是一个对象，所有实例对象都会继承它，它自身的属性都是不可遍历的  </p>
<h4 id="Object-defineProperty-，Object-defineProperties"><a href="#Object-defineProperty-，Object-defineProperties" class="headerlink" title="Object.defineProperty()，Object.defineProperties()"></a>Object.defineProperty()，Object.defineProperties()</h4><p><code>Object.defineProperty()</code>方法允许通过属性描述对象，定义或修改一个属性，然后返回修改后的对象，它的用法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.defineProperty(object, propertyName, attributesObject)<br></code></pre></div></td></tr></table></figure>
<p><code>Object.defineProperty</code>方法接受三个参数，依次如下  </p>
<ul>
<li>object：属性所在的对象  </li>
<li>propertyName：字符串，表示属性名  </li>
<li>attributesObject：属性描述对象  </li>
</ul>
<p>举例来说，定义<code>obj.p</code>可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">123</span>,<br>  writable: <span class="hljs-literal">false</span>,<br>  enumerable: <span class="hljs-literal">true</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><br>obj.p <span class="hljs-comment">// 123</span><br><br>obj.p = <span class="hljs-number">246</span>;<br>obj.p <span class="hljs-comment">// 123</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Object.defineProperty()</code>方法定义了<code>obj.p</code>属性。由于属性描述对象的<code>writable</code>属性为<code>false</code>，所以<code>obj.p</code>属性不可写。注意，这里的<code>Object.defineProperty</code>方法的第一个参数是<code>&#123;&#125;</code>（一个新建的空对象），<code>p</code>属性直接定义在这个空对象上面，然后返回这个对象，这是<code>Object.defineProperty()</code>的常见用法  </p>
<p>如果属性已经存在，<code>Object.defineProperty()</code>方法相当于更新该属性的属性描述对象  </p>
<p>如果一次性定义或修改多个属性，可以使用<code>Object.defineProperties()</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperties(&#123;&#125;, &#123;<br>  p1: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">123</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> &#125;,<br>  p2: &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> &#125;,<br>  p3: &#123; <span class="hljs-attr">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.p1 + <span class="hljs-built_in">this</span>.p2 &#125;,<br>    enumerable:<span class="hljs-literal">true</span>,<br>    configurable:<span class="hljs-literal">true</span><br>  &#125;<br>&#125;);<br><br>obj.p1 <span class="hljs-comment">// 123</span><br>obj.p2 <span class="hljs-comment">// &quot;abc&quot;</span><br>obj.p3 <span class="hljs-comment">// &quot;123abc&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Object.defineProperties()</code>同时定义了<code>obj</code>对象的三个属性。其中，<code>p3</code>属性定义了取值函数<code>get</code>，即每次读取该属性，都会调用这个取值函数。</p>
<p>注意，一旦定义了取值函数<code>get</code>（或存值函数<code>set</code>），就不能将<code>writable</code>属性设为<code>true</code>，或者同时定义<code>value</code>属性，否则会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">123</span>,<br>  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">456</span>; &#125;<br>&#125;);<br><span class="hljs-comment">// TypeError: Invalid property.</span><br><span class="hljs-comment">// A property cannot both have accessors and be writable or have a value</span><br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  writable: <span class="hljs-literal">true</span>,<br>  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">456</span>; &#125;<br>&#125;);<br><span class="hljs-comment">// TypeError: Invalid property descriptor.</span><br><span class="hljs-comment">// Cannot both specify accessors and a value or writable attribute</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，同时定义了<code>get</code>属性和<code>value</code>属性，以及将<code>writable</code>属性设为<code>true</code>，就会报错  </p>
<p><code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>参数里面的属性描述对象，<code>writable</code>、<code>configurable</code>、<code>enumerable</code>这三个属性的默认值都为<code>false</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;&#125;);<br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;foo&#x27;</span>)<br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">//   value: undefined,</span><br><span class="hljs-comment">//   writable: false,</span><br><span class="hljs-comment">//   enumerable: false,</span><br><span class="hljs-comment">//   configurable: false</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，定义<code>obj.foo</code>时用了一个空的属性描述对象，就可以看到各个元属性的默认值  </p>
<h4 id="Object-prototype-propertyIsEnumerable"><a href="#Object-prototype-propertyIsEnumerable" class="headerlink" title="Object.prototype.propertyIsEnumerable()"></a>Object.prototype.propertyIsEnumerable()</h4><p>实例对象的<code>propertyIsEnumerable()</code>方法返回一个布尔值，用来判断某个属性是否可遍历。注意，这个方法只能用于判断对象自身的属性，对于继承的属性一律返回<code>false</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.p = <span class="hljs-number">123</span>;<br><br>obj.propertyIsEnumerable(<span class="hljs-string">&#x27;p&#x27;</span>) <span class="hljs-comment">// true</span><br>obj.propertyIsEnumerable(<span class="hljs-string">&#x27;toString&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj.p</code>是可遍历的，而<code>obj.toString</code>是继承的属性  </p>
<h3 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h3><p>属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性  </p>
<h4 id="value"><a href="#value" class="headerlink" title="value"></a>value</h4><p><code>value</code>属性是目标属性的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.p = <span class="hljs-number">123</span>;<br><br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;p&#x27;</span>).value<br><span class="hljs-comment">// 123</span><br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">246</span> &#125;);<br>obj.p <span class="hljs-comment">// 246</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码是通过<code>value</code>属性，读取或改写<code>obj.p</code>的例子  </p>
<h4 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h4><p><code>writable</code>属性是一个布尔值，决定了目标属性的值（value）是否可以被改变  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<br>  value: <span class="hljs-number">37</span>,<br>  writable: <span class="hljs-literal">false</span><br>&#125;);<br><br>obj.a <span class="hljs-comment">// 37</span><br>obj.a = <span class="hljs-number">25</span>;<br>obj.a <span class="hljs-comment">// 37</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj.a</code>的<code>writable</code>属性是<code>false</code>。然后，改变<code>obj.a</code>的值，不会有任何效果  </p>
<p>注意，正常模式下，对<code>writable</code>为<code>false</code>的属性赋值不会报错，只会默默失败  </p>
<p>但是，严格模式下会报错，即使对<code>a</code>属性重新赋予一个同样的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<br>  value: <span class="hljs-number">37</span>,<br>  writable: <span class="hljs-literal">false</span><br>&#125;);<br><br>obj.a = <span class="hljs-number">37</span>;<br><span class="hljs-comment">// Uncaught TypeError: Cannot assign to read only property &#x27;a&#x27; of object</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码是严格模式，对<code>obj.a</code>任何赋值行为都会报错。</p>
<p>如果原型对象的某个属性的<code>writable</code>为<code>false</code>，那么子对象将无法自定义这个属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> proto = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;<br>  value: <span class="hljs-string">&#x27;a&#x27;</span>,<br>  writable: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(proto);<br><br>obj.foo = <span class="hljs-string">&#x27;b&#x27;</span>;<br>obj.foo <span class="hljs-comment">// &#x27;a&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>proto</code>是原型对象，它的<code>foo</code>属性不可写。<code>obj</code>对象继承<code>proto</code>，也不可以再自定义这个属性了  </p>
<p>如果是严格模式，这样做还会抛出一个错误  </p>
<p>但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> proto = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;<br>  value: <span class="hljs-string">&#x27;a&#x27;</span>,<br>  writable: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(proto);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;<br>  value: <span class="hljs-string">&#x27;b&#x27;</span><br>&#125;);<br><br>obj.foo <span class="hljs-comment">// &quot;b&quot;</span><br></code></pre></div></td></tr></table></figure>


<h4 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h4><p><code>enumerable</code>（可遍历性）返回一个布尔值，表示目标属性是否可遍历  </p>
<p>JavaScript 的早期版本，<code>for...in</code>循环是基于<code>in</code>运算符的。我们知道，<code>in</code>运算符不管某个属性是对象自身的还是继承的，都会返回<code>true</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> obj <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>toString</code>不是<code>obj</code>对象自身的属性，但是<code>in</code>运算符也返回<code>true</code>，这导致了<code>toString</code>属性也会被<code>for...in</code>循环遍历  </p>
<p>这显然不太合理，后来就引入了“可遍历性”这个概念。只有可遍历的属性，才会被<code>for...in</code>循环遍历，同时还规定<code>toString</code>这一类实例对象继承的原生属性，都是不可遍历的，这样就保证了<code>for...in</code>循环的可用性  </p>
<p>具体来说，如果一个属性的<code>enumerable</code>为<code>false</code>，下面三个操作不会取到该属性  </p>
<ul>
<li><code>for..in</code>循环  </li>
<li><code>Object.keys</code>方法  </li>
<li><code>JSON.stringify</code>方法  </li>
</ul>
<p>因此，<code>enumerable</code>可以用来设置“秘密”属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;x&#x27;</span>, &#123;<br>  value: <span class="hljs-number">123</span>,<br>  enumerable: <span class="hljs-literal">false</span><br>&#125;);<br><br>obj.x <span class="hljs-comment">// 123</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-built_in">console</span>.log(key);<br>&#125;<br><span class="hljs-comment">// undefined</span><br><br><span class="hljs-built_in">Object</span>.keys(obj)  <span class="hljs-comment">// []</span><br><span class="hljs-built_in">JSON</span>.stringify(obj) <span class="hljs-comment">// &quot;&#123;&#125;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj.x</code>属性的<code>enumerable</code>为<code>false</code>，所以一般的遍历操作都无法获取该属性，使得它有点像“秘密”属性，但不是真正的私有属性，还是可以直接获取它的值  </p>
<p>注意，<code>for...in</code>循环包括继承的属性，<code>Object.keys</code>方法不包括继承的属性。如果需要获取对象自身的所有属性，不管是否可遍历，可以使用<code>Object.getOwnPropertyNames</code>方法  </p>
<p>另外，<code>JSON.stringify</code>方法会排除<code>enumerable</code>为<code>false</code>的属性，有时可以利用这一点。如果对象的 JSON 格式输出要排除某些属性，就可以把这些属性的<code>enumerable</code>设为<code>false</code>  </p>
<h4 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h4><p><code>configurable</code>(可配置性）返回一个布尔值，决定了是否可以修改属性描述对象  </p>
<p><code>configurable</code>为<code>false</code>时，<code>value</code>、<code>writable</code>、<code>enumerable</code>和<code>configurable</code>都不能被修改了  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">1</span>,<br>  writable: <span class="hljs-literal">false</span>,<br>  enumerable: <span class="hljs-literal">false</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">2</span>&#125;)<br><span class="hljs-comment">// TypeError: Cannot redefine property: p</span><br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-attr">writable</span>: <span class="hljs-literal">true</span>&#125;)<br><span class="hljs-comment">// TypeError: Cannot redefine property: p</span><br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>&#125;)<br><span class="hljs-comment">// TypeError: Cannot redefine property: p</span><br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>&#125;)<br><span class="hljs-comment">// TypeError: Cannot redefine property: p</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj.p</code>的<code>configurable</code>为<code>false</code>。然后，改动<code>value</code>、<code>writable</code>、<code>enumerable</code>、<code>configurable</code>，结果都报错  </p>
<p>注意，<code>writable</code>只有在<code>false</code>改为<code>true</code>会报错，<code>true</code>改为<code>false</code>是允许的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  writable: <span class="hljs-literal">true</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>&#125;)<br><span class="hljs-comment">// 修改成功</span><br></code></pre></div></td></tr></table></figure>
<p>至于<code>value</code>，只要<code>writable</code>和<code>configurable</code>有一个为<code>true</code>，就允许改动  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">1</span>,<br>  writable: <span class="hljs-literal">true</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><br><span class="hljs-built_in">Object</span>.defineProperty(o1, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">2</span>&#125;)<br><span class="hljs-comment">// 修改成功</span><br><br><span class="hljs-keyword">var</span> o2 = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">1</span>,<br>  writable: <span class="hljs-literal">false</span>,<br>  configurable: <span class="hljs-literal">true</span><br>&#125;);<br><br><span class="hljs-built_in">Object</span>.defineProperty(o2, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<span class="hljs-attr">value</span>: <span class="hljs-number">2</span>&#125;)<br><span class="hljs-comment">// 修改成功</span><br></code></pre></div></td></tr></table></figure>
<p>另外，<code>writable</code>为<code>false</code>时，直接目标属性赋值，不报错，但不会成功  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">1</span>,<br>  writable: <span class="hljs-literal">false</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><br>obj.p = <span class="hljs-number">2</span>;<br>obj.p <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj.p</code>的<code>writable</code>为<code>false</code>，对<code>obj.p</code>直接赋值不会生效。如果是严格模式，还会报错  </p>
<p>可配置性决定了目标属性是否可以被删除（delete）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperties(&#123;&#125;, &#123;<br>  p1: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span> &#125;,<br>  p2: &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">configurable</span>: <span class="hljs-literal">false</span> &#125;<br>&#125;);<br><br><span class="hljs-keyword">delete</span> obj.p1 <span class="hljs-comment">// true</span><br><span class="hljs-keyword">delete</span> obj.p2 <span class="hljs-comment">// false</span><br><br>obj.p1 <span class="hljs-comment">// undefined</span><br>obj.p2 <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj.p1</code>的<code>configurable</code>是<code>true</code>，所以可以被删除，<code>obj.p2</code>就无法删除  </p>
<h3 id="存取器"><a href="#存取器" class="headerlink" title="存取器"></a>存取器</h3><p>除了直接定义以外，属性还可以用存取器（accessor）定义  </p>
<p>其中，存值函数称为<code>setter</code>，使用属性描述对象的<code>set</code>属性；取值函数称为<code>getter</code>，使用属性描述对象的<code>get</code>属性。</p>
<p>一旦对目标属性定义了存取器，那么存取的时候，都将执行对应的函数。利用这个功能，可以实现许多高级特性，比如定制属性的读取和赋值行为  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;getter&#x27;</span>;<br>  &#125;,<br>  set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setter: &#x27;</span> + value);<br>  &#125;<br>&#125;);<br><br>obj.p <span class="hljs-comment">// &quot;getter&quot;</span><br>obj.p = <span class="hljs-number">123</span> <span class="hljs-comment">// &quot;setter: 123&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj.p</code>定义了<code>get</code>和<code>set</code>属性。<code>obj.p</code>取值时，就会调用<code>get</code>；赋值时，就会调用<code>set</code>  </p>
<p><code>Javascript</code> 还提供了存取器的另一种写法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法二</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">p</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;getter&#x27;</span>;<br>  &#125;,<br>  <span class="hljs-keyword">set</span> <span class="hljs-title">p</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setter: &#x27;</span> + value);<br>  &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>上面两种写法，虽然属性<code>p</code>的读取和赋值行为是一样的，但是有一些细微的区别  </p>
<ul>
<li><p>第一种写法，属性<code>p</code>的<code>configurable</code>和<code>enumerable</code>都为<code>false</code>，从而导致属性<code>p</code>是不可遍历的  </p>
</li>
<li><p>第二种写法，属性<code>p</code>的<code>configurable</code>和<code>enumerable</code>都为<code>true</code>，因此属性<code>p</code>是可遍历的  </p>
</li>
</ul>
<p>实际开发中，写法二更常用  </p>
<p>注意，取值函数<code>get</code>不能接受参数，存值函数<code>set</code>只能接受一个参数（即属性的值）  </p>
<p>存取器往往用于，属性的值依赖对象内部数据的场合  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj =&#123;<br>  $n : <span class="hljs-number">5</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">next</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$n++ &#125;,<br>  <span class="hljs-keyword">set</span> <span class="hljs-title">next</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-built_in">this</span>.$n) <span class="hljs-built_in">this</span>.$n = n;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;新的值必须大于当前值&#x27;</span>);<br>  &#125;<br>&#125;;<br><br>obj.next <span class="hljs-comment">// 5</span><br><br>obj.next = <span class="hljs-number">10</span>;<br>obj.next <span class="hljs-comment">// 10</span><br><br>obj.next = <span class="hljs-number">5</span>;<br><span class="hljs-comment">// Uncaught Error: 新的值必须大于当前值</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>next</code>属性的存值函数和取值函数，都依赖于内部属性<code>$n</code>  </p>
<h3 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h3><p>有时，我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> extend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> <span class="hljs-keyword">from</span>) &#123;<br>    to[property] = <span class="hljs-keyword">from</span>[property];<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> to;<br>&#125;<br><br>extend(&#123;&#125;, &#123;<br>  a: <span class="hljs-number">1</span><br>&#125;)<br><span class="hljs-comment">// &#123;a: 1&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">extend(&#123;&#125;, &#123;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">a</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &#125;<br>&#125;)<br><span class="hljs-comment">// &#123;a: 1&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>为了解决这个问题，我们可以通过<code>Object.defineProperty</code>方法来拷贝属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> extend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> property <span class="hljs-keyword">in</span> <span class="hljs-keyword">from</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">from</span>.hasOwnProperty(property)) <span class="hljs-keyword">continue</span>;<br>    <span class="hljs-built_in">Object</span>.defineProperty(<br>      to,<br>      property,<br>      <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(<span class="hljs-keyword">from</span>, property)<br>    );<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> to;<br>&#125;<br><br>extend(&#123;&#125;, &#123; <span class="hljs-keyword">get</span> <span class="hljs-title">a</span>()&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &#125; &#125;)<br><span class="hljs-comment">// &#123; get a()&#123; return 1 &#125; &#125;)</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>hasOwnProperty</code>那一行用来过滤掉继承的属性，否则可能会报错，因为<code>Object.getOwnPropertyDescriptor</code>读不到继承属性的属性描述对象  </p>
<h3 id="控制对象状态"><a href="#控制对象状态" class="headerlink" title="控制对象状态"></a>控制对象状态</h3><p>有时需要冻结对象的读写状态，防止对象被改变  </p>
<p><code>Javascript</code> 提供了三种冻结方法，最弱的一种是<code>Object.preventExtensions</code>，其次是<code>Object.seal</code>，最强的是<code>Object.freeze</code>  </p>
<h4 id="Object-preventExtensions"><a href="#Object-preventExtensions" class="headerlink" title="Object.preventExtensions()"></a>Object.preventExtensions()</h4><p><code>Object.preventExtensions</code>方法可以使得一个对象无法再添加新的属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.preventExtensions(obj);<br><br><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;);<br><span class="hljs-comment">// TypeError: Cannot define property:p, object is not extensible.</span><br><br>obj.p = <span class="hljs-number">1</span>;<br>obj.p <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj</code>对象经过<code>Object.preventExtensions</code>以后，就无法添加新属性了  </p>
<h4 id="Object-isExtensible"><a href="#Object-isExtensible" class="headerlink" title="Object.isExtensible()"></a>Object.isExtensible()</h4><p><code>Object.isExtensible</code>方法用于检查一个对象是否使用了<code>Object.preventExtensions</code>方法。也就是说，检查是否可以为一个对象添加属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br><span class="hljs-built_in">Object</span>.isExtensible(obj) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.preventExtensions(obj);<br><span class="hljs-built_in">Object</span>.isExtensible(obj) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对<code>obj</code>对象使用<code>Object.preventExtensions</code>方法以后，再使用<code>Object.isExtensible</code>方法，返回<code>false</code>，表示已经不能添加新属性了  </p>
<h4 id="Object-seal"><a href="#Object-seal" class="headerlink" title="Object.seal()"></a>Object.seal()</h4><p><code>Object.seal</code>方法使得一个对象既无法添加新属性，也无法删除旧属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;;<br><span class="hljs-built_in">Object</span>.seal(obj);<br><br><span class="hljs-keyword">delete</span> obj.p;<br>obj.p <span class="hljs-comment">// &quot;hello&quot;</span><br><br>obj.x = <span class="hljs-string">&#x27;world&#x27;</span>;<br>obj.x <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj</code>对象执行<code>Object.seal</code>方法以后，就无法添加新属性和删除旧属性了  </p>
<p><code>Object.seal</code>实质是把属性描述对象的<code>configurable</code>属性设为<code>false</code>，因此属性描述对象不再能改变了  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-string">&#x27;a&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// seal方法之前</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;p&#x27;</span>)<br><span class="hljs-comment">// Object &#123;</span><br><span class="hljs-comment">//   value: &quot;a&quot;,</span><br><span class="hljs-comment">//   writable: true,</span><br><span class="hljs-comment">//   enumerable: true,</span><br><span class="hljs-comment">//   configurable: true</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-built_in">Object</span>.seal(obj);<br><br><span class="hljs-comment">// seal方法之后</span><br><span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, <span class="hljs-string">&#x27;p&#x27;</span>)<br><span class="hljs-comment">// Object &#123;</span><br><span class="hljs-comment">//   value: &quot;a&quot;,</span><br><span class="hljs-comment">//   writable: true,</span><br><span class="hljs-comment">//   enumerable: true,</span><br><span class="hljs-comment">//   configurable: false</span><br><span class="hljs-comment">// &#125;</span><br><br><span class="hljs-built_in">Object</span>.defineProperty(o, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  enumerable: <span class="hljs-literal">false</span><br>&#125;)<br><span class="hljs-comment">// TypeError: Cannot redefine property: p</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，使用<code>Object.seal</code>方法之后，属性描述对象的<code>configurable</code>属性就变成了<code>false</code>，然后改变<code>enumerable</code>属性就会报错  </p>
<p><code>Object.seal</code>只是禁止新增或删除属性，并不影响修改某个属性的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><span class="hljs-built_in">Object</span>.seal(obj);<br>obj.p = <span class="hljs-string">&#x27;b&#x27;</span>;<br>obj.p <span class="hljs-comment">// &#x27;b&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Object.seal</code>方法对<code>p</code>属性的<code>value</code>无效，是因为此时<code>p</code>属性的可写性由<code>writable</code>决定  </p>
<h4 id="Object-isSealed"><a href="#Object-isSealed" class="headerlink" title="Object.isSealed()"></a>Object.isSealed()</h4><p><code>Object.isSealed</code>方法用于检查一个对象是否使用了<code>Object.seal</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><br><span class="hljs-built_in">Object</span>.seal(obj);<br><span class="hljs-built_in">Object</span>.isSealed(obj) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>这时，<code>Object.isExtensible</code>方法也返回<code>false</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><br><span class="hljs-built_in">Object</span>.seal(obj);<br><span class="hljs-built_in">Object</span>.isExtensible(obj) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>


<h4 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze()"></a>Object.freeze()</h4><p><code>Object.freeze</code>方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.freeze(obj);<br><br>obj.p = <span class="hljs-string">&#x27;world&#x27;</span>;<br>obj.p <span class="hljs-comment">// &quot;hello&quot;</span><br><br>obj.t = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>obj.t <span class="hljs-comment">// undefined</span><br><br><span class="hljs-keyword">delete</span> obj.p <span class="hljs-comment">// false</span><br>obj.p <span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对<code>obj</code>对象进行<code>Object.freeze()</code>以后，修改属性、新增属性、删除属性都无效了。这些操作并不报错，只是默默地失败。如果在严格模式下，则会报错  </p>
<h4 id="Object-isFrozen"><a href="#Object-isFrozen" class="headerlink" title="Object.isFrozen()"></a>Object.isFrozen()</h4><p><code>Object.isFrozen</code>方法用于检查一个对象是否使用了<code>Object.freeze</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.freeze(obj);<br><span class="hljs-built_in">Object</span>.isFrozen(obj) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>使用<code>Object.freeze</code>方法以后，<code>Object.isSealed</code>将会返回<code>true</code>，<code>Object.isExtensible</code>返回<code>false</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.freeze(obj);<br><br><span class="hljs-built_in">Object</span>.isSealed(obj) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.isExtensible(obj) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p><code>Object.isFrozen</code>的一个用途是，确认某个对象没有被冻结后，再对它的属性赋值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-string">&#x27;hello&#x27;</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.freeze(obj);<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">Object</span>.isFrozen(obj)) &#123;<br>  obj.p = <span class="hljs-string">&#x27;world&#x27;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，确认<code>obj</code>没有被冻结后，再对它的属性赋值，就不会报错了  </p>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>上面的三个方法锁定对象的可写性有一个漏洞：可以通过改变原型对象，来为对象增加属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.preventExtensions(obj);<br><br><span class="hljs-keyword">var</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(obj);<br>proto.t = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>obj.t<br><span class="hljs-comment">// hello</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>本身不能新增属性，但是可以在它的原型对象上新增属性，就依然能够在<code>obj</code>上读到  </p>
<p>一种解决方案是，把<code>obj</code>的原型也冻结住  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-built_in">Object</span>.preventExtensions(obj);<br><br><span class="hljs-keyword">var</span> proto = <span class="hljs-built_in">Object</span>.getPrototypeOf(obj);<br><span class="hljs-built_in">Object</span>.preventExtensions(proto);<br><br>proto.t = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>obj.t <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  foo: <span class="hljs-number">1</span>,<br>  bar: [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>]<br>&#125;;<br><span class="hljs-built_in">Object</span>.freeze(obj);<br><br>obj.bar.push(<span class="hljs-string">&#x27;c&#x27;</span>);<br>obj.bar <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj.bar</code>属性指向一个数组，<code>obj</code>对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的  </p>
<h1 id="Array-对象"><a href="#Array-对象" class="headerlink" title="Array 对象"></a>Array 对象</h1><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p><code>Array</code>是<code>Javascript</code>的原生对象，同时也是一个构造函数，可以用它生成新的数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>);<br>arr.length <span class="hljs-comment">// 2</span><br>arr <span class="hljs-comment">// [ empty x 2 ]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Array()</code>构造函数的参数<code>2</code>，表示生成一个两个成员的数组，每个位置都是空值  </p>
<p>如果没有使用<code>new</code>关键字，运行结果也是一样的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>);<br></code></pre></div></td></tr></table></figure>
<p>考虑到语义性，以及与其他构造函数用户保持一致，建议总是加上<code>new</code>  </p>
<p><code>Array()</code>构造函数有一个很大的缺陷，不同的参数会导致行为不一致  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 无参数时，返回一个空数组</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>() <span class="hljs-comment">// []</span><br><br><span class="hljs-comment">// 单个正整数参数，表示返回的新数组的长度</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// [ empty ]</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// [ empty x 2 ]</span><br><br><span class="hljs-comment">// 非正整数的数值作为参数，会报错</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3.2</span>) <span class="hljs-comment">// RangeError: Invalid array length</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(-<span class="hljs-number">3</span>) <span class="hljs-comment">// RangeError: Invalid array length</span><br><br><span class="hljs-comment">// 单个非数值（比如字符串、布尔值、对象等）作为参数，</span><br><span class="hljs-comment">// 则该参数是返回的新数组的成员</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) <span class="hljs-comment">// [&#x27;abc&#x27;]</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>([<span class="hljs-number">1</span>]) <span class="hljs-comment">// [Array[1]]</span><br><br><span class="hljs-comment">// 多参数时，所有参数都是返回的新数组的成员</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [1, 2]</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></div></td></tr></table></figure>
<p>可以看到，<code>Array()</code>作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br><span class="hljs-comment">// good</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br></code></pre></div></td></tr></table></figure>
<p>注意，如果参数是一个正整数，返回数组的成员都是空位。虽然读取的时候返回<code>undefined</code>，但实际上该位置没有任何值。虽然这时可以读取到<code>length</code>属性，但是取不到键名  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> b = [<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>];<br><br>a.length <span class="hljs-comment">// 3</span><br>b.length <span class="hljs-comment">// 3</span><br><br>a[<span class="hljs-number">0</span>] <span class="hljs-comment">// undefined</span><br>b[<span class="hljs-number">0</span>] <span class="hljs-comment">// undefined</span><br><br><span class="hljs-number">0</span> <span class="hljs-keyword">in</span> a <span class="hljs-comment">// false</span><br><span class="hljs-number">0</span> <span class="hljs-keyword">in</span> b <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>a</code>是<code>Array()</code>生成的一个长度为3的空数组，<code>b</code>是一个三个成员都是<code>undefined</code>的数组，这两个数组是不一样的。读取键值的时候，<code>a</code>和<code>b</code>都返回<code>undefined</code>，但是<code>a</code>的键名（成员的序号）都是空的，<code>b</code>的键名是有值的  </p>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p><code>Array.isArray</code>方法返回一个布尔值，表示参数是否为数组。它可以弥补<code>typeof</code>运算符的不足  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">typeof</span> arr <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-built_in">Array</span>.isArray(arr) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>typeof</code>运算符只能显示数组的类型是<code>Object</code>，而<code>Array.isArray</code>方法可以识别数组  </p>
<h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><h3 id="valueOf-，toString"><a href="#valueOf-，toString" class="headerlink" title="valueOf()，toString()"></a>valueOf()，toString()</h3><p><code>valueOf</code>方法是一个所有对象都拥有的方法，表示对该对象求值  </p>
<p>不同对象的<code>valueOf</code>方法不尽一致，数组的<code>valueOf</code>方法返回数组本身  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.valueOf() <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></div></td></tr></table></figure>
<p><code>toString</code>方法也是对象的通用方法，数组的<code>toString</code>方法返回数组的字符串形式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.toString() <span class="hljs-comment">// &quot;1,2,3&quot;</span><br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]];<br>arr.toString() <span class="hljs-comment">// &quot;1,2,3,4,5,6&quot;</span><br></code></pre></div></td></tr></table></figure>


<h3 id="push-，pop"><a href="#push-，pop" class="headerlink" title="push()，pop()"></a>push()，pop()</h3><p><code>push</code>方法用于在数组的末端添加一个或多个元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<br><br>arr.push(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br>arr.push(<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">// 2</span><br>arr.push(<span class="hljs-literal">true</span>, &#123;&#125;) <span class="hljs-comment">// 4</span><br>arr <span class="hljs-comment">// [1, &#x27;a&#x27;, true, &#123;&#125;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码使用<code>push</code>方法，往数组中添加了四个成员  </p>
<p><code>pop</code>方法用于删除数组的最后一个元素，并返回该元素。注意，该方法会改变原数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>arr.pop() <span class="hljs-comment">// &#x27;c&#x27;</span><br>arr <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span><br></code></pre></div></td></tr></table></figure>
<p>对空数组使用<code>pop</code>方法，不会报错，而是返回<code>undefined</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[].pop() <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p><code>push</code>和<code>pop</code>结合使用，就构成了“后进先出”的栈结构（stack）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<br>arr.push(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>arr.push(<span class="hljs-number">3</span>);<br>arr.pop();<br>arr <span class="hljs-comment">// [1, 2]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>3</code>是最后进入数组的，但是最早离开数组  </p>
<h3 id="shift-，unshift"><a href="#shift-，unshift" class="headerlink" title="shift()，unshift()"></a>shift()，unshift()</h3><p><code>shift()</code>方法用于删除数组的第一个元素，并返回该元素。注意，该方法会改变原数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>a.shift() <span class="hljs-comment">// &#x27;a&#x27;</span><br>a <span class="hljs-comment">// [&#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，使用<code>shift()</code>方法以后，原数组就变了  </p>
<p><code>shift()</code>方法可以遍历并清空一个数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> list = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> item;<br><br><span class="hljs-keyword">while</span> (item = list.shift()) &#123;<br>  <span class="hljs-built_in">console</span>.log(item);<br>&#125;<br><br>list <span class="hljs-comment">// []</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码通过<code>list.shift()</code>方法每次取出一个元素，从而遍历数组  </p>
<p>它的前提是数组元素不能是<code>0</code>或任何布尔值等于<code>false</code>的元素，因此这样的遍历不是很可靠  </p>
<p><code>push()</code>和<code>shift()</code>结合使用，就构成了“先进先出”的队列结构（queue）  </p>
<p><code>unshift()</code>方法用于在数组的第一个位置添加元素，并返回添加新元素后的数组长度。注意，该方法会改变原数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>a.unshift(<span class="hljs-string">&#x27;x&#x27;</span>); <span class="hljs-comment">// 4</span><br>a <span class="hljs-comment">// [&#x27;x&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></div></td></tr></table></figure>
<p><code>unshift()</code>方法可以接受多个参数，这些参数都会添加到目标数组头部  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [ <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span> ];<br>arr.unshift(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// 4</span><br>arr <span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span><br></code></pre></div></td></tr></table></figure>


<h3 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h3><p><code>join()</code>方法以指定参数作为分隔符，将所有数组成员连接为一个字符串返回。如果不提供参数，默认用逗号分隔  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><br>a.join(<span class="hljs-string">&#x27; &#x27;</span>) <span class="hljs-comment">// &#x27;1 2 3 4&#x27;</span><br>a.join(<span class="hljs-string">&#x27; | &#x27;</span>) <span class="hljs-comment">// &quot;1 | 2 | 3 | 4&quot;</span><br>a.join() <span class="hljs-comment">// &quot;1,2,3,4&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果数组成员是<code>undefined</code>或<code>null</code>或空位，会被转成空字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>].join(<span class="hljs-string">&#x27;#&#x27;</span>)<br><span class="hljs-comment">// &#x27;#&#x27;</span><br><br>[<span class="hljs-string">&#x27;a&#x27;</span>,, <span class="hljs-string">&#x27;b&#x27;</span>].join(<span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-comment">// &#x27;a--b&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>通过<code>call</code>方法，这个方法也可以用于字符串或类似数组的对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.join.call(<span class="hljs-string">&#x27;hello&#x27;</span>, <span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-comment">// &quot;h-e-l-l-o&quot;</span><br><br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-built_in">Array</span>.prototype.join.call(obj, <span class="hljs-string">&#x27;-&#x27;</span>)<br><span class="hljs-comment">// &#x27;a-b&#x27;</span><br></code></pre></div></td></tr></table></figure>


<h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p><code>concat</code>方法用于多个数组的合并  </p>
<p>它将新数组的成员，添加到原数组成员的后部，然后返回一个新数组，原数组不变   </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;hello&#x27;</span>].concat([<span class="hljs-string">&#x27;world&#x27;</span>])<br><span class="hljs-comment">// [&quot;hello&quot;, &quot;world&quot;]</span><br><br>[<span class="hljs-string">&#x27;hello&#x27;</span>].concat([<span class="hljs-string">&#x27;world&#x27;</span>], [<span class="hljs-string">&#x27;!&#x27;</span>])<br><span class="hljs-comment">// [&quot;hello&quot;, &quot;world&quot;, &quot;!&quot;]</span><br><br>[].concat(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;)<br><span class="hljs-comment">// [&#123; a: 1 &#125;, &#123; b: 2 &#125;]</span><br><br>[<span class="hljs-number">2</span>].concat(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;)<br><span class="hljs-comment">// [2, &#123;a: 1&#125;]</span><br></code></pre></div></td></tr></table></figure>
<p>除了数组作为参数，<code>concat</code>也接受其他类型的值作为参数，添加到目标数组尾部  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].concat(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)<br><span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br></code></pre></div></td></tr></table></figure>
<p>如果数组成员包括对象，<code>concat</code>方法返回当前数组的一个浅拷贝。所谓“浅拷贝”，指的是新数组拷贝的是对象的引用  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">var</span> oldArray = [obj];<br><br><span class="hljs-keyword">var</span> newArray = oldArray.concat();<br><br>obj.a = <span class="hljs-number">2</span>;<br>newArray[<span class="hljs-number">0</span>].a <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，原数组包含一个对象，<code>concat</code>方法生成的新数组包含这个对象的引用。所以，改变原对象以后，新数组跟着改变  </p>
<h3 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h3><p><code>reverse</code>方法用于颠倒排列数组元素，返回改变后的数组。注意，该方法将改变原数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>a.reverse() <span class="hljs-comment">// [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span><br>a <span class="hljs-comment">// [&quot;c&quot;, &quot;b&quot;, &quot;a&quot;]</span><br></code></pre></div></td></tr></table></figure>


<h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p><code>slice()</code>方法用于提取目标数组的一部分，返回一个新数组，原数组不变  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">arr.slice(start, end);<br></code></pre></div></td></tr></table></figure>
<p>它的第一个参数为起始位置（从0开始，会包括在返回的新数组之中），第二个参数为终止位置（但该位置的元素本身不包括在内）。如果省略第二个参数，则一直返回到原数组的最后一个成员  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>a.slice(<span class="hljs-number">0</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br>a.slice(<span class="hljs-number">1</span>) <span class="hljs-comment">// [&quot;b&quot;, &quot;c&quot;]</span><br>a.slice(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;b&quot;]</span><br>a.slice(<span class="hljs-number">2</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// [&quot;c&quot;]</span><br>a.slice() <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，最后一个例子<code>slice()</code>没有参数，实际上等于返回一个原数组的拷贝  </p>
<p>如果<code>slice()</code>方法的参数是负数，则表示倒数计算的位置  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>a.slice(-<span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;b&quot;, &quot;c&quot;]</span><br>a.slice(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment">// [&quot;b&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>-2</code>表示倒数计算的第二个位置，<code>-1</code>表示倒数计算的第一个位置  </p>
<p>如果第一个参数大于等于数组长度，或者第二个参数小于第一个参数，则返回空数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br>a.slice(<span class="hljs-number">4</span>) <span class="hljs-comment">// []</span><br>a.slice(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// []</span><br></code></pre></div></td></tr></table></figure>
<p><code>slice()</code>方法的一个重要应用，是将类似数组的对象转为真正的数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.slice.call(&#123; <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">2</span> &#125;)<br><span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span><br><br><span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&quot;div&quot;</span>));<br><span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);<br></code></pre></div></td></tr></table></figure>
<p>上面代码的参数都不是数组，但是通过<code>call</code>方法，在它们上面调用<code>slice()</code>方法，就可以把它们转为真正的数组  </p>
<h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p><code>splice()</code>方法用于删除原数组的一部分成员，并可以在删除的位置添加新的数组成员，返回值是被删除的元素。注意，该方法会改变原数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">arr.splice(start, count, addElement1, addElement2, ...);<br></code></pre></div></td></tr></table></figure>
<p><code>splice</code>的第一个参数是删除的起始位置（从0开始），第二个参数是被删除的元素个数。如果后面还有更多的参数，则表示这些就是要被插入数组的新元素  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>];<br>a.splice(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;e&quot;, &quot;f&quot;]</span><br>a <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码从原数组4号位置，删除了两个数组成员  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>];<br>a.splice(<span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;e&quot;, &quot;f&quot;]</span><br>a <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, 1, 2]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码除了删除成员，还插入了两个新成员  </p>
<p>起始位置如果是负数，就表示从倒数位置开始删除  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-string">&#x27;f&#x27;</span>];<br>a.splice(-<span class="hljs-number">4</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;c&quot;, &quot;d&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，从倒数第四个位置<code>c</code>开始删除两个成员  </p>
<p>如果只是单纯地插入元素，<code>splice</code>方法的第二个参数可以设为<code>0</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>];<br><br>a.splice(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// []</span><br>a <span class="hljs-comment">// [1, 2, 1, 1]</span><br></code></pre></div></td></tr></table></figure>
<p>如果只提供第一个参数，等同于将原数组在指定位置拆分成两个数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>a.splice(<span class="hljs-number">2</span>) <span class="hljs-comment">// [3, 4]</span><br>a <span class="hljs-comment">// [1, 2]</span><br></code></pre></div></td></tr></table></figure>


<h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p><code>sort</code>方法对数组成员进行排序，默认是按照字典顺序排序。排序后，原数组将被改变  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span>].sort()<br><span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br><br>[<span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>].sort()<br><span class="hljs-comment">// [1, 2, 3, 4]</span><br><br>[<span class="hljs-number">11</span>, <span class="hljs-number">101</span>].sort()<br><span class="hljs-comment">// [101, 11]</span><br><br>[<span class="hljs-number">10111</span>, <span class="hljs-number">1101</span>, <span class="hljs-number">111</span>].sort()<br><span class="hljs-comment">// [10111, 1101, 111]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的最后两个例子，需要特殊注意。<code>sort()</code>方法不是按照大小排序，而是按照字典顺序。也就是说，数值会被先转成字符串，再按照字典顺序进行比较，所以<code>101</code>排在<code>11</code>的前面  </p>
<p>如果想让<code>sort</code>方法按照自定义方式排序，可以传入一个函数作为参数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-number">10111</span>, <span class="hljs-number">1101</span>, <span class="hljs-number">111</span>].sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a - b;<br>&#125;)<br><span class="hljs-comment">// [111, 1101, 10111]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>sort</code>的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于<code>0</code>，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">30</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">24</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">28</span>  &#125;<br>].sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">o1, o2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> o1.age - o2.age;<br>&#125;)<br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//   &#123; name: &quot;李四&quot;, age: 24 &#125;,</span><br><span class="hljs-comment">//   &#123; name: &quot;王五&quot;, age: 28  &#125;,</span><br><span class="hljs-comment">//   &#123; name: &quot;张三&quot;, age: 30 &#125;</span><br><span class="hljs-comment">// ]</span><br></code></pre></div></td></tr></table></figure>
<p>注意，自定义的排序函数应该返回数值，否则不同的浏览器可能有不同的实现，不能保证结果都一致  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// bad</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a &gt; b)<br><br><span class="hljs-comment">// good</span><br>[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>, <span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>].sort(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b)<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，前一种排序算法返回的是布尔值，这是不推荐使用的。后一种是数值，才是更好的写法  </p>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><code>map</code>方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br>numbers.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>;<br>&#125;);<br><span class="hljs-comment">// [2, 3, 4]</span><br><br>numbers<br><span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>numbers</code>数组的所有成员依次执行参数函数，运行结果组成一个新数组返回，原数组没有变化  </p>
<p><code>map</code>方法接受一个函数作为参数。该函数调用时，<code>map</code>方法向它传入三个参数：当前成员、当前位置和数组本身  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> elem * index;<br>&#125;);<br><span class="hljs-comment">// [0, 2, 6]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>map</code>方法的回调函数有三个参数，<code>elem</code>为当前成员的值，<code>index</code>为当前成员的位置，<code>arr</code>为原数组（<code>[1, 2, 3]</code>）  </p>
<p><code>map</code>方法还可以接受第二个参数，用来绑定回调函数内部的<code>this</code>变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>[e];<br>&#125;, arr)<br><span class="hljs-comment">// [&#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码通过<code>map</code>方法的第二个参数，将回调函数内部的<code>this</code>对象，指向<code>arr</code>数组  </p>
<p>如果数组有空位，<code>map</code>方法的回调函数在这个位置不会执行，会跳过数组的空位  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;a&#x27;</span> &#125;;<br><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>].map(f) <span class="hljs-comment">// [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>].map(f) <span class="hljs-comment">// [&quot;a&quot;, &quot;a&quot;, &quot;a&quot;]</span><br>[<span class="hljs-number">1</span>, , <span class="hljs-number">2</span>].map(f) <span class="hljs-comment">// [&quot;a&quot;, , &quot;a&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>map</code>方法不会跳过<code>undefined</code>和<code>null</code>，但是会跳过空位  </p>
<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h3><p><code>forEach</code>方法与<code>map</code>方法很相似，也是对数组的所有成员依次执行参数函数。但是，<code>forEach</code>方法不返回值，只用来操作数据  </p>
<p>这就是说，如果数组遍历的目的是为了得到返回值，那么使用<code>map</code>方法，否则使用<code>forEach</code>方法  </p>
<p><code>forEach</code>的用法与<code>map</code>方法一致，参数是一个函数，该函数同样接受三个参数：当前值、当前位置、整个数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">log</span>(<span class="hljs-params">element, index, array</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;[&#x27;</span> + index + <span class="hljs-string">&#x27;] = &#x27;</span> + element);<br>&#125;<br><br>[<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>].forEach(log);<br><span class="hljs-comment">// [0] = 2</span><br><span class="hljs-comment">// [1] = 5</span><br><span class="hljs-comment">// [2] = 9</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>forEach</code>遍历数组不是为了得到返回值，而是为了在屏幕输出内容，所以不必使用<code>map</code>方法  </p>
<p><code>forEach</code>方法也可以接受第二个参数，绑定参数函数的<code>this</code>变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> out = [];<br><br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">elem</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.push(elem * elem);<br>&#125;, out);<br><br>out <span class="hljs-comment">// [1, 4, 9]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，空数组<code>out</code>是<code>forEach</code>方法的第二个参数，结果，回调函数内部的<code>this</code>关键字就指向<code>out</code>  </p>
<p>注意，<code>forEach</code>方法无法中断执行，总是会将所有成员遍历完。如果希望符合某种条件时，就中断遍历，要使用<code>for</code>循环  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>  <span class="hljs-keyword">if</span> (arr[i] === <span class="hljs-number">2</span>) <span class="hljs-keyword">break</span>;<br>  <span class="hljs-built_in">console</span>.log(arr[i]);<br>&#125;<br><span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，执行到数组的第二个成员时，就会中断执行。<code>forEach</code>方法做不到这一点  </p>
<p><code>forEach</code>方法也会跳过数组的空位  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> log = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(n + <span class="hljs-number">1</span>);<br>&#125;;<br><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>].forEach(log)<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// NaN</span><br><span class="hljs-comment">// 3</span><br><br>[<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>].forEach(log)<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 3</span><br><br>[<span class="hljs-number">1</span>, , <span class="hljs-number">2</span>].forEach(log)<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>forEach</code>方法不会跳过<code>undefined</code>和<code>null</code>，但会跳过空位  </p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p><code>filter</code>方法用于过滤数组成员，满足条件的成员组成一个新数组返回  </p>
<p>它的参数是一个函数，所有数组成员依次执行该函数，返回结果为<code>true</code>的成员组成一个新数组返回。该方法不会改变原数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> (elem &gt; <span class="hljs-number">3</span>);<br>&#125;)<br><span class="hljs-comment">// [4, 5]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码将大于<code>3</code>的数组成员，作为一个新数组返回  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-literal">false</span>];<br><br>arr.filter(<span class="hljs-built_in">Boolean</span>)<br><span class="hljs-comment">// [1, &quot;a&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>filter</code>方法返回数组<code>arr</code>里面所有布尔值为<code>true</code>的成员  </p>
<p><code>filter</code>方法的参数函数可以接受三个参数：当前成员，当前位置和整个数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> index % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>;<br>&#125;);<br><span class="hljs-comment">// [1, 3, 5]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码返回偶数位置的成员组成的新数组  </p>
<p><code>filter</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">MAX</span>: <span class="hljs-number">3</span> &#125;;<br><span class="hljs-keyword">var</span> myFilter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (item &gt; <span class="hljs-built_in">this</span>.MAX) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">2</span>, <span class="hljs-number">8</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span>];<br>arr.filter(myFilter, obj) <span class="hljs-comment">// [8, 4, 9]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，过滤器<code>myFilter</code>内部有<code>this</code>变量，它可以被<code>filter</code>方法的第二个参数<code>obj</code>绑定，返回大于<code>3</code>的成员  </p>
<h3 id="some-，every"><a href="#some-，every" class="headerlink" title="some()，every()"></a>some()，every()</h3><p>这两个方法类似“断言”（assert），返回一个布尔值，表示判断数组成员是否符合某种条件  </p>
<p>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值  </p>
<p><code>some</code>方法是只要一个成员的返回值是<code>true</code>，则整个<code>some</code>方法的返回值就是<code>true</code>，否则返回<code>false</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>arr.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> elem &gt;= <span class="hljs-number">3</span>;<br>&#125;);<br><span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，如果数组<code>arr</code>有一个成员大于等于3，<code>some</code>方法就返回<code>true</code>  </p>
<p><code>every</code>方法是所有成员的返回值都是<code>true</code>，整个<code>every</code>方法才返回<code>true</code>，否则返回<code>false</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br>arr.every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, index, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> elem &gt;= <span class="hljs-number">3</span>;<br>&#125;);<br><span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，数组<code>arr</code>并非所有成员大于等于<code>3</code>，所以返回<code>false</code>  </p>
<p>注意，对于空数组，<code>some</code>方法返回<code>false</code>，<code>every</code>方法返回<code>true</code>，回调函数都不会执行  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isEven</span>(<span class="hljs-params">x</span>) </span>&#123; <span class="hljs-keyword">return</span> x % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> &#125;<br><br>[].some(isEven) <span class="hljs-comment">// false</span><br>[].every(isEven) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p><code>some</code>和<code>every</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量  </p>
<h3 id="reduce-，reduceRight"><a href="#reduce-，reduceRight" class="headerlink" title="reduce()，reduceRight()"></a>reduce()，reduceRight()</h3><p><code>reduce</code>方法和<code>reduceRight</code>方法依次处理数组的每个成员，最终累计为一个值。它们的差别是，<code>reduce</code>是从左到右处理（从第一个成员到最后一个成员），<code>reduceRight</code>则是从右到左（从最后一个成员到第一个成员），其他完全一样  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a, b);<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;)<br><span class="hljs-comment">// 1 2</span><br><span class="hljs-comment">// 3 3</span><br><span class="hljs-comment">// 6 4</span><br><span class="hljs-comment">// 10 5</span><br><span class="hljs-comment">//最后结果：15</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>reduce</code>方法求出数组所有成员的和。第一次执行，<code>a</code>是数组的第一个成员<code>1</code>，<code>b</code>是数组的第二个成员<code>2</code>。第二次执行，<code>a</code>为上一轮的返回值<code>3</code>，<code>b</code>为第三个成员<code>3</code>。第三次执行，<code>a</code>为上一轮的返回值<code>6</code>，<code>b</code>为第四个成员<code>4</code>。第四次执行，<code>a</code>为上一轮返回值<code>10</code>，<code>b</code>为第五个成员<code>5</code>。至此所有成员遍历完成，整个方法的返回值就是最后一轮的返回值<code>15</code>。</p>
<p><code>reduce</code>方法和<code>reduceRight</code>方法的第一个参数都是一个函数。该函数接受以下四个参数  </p>
<ol>
<li>累积变量，默认为数组的第一个成员</li>
<li>当前变量，默认为数组的第二个成员</li>
<li>当前位置（从0开始）</li>
<li>原数组</li>
</ol>
<p>这四个参数之中，只有前两个是必须的，后两个则是可选的。</p>
<p>如果要对累积变量指定初值，可以把它放在<code>reduce</code>方法和<code>reduceRight</code>方法的第二个参数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>].reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;, <span class="hljs-number">10</span>);<br><span class="hljs-comment">// 25</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码指定参数<code>a</code>的初值为10，所以数组从10开始累加，最终结果为25。注意，这时<code>b</code>是从数组的第一个成员开始遍历  </p>
<p>上面的第二个参数相当于设定了默认值，处理空数组时尤其有用  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">prev, cur</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> prev + cur;<br>&#125;<br><br>[].reduce(add)<br><span class="hljs-comment">// TypeError: Reduce of empty array with no initial value</span><br>[].reduce(add, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，由于空数组取不到初始值，<code>reduce</code>方法会报错。这时，加上第二个参数，就能保证总是会返回一个值  </p>
<p>下面是一个<code>reduceRight</code>方法的例子  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">subtract</span>(<span class="hljs-params">prev, cur</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> prev - cur;<br>&#125;<br><br>[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>].reduce(subtract) <span class="hljs-comment">// 0</span><br>[<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>].reduceRight(subtract) <span class="hljs-comment">// -4</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>reduce</code>方法相当于<code>3</code>减去<code>2</code>再减去<code>1</code>，<code>reduceRight</code>方法相当于<code>1</code>减去<code>2</code>再减去<code>3</code>  </p>
<p>由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。比如，找出字符长度最长的数组成员  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findLongest</span>(<span class="hljs-params">entries</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> entries.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">longest, entry</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> entry.length &gt; longest.length ? entry : longest;<br>  &#125;, <span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br><br>findLongest([<span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-string">&#x27;bb&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]) <span class="hljs-comment">// &quot;aaa&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>reduce</code>的参数函数会将字符长度较长的那个数组成员，作为累积值。这导致遍历所有成员之后，累积值就是字符长度最长的那个成员  </p>
<h3 id="indexOf-，lastIndexOf"><a href="#indexOf-，lastIndexOf" class="headerlink" title="indexOf()，lastIndexOf()"></a>indexOf()，lastIndexOf()</h3><p><code>indexOf</code>方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回<code>-1</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>a.indexOf(<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// 1</span><br>a.indexOf(<span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-comment">// -1</span><br></code></pre></div></td></tr></table></figure>
<p><code>indexOf</code>方法还可以接受第二个参数，表示搜索的开始位置  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>].indexOf(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// -1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码从1号位置开始搜索字符<code>a</code>，结果为<code>-1</code>，表示没有搜索到  </p>
<p><code>lastIndexOf</code>方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回<code>-1</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">2</span>];<br>a.lastIndexOf(<span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br>a.lastIndexOf(<span class="hljs-number">7</span>) <span class="hljs-comment">// -1</span><br></code></pre></div></td></tr></table></figure>
<p>注意，这两个方法不能用来搜索<code>NaN</code>的位置，即它们无法确定数组成员是否包含<code>NaN</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-literal">NaN</span>].indexOf(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// -1</span><br>[<span class="hljs-literal">NaN</span>].lastIndexOf(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// -1</span><br></code></pre></div></td></tr></table></figure>
<p>这是因为这两个方法内部，使用严格相等运算符（<code>===</code>）进行比较，而<code>NaN</code>是唯一一个不等于自身的值  </p>
<h3 id="链式使用"><a href="#链式使用" class="headerlink" title="链式使用"></a>链式使用</h3><p>上面这些数组方法之中，有不少返回的还是数组，所以可以链式使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> users = [<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;tom&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;tom@example.com&#x27;</span>&#125;,<br>  &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;peter&#x27;</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;peter@example.com&#x27;</span>&#125;<br>];<br><br>users<br>.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> user.email;<br>&#125;)<br>.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">email</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-regexp">/^t/</span>.test(email);<br>&#125;)<br>.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">email</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(email);<br>&#125;);<br><span class="hljs-comment">// &quot;tom@example.com&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，先产生一个所有 Email 地址组成的数组，然后再过滤出以<code>t</code>开头的 Email 地址，最后将它打印出来  </p>
<h2 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对象是 JavaScript 语言最主要的数据类型，三种原始类型的值——数值、字符串、布尔值——在一定条件下，也会自动转为对象，也就是原始类型的“包装对象”（wrapper）  </p>
<p>所谓“包装对象”，指的是与数值、字符串、布尔值分别相对应的<code>Number</code>、<code>String</code>、<code>Boolean</code>三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> v1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>);<br><span class="hljs-keyword">var</span> v2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);<br><span class="hljs-keyword">var</span> v3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-keyword">typeof</span> v1 <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> v2 <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> v3 <span class="hljs-comment">// &quot;object&quot;</span><br><br>v1 === <span class="hljs-number">123</span> <span class="hljs-comment">// false</span><br>v2 === <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-comment">// false</span><br>v3 === <span class="hljs-literal">true</span> <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，基于原始类型的值，生成了三个对应的包装对象。可以看到，<code>v1</code>、<code>v2</code>、<code>v3</code>都是对象，且与对应的简单类型值不相等  </p>
<p>包装对象的设计目的，首先是使得“对象”这种类型可以覆盖 <code>Javascript</code> 所有的值，整门语言有一个通用的数据模型，其次是使得原始类型的值也有办法调用自己的方法  </p>
<p><code>Number</code>、<code>String</code>和<code>Boolean</code>这三个原生对象，如果不作为构造函数调用（即调用时不加<code>new</code>），而是作为普通函数调用，常常用于将任意类型的值转为数值、字符串和布尔值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 字符串转为数值</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;123&#x27;</span>) <span class="hljs-comment">// 123</span><br><br><span class="hljs-comment">// 数值转为字符串</span><br><span class="hljs-built_in">String</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// &quot;123&quot;</span><br><br><span class="hljs-comment">// 数值转为布尔值</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>总结一下，这三个对象作为构造函数使用（带有<code>new</code>）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有<code>new</code>），可以将任意类型的值，转为原始类型的值  </p>
<h3 id="实例方法-1"><a href="#实例方法-1" class="headerlink" title="实例方法"></a>实例方法</h3><p>三种包装对象各自提供了许多实例方法。这里介绍两种它们共同具有、从<code>Object</code>对象继承的方法：<code>valueOf()</code>和<code>toString()</code>  </p>
<h4 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf()"></a>valueOf()</h4><p><code>valueOf()</code>方法返回包装对象实例对应的原始类型的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>).valueOf()  <span class="hljs-comment">// 123</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>).valueOf() <span class="hljs-comment">// &quot;abc&quot;</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>).valueOf() <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p><code>toString()</code>方法返回对应的字符串形式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>).toString() <span class="hljs-comment">// &quot;123&quot;</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>).toString() <span class="hljs-comment">// &quot;abc&quot;</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>).toString() <span class="hljs-comment">// &quot;true&quot;</span><br></code></pre></div></td></tr></table></figure>


<h3 id="原始类型与实例对象的自动转换"><a href="#原始类型与实例对象的自动转换" class="headerlink" title="原始类型与实例对象的自动转换"></a>原始类型与实例对象的自动转换</h3><p>某些场合，原始类型的值会自动当作包装对象调用，即调用包装对象的属性和方法  </p>
<p>这时，<code>Javascript</code> 引擎会自动将原始类型的值转为包装对象实例，并在使用后立刻销毁实例  </p>
<p>比如，字符串可以调用<code>length</code>属性，返回字符串的长度  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.length <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>abc</code>是一个字符串，本身不是对象，不能调用<code>length</code>属性。<code>Javascript</code> 引擎自动将其转为包装对象，在这个对象上调用<code>length</code>属性。调用结束后，这个临时对象就会被销毁。这就叫原始类型与实例对象的自动转换  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>str.length <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">var</span> strObj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(str)<br><span class="hljs-comment">// String &#123;</span><br><span class="hljs-comment">//   0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;</span><br><span class="hljs-comment">// &#125;</span><br>strObj.length <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，字符串<code>abc</code>的包装对象提供了多个属性，<code>length</code>只是其中之一  </p>
<p>自动转换生成的包装对象是只读的，无法修改。所以，字符串无法添加新属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;Hello World&#x27;</span>;<br>s.x = <span class="hljs-number">123</span>;<br>s.x <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码为字符串<code>s</code>添加了一个<code>x</code>属性，结果无效，总是返回<code>undefined</code>  </p>
<p>另一方面，调用结束后，包装对象实例会自动销毁。这意味着，下一次调用字符串的属性时，实际是调用一个新生成的对象，而不是上一次调用时生成的那个对象，所以取不到赋值在上一个对象的属性。如果要为字符串添加属性，只有在它的原型对象<code>String.prototype</code>上定义  </p>
<h3 id="自定义方法"><a href="#自定义方法" class="headerlink" title="自定义方法"></a>自定义方法</h3><p>除了原生的实例方法，包装对象还可以自定义方法和属性，供原始类型的值直接调用   </p>
<p>比如，我们可以新增一个<code>double</code>方法，使得字符串和数字翻倍  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.prototype.double = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.valueOf() + <span class="hljs-built_in">this</span>.valueOf();<br>&#125;;<br><br><span class="hljs-string">&#x27;abc&#x27;</span>.double()<br><span class="hljs-comment">// abcabc</span><br><br><span class="hljs-built_in">Number</span>.prototype.double = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.valueOf() + <span class="hljs-built_in">this</span>.valueOf();<br>&#125;;<br><br>(<span class="hljs-number">123</span>).double() <span class="hljs-comment">// 246</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码在<code>String</code>和<code>Number</code>这两个对象的原型上面，分别自定义了一个方法，从而可以在所有实例对象上调用。注意，最后一行的<code>123</code>外面必须要加上圆括号，否则后面的点运算符（<code>.</code>）会被解释成小数点  </p>
<h2 id="Boolean-对象"><a href="#Boolean-对象" class="headerlink" title="Boolean 对象"></a>Boolean 对象</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p><code>Boolean</code>对象是 <code>Javascript</code> 的三个包装对象之一。作为构造函数，它主要用于生成布尔值的包装对象实例   </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-keyword">typeof</span> b <span class="hljs-comment">// &quot;object&quot;</span><br>b.valueOf() <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的变量<code>b</code>是一个<code>Boolean</code>对象的实例，它的类型是对象，值为布尔值<code>true</code>  </p>
<p>注意，<code>false</code>对应的包装对象实例，布尔运算结果也是<code>true</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>).valueOf()) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// 无输出</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的第一个例子之所以得到<code>true</code>，是因为<code>false</code>对应的包装对象实例是一个对象，进行逻辑运算时，被自动转化成布尔值<code>true</code>（因为所有对象对应的布尔值都是<code>true</code>）。而实例的<code>valueOf</code>方法，则返回实例对应的原始值，本例为<code>false</code>  </p>
<h3 id="Boolean-函数的类型转换作用"><a href="#Boolean-函数的类型转换作用" class="headerlink" title="Boolean 函数的类型转换作用"></a>Boolean 函数的类型转换作用</h3><p><code>Boolean</code>对象除了可以作为构造函数，还可以单独使用，将任意值转为布尔值。这时<code>Boolean</code>就是一个单纯的工具方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span><br><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;false&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>([]) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>(&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-regexp">/foo/</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中几种得到<code>true</code>的情况，都值得认真记住  </p>
<p>顺便提一下，使用双重的否运算符（<code>!</code>）也可以将任意值转为对应的布尔值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">!!<span class="hljs-literal">undefined</span> <span class="hljs-comment">// false</span><br>!!<span class="hljs-literal">null</span> <span class="hljs-comment">// false</span><br>!!<span class="hljs-number">0</span> <span class="hljs-comment">// false</span><br>!!<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// false</span><br>!!<span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><br>!!<span class="hljs-number">1</span> <span class="hljs-comment">// true</span><br>!!<span class="hljs-string">&#x27;false&#x27;</span> <span class="hljs-comment">// true</span><br>!![] <span class="hljs-comment">// true</span><br>!!&#123;&#125; <span class="hljs-comment">// true</span><br>!!<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125; <span class="hljs-comment">// true</span><br>!!<span class="hljs-regexp">/foo/</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>最后，对于一些特殊值，<code>Boolean</code>对象前面加不加<code>new</code>，会得到完全相反的结果，必须小心  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// 无输出</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// true</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// 无输出</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>)) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>





<h2 id="Number-对象"><a href="#Number-对象" class="headerlink" title="Number 对象"></a>Number 对象</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p><code>Number</code>对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用  </p>
<p>作为构造函数时，它用于生成值为数值的对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">typeof</span> n <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Number</code>对象作为构造函数使用，返回一个值为<code>1</code>的对象  </p>
<p>作为工具函数时，它可以将任何类型的值转为数值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码将布尔值<code>true</code>转为数值<code>1</code>  </p>
<h3 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h3><p><code>Number</code>对象拥有以下一些静态属性（即直接定义在<code>Number</code>对象上的属性，而不是定义在实例上的属性）  </p>
<ul>
<li><code>Number.POSITIVE_INFINITY</code>：正的无限，指向<code>Infinity</code>  </li>
<li><code>Number.NEGATIVE_INFINITY</code>：负的无限，指向<code>-Infinity</code>  </li>
<li><code>Number.NaN</code>：表示非数值，指向<code>NaN</code>   </li>
<li><code>Number.MIN_VALUE</code>：表示最小的正数（即最接近0的正数，在64位浮点数体系中为<code>5e-324</code>），相应的，最接近0的负数为<code>-Number.MIN_VALUE</code>  </li>
<li><code>Number.MAX_SAFE_INTEGER</code>：表示能够精确表示的最大整数，即<code>9007199254740991</code>   </li>
<li><code>Number.MIN_SAFE_INTEGER</code>：表示能够精确表示的最小整数，即<code>-9007199254740991</code>  </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>.POSITIVE_INFINITY <span class="hljs-comment">// Infinity</span><br><span class="hljs-built_in">Number</span>.NEGATIVE_INFINITY <span class="hljs-comment">// -Infinity</span><br><span class="hljs-built_in">Number</span>.NaN <span class="hljs-comment">// NaN</span><br><br><span class="hljs-built_in">Number</span>.MAX_VALUE<br><span class="hljs-comment">// 1.7976931348623157e+308</span><br><span class="hljs-built_in">Number</span>.MAX_VALUE &lt; <span class="hljs-literal">Infinity</span><br><span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">Number</span>.MIN_VALUE<br><span class="hljs-comment">// 5e-324</span><br><span class="hljs-built_in">Number</span>.MIN_VALUE &gt; <span class="hljs-number">0</span><br><span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER <span class="hljs-comment">// 9007199254740991</span><br><span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER <span class="hljs-comment">// -9007199254740991</span><br></code></pre></div></td></tr></table></figure>


<h3 id="实例方法-2"><a href="#实例方法-2" class="headerlink" title="实例方法"></a>实例方法</h3><p><code>Number</code>对象有4个实例方法，都跟将数值转换成指定格式有关  </p>
<h4 id="Number-prototype-toString"><a href="#Number-prototype-toString" class="headerlink" title="Number.prototype.toString()"></a>Number.prototype.toString()</h4><p><code>Number</code>对象部署了自己的<code>toString</code>方法，用来将一个数值转为字符串形式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-number">10</span>).toString() <span class="hljs-comment">// &quot;10&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><code>toString</code>方法可以接受一个参数，表示输出的进制。如果省略这个参数，默认将数值先转为十进制，再输出字符串；否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-number">10</span>).toString(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010&quot;</span><br>(<span class="hljs-number">10</span>).toString(<span class="hljs-number">8</span>) <span class="hljs-comment">// &quot;12&quot;</span><br>(<span class="hljs-number">10</span>).toString(<span class="hljs-number">16</span>) <span class="hljs-comment">// &quot;a&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>10</code>一定要放在括号里，这样表明后面的点表示调用对象属性。如果不加括号，这个点会被 <code>Javascript</code> 引擎解释成小数点，从而报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">10.</span>toString(<span class="hljs-number">2</span>)<br><span class="hljs-comment">// SyntaxError: Unexpected token ILLEGAL</span><br></code></pre></div></td></tr></table></figure>
<p>只要能够让 <code>Javascript</code> 引擎不混淆小数点和对象的点运算符，各种写法都能用。除了为<code>10</code>加上括号，还可以在<code>10</code>后面加两个点，<code>Javascript</code> 会把第一个点理解成小数点（即<code>10.0</code>），把第二个点理解成调用对象属性，从而得到正确结果  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">10.</span>.toString(<span class="hljs-number">2</span>)<br><span class="hljs-comment">// &quot;1010&quot;</span><br><br><span class="hljs-comment">// 其他方法还包括</span><br><span class="hljs-number">10</span> .toString(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010&quot;</span><br><span class="hljs-number">10.0</span>.toString(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>这实际上意味着，可以直接对一个小数使用<code>toString</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">10.5</span>.toString() <span class="hljs-comment">// &quot;10.5&quot;</span><br><span class="hljs-number">10.5</span>.toString(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010.1&quot;</span><br><span class="hljs-number">10.5</span>.toString(<span class="hljs-number">8</span>) <span class="hljs-comment">// &quot;12.4&quot;</span><br><span class="hljs-number">10.5</span>.toString(<span class="hljs-number">16</span>) <span class="hljs-comment">// &quot;a.8&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>通过方括号运算符也可以调用<code>toString</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">10</span>[<span class="hljs-string">&#x27;toString&#x27;</span>](<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1010&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><code>toString</code>方法只能将十进制的数，转为其他进制的字符串。如果要将其他进制的数，转回十进制，需要使用<code>parseInt</code>方法  </p>
<h4 id="Number-prototype-toFixed"><a href="#Number-prototype-toFixed" class="headerlink" title="Number.prototype.toFixed()"></a>Number.prototype.toFixed()</h4><p><code>toFixed()</code>方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-number">10</span>).toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;10.00&quot;</span><br><span class="hljs-number">10.005</span>.toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;10.01&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>10</code>和<code>10.005</code>先转成2位小数，然后转成字符串。其中<code>10</code>必须放在括号里，否则后面的点会被处理成小数点  </p>
<p><code>toFixed()</code>方法的参数为小数位数，有效范围为0到100，超出这个范围将抛出 RangeError 错误  </p>
<p>由于浮点数的原因，小数<code>5</code>的四舍五入是不确定的，使用的时候必须小心  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-number">10.055</span>).toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// 10.05</span><br>(<span class="hljs-number">10.005</span>).toFixed(<span class="hljs-number">2</span>) <span class="hljs-comment">// 10.01</span><br></code></pre></div></td></tr></table></figure>


<h4 id="Number-prototype-toExponential"><a href="#Number-prototype-toExponential" class="headerlink" title="Number.prototype.toExponential()"></a>Number.prototype.toExponential()</h4><p><code>toExponential</code>方法用于将一个数转为科学计数法形式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-number">10</span>).toExponential()  <span class="hljs-comment">// &quot;1e+1&quot;</span><br>(<span class="hljs-number">10</span>).toExponential(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;1.0e+1&quot;</span><br>(<span class="hljs-number">10</span>).toExponential(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1.00e+1&quot;</span><br><br>(<span class="hljs-number">1234</span>).toExponential()  <span class="hljs-comment">// &quot;1.234e+3&quot;</span><br>(<span class="hljs-number">1234</span>).toExponential(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;1.2e+3&quot;</span><br>(<span class="hljs-number">1234</span>).toExponential(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;1.23e+3&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><code>toExponential</code>方法的参数是小数点后有效数字的位数，范围为0到100，超出这个范围，会抛出一个 RangeError 错误  </p>
<h4 id="Number-prototype-toPrecision"><a href="#Number-prototype-toPrecision" class="headerlink" title="Number.prototype.toPrecision()"></a>Number.prototype.toPrecision()</h4><p><code>Number.prototype.toPrecision()</code>方法用于将一个数转为指定位数的有效数字  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-number">12.34</span>).toPrecision(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;1e+1&quot;</span><br>(<span class="hljs-number">12.34</span>).toPrecision(<span class="hljs-number">2</span>) <span class="hljs-comment">// &quot;12&quot;</span><br>(<span class="hljs-number">12.34</span>).toPrecision(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;12.3&quot;</span><br>(<span class="hljs-number">12.34</span>).toPrecision(<span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;12.34&quot;</span><br>(<span class="hljs-number">12.34</span>).toPrecision(<span class="hljs-number">5</span>) <span class="hljs-comment">// &quot;12.340&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>该方法的参数为有效数字的位数，范围是1到100，超出这个范围会抛出 RangeError 错误  </p>
<p>该方法用于四舍五入时不太可靠，跟浮点数不是精确储存有关  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-number">12.35</span>).toPrecision(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;12.3&quot;</span><br>(<span class="hljs-number">12.25</span>).toPrecision(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;12.3&quot;</span><br>(<span class="hljs-number">12.15</span>).toPrecision(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;12.2&quot;</span><br>(<span class="hljs-number">12.45</span>).toPrecision(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;12.4&quot;</span><br></code></pre></div></td></tr></table></figure>


<h4 id="Number-prototype-toLocaleString"><a href="#Number-prototype-toLocaleString" class="headerlink" title="Number.prototype.toLocaleString()"></a>Number.prototype.toLocaleString()</h4><p><code>Number.prototype.toLocaleString()</code>方法接受一个地区码作为参数，返回一个字符串，表示当前数字在该地区的当地书写形式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-number">123</span>).toLocaleString(<span class="hljs-string">&#x27;zh-Hans-CN-u-nu-hanidec&#x27;</span>)<br><span class="hljs-comment">// &quot;一二三&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>该方法还可以接受第二个参数配置对象，用来定制指定用途的返回字符串。该对象的<code>style</code>属性指定输出样式，默认值是<code>decimal</code>，表示输出十进制形式。如果值为<code>percent</code>，表示输出百分数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-number">123</span>).toLocaleString(<span class="hljs-string">&#x27;zh-Hans-CN&#x27;</span>, &#123; <span class="hljs-attr">style</span>: <span class="hljs-string">&#x27;percent&#x27;</span> &#125;)<br><span class="hljs-comment">// &quot;12,300%&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果<code>style</code>属性的值为<code>currency</code>，则可以搭配<code>currency</code>属性，输出指定格式的货币字符串形式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-number">123</span>).toLocaleString(<span class="hljs-string">&#x27;zh-Hans-CN&#x27;</span>, &#123; <span class="hljs-attr">style</span>: <span class="hljs-string">&#x27;currency&#x27;</span>, <span class="hljs-attr">currency</span>: <span class="hljs-string">&#x27;CNY&#x27;</span> &#125;)<br><span class="hljs-comment">// &quot;￥123.00&quot;</span><br><br>(<span class="hljs-number">123</span>).toLocaleString(<span class="hljs-string">&#x27;de-DE&#x27;</span>, &#123; <span class="hljs-attr">style</span>: <span class="hljs-string">&#x27;currency&#x27;</span>, <span class="hljs-attr">currency</span>: <span class="hljs-string">&#x27;EUR&#x27;</span> &#125;)<br><span class="hljs-comment">// &quot;123,00 €&quot;</span><br><br>(<span class="hljs-number">123</span>).toLocaleString(<span class="hljs-string">&#x27;en-US&#x27;</span>, &#123; <span class="hljs-attr">style</span>: <span class="hljs-string">&#x27;currency&#x27;</span>, <span class="hljs-attr">currency</span>: <span class="hljs-string">&#x27;USD&#x27;</span> &#125;)<br><span class="hljs-comment">// &quot;$123.00&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果<code>Number.prototype.toLocaleString()</code>省略了参数，则由浏览器自行决定如何处理，通常会使用操作系统的地区设定。注意，该方法如果使用浏览器不认识的地区码，会抛出一个错误  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-number">123</span>).toLocaleString(<span class="hljs-string">&#x27;123&#x27;</span>) <span class="hljs-comment">// 出错</span><br></code></pre></div></td></tr></table></figure>


<h3 id="自定义方法-1"><a href="#自定义方法-1" class="headerlink" title="自定义方法"></a>自定义方法</h3><p>与其他对象一样，<code>Number.prototype</code>对象上面可以自定义方法，被<code>Number</code>的实例继承  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span> + x;<br>&#125;;<br><br><span class="hljs-number">8</span>[<span class="hljs-string">&#x27;add&#x27;</span>](<span class="hljs-number">2</span>) <span class="hljs-comment">// 10</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码为<code>Number</code>对象实例定义了一个<code>add</code>方法。在数值上调用某个方法，数值会自动转为<code>Number</code>的实例对象，所以就可以调用<code>add</code>方法了。由于<code>add</code>方法返回的还是数值，所以可以链式运算  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>.prototype.subtract = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span> - x;<br>&#125;;<br><br>(<span class="hljs-number">8</span>).add(<span class="hljs-number">2</span>).subtract(<span class="hljs-number">4</span>)<br><span class="hljs-comment">// 6</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码在<code>Number</code>对象的实例上部署了<code>subtract</code>方法，它可以与<code>add</code>方法链式调用  </p>
<p>我们还可以部署更复杂的方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>.prototype.iterate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> result = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-built_in">this</span>; i++) &#123;<br>    result.push(i);<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br><br>(<span class="hljs-number">8</span>).iterate()<br><span class="hljs-comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码在<code>Number</code>对象的原型上部署了<code>iterate</code>方法，将一个数值自动遍历为一个数组  </p>
<p>注意，数值的自定义方法，只能定义在它的原型对象<code>Number.prototype</code>上面，数值本身是无法自定义属性的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">1</span>;<br>n.x = <span class="hljs-number">1</span>;<br>n.x <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>n</code>是一个原始类型的数值。直接在它上面新增一个属性<code>x</code>，不会报错，但毫无作用，总是返回<code>undefined</code>。这是因为一旦被调用属性，<code>n</code>就自动转为<code>Number</code>的实例对象，调用结束后，该对象自动销毁。所以，下一次调用<code>n</code>的属性时，实际取到的是另一个对象，属性<code>x</code>当然就读不出来  </p>
<h2 id="String-对象"><a href="#String-对象" class="headerlink" title="String 对象"></a>String 对象</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><code>String</code>对象是 <code>Javascript</code> 原生提供的三个包装对象之一，用来生成字符串对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);<br><br><span class="hljs-keyword">typeof</span> s1 <span class="hljs-comment">// &quot;string&quot;</span><br><span class="hljs-keyword">typeof</span> s2 <span class="hljs-comment">// &quot;object&quot;</span><br><br>s2.valueOf() <span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，变量<code>s1</code>是字符串，<code>s2</code>是对象。由于<code>s2</code>是字符串对象，<code>s2.valueOf</code>方法返回的就是它所对应的原始字符串  </p>
<p>字符串对象是一个类似数组的对象（很像数组，但不是数组）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)<br><span class="hljs-comment">// String &#123;0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3&#125;</span><br><br>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>))[<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;b&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，字符串<code>abc</code>对应的字符串对象，有数值键（<code>0</code>、<code>1</code>、<code>2</code>）和<code>length</code>属性，所以可以像数组那样取值  </p>
<p>除了用作构造函数，<code>String</code>对象还可以当作工具方法使用，将任意类型的值转为字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// &quot;true&quot;</span><br><span class="hljs-built_in">String</span>(<span class="hljs-number">5</span>) <span class="hljs-comment">// &quot;5&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码将布尔值<code>true</code>和数值<code>5</code>，分别转换为字符串  </p>
<h3 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h3><h4 id="String-fromCharCode"><a href="#String-fromCharCode" class="headerlink" title="String.fromCharCode()"></a>String.fromCharCode()</h4><p><code>String</code>对象提供的静态方法（即定义在对象本身，而不是定义在对象实例的方法），主要是<code>String.fromCharCode()</code>。该方法的参数是一个或多个数值，代表 <code>Unicode</code> 码点，返回值是这些码点组成的字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.fromCharCode() <span class="hljs-comment">// &quot;&quot;</span><br><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">97</span>) <span class="hljs-comment">// &quot;a&quot;</span><br><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">104</span>, <span class="hljs-number">101</span>, <span class="hljs-number">108</span>, <span class="hljs-number">108</span>, <span class="hljs-number">111</span>)<br><span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>String.fromCharCode</code>方法的参数为空，就返回空字符串；否则，返回参数对应的 <code>Unicode</code> 字符串  </p>
<p>注意，该方法不支持 <code>Unicode</code> 码点大于<code>0xFFFF</code>的字符，即传入的参数不能大于<code>0xFFFF</code>（即十进制的 65535）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0x20BB7</span>)<br><span class="hljs-comment">// &quot;ஷ&quot;</span><br><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0x20BB7</span>) === <span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0x0BB7</span>)<br><span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>String.fromCharCode</code>参数<code>0x20BB7</code>大于<code>0xFFFF</code>，导致返回结果出错。<code>0x20BB7</code>对应的字符是汉字<code>𠮷</code>，但是返回结果却是另一个字符（码点<code>0x0BB7</code>）。这是因为<code>String.fromCharCode</code>发现参数值大于<code>0xFFFF</code>，就会忽略多出的位（即忽略<code>0x20BB7</code>里面的<code>2</code>）  </p>
<p>这种现象的根本原因在于，码点大于<code>0xFFFF</code>的字符占用四个字节，而 <code>Javascript</code> 默认支持两个字节的字符。这种情况下，必须把<code>0x20BB7</code>拆成两个字符表示  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">0xD842</span>, <span class="hljs-number">0xDFB7</span>)<br><span class="hljs-comment">// &quot;𠮷&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>0x20BB7</code>拆成两个字符<code>0xD842</code>和<code>0xDFB7</code>（即两个两字节字符，合成一个四字节字符），就能得到正确的结果。码点大于<code>0xFFFF</code>的字符的四字节表示法，由 <code>UTF-16</code> 编码方法决定  </p>
<h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><h4 id="String-prototype-length"><a href="#String-prototype-length" class="headerlink" title="String.prototype.length"></a>String.prototype.length</h4><p>字符串实例的<code>length</code>属性返回字符串的长度  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.length <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>


<h3 id="实例方法-3"><a href="#实例方法-3" class="headerlink" title="实例方法"></a>实例方法</h3><h4 id="String-prototype-charAt"><a href="#String-prototype-charAt" class="headerlink" title="String.prototype.charAt()"></a>String.prototype.charAt()</h4><p><code>charAt</code>方法返回指定位置的字符，参数是从<code>0</code>开始编号的位置  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);<br><br>s.charAt(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;b&quot;</span><br>s.charAt(s.length - <span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;c&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>这个方法完全可以用数组下标替代  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.charAt(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;b&quot;</span><br><span class="hljs-string">&#x27;abc&#x27;</span>[<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;b&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果参数为负数，或大于等于字符串的长度，<code>charAt</code>返回空字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.charAt(-<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;&quot;</span><br><span class="hljs-string">&#x27;abc&#x27;</span>.charAt(<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;&quot;</span><br></code></pre></div></td></tr></table></figure>


<h4 id="String-prototype-charCodeAt"><a href="#String-prototype-charCodeAt" class="headerlink" title="String.prototype.charCodeAt()"></a>String.prototype.charCodeAt()</h4><p><code>charCodeAt()</code>方法返回字符串指定位置的 <code>Unicode</code> 码点（十进制表示），相当于<code>String.fromCharCode()</code>的逆操作  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.charCodeAt(<span class="hljs-number">1</span>) <span class="hljs-comment">// 98</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>abc</code>的<code>1</code>号位置的字符是<code>b</code>，它的 <code>Unicode</code> 码点是<code>98</code>  </p>
<p>如果没有任何参数，<code>charCodeAt</code>返回首字符的 <code>Unicode</code> 码点  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.charCodeAt() <span class="hljs-comment">// 97</span><br></code></pre></div></td></tr></table></figure>
<p>如果参数为负数，或大于等于字符串的长度，<code>charCodeAt</code>返回<code>NaN</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>.charCodeAt(-<span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-string">&#x27;abc&#x27;</span>.charCodeAt(<span class="hljs-number">4</span>) <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure>
<p>注意，<code>charCodeAt</code>方法返回的 <code>Unicode</code> 码点不会大于65536（0xFFFF），也就是说，只返回两个字节的字符的码点。如果遇到码点大于 65536 的字符（四个字节的字符），必须连续使用两次<code>charCodeAt</code>，不仅读入<code>charCodeAt(i)</code>，还要读入<code>charCodeAt(i+1)</code>，将两个值放在一起，才能得到准确的字符  </p>
<h4 id="String-prototype-concat"><a href="#String-prototype-concat" class="headerlink" title="String.prototype.concat()"></a>String.prototype.concat()</h4><p><code>concat</code>方法用于连接两个字符串，返回一个新字符串，不改变原字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">&#x27;abc&#x27;</span>;<br><span class="hljs-keyword">var</span> s2 = <span class="hljs-string">&#x27;def&#x27;</span>;<br><br>s1.concat(s2) <span class="hljs-comment">// &quot;abcdef&quot;</span><br>s1 <span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>该方法可以接受多个参数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a&#x27;</span>.concat(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>) <span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果参数不是字符串，<code>concat</code>方法会将其先转为字符串，然后再连接  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> one = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> two = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">var</span> three = <span class="hljs-string">&#x27;3&#x27;</span>;<br><br><span class="hljs-string">&#x27;&#x27;</span>.concat(one, two, three) <span class="hljs-comment">// &quot;123&quot;</span><br>one + two + three <span class="hljs-comment">// &quot;33&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>concat</code>方法将参数先转成字符串再连接，所以返回的是一个三个字符的字符串。作为对比，加号运算符在两个运算数都是数值时，不会转换类型，所以返回的是一个两个字符的字符串  </p>
<h4 id="String-prototype-slice"><a href="#String-prototype-slice" class="headerlink" title="String.prototype.slice()"></a>String.prototype.slice()</h4><p><code>slice()</code>方法用于从原字符串取出子字符串并返回，不改变原字符串。它的第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.slice(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;Java&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果省略第二个参数，则表示子字符串一直到原字符串结束  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.slice(<span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.slice(-<span class="hljs-number">6</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br><span class="hljs-string">&#x27;JavaScript&#x27;</span>.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">6</span>) <span class="hljs-comment">// &quot;Java&quot;</span><br><span class="hljs-string">&#x27;JavaScript&#x27;</span>.slice(-<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;p&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果第一个参数大于第二个参数（正数情况下），<code>slice()</code>方法返回一个空字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.slice(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;&quot;</span><br></code></pre></div></td></tr></table></figure>


<h4 id="String-prototype-substring"><a href="#String-prototype-substring" class="headerlink" title="String.prototype.substring()"></a>String.prototype.substring()</h4><p><code>substring</code>方法用于从原字符串取出子字符串并返回，不改变原字符串，跟<code>slice</code>方法很相像  </p>
<p>它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substring(<span class="hljs-number">0</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;Java&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果省略第二个参数，则表示子字符串一直到原字符串的结束  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substring(<span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果第一个参数大于第二个参数，<code>substring</code>方法会自动更换两个参数的位置  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substring(<span class="hljs-number">10</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substring(<span class="hljs-number">4</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，调换<code>substring</code>方法的两个参数，都得到同样的结果  </p>
<p>如果参数是负数，<code>substring</code>方法会自动将负数转为0  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substring(-<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;JavaScript&quot;</span><br><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substring(<span class="hljs-number">4</span>, -<span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;Java&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，第二个例子的参数<code>-3</code>会自动变成<code>0</code>，等同于<code>&#39;JavaScript&#39;.substring(4, 0)</code>。由于第二个参数小于第一个参数，会自动互换位置，所以返回<code>Java</code>  </p>
<p>由于这些规则违反直觉，因此不建议使用<code>substring</code>方法，应该优先使用<code>slice</code>  </p>
<h4 id="String-prototype-substr"><a href="#String-prototype-substr" class="headerlink" title="String.prototype.substr()"></a>String.prototype.substr()</h4><p><code>substr</code>方法用于从原字符串取出子字符串并返回，不改变原字符串，跟<code>slice</code>和<code>substring</code>方法的作用相同  </p>
<p><code>substr</code>方法的第一个参数是子字符串的开始位置（从0开始计算），第二个参数是子字符串的长度  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substr(<span class="hljs-number">4</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果省略第二个参数，则表示子字符串一直到原字符串的结束  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substr(<span class="hljs-number">4</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substr(-<span class="hljs-number">6</span>) <span class="hljs-comment">// &quot;Script&quot;</span><br><span class="hljs-string">&#x27;JavaScript&#x27;</span>.substr(<span class="hljs-number">4</span>, -<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，第二个例子的参数<code>-1</code>自动转为<code>0</code>，表示子字符串长度为<code>0</code>，所以返回空字符串  </p>
<h4 id="String-prototype-indexOf-，String-prototype-lastIndexOf"><a href="#String-prototype-indexOf-，String-prototype-lastIndexOf" class="headerlink" title="String.prototype.indexOf()，String.prototype.lastIndexOf()"></a>String.prototype.indexOf()，String.prototype.lastIndexOf()</h4><p><code>indexOf</code>方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回<code>-1</code>，就表示不匹配  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;hello world&#x27;</span>.indexOf(<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-comment">// 4</span><br><span class="hljs-string">&#x27;JavaScript&#x27;</span>.indexOf(<span class="hljs-string">&#x27;script&#x27;</span>) <span class="hljs-comment">// -1</span><br></code></pre></div></td></tr></table></figure>
<p><code>indexOf</code>方法还可以接受第二个参数，表示从该位置开始向后匹配  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;hello world&#x27;</span>.indexOf(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 7</span><br></code></pre></div></td></tr></table></figure>
<p><code>lastIndexOf</code>方法的用法跟<code>indexOf</code>方法一致，主要的区别是<code>lastIndexOf</code>从尾部开始匹配，<code>indexOf</code>则是从头部开始匹配  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;hello world&#x27;</span>.lastIndexOf(<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-comment">// 7</span><br></code></pre></div></td></tr></table></figure>
<p>另外，<code>lastIndexOf</code>的第二个参数表示从该位置起向前匹配  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;hello world&#x27;</span>.lastIndexOf(<span class="hljs-string">&#x27;o&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 4</span><br></code></pre></div></td></tr></table></figure>


<h4 id="String-prototype-trim"><a href="#String-prototype-trim" class="headerlink" title="String.prototype.trim()"></a>String.prototype.trim()</h4><p><code>trim</code>方法用于去除字符串两端的空格，返回一个新字符串，不改变原字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;  hello world  &#x27;</span>.trim() <span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>该方法去除的不仅是空格，还包括制表符（<code>\t</code>、<code>\v</code>）、换行符（<code>\n</code>）和回车符（<code>\r</code>）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;\r\nabc \t&#x27;</span>.trim() <span class="hljs-comment">// &#x27;abc&#x27;</span><br></code></pre></div></td></tr></table></figure>


<h4 id="String-prototype-toLowerCase-，String-prototype-toUpperCase"><a href="#String-prototype-toLowerCase-，String-prototype-toUpperCase" class="headerlink" title="String.prototype.toLowerCase()，String.prototype.toUpperCase()"></a>String.prototype.toLowerCase()，String.prototype.toUpperCase()</h4><p><code>toLowerCase</code>方法用于将一个字符串全部转为小写，<code>toUpperCase</code>则是全部转为大写。它们都返回一个新字符串，不改变原字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;Hello World&#x27;</span>.toLowerCase()<br><span class="hljs-comment">// &quot;hello world&quot;</span><br><br><span class="hljs-string">&#x27;Hello World&#x27;</span>.toUpperCase()<br><span class="hljs-comment">// &quot;HELLO WORLD&quot;</span><br></code></pre></div></td></tr></table></figure>


<h4 id="String-prototype-match"><a href="#String-prototype-match" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h4><p><code>match</code>方法用于确定原字符串是否匹配某个子字符串，返回一个数组，成员为匹配的第一个字符串。如果没有找到匹配，则返回<code>null</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;cat, bat, sat, fat&#x27;</span>.match(<span class="hljs-string">&#x27;at&#x27;</span>) <span class="hljs-comment">// [&quot;at&quot;]</span><br><span class="hljs-string">&#x27;cat, bat, sat, fat&#x27;</span>.match(<span class="hljs-string">&#x27;xt&#x27;</span>) <span class="hljs-comment">// null</span><br></code></pre></div></td></tr></table></figure>
<p>返回的数组还有<code>index</code>属性和<code>input</code>属性，分别表示匹配字符串开始的位置和原始字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> matches = <span class="hljs-string">&#x27;cat, bat, sat, fat&#x27;</span>.match(<span class="hljs-string">&#x27;at&#x27;</span>);<br>matches.index <span class="hljs-comment">// 1</span><br>matches.input <span class="hljs-comment">// &quot;cat, bat, sat, fat&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><code>match</code>方法还可以使用正则表达式作为参数  </p>
<h4 id="String-prototype-search"><a href="#String-prototype-search" class="headerlink" title="String.prototype.search()"></a>String.prototype.search()</h4><p><code>search</code>方法的用法基本等同于<code>match</code>，但是返回值为匹配的第一个位置。如果没有找到匹配，则返回<code>-1</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;cat, bat, sat, fat&#x27;</span>.search(<span class="hljs-string">&#x27;at&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p><code>search</code>方法还可以使用正则表达式作为参数  </p>
<h4 id="String-prototype-replace"><a href="#String-prototype-replace" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h4><p><code>replace</code>方法用于替换匹配的子字符串，一般情况下只替换第一个匹配（除非使用带有<code>g</code>修饰符的正则表达式）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;aaa&#x27;</span>.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// &quot;baa&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><code>replace</code>方法还可以使用正则表达式作为参数  </p>
<h4 id="String-prototype-split"><a href="#String-prototype-split" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h4><p><code>split</code>方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>如果分割规则为空字符串，则返回数组的成员是原字符串的每一个字符  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;|&quot;, &quot;b&quot;, &quot;|&quot;, &quot;c&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>如果省略参数，则返回数组的唯一成员就是原字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split() <span class="hljs-comment">// [&quot;a|b|c&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>如果满足分割规则的两个部分紧邻着（即两个分割符中间没有其他字符），则返回数组之中会有一个空字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a||c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>) <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;&#x27;, &#x27;c&#x27;]</span><br></code></pre></div></td></tr></table></figure>
<p>如果满足分割规则的部分处于字符串的开头或结尾（即它的前面或后面没有其他字符），则返回数组的第一个或最后一个成员是一个空字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>) <span class="hljs-comment">// [&quot;&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="hljs-string">&#x27;a|b|&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p><code>split</code>方法还可以接受第二个参数，限定返回数组的最大成员数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// []</span><br><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// [&quot;a&quot;]</span><br><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;]</span><br><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br><span class="hljs-string">&#x27;a|b|c&#x27;</span>.split(<span class="hljs-string">&#x27;|&#x27;</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>split</code>方法的第二个参数，决定了返回数组的成员数  </p>
<p><code>split</code>方法还可以使用正则表达式作为参数  </p>
<h4 id="String-prototype-localeCompare"><a href="#String-prototype-localeCompare" class="headerlink" title="String.prototype.localeCompare()"></a>String.prototype.localeCompare()</h4><p><code>localeCompare</code>方法用于比较两个字符串。它返回一个整数  </p>
<p>如果小于0，表示第一个字符串小于第二个字符串  </p>
<p>如果等于0，表示两者相等  </p>
<p>如果大于0，表示第一个字符串大于第二个字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;apple&#x27;</span>.localeCompare(<span class="hljs-string">&#x27;banana&#x27;</span>) <span class="hljs-comment">// -1</span><br><span class="hljs-string">&#x27;apple&#x27;</span>.localeCompare(<span class="hljs-string">&#x27;apple&#x27;</span>) <span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure>
<p>该方法的最大特点，就是会考虑自然语言的顺序。举例来说，正常情况下，大写的英文字母小于小写字母  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;B&#x27;</span> &gt; <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，字母<code>B</code>小于字母<code>a</code>。因为 <code>Javascript</code> 采用的是 <code>Unicode</code> 码点比较，<code>B</code>的码点是66，而<code>a</code>的码点是97  </p>
<p>但是，<code>localeCompare</code>方法会考虑自然语言的排序情况，将<code>B</code>排在<code>a</code>的前面  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;B&#x27;</span>.localeCompare(<span class="hljs-string">&#x27;a&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>localeCompare</code>方法返回整数1，表示<code>B</code>较大  </p>
<p><code>localeCompare</code>还可以有第二个参数，指定所使用的语言（默认是英语），然后根据该语言的规则进行比较  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;ä&#x27;</span>.localeCompare(<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;de&#x27;</span>) <span class="hljs-comment">// -1</span><br><span class="hljs-string">&#x27;ä&#x27;</span>.localeCompare(<span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-string">&#x27;sv&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>de</code>表示德语，<code>sv</code>表示瑞典语。德语中，<code>ä</code>小于<code>z</code>，所以返回<code>-1</code>；瑞典语中，<code>ä</code>大于<code>z</code>，所以返回<code>1</code>    </p>
<h2 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h2><p><code>Math</code>是<code> Javascript</code> 的原生对象，提供各种数学功能  </p>
<p>该对象不是构造函数，不能生成实例，所有的属性和方法都必须在<code>Math</code>对象上调用  </p>
<h3 id="静态属性-1"><a href="#静态属性-1" class="headerlink" title="静态属性"></a>静态属性</h3><p><code>Math</code>对象的静态属性，提供以下一些数学常数  </p>
<ul>
<li><code>Math.E</code>：常数<code>e</code>  </li>
<li><code>Math.LN2</code>：2 的自然对数  </li>
<li><code>Math.LN10</code>：10 的自然对数  </li>
<li><code>Math.LOG2E</code>：以 2 为底的<code>e</code>的对数  </li>
<li><code>Math.LOG10E</code>：以 10 为底的<code>e</code>的对数  </li>
<li><code>Math.PI</code>：常数<code>π</code>  </li>
<li><code>Math.SQRT1_2</code>：0.5 的平方根  </li>
<li><code>Math.SQRT2</code>：2 的平方根  </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.E <span class="hljs-comment">// 2.718281828459045</span><br><span class="hljs-built_in">Math</span>.LN2 <span class="hljs-comment">// 0.6931471805599453</span><br><span class="hljs-built_in">Math</span>.LN10 <span class="hljs-comment">// 2.302585092994046</span><br><span class="hljs-built_in">Math</span>.LOG2E <span class="hljs-comment">// 1.4426950408889634</span><br><span class="hljs-built_in">Math</span>.LOG10E <span class="hljs-comment">// 0.4342944819032518</span><br><span class="hljs-built_in">Math</span>.PI <span class="hljs-comment">// 3.141592653589793</span><br><span class="hljs-built_in">Math</span>.SQRT1_2 <span class="hljs-comment">// 0.7071067811865476</span><br><span class="hljs-built_in">Math</span>.SQRT2 <span class="hljs-comment">// 1.4142135623730951</span><br></code></pre></div></td></tr></table></figure>
<p>这些属性都是只读的，不能修改。</p>
<h3 id="静态方法-2"><a href="#静态方法-2" class="headerlink" title="静态方法"></a>静态方法</h3><p><code>Math</code>对象提供以下一些静态方法  </p>
<ul>
<li><code>Math.abs()</code>：绝对值</li>
<li><code>Math.ceil()</code>：向上取整</li>
<li><code>Math.floor()</code>：向下取整</li>
<li><code>Math.max()</code>：最大值</li>
<li><code>Math.min()</code>：最小值</li>
<li><code>Math.pow()</code>：幂运算</li>
<li><code>Math.sqrt()</code>：平方根</li>
<li><code>Math.log()</code>：自然对数</li>
<li><code>Math.exp()</code>：<code>e</code>的指数</li>
<li><code>Math.round()</code>：四舍五入</li>
<li><code>Math.random()</code>：随机数</li>
</ul>
<h4 id="Math-abs"><a href="#Math-abs" class="headerlink" title="Math.abs()"></a>Math.abs()</h4><p><code>Math.abs</code>方法返回参数值的绝对值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.abs(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">Math</span>.abs(-<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<h4 id="Math-max-，Math-min"><a href="#Math-max-，Math-min" class="headerlink" title="Math.max()，Math.min()"></a>Math.max()，Math.min()</h4><p><code>Math.max</code>方法返回参数之中最大的那个值，<code>Math.min</code>返回最小的那个值。如果参数为空, <code>Math.min</code>返回<code>Infinity</code>, <code>Math.max</code>返回<code>-Infinity</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.max(<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 5</span><br><span class="hljs-built_in">Math</span>.min(<span class="hljs-number">2</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// -1</span><br><span class="hljs-built_in">Math</span>.min() <span class="hljs-comment">// Infinity</span><br><span class="hljs-built_in">Math</span>.max() <span class="hljs-comment">// -Infinity</span><br></code></pre></div></td></tr></table></figure>
<h4 id="Math-floor-，Math-ceil"><a href="#Math-floor-，Math-ceil" class="headerlink" title="Math.floor()，Math.ceil()"></a>Math.floor()，Math.ceil()</h4><p><code>Math.floor</code>方法返回小于或等于参数值的最大整数（地板值）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.floor(<span class="hljs-number">3.2</span>) <span class="hljs-comment">// 3</span><br><span class="hljs-built_in">Math</span>.floor(-<span class="hljs-number">3.2</span>) <span class="hljs-comment">// -4</span><br></code></pre></div></td></tr></table></figure>
<p><code>Math.ceil</code>方法返回大于或等于参数值的最小整数（天花板值）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.ceil(<span class="hljs-number">3.2</span>) <span class="hljs-comment">// 4</span><br><span class="hljs-built_in">Math</span>.ceil(-<span class="hljs-number">3.2</span>) <span class="hljs-comment">// -3</span><br></code></pre></div></td></tr></table></figure>
<p>这两个方法可以结合起来，实现一个总是返回数值的整数部分的函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ToInteger</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  x = <span class="hljs-built_in">Number</span>(x);<br>  <span class="hljs-keyword">return</span> x &lt; <span class="hljs-number">0</span> ? <span class="hljs-built_in">Math</span>.ceil(x) : <span class="hljs-built_in">Math</span>.floor(x);<br>&#125;<br><br>ToInteger(<span class="hljs-number">3.2</span>) <span class="hljs-comment">// 3</span><br>ToInteger(<span class="hljs-number">3.5</span>) <span class="hljs-comment">// 3</span><br>ToInteger(<span class="hljs-number">3.8</span>) <span class="hljs-comment">// 3</span><br>ToInteger(-<span class="hljs-number">3.2</span>) <span class="hljs-comment">// -3</span><br>ToInteger(-<span class="hljs-number">3.5</span>) <span class="hljs-comment">// -3</span><br>ToInteger(-<span class="hljs-number">3.8</span>) <span class="hljs-comment">// -3</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，不管正数或负数，<code>ToInteger</code>函数总是返回一个数值的整数部分  </p>
<h4 id="Math-round"><a href="#Math-round" class="headerlink" title="Math.round()"></a>Math.round()</h4><p><code>Math.round</code>方法用于四舍五入  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.round(<span class="hljs-number">0.1</span>) <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">Math</span>.round(<span class="hljs-number">0.5</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">Math</span>.round(<span class="hljs-number">0.6</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">Math</span>.floor(x + <span class="hljs-number">0.5</span>)<br></code></pre></div></td></tr></table></figure>
<p>注意，它对负数的处理（主要是对<code>0.5</code>的处理）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.round(-<span class="hljs-number">1.1</span>) <span class="hljs-comment">// -1</span><br><span class="hljs-built_in">Math</span>.round(-<span class="hljs-number">1.5</span>) <span class="hljs-comment">// -1</span><br><span class="hljs-built_in">Math</span>.round(-<span class="hljs-number">1.6</span>) <span class="hljs-comment">// -2</span><br></code></pre></div></td></tr></table></figure>
<h4 id="Math-pow"><a href="#Math-pow" class="headerlink" title="Math.pow()"></a>Math.pow()</h4><p><code>Math.pow</code>方法返回以第一个参数为底数、第二个参数为指数的幂运算值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 等同于 2 ** 2</span><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 4</span><br><span class="hljs-comment">// 等同于 2 ** 3</span><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 8</span><br></code></pre></div></td></tr></table></figure>
<p>下面是计算圆面积的方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> radius = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">var</span> area = <span class="hljs-built_in">Math</span>.PI * <span class="hljs-built_in">Math</span>.pow(radius, <span class="hljs-number">2</span>);<br></code></pre></div></td></tr></table></figure>
<h4 id="Math-sqrt"><a href="#Math-sqrt" class="headerlink" title="Math.sqrt()"></a>Math.sqrt()</h4><p><code>Math.sqrt</code>方法返回参数值的平方根。如果参数是一个负值，则返回<code>NaN</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.sqrt(<span class="hljs-number">4</span>) <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">Math</span>.sqrt(-<span class="hljs-number">4</span>) <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure>
<h4 id="Math-log"><a href="#Math-log" class="headerlink" title="Math.log()"></a>Math.log()</h4><p><code>Math.log</code>方法返回以<code>e</code>为底的自然对数值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.log(<span class="hljs-built_in">Math</span>.E) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">Math</span>.log(<span class="hljs-number">10</span>) <span class="hljs-comment">// 2.302585092994046</span><br></code></pre></div></td></tr></table></figure>
<p>如果要计算以10为底的对数，可以先用<code>Math.log</code>求出自然对数，然后除以<code>Math.LN10</code>；求以2为底的对数，可以除以<code>Math.LN2</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.log(<span class="hljs-number">100</span>)/<span class="hljs-built_in">Math</span>.LN10 <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">Math</span>.log(<span class="hljs-number">8</span>)/<span class="hljs-built_in">Math</span>.LN2 <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<h4 id="Math-exp"><a href="#Math-exp" class="headerlink" title="Math.exp()"></a>Math.exp()</h4><p><code>Math.exp</code>方法返回常数<code>e</code>的参数次方。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.exp(<span class="hljs-number">1</span>) <span class="hljs-comment">// 2.718281828459045</span><br><span class="hljs-built_in">Math</span>.exp(<span class="hljs-number">3</span>) <span class="hljs-comment">// 20.085536923187668</span><br></code></pre></div></td></tr></table></figure>
<h4 id="Math-random"><a href="#Math-random" class="headerlink" title="Math.random()"></a>Math.random()</h4><p><code>Math.random()</code>返回0到1之间的一个伪随机数，可能等于0，但是一定小于1  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.random() <span class="hljs-comment">// 0.7151307314634323</span><br></code></pre></div></td></tr></table></figure>
<p>任意范围的随机数生成函数如下   </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandomArbitrary</span>(<span class="hljs-params">min, max</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() * (max - min) + min;<br>&#125;<br><br>getRandomArbitrary(<span class="hljs-number">1.5</span>, <span class="hljs-number">6.5</span>)<br><span class="hljs-comment">// 2.4942810038223864</span><br></code></pre></div></td></tr></table></figure>
<p>任意范围的随机整数生成函数如下  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandomInt</span>(<span class="hljs-params">min, max</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (max - min + <span class="hljs-number">1</span>)) + min;<br>&#125;<br><br>getRandomInt(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 5</span><br></code></pre></div></td></tr></table></figure>
<p>返回随机字符的例子如下  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">random_str</span>(<span class="hljs-params">length</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> ALPHABET = <span class="hljs-string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span>;<br>  ALPHABET += <span class="hljs-string">&#x27;abcdefghijklmnopqrstuvwxyz&#x27;</span>;<br>  ALPHABET += <span class="hljs-string">&#x27;0123456789-_&#x27;</span>;<br>  <span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; ++i) &#123;<br>    <span class="hljs-keyword">var</span> rand = <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * ALPHABET.length);<br>    str += ALPHABET.substring(rand, rand + <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> str;<br>&#125;<br><br>random_str(<span class="hljs-number">6</span>) <span class="hljs-comment">// &quot;NdQKOr&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>random_str</code>函数接受一个整数作为参数，返回变量<code>ALPHABET</code>内的随机字符所组成的指定长度的字符串  </p>
<h4 id="三角函数方法"><a href="#三角函数方法" class="headerlink" title="三角函数方法"></a>三角函数方法</h4><p><code>Math</code>对象还提供一系列三角函数方法。</p>
<ul>
<li><code>Math.sin()</code>：返回参数的正弦（参数为弧度值）</li>
<li><code>Math.cos()</code>：返回参数的余弦（参数为弧度值）</li>
<li><code>Math.tan()</code>：返回参数的正切（参数为弧度值）</li>
<li><code>Math.asin()</code>：返回参数的反正弦（返回值为弧度值）</li>
<li><code>Math.acos()</code>：返回参数的反余弦（返回值为弧度值）</li>
<li><code>Math.atan()</code>：返回参数的反正切（返回值为弧度值）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.sin(<span class="hljs-number">0</span>) <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">Math</span>.cos(<span class="hljs-number">0</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">Math</span>.tan(<span class="hljs-number">0</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">Math</span>.sin(<span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">2</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">Math</span>.asin(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1.5707963267948966</span><br><span class="hljs-built_in">Math</span>.acos(<span class="hljs-number">1</span>) <span class="hljs-comment">// 0</span><br><span class="hljs-built_in">Math</span>.atan(<span class="hljs-number">1</span>) <span class="hljs-comment">// 0.7853981633974483</span><br></code></pre></div></td></tr></table></figure>


<h2 id="Date-对象"><a href="#Date-对象" class="headerlink" title="Date 对象"></a>Date 对象</h2><p><code>Date</code>对象是 <code>Javascript</code> 原生的时间库。它以国际标准时间（UTC）1970年1月1日00:00:00作为时间的零点，可以表示的时间范围是前后各1亿天（单位为毫秒）  </p>
<h3 id="普通函数的用法"><a href="#普通函数的用法" class="headerlink" title="普通函数的用法"></a>普通函数的用法</h3><p><code>Date</code>对象可以作为普通函数直接调用，返回一个代表当前时间的字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Date</span>()<br><span class="hljs-comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>注意，即使带有参数，<code>Date</code>作为普通函数使用时，返回的还是当前时间  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Date</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码说明，无论有没有参数，直接调用<code>Date</code>总是返回当前时间  </p>
<h3 id="构造函数的用法"><a href="#构造函数的用法" class="headerlink" title="构造函数的用法"></a>构造函数的用法</h3><p><code>Date</code>还可以当作构造函数使用。对它使用<code>new</code>命令，会返回一个<code>Date</code>对象的实例。如果不加参数，实例代表的就是当前时间  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> today = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br></code></pre></div></td></tr></table></figure>
<p><code>Date</code>实例有一个独特的地方。其他对象求值的时候，都是默认调用<code>.valueOf()</code>方法，但是<code>Date</code>实例求值的时候，默认调用的是<code>toString()</code>方法。这导致对<code>Date</code>实例求值，返回的是一个字符串，代表该实例对应的时间  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> today = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><br>today<br><span class="hljs-comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br><br><span class="hljs-comment">// 等同于</span><br>today.toString()<br><span class="hljs-comment">// &quot;Tue Dec 01 2015 09:34:43 GMT+0800 (CST)&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>today</code>是<code>Date</code>的实例，直接求值等同于调用<code>toString</code>方法  </p>
<p>作为构造函数时，<code>Date</code>对象可以接受多种格式的参数，返回一个该参数对应的时间实例  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 参数为时间零点开始计算的毫秒数</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">1378218728000</span>)<br><span class="hljs-comment">// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)</span><br><br><span class="hljs-comment">// 参数为日期字符串</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;January 6, 2013&#x27;</span>);<br><span class="hljs-comment">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span><br><br><span class="hljs-comment">// 参数为多个整数，</span><br><span class="hljs-comment">// 代表年、月、日、小时、分钟、秒、毫秒</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br></code></pre></div></td></tr></table></figure>
<p>关于<code>Date</code>构造函数的参数，有几点说明  </p>
<p>第一点，参数可以是负整数，代表1970年元旦之前的时间  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(-<span class="hljs-number">1378218728000</span>)<br><span class="hljs-comment">// Fri Apr 30 1926 17:27:52 GMT+0800 (CST)</span><br></code></pre></div></td></tr></table></figure>
<p>第二点，只要是能被<code>Date.parse()</code>方法解析的字符串，都可以当作参数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;2013-2-15&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;2013/2/15&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;02/15/2013&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;2013-FEB-15&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;FEB, 15, 2013&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;FEB 15, 2013&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;February, 15, 2013&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;February 15, 2013&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;15 Feb 2013&#x27;</span>)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;15, February, 2013&#x27;</span>)<br><span class="hljs-comment">// Fri Feb 15 2013 00:00:00 GMT+0800 (CST)</span><br></code></pre></div></td></tr></table></figure>
<p>上面多种日期字符串的写法，返回的都是同一个时间  </p>
<p>第三，参数为年、月、日等多个整数时，年和月是不能省略的，其他参数都可以省略的。也就是说，这时至少需要两个参数，因为如果只使用“年”这一个参数，<code>Date</code>会将其解释为毫秒数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>)<br><span class="hljs-comment">// Thu Jan 01 1970 08:00:02 GMT+0800 (CST)</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，2013被解释为毫秒数，而不是年份  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// Tue Jan 01 2013 00:00:00 GMT+0800 (CST)</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，不管有几个参数，返回的都是2013年1月1日零点  </p>
<p>最后，各个参数的取值范围如下  </p>
<ul>
<li>年：使用四位数年份，比如<code>2000</code>。如果写成两位数或个位数，则加上<code>1900</code>，即<code>10</code>代表1910年。如果是负数，表示公元前  </li>
<li>月：<code>0</code>表示一月，依次类推，<code>11</code>表示12月  </li>
<li>日：<code>1</code>到<code>31</code>  </li>
<li>小时：<code>0</code>到<code>23</code>  </li>
<li>分钟：<code>0</code>到<code>59</code>  </li>
<li>秒：<code>0</code>到<code>59</code>  </li>
<li>毫秒：<code>0</code>到<code>999</code>  </li>
</ul>
<p>注意，月份从<code>0</code>开始计算，但是，天数从<code>1</code>开始计算。另外，除了日期的默认值为<code>1</code>，小时、分钟、秒钟和毫秒的默认值都是<code>0</code>。</p>
<p>这些参数如果超出了正常范围，会被自动折算。比如，如果月设为<code>15</code>，就折算为下一年的4月  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">15</span>)<br><span class="hljs-comment">// Tue Apr 01 2014 00:00:00 GMT+0800 (CST)</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br><span class="hljs-comment">// Mon Dec 31 2012 00:00:00 GMT+0800 (CST)</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的第二个例子，日期设为<code>0</code>，就代表上个月的最后一天  </p>
<p>参数还可以使用负数，表示扣去的时间  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, -<span class="hljs-number">1</span>)<br><span class="hljs-comment">// Sat Dec 01 2012 00:00:00 GMT+0800 (CST)</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>)<br><span class="hljs-comment">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，分别对月和日使用了负数，表示从基准日扣去相应的时间  </p>
<h3 id="日期的运算"><a href="#日期的运算" class="headerlink" title="日期的运算"></a>日期的运算</h3><p>类型自动转换时，<code>Date</code>实例如果转为数值，则等于对应的毫秒数；如果转为字符串，则等于对应的日期字符串  </p>
<p>所以，两个日期实例对象进行减法运算时，返回的是它们间隔的毫秒数；进行加法运算时，返回的是两个字符串连接而成的新字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br><span class="hljs-keyword">var</span> d2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2000</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>);<br><br>d2 - d1<br><span class="hljs-comment">// 2678400000</span><br>d2 + d1<br><span class="hljs-comment">// &quot;Sat Apr 01 2000 00:00:00 GMT+0800 (CST)Wed Mar 01 2000 00:00:00 GMT+0800 (CST)&quot;</span><br></code></pre></div></td></tr></table></figure>


<h3 id="静态方法-3"><a href="#静态方法-3" class="headerlink" title="静态方法"></a>静态方法</h3><h4 id="Date-now"><a href="#Date-now" class="headerlink" title="Date.now()"></a>Date.now()</h4><p><code>Date.now</code>方法返回当前时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数，相当于 Unix 时间戳乘以1000。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Date</span>.now() <span class="hljs-comment">// 1364026285194</span><br></code></pre></div></td></tr></table></figure>


<h4 id="Date-parse"><a href="#Date-parse" class="headerlink" title="Date.parse()"></a>Date.parse()</h4><p><code>Date.parse</code>方法用来解析日期字符串，返回该时间距离时间零点（1970年1月1日 00:00:00）的毫秒数  </p>
<p>日期字符串应该符合 RFC 2822 和 ISO 8061 这两个标准，即<code>YYYY-MM-DDTHH:mm:ss.sssZ</code>格式，其中最后的<code>Z</code>表示时区。但是，其他格式也可以被解析  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;Aug 9, 1995&#x27;</span>)<br><span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;January 26, 2011 13:51:50&#x27;</span>)<br><span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;Mon, 25 Dec 1995 13:30:00 GMT&#x27;</span>)<br><span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;Mon, 25 Dec 1995 13:30:00 +0430&#x27;</span>)<br><span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;2011-10-10&#x27;</span>)<br><span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;2011-10-10T14:48:00&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<p>上面的日期字符串都可以解析  </p>
<p>如果解析失败，返回<code>NaN</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Date</span>.parse(<span class="hljs-string">&#x27;xxx&#x27;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure>


<h4 id="Date-UTC"><a href="#Date-UTC" class="headerlink" title="Date.UTC()"></a>Date.UTC()</h4><p><code>Date.UTC</code>方法接受年、月、日等变量作为参数，返回该时间距离时间零点（1970年1月1日 00:00:00 UTC）的毫秒数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 格式</span><br><span class="hljs-built_in">Date</span>.UTC(year, month[, date[, hrs[, min[, sec[, ms]]]]])<br><br><span class="hljs-comment">// 用法</span><br><span class="hljs-built_in">Date</span>.UTC(<span class="hljs-number">2011</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">567</span>)<br><span class="hljs-comment">// 1293847384567</span><br></code></pre></div></td></tr></table></figure>
<p>该方法的参数用法与<code>Date</code>构造函数完全一致，比如月从<code>0</code>开始计算，日期从<code>1</code>开始计算。区别在于<code>Date.UTC</code>方法的参数，会被解释为 UTC 时间（世界标准时间），<code>Date</code>构造函数的参数会被解释为当前时区的时间  </p>
<h3 id="实例方法-4"><a href="#实例方法-4" class="headerlink" title="实例方法"></a>实例方法</h3><p><code>Date</code>的实例对象，有几十个自己的方法，除了<code>valueOf</code>和<code>toString</code>，可以分为以下三类  </p>
<ul>
<li><code>to</code>类：从<code>Date</code>对象返回一个字符串，表示指定的时间  </li>
<li><code>get</code>类：获取<code>Date</code>对象的日期和时间  </li>
<li><code>set</code>类：设置<code>Date</code>对象的日期和时间  </li>
</ul>
<h4 id="Date-prototype-valueOf"><a href="#Date-prototype-valueOf" class="headerlink" title="Date.prototype.valueOf()"></a>Date.prototype.valueOf()</h4><p><code>valueOf</code>方法返回实例对象距离时间零点（1970年1月1日00:00:00 UTC）对应的毫秒数，该方法等同于<code>getTime</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><br>d.valueOf() <span class="hljs-comment">// 1362790014817</span><br>d.getTime() <span class="hljs-comment">// 1362790014817</span><br></code></pre></div></td></tr></table></figure>
<p>预期为数值的场合，<code>Date</code>实例会自动调用该方法，所以可以用下面的方法计算时间的间隔  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> start = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">var</span> end = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><span class="hljs-keyword">var</span> elapsed = end - start;<br></code></pre></div></td></tr></table></figure>


<h4 id="to-类方法"><a href="#to-类方法" class="headerlink" title="to 类方法"></a>to 类方法</h4><p><strong>（1）Date.prototype.toString()</strong>  </p>
<p><code>toString</code>方法返回一个完整的日期字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>d.toString()<br><span class="hljs-comment">// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;</span><br>d<br><span class="hljs-comment">// &quot;Tue Jan 01 2013 00:00:00 GMT+0800 (CST)&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>因为<code>toString</code>是默认的调用方法，所以如果直接读取<code>Date</code>实例，就相当于调用这个方法  </p>
<p><strong>（2）Date.prototype.toUTCString()</strong>  </p>
<p><code>toUTCString</code>方法返回对应的 UTC 时间，也就是比北京时间晚8个小时  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>d.toUTCString()<br><span class="hljs-comment">// &quot;Mon, 31 Dec 2012 16:00:00 GMT&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（3）Date.prototype.toISOString()</strong>  </p>
<p><code>toISOString</code>方法返回对应时间的 ISO8601 写法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>d.toISOString()<br><span class="hljs-comment">// &quot;2012-12-31T16:00:00.000Z&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>注意，<code>toISOString</code>方法返回的总是 UTC 时区的时间  </p>
<p><strong>（4）Date.prototype.toJSON()</strong>  </p>
<p><code>toJSON</code>方法返回一个符合 JSON 格式的 ISO 日期字符串，与<code>toISOString</code>方法的返回结果完全相同  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>d.toJSON()<br><span class="hljs-comment">// &quot;2012-12-31T16:00:00.000Z&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（5）Date.prototype.toDateString()</strong>  </p>
<p><code>toDateString</code>方法返回日期字符串（不含小时、分和秒）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>d.toDateString() <span class="hljs-comment">// &quot;Tue Jan 01 2013&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（6）Date.prototype.toTimeString()</strong>  </p>
<p><code>toTimeString</code>方法返回时间字符串（不含年月日）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>d.toTimeString() <span class="hljs-comment">// &quot;00:00:00 GMT+0800 (CST)&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（7）本地时间</strong>  </p>
<p>以下三种方法，可以将 Date 实例转为表示本地时间的字符串  </p>
<ul>
<li><code>Date.prototype.toLocaleString()</code>：完整的本地时间  </li>
<li><code>Date.prototype.toLocaleDateString()</code>：本地日期（不含小时、分和秒）  </li>
<li><code>Date.prototype.toLocaleTimeString()</code>：本地时间（不含年月日）  </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>d.toLocaleString()<br><span class="hljs-comment">// 中文版浏览器为&quot;2013年1月1日 上午12:00:00&quot;</span><br><span class="hljs-comment">// 英文版浏览器为&quot;1/1/2013 12:00:00 AM&quot;</span><br><br>d.toLocaleDateString()<br><span class="hljs-comment">// 中文版浏览器为&quot;2013年1月1日&quot;</span><br><span class="hljs-comment">// 英文版浏览器为&quot;1/1/2013&quot;</span><br><br>d.toLocaleTimeString()<br><span class="hljs-comment">// 中文版浏览器为&quot;上午12:00:00&quot;</span><br><span class="hljs-comment">// 英文版浏览器为&quot;12:00:00 AM&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>这三个方法都有两个可选的参数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">dateObj.toLocaleString([locales[, options]])<br>dateObj.toLocaleDateString([locales[, options]])<br>dateObj.toLocaleTimeString([locales[, options]])<br></code></pre></div></td></tr></table></figure>
<p>这两个参数中，<code>locales</code>是一个指定所用语言的字符串，<code>options</code>是一个配置对象  </p>
<p>下面是<code>locales</code>的例子，分别采用<code>en-US</code>和<code>zh-CN</code>语言设定  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>d.toLocaleString(<span class="hljs-string">&#x27;en-US&#x27;</span>) <span class="hljs-comment">// &quot;1/1/2013, 12:00:00 AM&quot;</span><br>d.toLocaleString(<span class="hljs-string">&#x27;zh-CN&#x27;</span>) <span class="hljs-comment">// &quot;2013/1/1 上午12:00:00&quot;</span><br><br>d.toLocaleDateString(<span class="hljs-string">&#x27;en-US&#x27;</span>) <span class="hljs-comment">// &quot;1/1/2013&quot;</span><br>d.toLocaleDateString(<span class="hljs-string">&#x27;zh-CN&#x27;</span>) <span class="hljs-comment">// &quot;2013/1/1&quot;</span><br><br>d.toLocaleTimeString(<span class="hljs-string">&#x27;en-US&#x27;</span>) <span class="hljs-comment">// &quot;12:00:00 AM&quot;</span><br>d.toLocaleTimeString(<span class="hljs-string">&#x27;zh-CN&#x27;</span>) <span class="hljs-comment">// &quot;上午12:00:00&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><code>options</code>配置对象有以下属性  </p>
<ul>
<li><code>dateStyle</code>：可能的值为<code>full</code>、<code>long</code>、<code>medium</code>、<code>short</code>  </li>
<li><code>timeStyle</code>：可能的值为<code>full</code>、<code>long</code>、<code>medium</code>、<code>short </code> </li>
<li><code>month</code>：可能的值为<code>numeric</code>、<code>2-digit</code>、<code>long</code>、<code>short</code>、<code>narrow </code> </li>
<li><code>year</code>：可能的值为<code>numeric</code>、<code>2-digit</code>  </li>
<li><code>weekday</code>：可能的值为<code>long</code>、<code>short</code>、<code>narrow</code>  </li>
<li><code>day</code>、<code>hour</code>、<code>minute</code>、<code>second</code>：可能的值为<code>numeric</code>、<code>2-digit </code> </li>
<li><code>timeZone</code>：可能的值为 IANA 的时区数据库  </li>
<li><code>timeZooneName</code>：可能的值为<code>long</code>、<code>short </code> </li>
<li><code>hour12</code>：24小时周期还是12小时周期，可能的值为<code>true</code>、<code>false</code>  </li>
</ul>
<p>下面是用法实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-number">2013</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><br>d.toLocaleDateString(<span class="hljs-string">&#x27;en-US&#x27;</span>, &#123;<br>  weekday: <span class="hljs-string">&#x27;long&#x27;</span>,<br>  year: <span class="hljs-string">&#x27;numeric&#x27;</span>,<br>  month: <span class="hljs-string">&#x27;long&#x27;</span>,<br>  day: <span class="hljs-string">&#x27;numeric&#x27;</span><br>&#125;)<br><span class="hljs-comment">// &quot;Tuesday, January 1, 2013&quot;</span><br><br>d.toLocaleDateString(<span class="hljs-string">&#x27;en-US&#x27;</span>, &#123;<br>  day: <span class="hljs-string">&quot;2-digit&quot;</span>,<br>  month: <span class="hljs-string">&quot;long&quot;</span>,<br>  year: <span class="hljs-string">&quot;2-digit&quot;</span><br>&#125;);<br><span class="hljs-comment">// &quot;January 01, 13&quot;</span><br><br>d.toLocaleTimeString(<span class="hljs-string">&#x27;en-US&#x27;</span>, &#123;<br>  timeZone: <span class="hljs-string">&#x27;UTC&#x27;</span>,<br>  timeZoneName: <span class="hljs-string">&#x27;short&#x27;</span><br>&#125;)<br><span class="hljs-comment">// &quot;4:00:00 PM UTC&quot;</span><br><br>d.toLocaleTimeString(<span class="hljs-string">&#x27;en-US&#x27;</span>, &#123;<br>  timeZone: <span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span>,<br>  timeZoneName: <span class="hljs-string">&#x27;long&#x27;</span><br>&#125;)<br><span class="hljs-comment">// &quot;12:00:00 AM China Standard Time&quot;</span><br><br>d.toLocaleTimeString(<span class="hljs-string">&#x27;en-US&#x27;</span>, &#123;<br>  hour12: <span class="hljs-literal">false</span><br>&#125;)<br><span class="hljs-comment">// &quot;00:00:00&quot;</span><br><br>d.toLocaleTimeString(<span class="hljs-string">&#x27;en-US&#x27;</span>, &#123;<br>  hour12: <span class="hljs-literal">true</span><br>&#125;)<br><span class="hljs-comment">// &quot;12:00:00 AM&quot;</span><br></code></pre></div></td></tr></table></figure>


<h4 id="get-类方法"><a href="#get-类方法" class="headerlink" title="get 类方法"></a>get 类方法</h4><p><code>Date</code>对象提供了一系列<code>get*</code>方法，用来获取实例对象某个方面的值  </p>
<ul>
<li><code>getTime()</code>：返回实例距离1970年1月1日00:00:00的毫秒数，等同于<code>valueOf</code>方法  </li>
<li><code>getDate()</code>：返回实例对象对应每个月的几号（从1开始）  </li>
<li><code>getDay()</code>：返回星期几，星期日为0，星期一为1，以此类推  </li>
<li><code>getFullYear()</code>：返回四位的年份  </li>
<li><code>getMonth()</code>：返回月份（0表示1月，11表示12月）  </li>
<li><code>getHours()</code>：返回小时（0-23）  </li>
<li><code>getMilliseconds()</code>：返回毫秒（0-999）  </li>
<li><code>getMinutes()</code>：返回分钟（0-59）  </li>
<li><code>getSeconds()</code>：返回秒（0-59）  </li>
<li><code>getTimezoneOffset()</code>：返回当前时间与 UTC 的时区差异，以分钟表示，返回结果考虑到了夏令时因素  </li>
</ul>
<p>所有这些<code>get*</code>方法返回的都是整数，不同方法返回值的范围不一样  </p>
<ul>
<li>分钟和秒：0 到 59</li>
<li>小时：0 到 23</li>
<li>星期：0（星期天）到 6（星期六）</li>
<li>日期：1 到 31</li>
<li>月份：0（一月）到 11（十二月）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;January 6, 2013&#x27;</span>);<br><br>d.getDate() <span class="hljs-comment">// 6</span><br>d.getMonth() <span class="hljs-comment">// 0</span><br>d.getFullYear() <span class="hljs-comment">// 2013</span><br>d.getTimezoneOffset() <span class="hljs-comment">// -480</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，最后一行返回<code>-480</code>，即 UTC 时间减去当前时间，单位是分钟。<code>-480</code>表示 UTC 比当前时间少480分钟，即当前时区比 UTC 早8个小时  </p>
<p>下面是一个例子，计算本年度还剩下多少天  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">leftDays</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> today = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>  <span class="hljs-keyword">var</span> endYear = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(today.getFullYear(), <span class="hljs-number">11</span>, <span class="hljs-number">31</span>, <span class="hljs-number">23</span>, <span class="hljs-number">59</span>, <span class="hljs-number">59</span>, <span class="hljs-number">999</span>);<br>  <span class="hljs-keyword">var</span> msPerDay = <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.round((endYear.getTime() - today.getTime()) / msPerDay);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面这些<code>get*</code>方法返回的都是当前时区的时间，<code>Date</code>对象还提供了这些方法对应的 UTC 版本，用来返回 UTC 时间。</p>
<ul>
<li><code>getUTCDate()</code></li>
<li><code>getUTCFullYear()</code></li>
<li><code>getUTCMonth()</code></li>
<li><code>getUTCDay()</code></li>
<li><code>getUTCHours()</code></li>
<li><code>getUTCMinutes()</code></li>
<li><code>getUTCSeconds()</code></li>
<li><code>getUTCMilliseconds()</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;January 6, 2013&#x27;</span>);<br><br>d.getDate() <span class="hljs-comment">// 6</span><br>d.getUTCDate() <span class="hljs-comment">// 5</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，实例对象<code>d</code>表示当前时区（东八时区）的1月6日0点0分0秒，这个时间对于当前时区来说是1月6日，所以<code>getDate</code>方法返回6，对于 UTC 时区来说是1月5日，所以<code>getUTCDate</code>方法返回5  </p>
<h4 id="set-类方法"><a href="#set-类方法" class="headerlink" title="set 类方法"></a>set 类方法</h4><p><code>Date</code>对象提供了一系列<code>set*</code>方法，用来设置实例对象的各个方面  </p>
<ul>
<li><code>setDate(date)</code>：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳  </li>
<li><code>setFullYear(year [, month, date])</code>：设置四位年份  </li>
<li><code>setHours(hour [, min, sec, ms])</code>：设置小时（0-23）  </li>
<li><code>setMilliseconds()</code>：设置毫秒（0-999）  </li>
<li><code>setMinutes(min [, sec, ms])</code>：设置分钟（0-59）  </li>
<li><code>setMonth(month [, date])</code>：设置月份（0-11）  </li>
<li><code>setSeconds(sec [, ms])</code>：设置秒（0-59）  </li>
<li><code>setTime(milliseconds)</code>：设置毫秒时间戳  </li>
</ul>
<p>这些方法基本是跟<code>get*</code>方法一一对应的，但是没有<code>setDay</code>方法，因为星期几是计算出来的，而不是设置的。另外，需要注意的是，凡是涉及到设置月份，都是从0开始算的，即<code>0</code>是1月，<code>11</code>是12月  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> (<span class="hljs-string">&#x27;January 6, 2013&#x27;</span>);<br><br>d <span class="hljs-comment">// Sun Jan 06 2013 00:00:00 GMT+0800 (CST)</span><br>d.setDate(<span class="hljs-number">9</span>) <span class="hljs-comment">// 1357660800000</span><br>d <span class="hljs-comment">// Wed Jan 09 2013 00:00:00 GMT+0800 (CST)</span><br></code></pre></div></td></tr></table></figure>
<p><code>set*</code>方法的参数都会自动折算。以<code>setDate()</code>为例，如果参数超过当月的最大天数，则向下一个月顺延，如果参数是负数，表示从上个月的最后一天开始减去的天数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;January 6, 2013&#x27;</span>);<br><br>d1.setDate(<span class="hljs-number">32</span>) <span class="hljs-comment">// 1359648000000</span><br>d1 <span class="hljs-comment">// Fri Feb 01 2013 00:00:00 GMT+0800 (CST)</span><br><br><span class="hljs-keyword">var</span> d2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span> (<span class="hljs-string">&#x27;January 6, 2013&#x27;</span>);<br><br>d2.setDate(-<span class="hljs-number">1</span>) <span class="hljs-comment">// 1356796800000</span><br>d2 <span class="hljs-comment">// Sun Dec 30 2012 00:00:00 GMT+0800 (CST)</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>d1.setDate(32)</code>将日期设为1月份的32号，因为1月份只有31号，所以自动折算为2月1日。<code>d2.setDate(-1)</code>表示设为上个月的倒数第二天，即12月30日  </p>
<p><code>set</code>类方法和<code>get</code>类方法，可以结合使用，得到相对时间  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><br><span class="hljs-comment">// 将日期向后推1000天</span><br>d.setDate(d.getDate() + <span class="hljs-number">1000</span>);<br><span class="hljs-comment">// 将时间设为6小时后</span><br>d.setHours(d.getHours() + <span class="hljs-number">6</span>);<br><span class="hljs-comment">// 将年份设为去年</span><br>d.setFullYear(d.getFullYear() - <span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure>
<p><code>set*</code>系列方法除了<code>setTime()</code>，都有对应的 UTC 版本，即设置 UTC 时区的时间  </p>
<ul>
<li><code>setUTCDate()</code></li>
<li><code>setUTCFullYear()</code></li>
<li><code>setUTCHours()</code></li>
<li><code>setUTCMilliseconds()</code></li>
<li><code>setUTCMinutes()</code></li>
<li><code>setUTCMonth()</code></li>
<li><code>setUTCSeconds()</code></li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;January 6, 2013&#x27;</span>);<br>d.getUTCHours() <span class="hljs-comment">// 16</span><br>d.setUTCHours(<span class="hljs-number">22</span>) <span class="hljs-comment">// 1357423200000</span><br>d <span class="hljs-comment">// Sun Jan 06 2013 06:00:00 GMT+0800 (CST)</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，本地时区（东八时区）的1月6日0点0分，是 UTC 时区的前一天下午16点。设为 UTC 时区的22点以后，就变为本地时区的上午6点  </p>
<h2 id="RegExp-对象"><a href="#RegExp-对象" class="headerlink" title="RegExp 对象"></a>RegExp 对象</h2><p><code>RegExp</code>对象提供正则表达式的功能  </p>
<h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用来按照“给定模式”匹配文本  </p>
<p>比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址  </p>
<p><code>Javascript</code> 的正则表达式体系是参照 Perl 5 建立的  </p>
<p>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/xyz/</span>;<br></code></pre></div></td></tr></table></figure>
<p>另一种是使用<code>RegExp</code>构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;xyz&#x27;</span>);<br></code></pre></div></td></tr></table></figure>
<p>上面两种写法是等价的，都新建了一个内容为<code>xyz</code>的正则表达式对象。它们的主要区别是</p>
<p>第一种方法在引擎编译代码时，就会新建正则表达式  </p>
<p>第二种方法在运行时新建正则表达式，所以前者的效率较高。而且，前者比较便利和直观  </p>
<p>所以实际应用中，基本上都采用字面量定义正则表达式  </p>
<p><code>RegExp</code>构造函数还可以接受第二个参数，表示修饰符  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;xyz&#x27;</span>, <span class="hljs-string">&#x27;i&#x27;</span>);<br><span class="hljs-comment">// 等价于</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/xyz/i</span>;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，正则表达式<code>/xyz/</code>有一个修饰符<code>i</code>  </p>
<h3 id="实例属性-1"><a href="#实例属性-1" class="headerlink" title="实例属性"></a>实例属性</h3><p>正则对象的实例属性分成两类  </p>
<p>一类是修饰符相关，用于了解设置了什么修饰符  </p>
<ul>
<li><code>RegExp.prototype.ignoreCase</code>：返回一个布尔值，表示是否设置了<code>i</code>修饰符  </li>
<li><code>RegExp.prototype.global</code>：返回一个布尔值，表示是否设置了<code>g</code>修饰符  </li>
<li><code>RegExp.prototype.multiline</code>：返回一个布尔值，表示是否设置了<code>m</code>修饰符  </li>
<li><code>RegExp.prototype.flags</code>：返回一个字符串，包含了已经设置的所有修饰符，按字母排序  </li>
</ul>
<p>上面四个属性都是只读的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/abc/igm</span>;<br><br>r.ignoreCase <span class="hljs-comment">// true</span><br>r.global <span class="hljs-comment">// true</span><br>r.multiline <span class="hljs-comment">// true</span><br>r.flags <span class="hljs-comment">// &#x27;gim&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>另一类是与修饰符无关的属性，主要是下面两个  </p>
<ul>
<li><code>RegExp.prototype.lastIndex</code>：返回一个整数，表示下一次开始搜索的位置。该属性可读写，但是只在进行连续搜索时有意义，详细介绍请看后文  </li>
<li><code>RegExp.prototype.source</code>：返回正则表达式的字符串形式（不包括反斜杠），该属性只读  </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/abc/igm</span>;<br><br>r.lastIndex <span class="hljs-comment">// 0</span><br>r.source <span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></div></td></tr></table></figure>


<h3 id="实例方法-5"><a href="#实例方法-5" class="headerlink" title="实例方法"></a>实例方法</h3><h4 id="RegExp-prototype-test"><a href="#RegExp-prototype-test" class="headerlink" title="RegExp.prototype.test()"></a>RegExp.prototype.test()</h4><p>正则实例对象的<code>test</code>方法返回一个布尔值，表示当前模式是否能匹配参数字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/cat/.test(<span class="hljs-string">&#x27;cats and dogs&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码验证参数字符串之中是否包含<code>cat</code>，结果返回<code>true</code>  </p>
<p>如果正则表达式带有<code>g</code>修饰符，则每一次<code>test</code>方法都从上一次结束的位置开始向后匹配  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/x/g</span>;<br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;_x_x&#x27;</span>;<br><br>r.lastIndex <span class="hljs-comment">// 0</span><br>r.test(s) <span class="hljs-comment">// true</span><br><br>r.lastIndex <span class="hljs-comment">// 2</span><br>r.test(s) <span class="hljs-comment">// true</span><br><br>r.lastIndex <span class="hljs-comment">// 4</span><br>r.test(s) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的正则表达式使用了<code>g</code>修饰符，表示是全局搜索，会有多个结果。接着，三次使用<code>test</code>方法，每一次开始搜索的位置都是上一次匹配的后一个位置  </p>
<p>带有<code>g</code>修饰符时，可以通过正则对象的<code>lastIndex</code>属性指定开始搜索的位置  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/x/g</span>;<br><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;_x_x&#x27;</span>;<br><br>r.lastIndex = <span class="hljs-number">4</span>;<br>r.test(s) <span class="hljs-comment">// false</span><br><br>r.lastIndex <span class="hljs-comment">// 0</span><br>r.test(s)<br></code></pre></div></td></tr></table></figure>
<p>上面代码指定从字符串的第五个位置开始搜索，这个位置为空，所以返回<code>false</code>。同时，<code>lastIndex</code>属性重置为<code>0</code>，所以第二次执行<code>r.test(s)</code>会返回<code>true</code>  </p>
<p>注意，带有<code>g</code>修饰符时，正则表达式内部会记住上一次的<code>lastIndex</code>属性，这时不应该更换所要匹配的字符串，否则会有一些难以察觉的错误  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/bb/g</span>;<br>r.test(<span class="hljs-string">&#x27;bb&#x27;</span>) <span class="hljs-comment">// true</span><br>r.test(<span class="hljs-string">&#x27;-bb-&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，由于正则表达式<code>r</code>是从上一次的<code>lastIndex</code>位置开始匹配，导致第二次执行<code>test</code>方法时出现预期以外的结果  </p>
<p><code>lastIndex</code>属性只对同一个正则表达式有效，所以下面这样写是错误的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-regexp">/a/g</span>.test(<span class="hljs-string">&#x27;babaa&#x27;</span>)) count++;<br></code></pre></div></td></tr></table></figure>
<p>上面代码会导致无限循环，因为<code>while</code>循环的每次匹配条件都是一个新的正则表达式，导致<code>lastIndex</code>属性总是等于0  </p>
<p>如果正则模式是一个空字符串，则匹配所有字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;&#x27;</span>).test(<span class="hljs-string">&#x27;abc&#x27;</span>)<br><span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>


<h4 id="RegExp-prototype-exec"><a href="#RegExp-prototype-exec" class="headerlink" title="RegExp.prototype.exec()"></a>RegExp.prototype.exec()</h4><p>正则实例对象的<code>exec()</code>方法，用来返回匹配结果。如果发现匹配，就返回一个数组，成员是匹配成功的子字符串，否则返回<code>null</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;_x_x&#x27;</span>;<br><span class="hljs-keyword">var</span> r1 = <span class="hljs-regexp">/x/</span>;<br><span class="hljs-keyword">var</span> r2 = <span class="hljs-regexp">/y/</span>;<br><br>r1.exec(s) <span class="hljs-comment">// [&quot;x&quot;]</span><br>r2.exec(s) <span class="hljs-comment">// null</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，正则对象<code>r1</code>匹配成功，返回一个数组，成员是匹配结果；正则对象<code>r2</code>匹配失败，返回<code>null</code>  </p>
<p>如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员  </p>
<p>第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说  </p>
<p>第二个成员对应第一个括号  </p>
<p>第三个成员对应第二个括号，以此类推  </p>
<p>整个数组的<code>length</code>属性等于组匹配的数量再加1  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;_x_x&#x27;</span>;<br><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/_(x)/</span>;<br><br>r.exec(s) <span class="hljs-comment">// [&quot;_x&quot;, &quot;x&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的<code>exec()</code>方法，返回一个数组。第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果  </p>
<p><code>exec()</code>方法的返回数组还包含以下两个属性  </p>
<ul>
<li><code>input</code>：整个原字符串。</li>
<li><code>index</code>：模式匹配成功的开始位置（从0开始计数）。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/a(b+)a/</span>;<br><span class="hljs-keyword">var</span> arr = r.exec(<span class="hljs-string">&#x27;_abbba_aba_&#x27;</span>);<br><br>arr <span class="hljs-comment">// [&quot;abbba&quot;, &quot;bbb&quot;]</span><br><br>arr.index <span class="hljs-comment">// 1</span><br>arr.input <span class="hljs-comment">// &quot;_abbba_aba_&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中的<code>index</code>属性等于1，是因为从原字符串的第二个位置开始匹配成功  </p>
<p>如果正则表达式加上<code>g</code>修饰符，则可以使用多次<code>exec()</code>方法，下一次搜索的位置从上一次匹配成功结束的位置开始  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/a/g</span>;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc_abc_abc&#x27;</span><br><br><span class="hljs-keyword">var</span> r1 = reg.exec(str);<br>r1 <span class="hljs-comment">// [&quot;a&quot;]</span><br>r1.index <span class="hljs-comment">// 0</span><br>reg.lastIndex <span class="hljs-comment">// 1</span><br><br><span class="hljs-keyword">var</span> r2 = reg.exec(str);<br>r2 <span class="hljs-comment">// [&quot;a&quot;]</span><br>r2.index <span class="hljs-comment">// 4</span><br>reg.lastIndex <span class="hljs-comment">// 5</span><br><br><span class="hljs-keyword">var</span> r3 = reg.exec(str);<br>r3 <span class="hljs-comment">// [&quot;a&quot;]</span><br>r3.index <span class="hljs-comment">// 8</span><br>reg.lastIndex <span class="hljs-comment">// 9</span><br><br><span class="hljs-keyword">var</span> r4 = reg.exec(str);<br>r4 <span class="hljs-comment">// null</span><br>reg.lastIndex <span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码连续用了四次<code>exec()</code>方法，前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，匹配结果返回<code>null</code>，正则实例对象的<code>lastIndex</code>属性也重置为<code>0</code>，意味着第四次匹配将从头开始  </p>
<p>利用<code>g</code>修饰符允许多次匹配的特点，可以用一个循环完成全部匹配  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/a/g</span>;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc_abc_abc&#x27;</span><br><br><span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">var</span> match = reg.exec(str);<br>  <span class="hljs-keyword">if</span> (!match) <span class="hljs-keyword">break</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;#&#x27;</span> + match.index + <span class="hljs-string">&#x27;:&#x27;</span> + match[<span class="hljs-number">0</span>]);<br>&#125;<br><span class="hljs-comment">// #0:a</span><br><span class="hljs-comment">// #4:a</span><br><span class="hljs-comment">// #8:a</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，只要<code>exec()</code>方法不返回<code>null</code>，就会一直循环下去，每次输出匹配的位置和匹配的文本  </p>
<p>正则实例对象的<code>lastIndex</code>属性不仅可读，还可写。设置了<code>g</code>修饰符的时候，只要手动设置了<code>lastIndex</code>的值，就会从指定位置开始匹配  </p>
<h3 id="字符串的实例方法"><a href="#字符串的实例方法" class="headerlink" title="字符串的实例方法"></a>字符串的实例方法</h3><p>字符串的实例方法之中，有4种与正则表达式有关  </p>
<ul>
<li><code>String.prototype.match()</code>：返回一个数组，成员是所有匹配的子字符串  </li>
<li><code>String.prototype.search()</code>：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置  </li>
<li><code>String.prototype.replace()</code>：按照给定的正则表达式进行替换，返回替换后的字符串  </li>
<li><code>String.prototype.split()</code>：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员  </li>
</ul>
<h4 id="String-prototype-match-1"><a href="#String-prototype-match-1" class="headerlink" title="String.prototype.match()"></a>String.prototype.match()</h4><p>字符串实例对象的<code>match</code>方法对字符串进行正则匹配，返回匹配结果  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;_x_x&#x27;</span>;<br><span class="hljs-keyword">var</span> r1 = <span class="hljs-regexp">/x/</span>;<br><span class="hljs-keyword">var</span> r2 = <span class="hljs-regexp">/y/</span>;<br><br>s.match(r1) <span class="hljs-comment">// [&quot;x&quot;]</span><br>s.match(r2) <span class="hljs-comment">// null</span><br></code></pre></div></td></tr></table></figure>
<p>从上面代码可以看到，字符串的<code>match</code>方法与正则对象的<code>exec</code>方法非常类似：匹配成功返回一个数组，匹配失败返回<code>null</code>  </p>
<p>如果正则表达式带有<code>g</code>修饰符，则该方法与正则对象的<code>exec</code>方法行为不同，会一次性返回所有匹配成功的结果  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;abba&#x27;</span>;<br><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/a/g</span>;<br><br>s.match(r) <span class="hljs-comment">// [&quot;a&quot;, &quot;a&quot;]</span><br>r.exec(s) <span class="hljs-comment">// [&quot;a&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>设置正则表达式的<code>lastIndex</code>属性，对<code>match</code>方法无效，匹配总是从字符串的第一个字符开始  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> r = <span class="hljs-regexp">/a|b/g</span>;<br>r.lastIndex = <span class="hljs-number">7</span>;<br><span class="hljs-string">&#x27;xaxb&#x27;</span>.match(r) <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;]</span><br>r.lastIndex <span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，设置正则对象的<code>lastIndex</code>属性是无效的  </p>
<h4 id="String-prototype-search-1"><a href="#String-prototype-search-1" class="headerlink" title="String.prototype.search()"></a>String.prototype.search()</h4><p>字符串对象的<code>search</code>方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回<code>-1</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;_x_x&#x27;</span>.search(<span class="hljs-regexp">/x/</span>)<br><span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，第一个匹配结果出现在字符串的<code>1</code>号位置  </p>
<h4 id="String-prototype-replace-1"><a href="#String-prototype-replace-1" class="headerlink" title="String.prototype.replace()"></a>String.prototype.replace()</h4><p>字符串对象的<code>replace</code>方法可以替换匹配的值。它接受两个参数，第一个是正则表达式，表示搜索模式，第二个是替换的内容  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">str.replace(search, replacement)<br></code></pre></div></td></tr></table></figure>
<p>正则表达式如果不加<code>g</code>修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;aaa&#x27;</span>.replace(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// &quot;baa&quot;</span><br><span class="hljs-string">&#x27;aaa&#x27;</span>.replace(<span class="hljs-regexp">/a/</span>, <span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// &quot;baa&quot;</span><br><span class="hljs-string">&#x27;aaa&#x27;</span>.replace(<span class="hljs-regexp">/a/g</span>, <span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// &quot;bbb&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，最后一个正则表达式使用了<code>g</code>修饰符，导致所有的<code>a</code>都被替换掉了  </p>
<p><code>replace</code>方法的一个应用，就是消除字符串首尾两端的空格  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;  #id div.class  &#x27;</span>;<br><br>str.replace(<span class="hljs-regexp">/^\s+|\s+$/g</span>, <span class="hljs-string">&#x27;&#x27;</span>)<br><span class="hljs-comment">// &quot;#id div.class&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><code>replace</code>方法的第二个参数可以使用美元符号<code>$</code>，用来指代所替换的内容  </p>
<ul>
<li><code>$&amp;</code>：匹配的子字符串  </li>
<li><code>$`</code>：匹配结果前面的文本  </li>
<li><code>$&#39;</code>：匹配结果后面的文本  </li>
<li><code>$n</code>：匹配成功的第<code>n</code>组内容，<code>n</code>是从1开始的自然数  </li>
<li><code>$$</code>：指代美元符号<code>$</code>  </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;hello world&#x27;</span>.replace(<span class="hljs-regexp">/(\w+)\s(\w+)/</span>, <span class="hljs-string">&#x27;$2 $1&#x27;</span>)<br><span class="hljs-comment">// &quot;world hello&quot;</span><br><br><span class="hljs-string">&#x27;abc&#x27;</span>.replace(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;[$`-$&amp;-$\&#x27;]&#x27;</span>)<br><span class="hljs-comment">// &quot;a[a-b-c]c&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，第一个例子是将匹配的组互换位置，第二个例子是改写匹配的值  </p>
<p><code>replace</code>方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;3 and 5&#x27;</span>.replace(<span class="hljs-regexp">/[0-9]+/g</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">match</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * match;<br>&#125;)<br><span class="hljs-comment">// &quot;6 and 10&quot;</span><br><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;The quick brown fox jumped over the lazy dog.&#x27;</span>;<br><span class="hljs-keyword">var</span> pattern = <span class="hljs-regexp">/quick|brown|lazy/ig</span>;<br><br>a.replace(pattern, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replacer</span>(<span class="hljs-params">match</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> match.toUpperCase();<br>&#125;);<br><span class="hljs-comment">// The QUICK BROWN fox jumped over the LAZY dog.</span><br></code></pre></div></td></tr></table></figure>
<p>作为<code>replace</code>方法第二个参数的替换函数，可以接受多个参数。其中，第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> prices = &#123;<br>  <span class="hljs-string">&#x27;p1&#x27;</span>: <span class="hljs-string">&#x27;$1.99&#x27;</span>,<br>  <span class="hljs-string">&#x27;p2&#x27;</span>: <span class="hljs-string">&#x27;$9.99&#x27;</span>,<br>  <span class="hljs-string">&#x27;p3&#x27;</span>: <span class="hljs-string">&#x27;$5.00&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> template = <span class="hljs-string">&#x27;&lt;span id=&quot;p1&quot;&gt;&lt;/span&gt;&#x27;</span><br>  + <span class="hljs-string">&#x27;&lt;span id=&quot;p2&quot;&gt;&lt;/span&gt;&#x27;</span><br>  + <span class="hljs-string">&#x27;&lt;span id=&quot;p3&quot;&gt;&lt;/span&gt;&#x27;</span>;<br><br>template.replace(<br>  /(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;)(.*?)(&quot;</span>&gt;</span>)(&lt;\/span&gt;)/g,</span><br><span class="xml">  function(match, $1, $2, $3, $4)&#123;</span><br><span class="xml">    return $1 + $2 + $3 + prices[$2] + $4;</span><br><span class="xml">  &#125;</span><br><span class="xml">);</span><br><span class="xml">// &quot;<span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>$1.99<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p2&quot;</span>&gt;</span>$9.99<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p3&quot;</span>&gt;</span>$5.00<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用<code>$1</code>到<code>$4</code>表示。匹配函数的作用是将价格插入模板中  </p>
<h4 id="String-prototype-split-1"><a href="#String-prototype-split-1" class="headerlink" title="String.prototype.split()"></a>String.prototype.split()</h4><p>字符串对象的<code>split</code>方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">str.split(separator, [limit])<br></code></pre></div></td></tr></table></figure>
<p>该方法接受两个参数，第一个参数是正则表达式，表示分隔规则，第二个参数是返回数组的最大成员数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 非正则分隔</span><br><span class="hljs-string">&#x27;a,  b,c, d&#x27;</span>.split(<span class="hljs-string">&#x27;,&#x27;</span>)<br><span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;  b&#x27;, &#x27;c&#x27;, &#x27; d&#x27; ]</span><br><br><span class="hljs-comment">// 正则分隔，去除多余的空格</span><br><span class="hljs-string">&#x27;a,  b,c, d&#x27;</span>.split(<span class="hljs-regexp">/, */</span>)<br><span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27; ]</span><br><br><span class="hljs-comment">// 指定返回数组的最大成员</span><br><span class="hljs-string">&#x27;a,  b,c, d&#x27;</span>.split(<span class="hljs-regexp">/, */</span>, <span class="hljs-number">2</span>)<br>[ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span> ]<br></code></pre></div></td></tr></table></figure>
<p>上面代码使用正则表达式，去除了子字符串的逗号后面的空格  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 例一</span><br><span class="hljs-string">&#x27;aaa*a*&#x27;</span>.split(<span class="hljs-regexp">/a*/</span>)<br><span class="hljs-comment">// [ &#x27;&#x27;, &#x27;*&#x27;, &#x27;*&#x27; ]</span><br><br><span class="hljs-comment">// 例二</span><br><span class="hljs-string">&#x27;aaa**a*&#x27;</span>.split(<span class="hljs-regexp">/a*/</span>)<br><span class="hljs-comment">// [&quot;&quot;, &quot;*&quot;, &quot;*&quot;, &quot;*&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的分割规则是0次或多次的<code>a</code>，由于正则默认是贪婪匹配，所以例一的第一个分隔符是<code>aaa</code>，第二个分割符是<code>a</code>，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是<code>aaa</code>，第二个分隔符是0个<code>a</code>（即空字符），第三个分隔符是<code>a</code>，所以将字符串分成四个部分  </p>
<p>如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;aaa*a*&#x27;</span>.split(<span class="hljs-regexp">/(a*)/</span>)<br><span class="hljs-comment">// [ &#x27;&#x27;, &#x27;aaa&#x27;, &#x27;*&#x27;, &#x27;a&#x27;, &#x27;*&#x27; ]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的正则表达式使用了括号，第一个组匹配是<code>aaa</code>，第二个组匹配是<code>a</code>，它们都作为数组成员返回  </p>
<h3 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h3><p>正则表达式的规则很复杂，下面一一介绍这些规则  </p>
<h4 id="字面量字符和元字符"><a href="#字面量字符和元字符" class="headerlink" title="字面量字符和元字符"></a>字面量字符和元字符</h4><p>大部分字符在正则表达式中，就是字面的含义，比如<code>/a/</code>匹配<code>a</code>，<code>/b/</code>匹配<code>b</code>。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的<code>a</code>和<code>b</code>），那么它们就叫做“字面量字符”（literal characters）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/dog/.test(<span class="hljs-string">&#x27;old dog&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中正则表达式的<code>dog</code>，就是字面量字符，所以<code>/dog/</code>匹配<code>old dog</code>，因为它就表示<code>d</code>、<code>o</code>、<code>g</code>三个字母连在一起。</p>
<p>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。</p>
<p><strong>（1）点字符（.)</strong></p>
<p>点字符（<code>.</code>）匹配除回车（<code>\r</code>）、换行(<code>\n</code>) 、行分隔符（<code>\u2028</code>）和段分隔符（<code>\u2029</code>）以外的所有字符。注意，对于码点大于<code>0xFFFF</code>字符，点字符不能正确匹配，会认为这是两个字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/c.t/<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>c.t</code>匹配<code>c</code>和<code>t</code>之间包含任意一个字符的情况，只要这三个字符在同一行，比如<code>cat</code>、<code>c2t</code>、<code>c-t</code>等等，但是不匹配<code>coot</code>。</p>
<p><strong>（2）位置字符</strong></p>
<p>位置字符用来提示字符所处的位置，主要有两个字符。</p>
<ul>
<li><code>^</code> 表示字符串的开始位置</li>
<li><code>$</code> 表示字符串的结束位置</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// test必须出现在开始位置</span><br>/^test/.test(<span class="hljs-string">&#x27;test123&#x27;</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// test必须出现在结束位置</span><br>/test$/.test(<span class="hljs-string">&#x27;new test&#x27;</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 从开始位置到结束位置只有test</span><br>/^test$/.test(<span class="hljs-string">&#x27;test&#x27;</span>) <span class="hljs-comment">// true</span><br>/^test$/.test(<span class="hljs-string">&#x27;test test&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（3）选择符（<code>|</code>）</strong></p>
<p>竖线符号（<code>|</code>）在正则表达式中表示“或关系”（OR），即<code>cat|dog</code>表示匹配<code>cat</code>或<code>dog</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/<span class="hljs-number">11</span>|<span class="hljs-number">22</span>/.test(<span class="hljs-string">&#x27;911&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，正则表达式指定必须匹配<code>11</code>或<code>22</code>。</p>
<p>多个选择符可以联合使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 匹配fred、barney、betty之中的一个</span><br>/fred|barney|betty/<br></code></pre></div></td></tr></table></figure>
<p>选择符会包括它前后的多个字符，比如<code>/ab|cd/</code>指的是匹配<code>ab</code>或者<code>cd</code>，而不是指匹配<code>b</code>或者<code>c</code>。如果想修改这个行为，可以使用圆括号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/a( |\t)b/.test(<span class="hljs-string">&#x27;a\tb&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码指的是，<code>a</code>和<code>b</code>之间有一个空格或者一个制表符。</p>
<p>其他的元字符还包括<code>\</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>()</code>、<code>[]</code>、<code>&#123;&#125;</code>等，将在下文解释。</p>
<h4 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h4><p>正则表达式中那些有特殊含义的元字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配<code>+</code>，就要写成<code>\+</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/<span class="hljs-number">1</span>+<span class="hljs-number">1</span>/.test(<span class="hljs-string">&#x27;1+1&#x27;</span>)<br><span class="hljs-comment">// false</span><br><br>/<span class="hljs-number">1</span>\+<span class="hljs-number">1</span>/.test(<span class="hljs-string">&#x27;1+1&#x27;</span>)<br><span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，第一个正则表达式之所以不匹配，因为加号是元字符，不代表自身。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。</p>
<p>正则表达式中，需要反斜杠转义的，一共有12个字符：<code>^</code>、<code>.</code>、<code>[</code>、<code>$</code>、<code>(</code>、<code>)</code>、<code>|</code>、<code>*</code>、<code>+</code>、<code>?</code>、<code>&#123;</code>和<code>\</code>。需要特别注意的是，如果使用<code>RegExp</code>方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;1\+1&#x27;</span>)).test(<span class="hljs-string">&#x27;1+1&#x27;</span>)<br><span class="hljs-comment">// false</span><br><br>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&#x27;1\\+1&#x27;</span>)).test(<span class="hljs-string">&#x27;1+1&#x27;</span>)<br><span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>RegExp</code>作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。</p>
<h4 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h4><p>正则表达式对一些不能打印的特殊字符，提供了表达方法。</p>
<ul>
<li><code>\cX</code> 表示<code>Ctrl-[X]</code>，其中的<code>X</code>是A-Z之中任一个英文字母，用来匹配控制字符。</li>
<li><code>[\b]</code> 匹配退格键(U+0008)，不要与<code>\b</code>混淆。</li>
<li><code>\n</code> 匹配换行键。</li>
<li><code>\r</code> 匹配回车键。</li>
<li><code>\t</code> 匹配制表符 tab（U+0009）。</li>
<li><code>\v</code> 匹配垂直制表符（U+000B）。</li>
<li><code>\f</code> 匹配换页符（U+000C）。</li>
<li><code>\0</code> 匹配<code>null</code>字符（U+0000）。</li>
<li><code>\xhh</code> 匹配一个以两位十六进制数（<code>\x00</code>-<code>\xFF</code>）表示的字符。</li>
<li><code>\uhhhh</code> 匹配一个以四位十六进制数（<code>\u0000</code>-<code>\uFFFF</code>）表示的 Unicode 字符。</li>
</ul>
<h4 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h4><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如<code>[xyz]</code> 表示<code>x</code>、<code>y</code>、<code>z</code>之中任选一个匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/[abc]/.test(<span class="hljs-string">&#x27;hello world&#x27;</span>) <span class="hljs-comment">// false</span><br>/[abc]/.test(<span class="hljs-string">&#x27;apple&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，字符串<code>hello world</code>不包含<code>a</code>、<code>b</code>、<code>c</code>这三个字母中的任一个，所以返回<code>false</code>；字符串<code>apple</code>包含字母<code>a</code>，所以返回<code>true</code>。</p>
<p>有两个字符在字符类中有特殊含义。</p>
<p><strong>（1）脱字符（&#94;）</strong></p>
<p>如果方括号内的第一个字符是<code>[^]</code>，则表示除了字符类之中的字符，其他字符都可以匹配。比如，<code>[^xyz]</code>表示除了<code>x</code>、<code>y</code>、<code>z</code>之外都可以匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/[^abc]/.test(<span class="hljs-string">&#x27;bbc news&#x27;</span>) <span class="hljs-comment">// true</span><br>/[^abc]/.test(<span class="hljs-string">&#x27;bbc&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，字符串<code>bbc news</code>包含<code>a</code>、<code>b</code>、<code>c</code>以外的其他字符，所以返回<code>true</code>；字符串<code>bbc</code>不包含<code>a</code>、<code>b</code>、<code>c</code>以外的其他字符，所以返回<code>false</code>。</p>
<p>如果方括号内没有其他字符，即只有<code>[^]</code>，就表示匹配一切字符，其中包括换行符。相比之下，点号作为元字符（<code>.</code>）是不包括换行符的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;Please yes\nmake my day!&#x27;</span>;<br><br>s.match(<span class="hljs-regexp">/yes.*day/</span>) <span class="hljs-comment">// null</span><br>s.match(<span class="hljs-regexp">/yes[^]*day/</span>) <span class="hljs-comment">// [ &#x27;yes\nmake my day&#x27;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，字符串<code>s</code>含有一个换行符，点号不包括换行符，所以第一个正则表达式匹配失败；第二个正则表达式<code>[^]</code>包含一切字符，所以匹配成功。</p>
<blockquote>
<p>注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。</p>
</blockquote>
<p><strong>（2）连字符（-）</strong></p>
<p>某些情况下，对于连续序列的字符，连字符（<code>-</code>）用来提供简写形式，表示字符的连续范围。比如，<code>[abc]</code>可以写成<code>[a-c]</code>，<code>[0123456789]</code>可以写成<code>[0-9]</code>，同理<code>[A-Z]</code>表示26个大写字母。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/a-z/.test(<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// false</span><br>/[a-z]/.test(<span class="hljs-string">&#x27;b&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符<code>b</code>。只有当连字号用在方括号之中，才表示连续的字符序列。</p>
<p>以下都是合法的字符类简写形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-number">0</span>-<span class="hljs-number">9.</span>,]<br>[<span class="hljs-number">0</span>-9a-fA-F]<br>[a-zA-Z0-<span class="hljs-number">9</span>-]<br>[<span class="hljs-number">1</span>-<span class="hljs-number">31</span>]<br></code></pre></div></td></tr></table></figure>
<p>上面代码中最后一个字符类<code>[1-31]</code>，不代表<code>1</code>到<code>31</code>，只代表<code>1</code>到<code>3</code>。</p>
<p>连字符还可以用来指定 Unicode 字符的范围。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;\u0130\u0131\u0132&quot;</span>;<br>/[\u0128-\uFFFF]/.test(str)<br><span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>\u0128-\uFFFF</code>表示匹配码点在<code>0128</code>到<code>FFFF</code>之间的所有字符。</p>
<p>另外，不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是<code>[A-z]</code>，表面上它是选中从大写的<code>A</code>到小写的<code>z</code>之间52个字母，但是由于在 ASCII 编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/[A-z]/.test(<span class="hljs-string">&#x27;\\&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，由于反斜杠（’\‘）的ASCII码在大写字母与小写字母之间，结果会被选中。</p>
<h4 id="预定义模式"><a href="#预定义模式" class="headerlink" title="预定义模式"></a>预定义模式</h4><p>预定义模式指的是某些常见模式的简写方式。</p>
<ul>
<li><code>\d</code> 匹配0-9之间的任一数字，相当于<code>[0-9]</code>。</li>
<li><code>\D</code> 匹配所有0-9以外的字符，相当于<code>[^0-9]</code>。</li>
<li><code>\w</code> 匹配任意的字母、数字和下划线，相当于<code>[A-Za-z0-9_]</code>。</li>
<li><code>\W</code> 除所有字母、数字和下划线以外的字符，相当于<code>[^A-Za-z0-9_]</code>。</li>
<li><code>\s</code> 匹配空格（包括换行符、制表符、空格符等），相等于<code>[ \t\r\n\v\f]</code>。</li>
<li><code>\S</code> 匹配非空格的字符，相当于<code>[^ \t\r\n\v\f]</code>。</li>
<li><code>\b</code> 匹配词的边界。</li>
<li><code>\B</code> 匹配非词边界，即在词的内部。</li>
</ul>
<p>下面是一些例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// \s 的例子</span><br>/\s\w*<span class="hljs-regexp">/.exec(&#x27;hello world&#x27;) /</span><span class="hljs-regexp">/ [&quot; world&quot;]</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">/</span><span class="hljs-regexp">/ \b 的例子</span><br><span class="hljs-regexp">/</span>\bworld/.test(<span class="hljs-string">&#x27;hello world&#x27;</span>) <span class="hljs-comment">// true</span><br>/\bworld/.test(<span class="hljs-string">&#x27;hello-world&#x27;</span>) <span class="hljs-comment">// true</span><br>/\bworld/.test(<span class="hljs-string">&#x27;helloworld&#x27;</span>) <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// \B 的例子</span><br>/\Bworld/.test(<span class="hljs-string">&#x27;hello-world&#x27;</span>) <span class="hljs-comment">// false</span><br>/\Bworld/.test(<span class="hljs-string">&#x27;helloworld&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>\s</code>表示空格，所以匹配结果会包括空格。<code>\b</code>表示词的边界，所以<code>world</code>的词首必须独立（词尾是否独立未指定），才会匹配。同理，<code>\B</code>表示非词的边界，只有<code>world</code>的词首不独立，才会匹配。</p>
<p>通常，正则表达式遇到换行符（<code>\n</code>）就会停止匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> html = <span class="hljs-string">&quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span>;<br><br>/.*/.exec(html)[<span class="hljs-number">0</span>]<br><span class="hljs-comment">// &quot;&lt;b&gt;Hello&lt;/b&gt;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，字符串<code>html</code>包含一个换行符，结果点字符（<code>.</code>）不匹配换行符，导致匹配结果可能不符合原意。这时使用<code>\s</code>字符类，就能包括换行符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> html = <span class="hljs-string">&quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span>;<br><br>/[\S\s]*/.exec(html)[<span class="hljs-number">0</span>]<br><span class="hljs-comment">// &quot;&lt;b&gt;Hello&lt;/b&gt;\n&lt;i&gt;world!&lt;/i&gt;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>[\S\s]</code>指代一切字符。</p>
<h4 id="重复类"><a href="#重复类" class="headerlink" title="重复类"></a>重复类</h4><p>模式的精确匹配次数，使用大括号（<code>&#123;&#125;</code>）表示。<code>&#123;n&#125;</code>表示恰好重复<code>n</code>次，<code>&#123;n,&#125;</code>表示至少重复<code>n</code>次，<code>&#123;n,m&#125;</code>表示重复不少于<code>n</code>次，不多于<code>m</code>次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/lo&#123;<span class="hljs-number">2</span>&#125;k/.test(<span class="hljs-string">&#x27;look&#x27;</span>) <span class="hljs-comment">// true</span><br>/lo&#123;<span class="hljs-number">2</span>,<span class="hljs-number">5</span>&#125;k/.test(<span class="hljs-string">&#x27;looook&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，第一个模式指定<code>o</code>连续出现2次，第二个模式指定<code>o</code>连续出现2次到5次之间。</p>
<h4 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h4><p>量词符用来设定某个模式出现的次数。</p>
<ul>
<li><code>?</code> 问号表示某个模式出现0次或1次，等同于<code>&#123;0, 1&#125;</code>。</li>
<li><code>*</code> 星号表示某个模式出现0次或多次，等同于<code>&#123;0,&#125;</code>。</li>
<li><code>+</code> 加号表示某个模式出现1次或多次，等同于<code>&#123;1,&#125;</code>。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// t 出现0次或1次</span><br>/t?est/.test(<span class="hljs-string">&#x27;test&#x27;</span>) <span class="hljs-comment">// true</span><br>/t?est/.test(<span class="hljs-string">&#x27;est&#x27;</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// t 出现1次或多次</span><br>/t+est/.test(<span class="hljs-string">&#x27;test&#x27;</span>) <span class="hljs-comment">// true</span><br>/t+est/.test(<span class="hljs-string">&#x27;ttest&#x27;</span>) <span class="hljs-comment">// true</span><br>/t+est/.test(<span class="hljs-string">&#x27;est&#x27;</span>) <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// t 出现0次或多次</span><br>/t*est/.test(<span class="hljs-string">&#x27;test&#x27;</span>) <span class="hljs-comment">// true</span><br>/t*est/.test(<span class="hljs-string">&#x27;ttest&#x27;</span>) <span class="hljs-comment">// true</span><br>/t*est/.test(<span class="hljs-string">&#x27;tttest&#x27;</span>) <span class="hljs-comment">// true</span><br>/t*est/.test(<span class="hljs-string">&#x27;est&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<h4 id="贪婪模式"><a href="#贪婪模式" class="headerlink" title="贪婪模式"></a>贪婪模式</h4><p>上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配到下一个字符不满足匹配规则为止。这被称为贪婪模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>s.match(<span class="hljs-regexp">/a+/</span>) <span class="hljs-comment">// [&quot;aaa&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，模式是<code>/a+/</code>，表示匹配1个<code>a</code>或多个<code>a</code>，那么到底会匹配几个<code>a</code>呢？因为默认是贪婪模式，会一直匹配到字符<code>a</code>不出现为止，所以匹配结果是3个<code>a</code>。</p>
<p>除了贪婪模式，还有非贪婪模式，即最小可能匹配。只要一发现匹配，就返回结果，不要往下检查。如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;aaa&#x27;</span>;<br>s.match(<span class="hljs-regexp">/a+?/</span>) <span class="hljs-comment">// [&quot;a&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面例子中，模式结尾添加了一个问号<code>/a+?/</code>，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配，<code>+?</code>表示只要发现一个<code>a</code>，就不再往下匹配了。</p>
<p>除了非贪婪模式的加号（<code>+?</code>），还有非贪婪模式的星号（<code>*?</code>）和非贪婪模式的问号（<code>??</code>）。</p>
<ul>
<li><code>+?</code>：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</li>
<li><code>*?</code>：表示某个模式出现0次或多次，匹配时采用非贪婪模式。</li>
<li><code>??</code>：表格某个模式出现0次或1次，匹配时采用非贪婪模式。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abb&#x27;</span>.match(<span class="hljs-regexp">/ab*/</span>) <span class="hljs-comment">// [&quot;abb&quot;]</span><br><span class="hljs-string">&#x27;abb&#x27;</span>.match(<span class="hljs-regexp">/ab*?/</span>) <span class="hljs-comment">// [&quot;a&quot;]</span><br><br><span class="hljs-string">&#x27;abb&#x27;</span>.match(<span class="hljs-regexp">/ab?/</span>) <span class="hljs-comment">// [&quot;ab&quot;]</span><br><span class="hljs-string">&#x27;abb&#x27;</span>.match(<span class="hljs-regexp">/ab??/</span>) <span class="hljs-comment">// [&quot;a&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面例子中，<code>/ab*/</code>表示如果<code>a</code>后面有多个<code>b</code>，那么匹配尽可能多的<code>b</code>；<code>/ab*?/</code>表示匹配尽可能少的<code>b</code>，也就是0个<code>b</code>。</p>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。</p>
<p>修饰符可以单个使用，也可以多个一起使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 单个修饰符</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/test/i</span>;<br><br><span class="hljs-comment">// 多个修饰符</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/test/ig</span>;<br></code></pre></div></td></tr></table></figure>
<p><strong>（1）g 修饰符</strong></p>
<p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。<code>g</code>修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/b/</span>;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abba&#x27;</span>;<br><br>regex.test(str); <span class="hljs-comment">// true</span><br>regex.test(str); <span class="hljs-comment">// true</span><br>regex.test(str); <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，正则模式不含<code>g</code>修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回<code>true</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/b/g</span>;<br><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abba&#x27;</span>;<br><br>regex.test(str); <span class="hljs-comment">// true</span><br>regex.test(str); <span class="hljs-comment">// true</span><br>regex.test(str); <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，正则模式含有<code>g</code>修饰符，每次都是从上一次匹配成功处，开始向后匹配。因为字符串<code>abba</code>只有两个<code>b</code>，所以前两次匹配结果为<code>true</code>，第三次匹配结果为<code>false</code>。</p>
<p><strong>（2）i 修饰符</strong></p>
<p>默认情况下，正则对象区分字母的大小写，加上<code>i</code>修饰符以后表示忽略大小写（ignoreCase）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/abc/.test(<span class="hljs-string">&#x27;ABC&#x27;</span>) <span class="hljs-comment">// false</span><br>/abc/i.test(<span class="hljs-string">&#x27;ABC&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，加了<code>i</code>修饰符以后，不考虑大小写，所以模式<code>abc</code>匹配字符串<code>ABC</code>。</p>
<p><strong>（3）m 修饰符</strong></p>
<p><code>m</code>修饰符表示多行模式（multiline），会修改<code>^</code>和<code>$</code>的行为。默认情况下（即不加<code>m</code>修饰符时），<code>^</code>和<code>$</code>匹配字符串的开始处和结尾处，加上<code>m</code>修饰符以后，<code>^</code>和<code>$</code>还会匹配行首和行尾，即<code>^</code>和<code>$</code>会识别换行符（<code>\n</code>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/world$/.test(<span class="hljs-string">&#x27;hello world\n&#x27;</span>) <span class="hljs-comment">// false</span><br>/world$/m.test(<span class="hljs-string">&#x27;hello world\n&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面的代码中，字符串结尾处有一个换行符。如果不加<code>m</code>修饰符，匹配不成功，因为字符串的结尾不是<code>world</code>；加上以后，<code>$</code>可以匹配行尾。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/^b/m.test(<span class="hljs-string">&#x27;a\nb&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码要求匹配行首的<code>b</code>，如果不加<code>m</code>修饰符，就相当于<code>b</code>只能处在字符串的开始处。加上<code>m</code>修饰符以后，换行符<code>\n</code>也会被认为是一行的开始。</p>
<h4 id="组匹配"><a href="#组匹配" class="headerlink" title="组匹配"></a>组匹配</h4><p><strong>（1）概述</strong></p>
<p>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/fred+<span class="hljs-regexp">/.test(&#x27;fredd&#x27;) /</span><span class="hljs-regexp">/ true</span><br><span class="hljs-regexp">/</span>(fred)+<span class="hljs-regexp">/.test(&#x27;fredfred&#x27;) /</span><span class="hljs-regexp">/ true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，第一个模式没有括号，结果<code>+</code>只表示重复字母<code>d</code>，第二个模式有括号，结果<code>+</code>就表示匹配<code>fred</code>这个词。</p>
<p>下面是另外一个分组捕获的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-string">&#x27;abcabc&#x27;</span>.match(<span class="hljs-regexp">/(.)b(.)/</span>);<br>m<br><span class="hljs-comment">// [&#x27;abc&#x27;, &#x27;a&#x27;, &#x27;c&#x27;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，正则表达式<code>/(.)b(.)/</code>一共使用两个括号，第一个括号捕获<code>a</code>，第二个括号捕获<code>c</code>。</p>
<p>注意，使用组匹配时，不宜同时使用<code>g</code>修饰符，否则<code>match</code>方法不会捕获分组的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-string">&#x27;abcabc&#x27;</span>.match(<span class="hljs-regexp">/(.)b(.)/g</span>);<br>m <span class="hljs-comment">// [&#x27;abc&#x27;, &#x27;abc&#x27;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码使用带<code>g</code>修饰符的正则表达式，结果<code>match</code>方法只捕获了匹配整个表达式的部分。这时必须使用正则表达式的<code>exec</code>方法，配合循环，才能读到每一轮匹配的组捕获。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abcabc&#x27;</span>;<br><span class="hljs-keyword">var</span> reg = <span class="hljs-regexp">/(.)b(.)/g</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">var</span> result = reg.exec(str);<br>  <span class="hljs-keyword">if</span> (!result) <span class="hljs-keyword">break</span>;<br>  <span class="hljs-built_in">console</span>.log(result);<br>&#125;<br><span class="hljs-comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]</span><br><span class="hljs-comment">// [&quot;abc&quot;, &quot;a&quot;, &quot;c&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>正则表达式内部，还可以用<code>\n</code>引用括号匹配的内容，<code>n</code>是从1开始的自然数，表示对应顺序的括号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/(.)b(.)\1b\<span class="hljs-number">2</span>/.test(<span class="hljs-string">&quot;abcabc&quot;</span>)<br><span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面的代码中，<code>\1</code>表示第一个括号匹配的内容（即<code>a</code>），<code>\2</code>表示第二个括号匹配的内容（即<code>c</code>）。</p>
<p>下面是另外一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/y(..)(.)\<span class="hljs-number">2</span>\<span class="hljs-number">1</span>/.test(<span class="hljs-string">&#x27;yabccab&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>括号还可以嵌套。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/y((..)\<span class="hljs-number">2</span>)\<span class="hljs-number">1</span>/.test(<span class="hljs-string">&#x27;yabababab&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>\1</code>指向外层括号，<code>\2</code>指向内层括号。</p>
<p>组匹配非常有用，下面是一个匹配网页标签的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tagName = <span class="hljs-regexp">/&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/</span>;<br><br>tagName.exec(<span class="hljs-string">&quot;&lt;b&gt;bold&lt;/b&gt;&quot;</span>)[<span class="hljs-number">1</span>]<br><span class="hljs-comment">// &#x27;b&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，圆括号匹配尖括号之中的标签，而<code>\1</code>就表示对应的闭合标签。</p>
<p>上面代码略加修改，就能捕获带有属性的标签。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> html = <span class="hljs-string">&#x27;&lt;b class=&quot;hello&quot;&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;&#x27;</span>;<br><span class="hljs-keyword">var</span> tag = <span class="hljs-regexp">/&lt;(\w+)([^&gt;]*)&gt;(.*?)&lt;\/\1&gt;/g</span>;<br><br><span class="hljs-keyword">var</span> match = tag.exec(html);<br><br>match[<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;b&quot;</span><br>match[<span class="hljs-number">2</span>] <span class="hljs-comment">// &quot; class=&quot;hello&quot;&quot;</span><br>match[<span class="hljs-number">3</span>] <span class="hljs-comment">// &quot;Hello&quot;</span><br><br>match = tag.exec(html);<br><br>match[<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;i&quot;</span><br>match[<span class="hljs-number">2</span>] <span class="hljs-comment">// &quot;&quot;</span><br>match[<span class="hljs-number">3</span>] <span class="hljs-comment">// &quot;world&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（2）非捕获组</strong></p>
<p><code>(?:x)</code>称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</p>
<p>非捕获组的作用请考虑这样一个场景，假定需要匹配<code>foo</code>或者<code>foofoo</code>，正则表达式就应该写成<code>/(foo)&#123;1, 2&#125;/</code>，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为<code>/(?:foo)&#123;1, 2&#125;/</code>，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。</p>
<p>请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-string">&#x27;abc&#x27;</span>.match(<span class="hljs-regexp">/(?:.)b(.)/</span>);<br>m <span class="hljs-comment">// [&quot;abc&quot;, &quot;c&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。</p>
<p>下面是用来分解网址的正则表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 正常匹配</span><br><span class="hljs-keyword">var</span> url = <span class="hljs-regexp">/(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/</span>;<br><br>url.exec(<span class="hljs-string">&#x27;http://google.com/&#x27;</span>);<br><span class="hljs-comment">// [&quot;http://google.com/&quot;, &quot;http&quot;, &quot;google.com&quot;, &quot;/&quot;]</span><br><br><span class="hljs-comment">// 非捕获组匹配</span><br><span class="hljs-keyword">var</span> url = <span class="hljs-regexp">/(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/</span>;<br><br>url.exec(<span class="hljs-string">&#x27;http://google.com/&#x27;</span>);<br><span class="hljs-comment">// [&quot;http://google.com/&quot;, &quot;google.com&quot;, &quot;/&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面的代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。</p>
<p><strong>（3）先行断言</strong></p>
<p><code>x(?=y)</code>称为先行断言（Positive look-ahead），<code>x</code>只有在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成<code>/\d+(?=%)/</code>。</p>
<p>“先行断言”中，括号里的部分是不会返回的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-string">&#x27;abc&#x27;</span>.match(<span class="hljs-regexp">/b(?=c)/</span>);<br>m <span class="hljs-comment">// [&quot;b&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面的代码使用了先行断言，<code>b</code>在<code>c</code>前面所以被匹配，但是括号对应的<code>c</code>不会被返回。</p>
<p><strong>（4）先行否定断言</strong></p>
<p><code>x(?!y)</code>称为先行否定断言（Negative look-ahead），<code>x</code>只有不在<code>y</code>前面才匹配，<code>y</code>不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成<code>/\d+(?!%)/</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">/\d+(?!\.)/.exec(<span class="hljs-string">&#x27;3.14&#x27;</span>)<br><span class="hljs-comment">// [&quot;14&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是<code>14</code>。</p>
<p>“先行否定断言”中，括号里的部分是不会返回的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-string">&#x27;abd&#x27;</span>.match(<span class="hljs-regexp">/b(?!c)/</span>);<br>m <span class="hljs-comment">// [&#x27;b&#x27;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面的代码使用了先行否定断言，<code>b</code>不在<code>c</code>前面所以被匹配，而且括号对应的<code>d</code>不会被返回  </p>
<h2 id="JSON-对象"><a href="#JSON-对象" class="headerlink" title="JSON 对象"></a>JSON 对象</h2><h3 id="JSON-格式"><a href="#JSON-格式" class="headerlink" title="JSON 格式"></a>JSON 格式</h3><p>JSON 格式（JavaScript Object Notation 的缩写）是一种用于数据交换的文本格式，2001年由 Douglas Crockford 提出，目的是取代繁琐笨重的 XML 格式。</p>
<p>相比 XML 格式，JSON 格式有两个显著的优点：书写简单，一目了然；符合 JavaScript 原生语法，可以由解释引擎直接处理，不用另外添加解析代码。所以，JSON 迅速被接受，已经成为各大网站交换数据的标准格式，并被写入标准  </p>
<p>每个 JSON 对象就是一个值，可能是一个数组或对象，也可能是一个原始类型的值。总之，只能是一个值，不能是两个或更多的值  </p>
<p>JSON 对值的类型和格式有严格的规定  </p>
<blockquote>
<ol>
<li><p>复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。</p>
</li>
<li><p>原始类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和<code>null</code>（不能使用<code>NaN</code>, <code>Infinity</code>, <code>-Infinity</code>和<code>undefined</code>）。</p>
</li>
<li><p>字符串必须使用双引号表示，不能使用单引号。</p>
</li>
<li><p>对象的键名必须放在双引号里面。</p>
</li>
<li><p>数组或对象最后一个成员的后面，不能加逗号。</p>
</li>
</ol>
</blockquote>
<p>以下都是合法的 JSON  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>]<br><br>&#123; <span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;two&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;three&quot;</span>: <span class="hljs-number">3</span> &#125;<br><br>&#123;<span class="hljs-string">&quot;names&quot;</span>: [<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>] &#125;<br><br>[ &#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;李四&quot;</span>&#125; ]<br></code></pre></div></td></tr></table></figure>
<p>以下都是不合法的 JSON  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">32</span> &#125;  <span class="hljs-comment">// 属性名必须使用双引号</span><br><br>[<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">128</span>, <span class="hljs-number">0xFFF</span>] <span class="hljs-comment">// 不能使用十六进制值</span><br><br>&#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-literal">undefined</span> &#125; <span class="hljs-comment">// 不能使用 undefined</span><br><br>&#123; <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;张三&quot;</span>,<br>  <span class="hljs-string">&quot;birthday&quot;</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;Fri, 26 Aug 2011 07:13:10 GMT&#x27;</span>),<br>  <span class="hljs-string">&quot;getName&quot;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name;<br>  &#125;<br>&#125; <span class="hljs-comment">// 属性值不能使用函数和日期对象</span><br></code></pre></div></td></tr></table></figure>
<p>注意，<code>null</code>、空数组和空对象都是合法的 JSON 值  </p>
<h3 id="JSON-对象-1"><a href="#JSON-对象-1" class="headerlink" title="JSON 对象"></a>JSON 对象</h3><p><code>JSON</code>对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。它有两个静态方法：<code>JSON.stringify()</code>和<code>JSON.parse()</code>  </p>
<h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify()"></a>JSON.stringify()</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>JSON.stringify()</code>方法用于将一个值转为 JSON 字符串。该字符串符合 JSON 格式，并且可以被<code>JSON.parse()</code>方法还原。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">&#x27;abc&#x27;</span>) <span class="hljs-comment">// &quot;&quot;abc&quot;&quot;</span><br><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;1&quot;</span><br><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-literal">false</span>) <span class="hljs-comment">// &quot;false&quot;</span><br><span class="hljs-built_in">JSON</span>.stringify([]) <span class="hljs-comment">// &quot;[]&quot;</span><br><span class="hljs-built_in">JSON</span>.stringify(&#123;&#125;) <span class="hljs-comment">// &quot;&#123;&#125;&quot;</span><br><br><span class="hljs-built_in">JSON</span>.stringify([<span class="hljs-number">1</span>, <span class="hljs-string">&quot;false&quot;</span>, <span class="hljs-literal">false</span>])<br><span class="hljs-comment">// &#x27;[1,&quot;false&quot;,false]&#x27;</span><br><br><span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;张三&quot;</span> &#125;)<br><span class="hljs-comment">// &#x27;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码将各种类型的值，转成 JSON 字符串  </p>
<p>注意，对于原始类型的字符串，转换结果会带双引号  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">&#x27;foo&#x27;</span>) === <span class="hljs-string">&quot;foo&quot;</span> <span class="hljs-comment">// false</span><br><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">&#x27;foo&#x27;</span>) === <span class="hljs-string">&quot;\&quot;foo\&quot;&quot;</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，字符串<code>foo</code>，被转成了<code>&quot;\&quot;foo\&quot;&quot;</code>。这是因为将来还原的时候，内层双引号可以让 JavaScript 引擎知道，这是一个字符串，而不是其他类型的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-literal">false</span>) <span class="hljs-comment">// &quot;false&quot;</span><br><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-string">&#x27;false&#x27;</span>) <span class="hljs-comment">// &quot;\&quot;false\&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，如果不是内层的双引号，将来还原的时候，引擎就无法知道原始值是布尔值还是字符串  </p>
<p>如果对象的属性是<code>undefined</code>、函数或 XML 对象，该属性会被<code>JSON.stringify()</code>过滤  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  a: <span class="hljs-literal">undefined</span>,<br>  b: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>&#125;;<br><br><span class="hljs-built_in">JSON</span>.stringify(obj) <span class="hljs-comment">// &quot;&#123;&#125;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的<code>a</code>属性是<code>undefined</code>，而<code>b</code>属性是一个函数，结果都被<code>JSON.stringify</code>过滤  </p>
<p>如果数组的成员是<code>undefined</code>、函数或 XML 对象，则这些值被转成<code>null</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-literal">undefined</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;];<br><span class="hljs-built_in">JSON</span>.stringify(arr) <span class="hljs-comment">// &quot;[null,null]&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，数组<code>arr</code>的成员是<code>undefined</code>和函数，它们都被转成了<code>null</code>  </p>
<p>正则对象会被转成空对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-regexp">/foo/</span>) <span class="hljs-comment">// &quot;&#123;&#125;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><code>JSON.stringify()</code>方法会忽略对象的不可遍历的属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.defineProperties(obj, &#123;<br>  <span class="hljs-string">&#x27;foo&#x27;</span>: &#123;<br>    value: <span class="hljs-number">1</span>,<br>    enumerable: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-string">&#x27;bar&#x27;</span>: &#123;<br>    value: <span class="hljs-number">2</span>,<br>    enumerable: <span class="hljs-literal">false</span><br>  &#125;<br>&#125;);<br><br><span class="hljs-built_in">JSON</span>.stringify(obj); <span class="hljs-comment">// &quot;&#123;&quot;foo&quot;:1&#125;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>bar</code>是<code>obj</code>对象的不可遍历属性，<code>JSON.stringify</code>方法会忽略这个属性  </p>
<h4 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h4><p><code>JSON.stringify()</code>方法还可以接受一个数组，作为第二个参数，指定参数对象的哪些属性需要转成字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-string">&#x27;prop1&#x27;</span>: <span class="hljs-string">&#x27;value1&#x27;</span>,<br>  <span class="hljs-string">&#x27;prop2&#x27;</span>: <span class="hljs-string">&#x27;value2&#x27;</span>,<br>  <span class="hljs-string">&#x27;prop3&#x27;</span>: <span class="hljs-string">&#x27;value3&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> selectedProperties = [<span class="hljs-string">&#x27;prop1&#x27;</span>, <span class="hljs-string">&#x27;prop2&#x27;</span>];<br><br><span class="hljs-built_in">JSON</span>.stringify(obj, selectedProperties)<br><span class="hljs-comment">// &quot;&#123;&quot;prop1&quot;:&quot;value1&quot;,&quot;prop2&quot;:&quot;value2&quot;&#125;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>JSON.stringify()</code>方法的第二个参数指定，只转<code>prop1</code>和<code>prop2</code>两个属性  </p>
<p>这个类似白名单的数组，只对对象的属性有效，对数组无效  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify([<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>], [<span class="hljs-string">&#x27;0&#x27;</span>])<br><span class="hljs-comment">// &quot;[&quot;a&quot;,&quot;b&quot;]&quot;</span><br><br><span class="hljs-built_in">JSON</span>.stringify(&#123;<span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>&#125;, [<span class="hljs-string">&#x27;0&#x27;</span>])<br><span class="hljs-comment">// &quot;&#123;&quot;0&quot;:&quot;a&quot;&#125;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，第二个参数指定 JSON 格式只转<code>0</code>号属性，实际上对数组是无效的，只对对象有效  </p>
<p>第二个参数还可以是一个函数，用来更改<code>JSON.stringify()</code>的返回值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">key, value</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;number&quot;</span>) &#123;<br>    value = <span class="hljs-number">2</span> * value;<br>  &#125;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;, f)<br><span class="hljs-comment">// &#x27;&#123;&quot;a&quot;: 2,&quot;b&quot;: 4&#125;&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中的<code>f</code>函数，接受两个参数，分别是被转换的对象的键名和键值。如果键值是数值，就将它乘以<code>2</code>，否则就原样返回  </p>
<p>注意，这个处理函数是递归处理所有的键  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: <span class="hljs-number">1</span>&#125;&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">key, value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[&quot;</span>+ key +<span class="hljs-string">&quot;]:&quot;</span> + value);<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-built_in">JSON</span>.stringify(obj, f)<br><span class="hljs-comment">// []:[object Object]</span><br><span class="hljs-comment">// [a]:[object Object]</span><br><span class="hljs-comment">// [b]:1</span><br><span class="hljs-comment">// &#x27;&#123;&quot;a&quot;:&#123;&quot;b&quot;:1&#125;&#125;&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>一共会被<code>f</code>函数处理三次，输出的最后那行是<code>JSON.stringify()</code>的默认输出。第一次键名为空，键值是整个对象<code>obj</code>；第二次键名为<code>a</code>，键值是<code>&#123;b: 1&#125;</code>；第三次键名为<code>b</code>，键值为1  </p>
<p>递归处理中，每一次处理的对象，都是前一次返回的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">key, value</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;;<br>  &#125;<br>  <span class="hljs-keyword">return</span> value * <span class="hljs-number">2</span>;<br>&#125;<br><br><span class="hljs-built_in">JSON</span>.stringify(obj, f)<br><span class="hljs-comment">// &quot;&#123;&quot;b&quot;: 4&#125;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>f</code>函数修改了对象<code>obj</code>，接着<code>JSON.stringify()</code>方法就递归处理修改后的对象<code>obj</code>  </p>
<p>如果处理函数返回<code>undefined</code>或没有返回值，则该属性会被忽略  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">key, value</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(value) === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">undefined</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">a</span>: <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">123</span> &#125;, f)<br><span class="hljs-comment">// &#x27;&#123;&quot;b&quot;: 123&#125;&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>a</code>属性经过处理后，返回<code>undefined</code>，于是该属性被忽略了  </p>
<h4 id="第三个参数"><a href="#第三个参数" class="headerlink" title="第三个参数"></a>第三个参数</h4><p><code>JSON.stringify()</code>还可以接受第三个参数，用于增加返回的 JSON 字符串的可读性  </p>
<p>默认返回的是单行字符串，对于大型的 JSON 对象，可读性非常差。第三个参数使得每个属性单独占据一行，并且将每个属性前面添加指定的前缀（不超过10个字符）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 默认输出</span><br><span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">p1</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">p2</span>: <span class="hljs-number">2</span> &#125;)<br><span class="hljs-comment">// JSON.stringify(&#123; p1: 1, p2: 2 &#125;)</span><br><br><span class="hljs-comment">// 分行输出</span><br><span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">p1</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">p2</span>: <span class="hljs-number">2</span> &#125;, <span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;\t&#x27;</span>)<br><span class="hljs-comment">// &#123;</span><br><span class="hljs-comment">// 	&quot;p1&quot;: 1,</span><br><span class="hljs-comment">// 	&quot;p2&quot;: 2</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></div></td></tr></table></figure>
<p>上面例子中，第三个属性<code>\t</code>在每个属性前面添加一个制表符，然后分行显示  </p>
<p>第三个属性如果是一个数字，则表示每个属性前面添加的空格（最多不超过10个）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.stringify(&#123; <span class="hljs-attr">p1</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">p2</span>: <span class="hljs-number">2</span> &#125;, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">&quot;&#123;</span><br><span class="hljs-comment">  &quot;p1&quot;: 1,</span><br><span class="hljs-comment">  &quot;p2&quot;: 2</span><br><span class="hljs-comment">&#125;&quot;</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>
<h4 id="参数对象的-toJSON-方法"><a href="#参数对象的-toJSON-方法" class="headerlink" title="参数对象的 toJSON() 方法"></a>参数对象的 toJSON() 方法</h4><p>如果参数对象有自定义的<code>toJSON()</code>方法，那么<code>JSON.stringify()</code>会使用这个方法的返回值作为参数，而忽略原对象的其他属性  </p>
<p>下面是一个普通的对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;<br>  firstName: <span class="hljs-string">&#x27;三&#x27;</span>,<br>  lastName: <span class="hljs-string">&#x27;张&#x27;</span>,<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.lastName + <span class="hljs-built_in">this</span>.firstName;<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">JSON</span>.stringify(user)<br><span class="hljs-comment">// &quot;&#123;&quot;firstName&quot;:&quot;三&quot;,&quot;lastName&quot;:&quot;张&quot;,&quot;fullName&quot;:&quot;张三&quot;&#125;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>现在，为这个对象加上<code>toJSON()</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> user = &#123;<br>  firstName: <span class="hljs-string">&#x27;三&#x27;</span>,<br>  lastName: <span class="hljs-string">&#x27;张&#x27;</span>,<br><br>  <span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>()&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.lastName + <span class="hljs-built_in">this</span>.firstName;<br>  &#125;,<br><br>  toJSON: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      name: <span class="hljs-built_in">this</span>.lastName + <span class="hljs-built_in">this</span>.firstName<br>    &#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">JSON</span>.stringify(user)<br><span class="hljs-comment">// &quot;&#123;&quot;name&quot;:&quot;张三&quot;&#125;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>JSON.stringify()</code>发现参数对象有<code>toJSON()</code>方法，就直接使用这个方法的返回值作为参数，而忽略原对象的其他参数  </p>
<p><code>Date</code>对象就有一个自己的<code>toJSON()</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> date = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(<span class="hljs-string">&#x27;2015-01-01&#x27;</span>);<br>date.toJSON() <span class="hljs-comment">// &quot;2015-01-01T00:00:00.000Z&quot;</span><br><span class="hljs-built_in">JSON</span>.stringify(date) <span class="hljs-comment">// &quot;&quot;2015-01-01T00:00:00.000Z&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>JSON.stringify()</code>发现处理的是<code>Date</code>对象实例，就会调用这个实例对象的<code>toJSON()</code>方法，将该方法的返回值作为参数  </p>
<p><code>toJSON()</code>方法的一个应用是，将正则对象自动转为字符串。因为<code>JSON.stringify()</code>默认不能转换正则对象，但是设置了<code>toJSON()</code>方法以后，就可以转换正则对象了  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  reg: <span class="hljs-regexp">/foo/</span><br>&#125;;<br><br><span class="hljs-comment">// 不设置 toJSON 方法时</span><br><span class="hljs-built_in">JSON</span>.stringify(obj) <span class="hljs-comment">// &quot;&#123;&quot;reg&quot;:&#123;&#125;&#125;&quot;</span><br><br><span class="hljs-comment">// 设置 toJSON 方法时</span><br><span class="hljs-built_in">RegExp</span>.prototype.toJSON = <span class="hljs-built_in">RegExp</span>.prototype.toString;<br><span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-regexp">/foo/</span>) <span class="hljs-comment">// &quot;&quot;/foo/&quot;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码在正则对象的原型上面部署了<code>toJSON()</code>方法，将其指向<code>toString()</code>方法，因此转换成 JSON 格式时，正则对象就先调用<code>toJSON()</code>方法转为字符串，然后再被<code>JSON.stringify()</code>方法处理  </p>
<h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse()"></a>JSON.parse()</h3><p><code>JSON.parse()</code>方法用于将 JSON 字符串转换成对应的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&#123;&#125;&#x27;</span>) <span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;true&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&quot;foo&quot;&#x27;</span>) <span class="hljs-comment">// &quot;foo&quot;</span><br><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;[1, 5, &quot;false&quot;]&#x27;</span>) <span class="hljs-comment">// [1, 5, &quot;false&quot;]</span><br><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;null&#x27;</span>) <span class="hljs-comment">// null</span><br><br><span class="hljs-keyword">var</span> o = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;张三&quot;&#125;&#x27;</span>);<br>o.name <span class="hljs-comment">// 张三</span><br></code></pre></div></td></tr></table></figure>
<p>如果传入的字符串不是有效的 JSON 格式，<code>JSON.parse()</code>方法将报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&quot;&#x27;String&#x27;&quot;</span>) <span class="hljs-comment">// illegal single quotes</span><br><span class="hljs-comment">// SyntaxError: Unexpected token ILLEGAL</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，双引号字符串中是一个单引号字符串，因为单引号字符串不符合 JSON 格式，所以报错  </p>
<p>为了处理解析错误，可以将<code>JSON.parse()</code>方法放在<code>try...catch</code>代码块中  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&quot;&#x27;String&#x27;&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;parsing error&#x27;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>JSON.parse()</code>方法可以接受一个处理函数，作为第二个参数，用法与<code>JSON.stringify()</code>方法类似  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">key, value</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;a&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> value + <span class="hljs-number">10</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br><br><span class="hljs-built_in">JSON</span>.parse(<span class="hljs-string">&#x27;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2&#125;&#x27;</span>, f)<br><span class="hljs-comment">// &#123;a: 11, b: 2&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>JSON.parse()</code>的第二个参数是一个函数，如果键名是<code>a</code>，该函数会将键值加上10    </p>
<h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="实例对象与-new-命令"><a href="#实例对象与-new-命令" class="headerlink" title="实例对象与 new 命令"></a>实例对象与 new 命令</h2><p><code>Javascript</code> 语言具有很强的面向对象编程能力，本章介绍 <code>Javascript</code> 面向对象编程的基础知识  </p>
<h3 id="对象是什么"><a href="#对象是什么" class="headerlink" title="对象是什么"></a>对象是什么</h3><p>面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟  </p>
<p>每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目  </p>
<p>那么，“对象”（object）到底是什么？我们从两个层次来理解  </p>
<p><strong>（1）对象是单个实物的抽象</strong>  </p>
<p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个远程服务器连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程  </p>
<p><strong>（2）对象是一个容器，封装了属性（property）和方法（method）</strong>  </p>
<p>属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为<code>animal</code>对象，使用“属性”记录具体是哪一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）  </p>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成  </p>
<p>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，<code>Javascript</code> 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）  </p>
<p><code>Javascript</code> 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构  </p>
<p>构造函数就是一个普通的函数，但具有自己的特征和用法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Vehicle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.price = <span class="hljs-number">1000</span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Vehicle</code>就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写  </p>
<p>构造函数的特点有两个  </p>
<ul>
<li>函数体内部使用了<code>this</code>关键字，代表了所要生成的对象实例  </li>
<li>生成对象的时候，必须使用<code>new</code>命令  </li>
</ul>
<p>下面先介绍<code>new</code>命令  </p>
<h3 id="new-命令"><a href="#new-命令" class="headerlink" title="new 命令"></a>new 命令</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>new</code>命令的作用，就是执行构造函数，返回一个实例对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Vehicle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.price = <span class="hljs-number">1000</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Vehicle();<br>v.price <span class="hljs-comment">// 1000</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码通过<code>new</code>命令，让构造函数<code>Vehicle</code>生成一个实例对象，保存在变量<code>v</code>中。这个新生成的实例对象，从构造函数<code>Vehicle</code>得到了<code>price</code>属性。<code>new</code>命令执行时，构造函数内部的<code>this</code>，就代表了新生成的实例对象，<code>this.price</code>表示实例对象有一个<code>price</code>属性，值是1000  </p>
<p>使用<code>new</code>命令时，根据需要，构造函数也可以接受参数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Vehicle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">p</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.price = p;<br>&#125;;<br><br><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Vehicle(<span class="hljs-number">500</span>);<br></code></pre></div></td></tr></table></figure>
<p><code>new</code>命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 推荐的写法</span><br><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Vehicle();<br><span class="hljs-comment">// 不推荐的写法</span><br><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Vehicle;<br></code></pre></div></td></tr></table></figure>
<p>一个很自然的问题是，如果忘了使用<code>new</code>命令，直接调用构造函数会发生什么事？  </p>
<p>这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，<code>this</code>这时代表全局对象，将造成一些意想不到的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Vehicle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">this</span>.price = <span class="hljs-number">1000</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> v = Vehicle();<br>v <span class="hljs-comment">// undefined</span><br>price <span class="hljs-comment">// 1000</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，调用<code>Vehicle</code>构造函数时，忘了加上<code>new</code>命令。结果，变量<code>v</code>变成了<code>undefined</code>，而<code>price</code>属性变成了全局变量。因此，应该非常小心，避免不使用<code>new</code>命令、直接调用构造函数  </p>
<p>为了保证构造函数必须与<code>new</code>命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上<code>use strict</code>。这样的话，一旦忘了使用<code>new</code>命令，直接调用构造函数就会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fubar</span>(<span class="hljs-params">foo, bar</span>)</span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-built_in">this</span>._foo = foo;<br>  <span class="hljs-built_in">this</span>._bar = bar;<br>&#125;<br><br>Fubar()<br><span class="hljs-comment">// TypeError: Cannot set property &#x27;_foo&#x27; of undefined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的<code>Fubar</code>为构造函数，<code>use strict</code>命令保证了该函数在严格模式下运行。由于严格模式中，函数内部的<code>this</code>不能指向全局对象，默认等于<code>undefined</code>，导致不加<code>new</code>调用会报错（<code>Javascript</code> 不允许对<code>undefined</code>添加属性）  </p>
<p>另一个解决办法，构造函数内部判断是否使用<code>new</code>命令，如果发现没有使用，则直接返回一个实例对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fubar</span>(<span class="hljs-params">foo, bar</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> Fubar)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fubar(foo, bar);<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>._foo = foo;<br>  <span class="hljs-built_in">this</span>._bar = bar;<br>&#125;<br><br>Fubar(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)._foo <span class="hljs-comment">// 1</span><br>(<span class="hljs-keyword">new</span> Fubar(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))._foo <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中的构造函数，不管加不加<code>new</code>命令，都会得到同样的结果  </p>
<h4 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h4><p>使用<code>new</code>命令时，它后面的函数依次执行下面的步骤  </p>
<ol>
<li>创建一个空对象，作为将要返回的对象实例  </li>
<li>将这个空对象的原型，指向构造函数的<code>prototype</code>属性  </li>
<li>将这个空对象赋值给函数内部的<code>this</code>关键字  </li>
<li>开始执行构造函数内部的代码  </li>
</ol>
<p>也就是说，构造函数内部，<code>this</code>指的是一个新生成的空对象，所有针对<code>this</code>的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即<code>this</code>对象），将其“构造”为需要的样子  </p>
<p>如果构造函数内部有<code>return</code>语句，而且<code>return</code>后面跟着一个对象，<code>new</code>命令会返回<code>return</code>语句指定的对象；否则，就会不管<code>return</code>语句，返回<code>this</code>对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Vehicle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.price = <span class="hljs-number">1000</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span>;<br>&#125;;<br><br>(<span class="hljs-keyword">new</span> Vehicle()) === <span class="hljs-number">1000</span><br><span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，构造函数<code>Vehicle</code>的<code>return</code>语句返回一个数值。这时，<code>new</code>命令就会忽略这个<code>return</code>语句，返回“构造”后的<code>this</code>对象  </p>
<p>但是，如果<code>return</code>语句返回的是一个跟<code>this</code>无关的新对象，<code>new</code>命令会返回这个新对象，而不是<code>this</code>对象。这一点需要特别引起注意  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Vehicle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">this</span>.price = <span class="hljs-number">1000</span>;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">price</span>: <span class="hljs-number">2000</span> &#125;;<br>&#125;;<br><br>(<span class="hljs-keyword">new</span> Vehicle()).price<br><span class="hljs-comment">// 2000</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，构造函数<code>Vehicle</code>的<code>return</code>语句，返回的是一个新对象。<code>new</code>命令会返回这个对象，而不是<code>this</code>对象  </p>
<p>另一方面，如果对普通函数（内部没有<code>this</code>关键字的函数）使用<code>new</code>命令，则会返回一个空对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMessage</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;this is a message&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> msg = <span class="hljs-keyword">new</span> getMessage();<br><br>msg <span class="hljs-comment">// &#123;&#125;</span><br><span class="hljs-keyword">typeof</span> msg <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>getMessage</code>是一个普通函数，返回一个字符串。对它使用<code>new</code>命令，会得到一个空对象。这是因为<code>new</code>命令总是返回一个对象，要么是实例对象，要么是<code>return</code>语句指定的对象。本例中，<code>return</code>语句返回的是字符串，所以<code>new</code>命令就忽略了该语句  </p>
<p><code>new</code>命令简化的内部流程，可以用下面的代码表示  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_new</span>(<span class="hljs-params"><span class="hljs-comment">/* 构造函数 */</span> constructor, <span class="hljs-comment">/* 构造函数参数 */</span> params</span>) </span>&#123;<br>  <span class="hljs-comment">// 将 arguments 对象转为数组</span><br>  <span class="hljs-keyword">var</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>);<br>  <span class="hljs-comment">// 取出构造函数</span><br>  <span class="hljs-keyword">var</span> <span class="hljs-title">constructor</span> = <span class="hljs-title">args</span>.<span class="hljs-title">shift</span>(<span class="hljs-params"></span>);<br>  <span class="hljs-comment">// 创建一个空对象，继承构造函数的 prototype 属性</span><br>  <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">Object</span>.create(<span class="hljs-title">constructor</span>.<span class="hljs-title">prototype</span>);<br>  <span class="hljs-comment">// 执行构造函数</span><br>  <span class="hljs-keyword">var</span> result = <span class="hljs-title">constructor</span>.<span class="hljs-title">apply</span>(<span class="hljs-params">context, args</span>);<br>  <span class="hljs-comment">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span><br>  <span class="hljs-keyword">return</span> (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; result != <span class="hljs-literal">null</span>) ? result : context;<br>&#125;<br><br><span class="hljs-comment">// 实例</span><br><span class="hljs-keyword">var</span> actor = _new(Person, <span class="hljs-string">&#x27;张三&#x27;</span>, <span class="hljs-number">28</span>);<br></code></pre></div></td></tr></table></figure>
<h4 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h4><p>函数内部可以使用<code>new.target</code>属性。如果当前函数是<code>new</code>命令调用，<code>new.target</code>指向当前函数，否则为<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span>.target === f);<br>&#125;<br><br>f() <span class="hljs-comment">// false</span><br><span class="hljs-keyword">new</span> f() <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>使用这个属性，可以判断函数调用的时候，是否使用<code>new</code>命令。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">new</span>.target) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;请使用 new 命令调用！&#x27;</span>);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>f() <span class="hljs-comment">// Uncaught Error: 请使用 new 命令调用！</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，构造函数<code>f</code>调用时，没有使用<code>new</code>命令，就抛出一个错误。</p>
<h3 id="Object-create-创建实例对象"><a href="#Object-create-创建实例对象" class="headerlink" title="Object.create() 创建实例对象"></a>Object.create() 创建实例对象</h3><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用<code>Object.create()</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person1 = &#123;<br>  name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  age: <span class="hljs-number">38</span>,<br>  greeting: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi! I\&#x27;m &#x27;</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;.&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> person2 = <span class="hljs-built_in">Object</span>.create(person1);<br><br>person2.name <span class="hljs-comment">// 张三</span><br>person2.greeting() <span class="hljs-comment">// Hi! I&#x27;m 张三.</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>person1</code>是<code>person2</code>的模板，后者继承了前者的属性和方法  </p>
<h2 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p><code>this</code>关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成  </p>
<p>前一章已经提到，<code>this</code>可以用在构造函数之中，表示实例对象。除此之外，<code>this</code>还可以用在别的场合。但不管是什么场合，<code>this</code>都有一个共同点：它总是返回一个对象  </p>
<p>简单说，<code>this</code>就是属性或方法“当前”所在的对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span>.property<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>this</code>就代表<code>property</code>属性当前所在的对象  </p>
<p>下面是一个实际的例子  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123;<br>  name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  describe: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;姓名：&#x27;</span>+ <span class="hljs-built_in">this</span>.name;<br>  &#125;<br>&#125;;<br><br>person.describe()<br><span class="hljs-comment">// &quot;姓名：张三&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>this.name</code>表示<code>name</code>属性所在的那个对象。由于<code>this.name</code>是在<code>describe</code>方法中调用，而<code>describe</code>方法所在的当前对象是<code>person</code>，因此<code>this</code>指向<code>person</code>，<code>this.name</code>就是<code>person.name</code>  </p>
<p>由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即<code>this</code>的指向是可变的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> A = &#123;<br>  name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  describe: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;姓名：&#x27;</span>+ <span class="hljs-built_in">this</span>.name;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> B = &#123;<br>  name: <span class="hljs-string">&#x27;李四&#x27;</span><br>&#125;;<br><br>B.describe = A.describe;<br>B.describe()<br><span class="hljs-comment">// &quot;姓名：李四&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>A.describe</code>属性被赋给<code>B</code>，于是<code>B.describe</code>就表示<code>describe</code>方法所在的当前对象是<code>B</code>，所以<code>this.name</code>就指向<code>B.name</code>  </p>
<p>稍稍重构这个例子，<code>this</code>的动态指向就能看得更清楚  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;姓名：&#x27;</span>+ <span class="hljs-built_in">this</span>.name;<br>&#125;<br><br><span class="hljs-keyword">var</span> A = &#123;<br>  name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  describe: f<br>&#125;;<br><br><span class="hljs-keyword">var</span> B = &#123;<br>  name: <span class="hljs-string">&#x27;李四&#x27;</span>,<br>  describe: f<br>&#125;;<br><br>A.describe() <span class="hljs-comment">// &quot;姓名：张三&quot;</span><br>B.describe() <span class="hljs-comment">// &quot;姓名：李四&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>f</code>内部使用了<code>this</code>关键字，随着<code>f</code>所在的对象不同，<code>this</code>的指向也不同  </p>
<p>只要函数被赋给另一个变量，<code>this</code>的指向就会变  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> A = &#123;<br>  name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  describe: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;姓名：&#x27;</span>+ <span class="hljs-built_in">this</span>.name;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;李四&#x27;</span>;<br><span class="hljs-keyword">var</span> f = A.describe;<br>f() <span class="hljs-comment">// &quot;姓名：李四&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>A.describe</code>被赋值给变量<code>f</code>，内部的<code>this</code>就会指向<code>f</code>运行时所在的对象（本例是顶层对象）  </p>
<p>再看一个网页编程的例子  </p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">3</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">&quot;validate(this, 18, 99);&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">validate</span>(<span class="hljs-params">obj, lowval, hival</span>)</span>&#123;</span><br><span class="javascript">  <span class="hljs-keyword">if</span> ((obj.value &lt; lowval) || (obj.value &gt; hival))</span><br><span class="javascript">    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Invalid Value!&#x27;</span>);</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码是一个文本输入框，每当用户输入一个值，就会调用<code>onChange</code>回调函数，验证这个值是否在指定范围。浏览器会向回调函数传入当前对象，因此<code>this</code>就代表传入当前对象（即文本框），然后就可以从<code>this.value</code>上面读到用户的输入值  </p>
<p>总结一下，<code>Javascript</code> 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，<code>this</code>就是函数运行时所在的对象（环境）  </p>
<p>这本来并不会让用户糊涂，但是 <code>Javascript</code> 支持运行环境动态切换，也就是说，<code>this</code>的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方  </p>
<h3 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h3><p><code>Javascript</code> 语言之所以有 <code>this</code> 的设计，跟内存里面的数据结构有关系  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">foo</span>:  <span class="hljs-number">5</span> &#125;;<br></code></pre></div></td></tr></table></figure>
<p>上面的代码将一个对象赋值给变量<code>obj</code>  </p>
<p><code>Javascript</code> 引擎会先在内存里面，生成一个对象<code>&#123; foo: 5 &#125;</code>，然后把这个对象的内存地址赋值给变量<code>obj</code>。也就是说，变量<code>obj</code>是一个地址（reference）。后面如果要读取<code>obj.foo</code>，引擎先从<code>obj</code>拿到内存地址，然后再从该地址读出原始的对象，返回它的<code>foo</code>属性  </p>
<p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的<code>foo</code>属性，实际上是以下面的形式保存的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;<br>  foo: &#123;<br>    [[value]]: <span class="hljs-number">5</span><br>    [[writable]]: <span class="hljs-literal">true</span><br>    [[enumerable]]: <span class="hljs-literal">true</span><br>    [[configurable]]: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>注意，<code>foo</code>属性的值保存在属性描述对象的<code>value</code>属性里面  </p>
<p>这样的结构是很清晰的，问题在于属性的值可能是一个函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125; &#125;;<br></code></pre></div></td></tr></table></figure>
<p>这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给<code>foo</code>属性的<code>value</code>属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;<br>  foo: &#123;<br>    [[value]]: 函数的地址<br>    ...<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">f</span>: f &#125;;<br><br><span class="hljs-comment">// 单独执行</span><br>f()<br><br><span class="hljs-comment">// obj 环境执行</span><br>obj.f()<br></code></pre></div></td></tr></table></figure>
<p>JavaScript 允许在函数体内部，引用当前环境的其他变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(x);<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数体里面使用了变量<code>x</code>。该变量由运行环境提供  </p>
<p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数体里面的<code>this.x</code>就是指当前运行环境的<code>x</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>&#125;<br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  f: f,<br>  x: <span class="hljs-number">2</span>,<br>&#125;;<br><br><span class="hljs-comment">// 单独执行</span><br>f() <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// obj 环境执行</span><br>obj.f() <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>f</code>在全局环境执行，<code>this.x</code>指向全局环境的<code>x</code>；在<code>obj</code>环境执行，<code>this.x</code>指向<code>obj.x</code>  </p>
<h3 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h3><p><code>this</code>主要有以下几个使用场合  </p>
<p><strong>（1）全局环境</strong>  </p>
<p>全局环境使用<code>this</code>，它指的就是顶层对象<code>window</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">this</span> === <span class="hljs-built_in">window</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === <span class="hljs-built_in">window</span>);<br>&#125;<br>f() <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，<code>this</code>就是指顶层对象<code>window</code>  </p>
<p><strong>（2）构造函数</strong>  </p>
<p>构造函数中的<code>this</code>，指的是实例对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> Obj = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">p</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.p = p;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>上面代码定义了一个构造函数<code>Obj</code>。由于<code>this</code>指向实例对象，所以在构造函数内部定义<code>this.p</code>，就相当于定义实例对象有一个<code>p</code>属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> Obj(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br>o.p <span class="hljs-comment">// &quot;Hello World!&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>**（3）对象的方法 ** </p>
<p>如果对象的方法里面包含<code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变<code>this</code>的指向  </p>
<p>但是，这条规则很不容易把握。请看下面的代码  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj =&#123;<br>  foo: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;;<br><br>obj.foo() <span class="hljs-comment">// obj</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj.foo</code>方法执行时，它内部的<code>this</code>指向<code>obj</code>  </p>
<p>但是，下面这几种用法，都会改变<code>this</code>的指向  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 情况一</span><br>(obj.foo = obj.foo)() <span class="hljs-comment">// window</span><br><span class="hljs-comment">// 情况二</span><br>(<span class="hljs-literal">false</span> || obj.foo)() <span class="hljs-comment">// window</span><br><span class="hljs-comment">// 情况三</span><br>(<span class="hljs-number">1</span>, obj.foo)() <span class="hljs-comment">// window</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj.foo</code>就是一个值。这个值真正调用的时候，运行环境已经不是<code>obj</code>了，而是全局环境，所以<code>this</code>不再指向<code>obj</code>  </p>
<p>可以这样理解，<code>Javascript</code> 引擎内部，<code>obj</code>和<code>obj.foo</code>储存在两个内存地址，称为地址一和地址二。<code>obj.foo()</code>这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，<code>this</code>指向<code>obj</code>。但是，上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此<code>this</code>指向全局环境。上面三种情况等同于下面的代码  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 情况一</span><br>(obj.foo = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;)()<br><span class="hljs-comment">// 等同于</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;)()<br><br><span class="hljs-comment">// 情况二</span><br>(<span class="hljs-literal">false</span> || <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;)()<br><br><span class="hljs-comment">// 情况三</span><br>(<span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;)()<br></code></pre></div></td></tr></table></figure>
<p>如果<code>this</code>所在的方法不在对象的第一层，这时<code>this</code>只是指向当前一层的对象，而不会继承更上面的层  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;<br>  p: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>  b: &#123;<br>    m: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.p);<br>    &#125;<br>  &#125;<br>&#125;;<br><br>a.b.m() <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>a.b.m</code>方法在<code>a</code>对象的第二层，该方法内部的<code>this</code>不是指向<code>a</code>，而是指向<code>a.b</code>，因为实际执行的是下面的代码  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> b = &#123;<br>  m: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>   <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.p);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> a = &#123;<br>  p: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>  b: b<br>&#125;;<br><br>(a.b).m() <span class="hljs-comment">// 等同于 b.m()</span><br></code></pre></div></td></tr></table></figure>
<p>如果要达到预期效果，只有写成下面这样  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;<br>  b: &#123;<br>    m: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.p);<br>    &#125;,<br>    p: <span class="hljs-string">&#x27;Hello&#x27;</span><br>  &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>如果这时将嵌套对象内部的方法赋值给一个变量，<code>this</code>依然会指向全局对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;<br>  b: &#123;<br>    m: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.p);<br>    &#125;,<br>    p: <span class="hljs-string">&#x27;Hello&#x27;</span><br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> hello = a.b.m;<br>hello() <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>m</code>是多层对象内部的一个方法。为求简便，将其赋值给<code>hello</code>变量，结果调用时，<code>this</code>指向了顶层对象。为了避免这个问题，可以只将<code>m</code>所在的对象赋值给<code>hello</code>，这样调用时，<code>this</code>的指向就不会变  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hello = a.b;<br>hello.m() <span class="hljs-comment">// Hello</span><br></code></pre></div></td></tr></table></figure>
<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><h4 id="避免多层-this"><a href="#避免多层-this" class="headerlink" title="避免多层 this"></a>避免多层 this</h4><p>由于<code>this</code>的指向是不确定的，所以切勿在函数中包含多层的<code>this</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>  f1: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    &#125;();<br>  &#125;<br>&#125;<br><br>o.f1()<br><span class="hljs-comment">// Object</span><br><span class="hljs-comment">// Window</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码包含两层<code>this</code>，结果运行后，第一层指向对象<code>o</code>，第二层指向全局对象，因为实际执行的是下面的代码  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> temp = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> o = &#123;<br>  f1: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">var</span> f2 = temp();<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>一个解决方法是在第二层改用一个指向外层<code>this</code>的变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>  f1: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(that);<br>    &#125;();<br>  &#125;<br>&#125;<br><br>o.f1()<br><span class="hljs-comment">// Object</span><br><span class="hljs-comment">// Object</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码定义了变量<code>that</code>，固定指向外层的<code>this</code>，然后在内层使用<code>that</code>，就不会发生<code>this</code>指向的改变  </p>
<p>事实上，使用一个变量固定<code>this</code>的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握  </p>
<p>JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的<code>this</code>指向顶层对象，就会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> counter = &#123;<br>  count: <span class="hljs-number">0</span><br>&#125;;<br>counter.inc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.count++<br>&#125;;<br><span class="hljs-keyword">var</span> f = counter.inc;<br>f()<br><span class="hljs-comment">// TypeError: Cannot read property &#x27;count&#x27; of undefined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>inc</code>方法通过<code>&#39;use strict&#39;</code>声明采用严格模式，这时内部的<code>this</code>一旦指向顶层对象，就会报错  </p>
<h4 id="避免数组处理方法中的-this"><a href="#避免数组处理方法中的-this" class="headerlink" title="避免数组处理方法中的 this"></a>避免数组处理方法中的 this</h4><p>数组的<code>map</code>和<code>foreach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用<code>this</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>  v: <span class="hljs-string">&#x27;hello&#x27;</span>,<br>  p: [ <span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;a2&#x27;</span> ],<br>  f: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.p.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.v + <span class="hljs-string">&#x27; &#x27;</span> + item);<br>    &#125;);<br>  &#125;<br>&#125;<br><br>o.f()<br><span class="hljs-comment">// undefined a1</span><br><span class="hljs-comment">// undefined a2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>foreach</code>方法的回调函数中的<code>this</code>，其实是指向<code>window</code>对象，因此取不到<code>o.v</code>的值。原因跟上一段的多层<code>this</code>是一样的，就是内层的<code>this</code>不指向外部，而指向顶层对象  </p>
<p>解决这个问题的一种方法，就是前面提到的，使用中间变量固定<code>this</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>  v: <span class="hljs-string">&#x27;hello&#x27;</span>,<br>  p: [ <span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;a2&#x27;</span> ],<br>  f: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> that = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-built_in">this</span>.p.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(that.v+<span class="hljs-string">&#x27; &#x27;</span>+item);<br>    &#125;);<br>  &#125;<br>&#125;<br><br>o.f()<br><span class="hljs-comment">// hello a1</span><br><span class="hljs-comment">// hello a2</span><br></code></pre></div></td></tr></table></figure>
<p>另一种方法是将<code>this</code>当作<code>foreach</code>方法的第二个参数，固定它的运行环境  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<br>  v: <span class="hljs-string">&#x27;hello&#x27;</span>,<br>  p: [ <span class="hljs-string">&#x27;a1&#x27;</span>, <span class="hljs-string">&#x27;a2&#x27;</span> ],<br>  f: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.p.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.v + <span class="hljs-string">&#x27; &#x27;</span> + item);<br>    &#125;, <span class="hljs-built_in">this</span>);<br>  &#125;<br>&#125;<br><br>o.f()<br><span class="hljs-comment">// hello a1</span><br><span class="hljs-comment">// hello a2</span><br></code></pre></div></td></tr></table></figure>
<h4 id="避免回调函数中的-this"><a href="#避免回调函数中的-this" class="headerlink" title="避免回调函数中的 this"></a>避免回调函数中的 this</h4><p>回调函数中的<code>this</code>往往会改变指向，最好避免使用  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>o.f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === o);<br>&#125;<br><br><span class="hljs-comment">// jQuery 的写法</span><br>$(<span class="hljs-string">&#x27;#button&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>, o.f);<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，点击按钮以后，控制台会显示<code>false</code>。原因是此时<code>this</code>不再指向<code>o</code>对象，而是指向按钮的 DOM 对象，因为<code>f</code>方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误  </p>
<p>为了解决这个问题，可以采用下面的一些方法对<code>this</code>进行绑定，也就是使得<code>this</code>固定指向某个对象，减少不确定性  </p>
<h3 id="绑定-this-的方法"><a href="#绑定-this-的方法" class="headerlink" title="绑定 this 的方法"></a>绑定 this 的方法</h3><p><code>this</code>的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把<code>this</code>固定下来，避免出现意想不到的情况。JavaScript 提供了<code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换/固定<code>this</code>的指向  </p>
<h4 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h4><p>函数实例的<code>call</code>方法，可以指定函数内部<code>this</code>的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;;<br><br>f() === <span class="hljs-built_in">window</span> <span class="hljs-comment">// true</span><br>f.call(obj) === obj <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，全局环境运行函数<code>f</code>时，<code>this</code>指向全局环境（浏览器为<code>window</code>对象）；<code>call</code>方法可以改变<code>this</code>的指向，指定<code>this</code>指向对象<code>obj</code>，然后在对象<code>obj</code>的作用域中运行函数<code>f</code>  </p>
<p><code>call</code>方法的参数，应该是一个对象。如果参数为空、<code>null</code>和<code>undefined</code>，则默认传入全局对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">123</span>;<br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">n</span>: <span class="hljs-number">456</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.n);<br>&#125;<br><br>a.call() <span class="hljs-comment">// 123</span><br>a.call(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 123</span><br>a.call(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 123</span><br>a.call(<span class="hljs-built_in">window</span>) <span class="hljs-comment">// 123</span><br>a.call(obj) <span class="hljs-comment">// 456</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>a</code>函数中的<code>this</code>关键字，如果指向全局对象，返回结果为<code>123</code>。如果使用<code>call</code>方法将<code>this</code>关键字指向<code>obj</code>对象，返回结果为<code>456</code>。可以看到，如果<code>call</code>方法没有参数，或者参数为<code>null</code>或<code>undefined</code>，则等同于指向全局对象  </p>
<p>如果<code>call</code>方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入<code>call</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;;<br><br>f.call(<span class="hljs-number">5</span>)<br><span class="hljs-comment">// Number &#123;[[PrimitiveValue]]: 5&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>call</code>的参数为<code>5</code>，不是对象，会被自动转成包装对象（<code>Number</code>的实例），绑定<code>f</code>内部的<code>this</code>。</p>
<p><code>call</code>方法还可以接受多个参数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">func.call(thisValue, arg1, arg2, ...)<br></code></pre></div></td></tr></table></figure>
<p><code>call</code>的第一个参数就是<code>this</code>所要指向的那个对象，后面的参数则是函数调用时所需的参数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br>add.call(<span class="hljs-built_in">this</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>call</code>方法指定函数<code>add</code>内部的<code>this</code>绑定当前环境（对象），并且参数为<code>1</code>和<code>2</code>，因此函数<code>add</code>运行后得到<code>3</code>  </p>
<p><code>call</code>方法的一个应用是调用对象的原生方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.hasOwnProperty(<span class="hljs-string">&#x27;toString&#x27;</span>) <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 覆盖掉继承的 hasOwnProperty 方法</span><br>obj.hasOwnProperty = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;;<br>obj.hasOwnProperty(<span class="hljs-string">&#x27;toString&#x27;</span>) <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">Object</span>.prototype.hasOwnProperty.call(obj, <span class="hljs-string">&#x27;toString&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>hasOwnProperty</code>是<code>obj</code>对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。<code>call</code>方法可以解决这个问题，它将<code>hasOwnProperty</code>方法的原始定义放到<code>obj</code>对象上执行，这样无论<code>obj</code>上有没有同名方法，都不会影响结果  </p>
<h4 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h4><p><code>apply</code>方法的作用与<code>call</code>方法类似，也是改变<code>this</code>指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">func.apply(thisValue, [arg1, arg2, ...])<br></code></pre></div></td></tr></table></figure>
<p><code>apply</code>方法的第一个参数也是<code>this</code>所要指向的那个对象，如果设为<code>null</code>或<code>undefined</code>，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在<code>call</code>方法中必须一个个添加，但是在<code>apply</code>方法中，必须以数组形式添加  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">x, y</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(x + y);<br>&#125;<br><br>f.call(<span class="hljs-literal">null</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 2</span><br>f.apply(<span class="hljs-literal">null</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]) <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>f</code>函数本来接受两个参数，使用<code>apply</code>方法以后，就变成可以接受一个数组作为参数。</p>
<p>利用这一点，可以做一些有趣的应用  </p>
<p><strong>（1）找出数组最大元素</strong>  </p>
<p>JavaScript 不提供找出数组最大元素的函数。结合使用<code>apply</code>方法和<code>Math.max</code>方法，就可以返回数组的最大元素  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">10</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">15</span>, <span class="hljs-number">9</span>];<br><span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, a) <span class="hljs-comment">// 15</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（2）将数组的空元素变为<code>undefined</code></strong>  </p>
<p>通过<code>apply</code>方法，利用<code>Array</code>构造函数将数组的空元素变成<code>undefined</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, [<span class="hljs-string">&#x27;a&#x27;</span>, ,<span class="hljs-string">&#x27;b&#x27;</span>])<br><span class="hljs-comment">// [ &#x27;a&#x27;, undefined, &#x27;b&#x27; ]</span><br></code></pre></div></td></tr></table></figure>
<p>空元素与<code>undefined</code>的差别在于，数组的<code>forEach</code>方法会跳过空元素，但是不会跳过<code>undefined</code>。因此，遍历内部元素的时候，会得到不同的结果  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>, , <span class="hljs-string">&#x27;b&#x27;</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">i</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br><br>a.forEach(print)<br><span class="hljs-comment">// a</span><br><span class="hljs-comment">// b</span><br><br><span class="hljs-built_in">Array</span>.apply(<span class="hljs-literal">null</span>, a).forEach(print)<br><span class="hljs-comment">// a</span><br><span class="hljs-comment">// undefined</span><br><span class="hljs-comment">// b</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（3）转换类似数组的对象</strong>  </p>
<p>另外，利用数组对象的<code>slice</code>方法，可以将一个类似数组的对象（比如<code>arguments</code>对象）转为真正的数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.slice.apply(&#123;<span class="hljs-number">0</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// [1]</span><br><span class="hljs-built_in">Array</span>.prototype.slice.apply(&#123;<span class="hljs-number">0</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// []</span><br><span class="hljs-built_in">Array</span>.prototype.slice.apply(&#123;<span class="hljs-number">0</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">length</span>: <span class="hljs-number">2</span>&#125;) <span class="hljs-comment">// [1, undefined]</span><br><span class="hljs-built_in">Array</span>.prototype.slice.apply(&#123;<span class="hljs-attr">length</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// [undefined]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的<code>apply</code>方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有<code>length</code>属性，以及相对应的数字键  </p>
<p><strong>（4）绑定回调函数的对象</strong>  </p>
<p>前面的按钮点击事件的例子，可以改写如下  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br>o.f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === o);<br>&#125;<br><br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>  o.f.apply(o);<br>  <span class="hljs-comment">// 或者 o.f.call(o);</span><br>&#125;;<br><br><span class="hljs-comment">// jQuery 的写法</span><br>$(<span class="hljs-string">&#x27;#button&#x27;</span>).on(<span class="hljs-string">&#x27;click&#x27;</span>, f);<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，点击按钮以后，控制台将会显示<code>true</code>。由于<code>apply()</code>方法（或者<code>call()</code>方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的<code>bind()</code>方法  </p>
<h4 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h4><p><code>bind()</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>d.getTime() <span class="hljs-comment">// 1481869925657</span><br><br><span class="hljs-keyword">var</span> print = d.getTime;<br>print() <span class="hljs-comment">// Uncaught TypeError: this is not a Date object.</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，我们将<code>d.getTime()</code>方法赋给变量<code>print</code>，然后调用<code>print()</code>就报错了。这是因为<code>getTime()</code>方法内部的<code>this</code>，绑定<code>Date</code>对象的实例，赋给变量<code>print</code>以后，内部的<code>this</code>已经不指向<code>Date</code>对象的实例了  </p>
<p><code>bind()</code>方法可以解决这个问题  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> print = d.getTime.bind(d);<br>print() <span class="hljs-comment">// 1481869925657</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>bind()</code>方法将<code>getTime()</code>方法内部的<code>this</code>绑定到<code>d</code>对象，这时就可以安全地将这个方法赋值给其他变量了  </p>
<p><code>bind</code>方法的参数就是所要绑定<code>this</code>的对象，下面是一个更清晰的例子  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> counter = &#123;<br>  count: <span class="hljs-number">0</span>,<br>  inc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.count++;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> func = counter.inc.bind(counter);<br>func();<br>counter.count <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>counter.inc()</code>方法被赋值给变量<code>func</code>。这时必须用<code>bind()</code>方法将<code>inc()</code>内部的<code>this</code>，绑定到<code>counter</code>，否则就会出错  </p>
<p><code>this</code>绑定到其他对象也是可以的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> counter = &#123;<br>  count: <span class="hljs-number">0</span>,<br>  inc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.count++;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  count: <span class="hljs-number">100</span><br>&#125;;<br><span class="hljs-keyword">var</span> func = counter.inc.bind(obj);<br>func();<br>obj.count <span class="hljs-comment">// 101</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>bind()</code>方法将<code>inc()</code>方法内部的<code>this</code>，绑定到<code>obj</code>对象。结果调用<code>func</code>函数以后，递增的就是<code>obj</code>内部的<code>count</code>属性  </p>
<p><code>bind()</code>还可以接受更多的参数，将这些参数绑定原函数的参数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x * <span class="hljs-built_in">this</span>.m + y * <span class="hljs-built_in">this</span>.n;<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  m: <span class="hljs-number">2</span>,<br>  n: <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> newAdd = add.bind(obj, <span class="hljs-number">5</span>);<br>newAdd(<span class="hljs-number">5</span>) <span class="hljs-comment">// 20</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>bind()</code>方法除了绑定<code>this</code>对象，还将<code>add()</code>函数的第一个参数<code>x</code>绑定成<code>5</code>，然后返回一个新函数<code>newAdd()</code>，这个函数只要再接受一个参数<code>y</code>就能运行了  </p>
<p>如果<code>bind()</code>方法的第一个参数是<code>null</code>或<code>undefined</code>，等于将<code>this</code>绑定到全局对象，函数运行时<code>this</code>指向顶层对象（浏览器为<code>window</code>）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-keyword">var</span> plus5 = add.bind(<span class="hljs-literal">null</span>, <span class="hljs-number">5</span>);<br>plus5(<span class="hljs-number">10</span>) <span class="hljs-comment">// 15</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>add()</code>内部并没有<code>this</code>，使用<code>bind()</code>方法的主要目的是绑定参数<code>x</code>，以后每次运行新函数<code>plus5()</code>，就只需要提供另一个参数<code>y</code>就够了。而且因为<code>add()</code>内部没有<code>this</code>，所以<code>bind()</code>的第一个参数是<code>null</code>，不过这里如果是其他对象，也没有影响  </p>
<p><code>bind()</code>方法有一些使用注意点  </p>
<p><strong>（1）每一次返回一个新函数</strong></p>
<p><code>bind()</code>方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">element.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, o.m.bind(o));<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>click</code>事件绑定<code>bind()</code>方法生成的一个匿名函数。这样会导致无法取消绑定，所以下面的代码是无效的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">element.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, o.m.bind(o));<br></code></pre></div></td></tr></table></figure>
<p>正确的方法是写成下面这样：  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> listener = o.m.bind(o);<br>element.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, listener);<br><span class="hljs-comment">//  ...</span><br>element.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, listener);<br></code></pre></div></td></tr></table></figure>
<p>**（2）结合回调函数使用 ** </p>
<p>回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含<code>this</code>的方法直接当作回调函数。解决方法就是使用<code>bind()</code>方法，将<code>counter.inc()</code>绑定<code>counter</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> counter = &#123;<br>  count: <span class="hljs-number">0</span>,<br>  inc: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">    &#x27;use strict&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.count++;<br>  &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callIt</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  callback();<br>&#125;<br><br>callIt(counter.inc.bind(counter));<br>counter.count <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>callIt()</code>方法会调用回调函数。这时如果直接把<code>counter.inc</code>传入，调用时<code>counter.inc()</code>内部的<code>this</code>就会指向全局对象。使用<code>bind()</code>方法将<code>counter.inc</code>绑定<code>counter</code>以后，就不会有这个问题，<code>this</code>总是指向<code>counter</code>  </p>
<p>还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的<code>this</code>指向，很可能也会出错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  name: <span class="hljs-string">&#x27;张三&#x27;</span>,<br>  times: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>  print: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.times.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>    &#125;);<br>  &#125;<br>&#125;;<br><br>obj.print()<br><span class="hljs-comment">// 没有任何输出</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj.print</code>内部<code>this.times</code>的<code>this</code>是指向<code>obj</code>的，这个没有问题。但是，<code>forEach()</code>方法的回调函数内部的<code>this.name</code>却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">obj.print = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.times.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === <span class="hljs-built_in">window</span>);<br>  &#125;);<br>&#125;;<br><br>obj.print()<br><span class="hljs-comment">// true</span><br><span class="hljs-comment">// true</span><br><span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>解决这个问题，也是通过<code>bind()</code>方法绑定<code>this</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">obj.print = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.times.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;.bind(<span class="hljs-built_in">this</span>));<br>&#125;;<br><br>obj.print()<br><span class="hljs-comment">// 张三</span><br><span class="hljs-comment">// 张三</span><br><span class="hljs-comment">// 张三</span><br></code></pre></div></td></tr></table></figure>
<p>**（3）结合<code>call()</code>方法使用  **</p>
<p>利用<code>bind()</code>方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的<code>slice()</code>方法为例  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].slice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// [1]</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">Array</span>.prototype.slice.call([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// [1]</span><br></code></pre></div></td></tr></table></figure>
<p>上面的代码中，数组的<code>slice</code>方法从<code>[1, 2, 3]</code>里面，按照指定的开始位置和结束位置，切分出另一个数组。这样做的本质是在<code>[1, 2, 3]</code>上面调用<code>Array.prototype.slice()</code>方法，因此可以用<code>call</code>方法表达这个过程，得到同样的结果  </p>
<p><code>call()</code>方法实质上是调用<code>Function.prototype.call()</code>方法，因此上面的表达式可以用<code>bind()</code>方法改写  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> slice = <span class="hljs-built_in">Function</span>.prototype.call.bind(<span class="hljs-built_in">Array</span>.prototype.slice);<br>slice([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">0</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// [1]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的含义就是，将<code>Array.prototype.slice</code>变成<code>Function.prototype.call</code>方法所在的对象，调用时就变成了<code>Array.prototype.slice.call</code>。类似的写法还可以用于其他数组方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> push = <span class="hljs-built_in">Function</span>.prototype.call.bind(<span class="hljs-built_in">Array</span>.prototype.push);<br><span class="hljs-keyword">var</span> pop = <span class="hljs-built_in">Function</span>.prototype.call.bind(<span class="hljs-built_in">Array</span>.prototype.pop);<br><br><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span> ,<span class="hljs-number">2</span> ,<span class="hljs-number">3</span>];<br>push(a, <span class="hljs-number">4</span>)<br>a <span class="hljs-comment">// [1, 2, 3, 4]</span><br><br>pop(a)<br>a <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></div></td></tr></table></figure>
<p>如果再进一步，将<code>Function.prototype.call</code>方法绑定到<code>Function.prototype.bind</code>对象，就意味着<code>bind</code>的调用形式也可以被改写  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.v);<br>&#125;<br><br><span class="hljs-keyword">var</span> o = &#123; <span class="hljs-attr">v</span>: <span class="hljs-number">123</span> &#125;;<br><span class="hljs-keyword">var</span> bind = <span class="hljs-built_in">Function</span>.prototype.call.bind(<span class="hljs-built_in">Function</span>.prototype.bind);<br>bind(f, o)() <span class="hljs-comment">// 123</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的含义就是，将<code>Function.prototype.bind</code>方法绑定在<code>Function.prototype.call</code>上面，所以<code>bind</code>方法就可以直接使用，不需要在函数实例上使用  </p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>面向对象编程很重要的一个方面，就是对象的继承  </p>
<p>A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的  </p>
<p>大部分面向对象的编程语言，都是通过“类”（class）实现对象的继承。传统上，<code>Javascript</code> 语言的继承不通过 class，而是通过“原型对象”（prototype）实现，本章介绍 <code>Javascript</code> 的原型链继承  </p>
<blockquote>
<p>ES6 引入了 class 语法，基于 class 的继承不在这个教程介绍  </p>
</blockquote>
<h3 id="原型对象概述"><a href="#原型对象概述" class="headerlink" title="原型对象概述"></a>原型对象概述</h3><h4 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h4><p><code>Javascript</code> 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span> (<span class="hljs-params">name, color</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.color = color;<br>&#125;<br><br><span class="hljs-keyword">var</span> cat1 = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;大毛&#x27;</span>, <span class="hljs-string">&#x27;白色&#x27;</span>);<br><br>cat1.name <span class="hljs-comment">// &#x27;大毛&#x27;</span><br>cat1.color <span class="hljs-comment">// &#x27;白色&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Cat</code>函数是一个构造函数，函数内部定义了<code>name</code>属性和<code>color</code>属性，所有实例对象（上例是<code>cat1</code>）都会生成这两个属性，即这两个属性会定义在实例对象上面  </p>
<p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name, color</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>  <span class="hljs-built_in">this</span>.color = color;<br>  <span class="hljs-built_in">this</span>.meow = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;喵喵&#x27;</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> cat1 = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;大毛&#x27;</span>, <span class="hljs-string">&#x27;白色&#x27;</span>);<br><span class="hljs-keyword">var</span> cat2 = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;二毛&#x27;</span>, <span class="hljs-string">&#x27;黑色&#x27;</span>);<br><br>cat1.meow === cat2.meow<br><span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>cat1</code>和<code>cat2</code>是同一个构造函数的两个实例，它们都具有<code>meow</code>方法。由于<code>meow</code>方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个<code>meow</code>方法。这既没有必要，又浪费系统资源，因为所有<code>meow</code>方法都是同样的行为，完全应该共享  </p>
<p>这个问题的解决方法，就是 <code>Javascript</code> 的原型对象（prototype）  </p>
<h4 id="prototype-属性的作用"><a href="#prototype-属性的作用" class="headerlink" title="prototype 属性的作用"></a>prototype 属性的作用</h4><p><code>Javascript</code> 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系  </p>
<p>下面，先看怎么为对象指定原型。<code>Javascript</code> 规定，每个函数都有一个<code>prototype</code>属性，指向一个对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">typeof</span> f.prototype <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>f</code>默认具有<code>prototype</code>属性，指向一个对象  </p>
<p>对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br>Animal.prototype.color = <span class="hljs-string">&#x27;white&#x27;</span>;<br><br><span class="hljs-keyword">var</span> cat1 = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;大毛&#x27;</span>);<br><span class="hljs-keyword">var</span> cat2 = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;二毛&#x27;</span>);<br><br>cat1.color <span class="hljs-comment">// &#x27;white&#x27;</span><br>cat2.color <span class="hljs-comment">// &#x27;white&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，构造函数<code>Animal</code>的<code>prototype</code>属性，就是实例对象<code>cat1</code>和<code>cat2</code>的原型对象。原型对象上添加一个<code>color</code>属性，结果，实例对象都共享了该属性  </p>
<p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在<strong>所有</strong>实例对象上  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">Animal.prototype.color = <span class="hljs-string">&#x27;yellow&#x27;</span>;<br><br>cat1.color <span class="hljs-comment">// &quot;yellow&quot;</span><br>cat2.color <span class="hljs-comment">// &quot;yellow&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，原型对象的<code>color</code>属性的值变为<code>yellow</code>，两个实例对象的<code>color</code>属性立刻跟着变了。这是因为实例对象其实没有<code>color</code>属性，都是读取原型对象的<code>color</code>属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处  </p>
<p>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">cat1.color = <span class="hljs-string">&#x27;black&#x27;</span>;<br><br>cat1.color <span class="hljs-comment">// &#x27;black&#x27;</span><br>cat2.color <span class="hljs-comment">// &#x27;yellow&#x27;</span><br>Animal.prototype.color <span class="hljs-comment">// &#x27;yellow&#x27;;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，实例对象<code>cat1</code>的<code>color</code>属性改为<code>black</code>，就使得它不再去原型对象读取<code>color</code>属性，后者的值依然为<code>yellow</code>  </p>
<p>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">Animal.prototype.walk = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27; is walking&#x27;</span>);<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Animal.prototype</code>对象上面定义了一个<code>walk</code>方法，这个方法将可以在所有<code>Animal</code>实例对象上面调用  </p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p><code>Javascript</code> 规定，所有对象都有自己的原型对象（prototype）  </p>
<p>一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p>
<p>如果一层层地上溯，所有对象的原型最终都可以上溯到<code>Object.prototype</code>，即<code>Object</code>构造函数的<code>prototype</code>属性。也就是说，所有对象都继承了<code>Object.prototype</code>的属性。这就是所有对象都有<code>valueOf</code>和<code>toString</code>方法的原因，因为这是从<code>Object.prototype</code>继承的  </p>
<p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是<code>Object.prototype</code>的原型是<code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是<code>null</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-built_in">Object</span>.prototype)<br><span class="hljs-comment">// null</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，<code>Object.prototype</code>对象的原型是<code>null</code>，由于<code>null</code>没有任何属性，所以原型链到此为止。<code>Object.getPrototypeOf</code>方法返回参数对象的原型，具体介绍请看后文  </p>
<p>读取对象的某个属性时，<code>Javascript</code> 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的<code>Object.prototype</code>还是找不到，则返回<code>undefined</code>。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）  </p>
<p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链   </p>
<p>举例来说，如果让构造函数的<code>prototype</code>属性指向一个数组，就意味着实例对象可以调用数组方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> MyArray = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><br>MyArray.prototype = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<br>MyArray.prototype.constructor = MyArray;<br><br><span class="hljs-keyword">var</span> mine = <span class="hljs-keyword">new</span> MyArray();<br>mine.push(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>mine.length <span class="hljs-comment">// 3</span><br>mine <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>mine</code>是构造函数<code>MyArray</code>的实例对象，由于<code>MyArray.prototype</code>指向一个数组实例，使得<code>mine</code>可以调用数组方法（这些方法定义在数组实例的<code>prototype</code>对象上面）。最后那行<code>instanceof</code>表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明<code>mine</code>为<code>Array</code>的实例，<code>instanceof</code>运算符的详细解释详见后文  </p>
<h4 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h4><p><code>prototype</code>对象有一个<code>constructor</code>属性，默认指向<code>prototype</code>对象所在的构造函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">P</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>P.prototype.constructor === P <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>由于<code>constructor</code>属性定义在<code>prototype</code>对象上面，意味着可以被所有实例对象继承  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">P</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> P();<br><br>p.constructor === P <span class="hljs-comment">// true</span><br>p.constructor === P.prototype.constructor <span class="hljs-comment">// true</span><br>p.hasOwnProperty(<span class="hljs-string">&#x27;constructor&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>p</code>是构造函数<code>P</code>的实例对象，但是<code>p</code>自身没有<code>constructor</code>属性，该属性其实是读取原型链上面的<code>P.prototype.constructor</code>属性  </p>
<p><code>constructor</code>属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> F();<br><br>f.constructor === F <span class="hljs-comment">// true</span><br>f.constructor === <span class="hljs-built_in">RegExp</span> <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>constructor</code>属性确定了实例对象<code>f</code>的构造函数是<code>F</code>，而不是<code>RegExp</code>  </p>
<p>另一方面，有了<code>constructor</code>属性，就可以从一个实例对象新建另一个实例  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Constr</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> x = <span class="hljs-keyword">new</span> Constr();<br><br><span class="hljs-keyword">var</span> y = <span class="hljs-keyword">new</span> x.constructor();<br>y <span class="hljs-keyword">instanceof</span> Constr <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>x</code>是构造函数<code>Constr</code>的实例，可以从<code>x.constructor</code>间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">Constr.prototype.createCopy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">this</span>.constructor();<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>createCopy</code>方法调用构造函数，新建另一个实例  </p>
<p><code>constructor</code>属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改<code>constructor</code>属性，防止引用的时候出错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><br>Person.prototype.constructor === Person <span class="hljs-comment">// true</span><br><br>Person.prototype = &#123;<br>  method: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>&#125;;<br><br>Person.prototype.constructor === Person <span class="hljs-comment">// false</span><br>Person.prototype.constructor === <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，构造函数<code>Person</code>的原型对象改掉了，但是没有修改<code>constructor</code>属性，导致这个属性不再指向<code>Person</code>。由于<code>Person</code>的新原型是一个普通对象，而普通对象的<code>constructor</code>属性指向<code>Object</code>构造函数，导致<code>Person.prototype.constructor</code>变成了<code>Object</code>  </p>
<p>所以，修改原型对象时，一般要同时修改<code>constructor</code>属性的指向  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 坏的写法</span><br>C.prototype = &#123;<br>  method1: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...</span>) </span>&#123; ... &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// 好的写法</span><br>C.prototype = &#123;<br>  <span class="hljs-title">constructor</span>: <span class="hljs-title">C</span>,<br>  <span class="hljs-title">method1</span>: <span class="hljs-title">function</span> (<span class="hljs-params">...</span>) &#123; ... &#125;,<br>  <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// 更好的写法</span><br>C.prototype.method1 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...</span>) </span>&#123; ... &#125;;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，要么将<code>constructor</code>属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证<code>instanceof</code>运算符不会失真  </p>
<p>如果不能确定<code>constructor</code>属性是什么函数，还有一个办法：通过<code>name</code>属性，从实例得到构造函数的名称  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foo</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> Foo();<br>f.constructor.name <span class="hljs-comment">// &quot;Foo&quot;</span><br></code></pre></div></td></tr></table></figure>


<blockquote>
<p>若是至此依然云里雾里，可以参考B站的一个<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV117411v76o/?spm_id_from=333.788.recommend_more_video.0">视频</a>  </p>
</blockquote>
<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p><code>instanceof</code>运算符返回一个布尔值，表示对象是否为某个构造函数的实例  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> Vehicle();<br>v <span class="hljs-keyword">instanceof</span> Vehicle <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>v</code>是构造函数<code>Vehicle</code>的实例，所以返回<code>true</code>  </p>
<p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">v <span class="hljs-keyword">instanceof</span> Vehicle<br><span class="hljs-comment">// 等同于</span><br>Vehicle.prototype.isPrototypeOf(v)<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Vehicle</code>是对象<code>v</code>的构造函数，它的原型对象是<code>Vehicle.prototype</code>，<code>isPrototypeOf()</code>方法是 <code>Javascript</code> 提供的原生方法，用于检查某个对象是否为另一个对象的原型，详细解释见后文  </p>
<p>由于<code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>d <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Date</span> <span class="hljs-comment">// true</span><br>d <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>d</code>同时是<code>Date</code>和<code>Object</code>的实例，因此对这两个构造函数都返回<code>true</code>  </p>
<p>由于任意对象（除了<code>null</code>）都是<code>Object</code>的实例，所以<code>instanceof</code>运算符可以判断一个值是否为非<code>null</code>的对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span> &#125;;<br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-literal">null</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，除了<code>null</code>，其他对象的<code>instanceOf Object</code>的运算结果都是<code>true</code>  </p>
<p><code>instanceof</code>的原理是检查右边构造函数的<code>prototype</code>属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有<code>null</code>对象。这时，<code>instanceof</code>判断会失真  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br><span class="hljs-keyword">typeof</span> obj <span class="hljs-comment">// &quot;object&quot;</span><br>obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Object.create(null)</code>返回一个新对象<code>obj</code>，它的原型是<code>null</code>（<code>Object.create()</code>的详细介绍见后文）。右边的构造函数<code>Object</code>的<code>prototype</code>属性，不在左边的原型链上，因此<code>instanceof</code>就认为<code>obj</code>不是<code>Object</code>的实例。这是唯一的<code>instanceof</code>运算符判断会失真的情况（一个对象的原型是<code>null</code>）  </p>
<p><code>instanceof</code>运算符的一个用处，是判断值的类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> y = &#123;&#125;;<br>x <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// true</span><br>y <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>instanceof</code>运算符判断，变量<code>x</code>是数组，变量<code>y</code>是对象  </p>
<p>注意，<code>instanceof</code>运算符只能用于对象，不适用原始类型的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>s <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span> <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，字符串不是<code>String</code>对象的实例（因为字符串不是对象），所以返回<code>false</code>  </p>
<p>此外，对于<code>undefined</code>和<code>null</code>，<code>instanceof</code>运算符总是返回<code>false</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-literal">undefined</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">null</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>利用<code>instanceof</code>运算符，还可以巧妙地解决，调用构造函数时，忘了加<code>new</code>命令的问题  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fubar</span> (<span class="hljs-params">foo, bar</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> Fubar) &#123;<br>    <span class="hljs-built_in">this</span>._foo = foo;<br>    <span class="hljs-built_in">this</span>._bar = bar;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Fubar(foo, bar);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码使用<code>instanceof</code>运算符，在函数体内部判断<code>this</code>关键字是否为构造函数<code>Fubar</code>的实例。如果不是，就表明忘了加<code>new</code>命令。</p>
<h3 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h3><p>让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sub</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  Super.call(<span class="hljs-built_in">this</span>);<br>  <span class="hljs-built_in">this</span>.prop = value;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Sub</code>是子类的构造函数，<code>this</code>是子类的实例。在实例上调用父类的构造函数<code>Super</code>，就会让子类实例具有父类实例的属性  </p>
<p>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">Sub.prototype = <span class="hljs-built_in">Object</span>.create(Super.prototype);<br>Sub.prototype.constructor = Sub;<br>Sub.prototype.method = <span class="hljs-string">&#x27;...&#x27;</span>;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Sub.prototype</code>是子类的原型，要将它赋值为<code>Object.create(Super.prototype)</code>，而不是直接等于<code>Super.prototype</code>。否则后面两行对<code>Sub.prototype</code>的操作，会连父类的原型<code>Super.prototype</code>一起修改掉。</p>
<p>另外一种写法是<code>Sub.prototype</code>等于一个父类实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">Sub.prototype = <span class="hljs-keyword">new</span> Super();<br></code></pre></div></td></tr></table></figure>
<p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。</p>
<p>举例来说，下面是一个<code>Shape</code>构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Shape</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.x = <span class="hljs-number">0</span>;<br>  <span class="hljs-built_in">this</span>.y = <span class="hljs-number">0</span>;<br>&#125;<br><br>Shape.prototype.move = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.x += x;<br>  <span class="hljs-built_in">this</span>.y += y;<br>  <span class="hljs-built_in">console</span>.info(<span class="hljs-string">&#x27;Shape moved.&#x27;</span>);<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>我们需要让<code>Rectangle</code>构造函数继承<code>Shape</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 第一步，子类继承父类的实例</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"></span>) </span>&#123;<br>  Shape.call(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 调用父类构造函数</span><br>&#125;<br><span class="hljs-comment">// 另一种写法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Rectangle</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.base = Shape;<br>  <span class="hljs-built_in">this</span>.base();<br>&#125;<br><br><span class="hljs-comment">// 第二步，子类继承父类的原型</span><br>Rectangle.prototype = <span class="hljs-built_in">Object</span>.create(Shape.prototype);<br>Rectangle.prototype.constructor = Rectangle;<br></code></pre></div></td></tr></table></figure>
<p>采用这样的写法以后，<code>instanceof</code>运算符会对子类和父类的构造函数，都返回<code>true</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> rect = <span class="hljs-keyword">new</span> Rectangle();<br><br>rect <span class="hljs-keyword">instanceof</span> Rectangle  <span class="hljs-comment">// true</span><br>rect <span class="hljs-keyword">instanceof</span> Shape  <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">ClassB.prototype.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  ClassA.prototype.print.call(<span class="hljs-built_in">this</span>);<br>  <span class="hljs-comment">// some code</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，子类<code>B</code>的<code>print</code>方法先调用父类<code>A</code>的<code>print</code>方法，再部署自己的代码。这就等于继承了父类<code>A</code>的<code>print</code>方法  </p>
<blockquote>
<p>若是至此依然云里雾里，可以参考B站的一个<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1N7411k7D2?from=search&seid=3699264387570966853">视频</a>  </p>
</blockquote>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p><code>Javascript</code> 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.hello = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">M2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.world = <span class="hljs-string">&#x27;world&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">S</span>(<span class="hljs-params"></span>) </span>&#123;<br>  M1.call(<span class="hljs-built_in">this</span>);<br>  M2.call(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-comment">// 继承 M1</span><br>S.prototype = <span class="hljs-built_in">Object</span>.create(M1.prototype);<br><span class="hljs-comment">// 继承链上加入 M2</span><br><span class="hljs-built_in">Object</span>.assign(S.prototype, M2.prototype);<br><br><span class="hljs-comment">// 指定构造函数</span><br>S.prototype.constructor = S;<br><br><span class="hljs-keyword">var</span> s = <span class="hljs-keyword">new</span> S();<br>s.hello <span class="hljs-comment">// &#x27;hello&#x27;</span><br>s.world <span class="hljs-comment">// &#x27;world&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，子类<code>S</code>同时继承了父类<code>M1</code>和<code>M2</code>。这种模式又称为 Mixin（混入）  </p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>随着网站逐渐变成“互联网应用程序”，嵌入网页的 <code>Javascript</code> 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑  </p>
<p><code>Javascript</code> 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块  </p>
<p>但是，<code>Javascript</code> 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果  </p>
<h4 id="基本的实现方法"><a href="#基本的实现方法" class="headerlink" title="基本的实现方法"></a>基本的实现方法</h4><p>模块是实现特定功能的一组属性和方法的封装  </p>
<p>简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> module1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(&#123;<br>　_count : <span class="hljs-number">0</span>,<br>　m1 : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>　　<span class="hljs-comment">//...</span><br>　&#125;,<br>　m2 : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>  　<span class="hljs-comment">//...</span><br>　&#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure>
<p>上面的函数<code>m1</code>和<code>m2</code>，都封装在<code>module1</code>对象里。使用的时候，就是调用这个对象的属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">module1.m1();<br></code></pre></div></td></tr></table></figure>
<p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">module1._count = <span class="hljs-number">5</span>;<br></code></pre></div></td></tr></table></figure>
<h4 id="封装私有变量：构造函数的写法"><a href="#封装私有变量：构造函数的写法" class="headerlink" title="封装私有变量：构造函数的写法"></a>封装私有变量：构造函数的写法</h4><p>我们可以利用构造函数，封装私有变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">StringBuilder</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> buffer = [];<br><br>  <span class="hljs-built_in">this</span>.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) </span>&#123;<br>     buffer.push(str);<br>  &#125;;<br><br>  <span class="hljs-built_in">this</span>.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> buffer.join(<span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>buffer</code>是模块的私有变量。一旦生成实例对象，外部是无法直接访问<code>buffer</code>的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">StringBuilder</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>._buffer = [];<br>&#125;<br><br>StringBuilder.prototype = &#123;<br>  <span class="hljs-title">constructor</span>: <span class="hljs-title">StringBuilder</span>,<br>  <span class="hljs-title">add</span>: <span class="hljs-title">function</span> (<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-built_in">this</span>._buffer.push(str);<br>  &#125;,<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>._buffer.join(<span class="hljs-string">&#x27;&#x27;</span>);<br>  &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。</p>
<h4 id="封装私有变量：立即执行函数的写法"><a href="#封装私有变量：立即执行函数的写法" class="headerlink" title="封装私有变量：立即执行函数的写法"></a>封装私有变量：立即执行函数的写法</h4><p>另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> module1 = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>　<span class="hljs-keyword">var</span> _count = <span class="hljs-number">0</span>;<br>　<span class="hljs-keyword">var</span> m1 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>　  <span class="hljs-comment">//...</span><br>　&#125;;<br>　<span class="hljs-keyword">var</span> m2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>　　<span class="hljs-comment">//...</span><br>　&#125;;<br>　<span class="hljs-keyword">return</span> &#123;<br>　　m1 : m1,<br>　　m2 : m2<br>　&#125;;<br>&#125;)();<br></code></pre></div></td></tr></table></figure>
<p>使用上面的写法，外部代码无法读取内部的<code>_count</code>变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.info(module1._count); <span class="hljs-comment">//undefined</span><br></code></pre></div></td></tr></table></figure>
<p>上面的<code>module1</code>就是 <code>Javascript</code> 模块的基本写法。下面，再对这种写法进行加工  </p>
<h4 id="模块的放大模式"><a href="#模块的放大模式" class="headerlink" title="模块的放大模式"></a>模块的放大模式</h4><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> module1 = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mod</span>)</span>&#123;<br>　mod.m3 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>　　<span class="hljs-comment">//...</span><br>　&#125;;<br>　<span class="hljs-keyword">return</span> mod;<br>&#125;)(module1);<br></code></pre></div></td></tr></table></figure>
<p>上面的代码为<code>module1</code>模块添加了一个新方法<code>m3()</code>，然后返回新的<code>module1</code>模块。</p>
<p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> module1 = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">mod</span>) </span>&#123;<br>　<span class="hljs-comment">//...</span><br>　<span class="hljs-keyword">return</span> mod;<br>&#125;)(<span class="hljs-built_in">window</span>.module1 || &#123;&#125;);<br></code></pre></div></td></tr></table></figure>
<p>与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象  </p>
<h4 id="输入全局变量"><a href="#输入全局变量" class="headerlink" title="输入全局变量"></a>输入全局变量</h4><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</p>
<p>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> module1 = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$, YAHOO</span>) </span>&#123;<br>　<span class="hljs-comment">//...</span><br>&#125;)(jQuery, YAHOO);<br></code></pre></div></td></tr></table></figure>
<p>上面的<code>module1</code>模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入<code>module1</code>。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>
<p>立即执行函数还可以起到命名空间的作用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">$, <span class="hljs-built_in">window</span>, <span class="hljs-built_in">document</span></span>) </span>&#123;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">go</span>(<span class="hljs-params">num</span>) </span>&#123;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleEvents</span>(<span class="hljs-params"></span>) </span>&#123;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initialize</span>(<span class="hljs-params"></span>) </span>&#123;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dieCarouselDie</span>(<span class="hljs-params"></span>) </span>&#123;<br>  &#125;<br><br>  <span class="hljs-comment">//attach to the global scope</span><br>  <span class="hljs-built_in">window</span>.finalCarousel = &#123;<br>    init : initialize,<br>    destroy : dieCarouselDie<br>  &#125;<br><br>&#125;)( jQuery, <span class="hljs-built_in">window</span>, <span class="hljs-built_in">document</span> );<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>finalCarousel</code>对象输出到全局，对外暴露<code>init</code>和<code>destroy</code>接口，内部方法<code>go</code>、<code>handleEvents</code>、<code>initialize</code>、<code>dieCarouselDie</code>都是外部无法调用的  </p>
<h2 id="Object-对象的相关方法"><a href="#Object-对象的相关方法" class="headerlink" title="Object 对象的相关方法"></a>Object 对象的相关方法</h2><p><code>Javascript</code> 在<code>Object</code>对象上面，提供了很多相关方法，处理面向对象编程的相关操作。本章介绍这些方法  </p>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p><code>Object.getPrototypeOf</code>方法返回参数对象的原型。这是获取原型对象的标准方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> F();<br><span class="hljs-built_in">Object</span>.getPrototypeOf(f) === F.prototype <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，实例对象<code>f</code>的原型是<code>F.prototype</code>  </p>
<p>下面是几种特殊对象的原型  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 空对象的原型是 Object.prototype</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(&#123;&#125;) === <span class="hljs-built_in">Object</span>.prototype <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// Object.prototype 的原型是 null</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(<span class="hljs-built_in">Object</span>.prototype) === <span class="hljs-literal">null</span> <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 函数的原型是 Function.prototype</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-built_in">Object</span>.getPrototypeOf(f) === <span class="hljs-built_in">Function</span>.prototype <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = &#123;&#125;;<br><span class="hljs-keyword">var</span> b = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">Object</span>.setPrototypeOf(a, b);<br><br><span class="hljs-built_in">Object</span>.getPrototypeOf(a) === b <span class="hljs-comment">// true</span><br>a.x <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Object.setPrototypeOf</code>方法将对象<code>a</code>的原型，设置为对象<code>b</code>，因此<code>a</code>可以共享<code>b</code>的属性  </p>
<p><code>new</code>命令可以使用<code>Object.setPrototypeOf</code>方法模拟  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> F();<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-built_in">Object</span>.setPrototypeOf(&#123;&#125;, F.prototype);<br>F.call(f);<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>new</code>命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的<code>prototype</code>属性（上例是<code>F.prototype</code>）；第二步，将构造函数内部的<code>this</code>绑定这个空对象，然后执行构造函数，使得定义在<code>this</code>上面的方法和属性（上例是<code>this.foo</code>），都转移到这个空对象上  </p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>生成实例对象的常用方法是，使用<code>new</code>命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？  </p>
<p><code>Javascript</code> 提供了<code>Object.create()</code>方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 原型对象</span><br><span class="hljs-keyword">var</span> A = &#123;<br>  print: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 实例对象</span><br><span class="hljs-keyword">var</span> B = <span class="hljs-built_in">Object</span>.create(A);<br><br><span class="hljs-built_in">Object</span>.getPrototypeOf(B) === A <span class="hljs-comment">// true</span><br>B.print() <span class="hljs-comment">// hello</span><br>B.print === A.print <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Object.create()</code>方法以<code>A</code>对象为原型，生成了<code>B</code>对象。<code>B</code>继承了<code>A</code>的所有属性和方法  </p>
<p>实际上，<code>Object.create()</code>方法可以用下面的代码代替  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>.create !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>  <span class="hljs-built_in">Object</span>.create = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>    F.prototype = obj;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F();<br>  &#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码表明，<code>Object.create()</code>方法的实质是新建一个空的构造函数<code>F</code>，然后让<code>F.prototype</code>属性指向参数对象<code>obj</code>，最后返回一个<code>F</code>的实例，从而实现让该实例继承<code>obj</code>的属性  </p>
<p>下面三种方式生成的新对象是等价的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = <span class="hljs-built_in">Object</span>.create(&#123;&#125;);<br><span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.prototype);<br><span class="hljs-keyword">var</span> obj3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br></code></pre></div></td></tr></table></figure>
<p>如果想要生成一个不继承任何属性（比如没有<code>toString()</code>和<code>valueOf()</code>方法）的对象，可以将<code>Object.create()</code>的参数设为<code>null</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br><br>obj.valueOf()<br><span class="hljs-comment">// TypeError: Object [object Object] has no method &#x27;valueOf&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的原型是<code>null</code>，它就不具备一些定义在<code>Object.prototype</code>对象上面的属性，比如<code>valueOf()</code>方法  </p>
<p>使用<code>Object.create()</code>方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.create()<br><span class="hljs-comment">// TypeError: Object prototype may only be an Object or null</span><br><span class="hljs-built_in">Object</span>.create(<span class="hljs-number">123</span>)<br><span class="hljs-comment">// TypeError: Object prototype may only be an Object or null</span><br></code></pre></div></td></tr></table></figure>
<p><code>Object.create()</code>方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj1 = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">Object</span>.create(obj1);<br><br>obj1.p = <span class="hljs-number">2</span>;<br>obj2.p <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，修改对象原型<code>obj1</code>会影响到实例对象<code>obj2</code>  </p>
<p>除了对象的原型，<code>Object.create()</code>方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(&#123;&#125;, &#123;<br>  p1: &#123;<br>    value: <span class="hljs-number">123</span>,<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    writable: <span class="hljs-literal">true</span>,<br>  &#125;,<br>  p2: &#123;<br>    value: <span class="hljs-string">&#x27;abc&#x27;</span>,<br>    enumerable: <span class="hljs-literal">true</span>,<br>    configurable: <span class="hljs-literal">true</span>,<br>    writable: <span class="hljs-literal">true</span>,<br>  &#125;<br>&#125;);<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(&#123;&#125;);<br>obj.p1 = <span class="hljs-number">123</span>;<br>obj.p2 = <span class="hljs-string">&#x27;abc&#x27;</span>;<br></code></pre></div></td></tr></table></figure>
<p><code>Object.create()</code>方法生成的对象，继承了它的原型对象的构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> A();<br><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">Object</span>.create(a);<br><br>b.constructor === A <span class="hljs-comment">// true</span><br>b <span class="hljs-keyword">instanceof</span> A <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>b</code>对象的原型是<code>a</code>对象，因此继承了<code>a</code>对象的构造函数<code>A</code>  </p>
<h3 id="Object-prototype-isPrototypeOf"><a href="#Object-prototype-isPrototypeOf" class="headerlink" title="Object.prototype.isPrototypeOf()"></a>Object.prototype.isPrototypeOf()</h3><p>实例对象的<code>isPrototypeOf</code>方法，用来判断该对象是否为参数对象的原型  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123;&#125;;<br><span class="hljs-keyword">var</span> o2 = <span class="hljs-built_in">Object</span>.create(o1);<br><span class="hljs-keyword">var</span> o3 = <span class="hljs-built_in">Object</span>.create(o2);<br><br>o2.isPrototypeOf(o3) <span class="hljs-comment">// true</span><br>o1.isPrototypeOf(o3) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>o1</code>和<code>o2</code>都是<code>o3</code>的原型。这表明只要实例对象处在参数对象的原型链上，<code>isPrototypeOf</code>方法都返回<code>true</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.isPrototypeOf(&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.prototype.isPrototypeOf([]) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.prototype.isPrototypeOf(<span class="hljs-regexp">/xyz/</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Object</span>.prototype.isPrototypeOf(<span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，由于<code>Object.prototype</code>处于原型链的最顶端，所以对各种实例都返回<code>true</code>，只有直接继承自<code>null</code>的对象除外  </p>
<h3 id="Object-prototype-proto"><a href="#Object-prototype-proto" class="headerlink" title="Object.prototype.__proto__"></a>Object.prototype.__proto__</h3><p>实例对象的<code>__proto__</code>属性（前后各两个下划线），返回该对象的原型。该属性可读写  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-keyword">var</span> p = &#123;&#125;;<br><br>obj.__proto__ = p;<br><span class="hljs-built_in">Object</span>.getPrototypeOf(obj) === p <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码通过<code>__proto__</code>属性，将<code>p</code>对象设为<code>obj</code>对象的原型。</p>
<p>根据语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用<code>Object.getPrototypeOf()</code>和<code>Object.setPrototypeOf()</code>，进行原型对象的读写操作  </p>
<p>原型链可以用<code>__proto__</code>很直观地表示  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> A = &#123;<br>  name: <span class="hljs-string">&#x27;张三&#x27;</span><br>&#125;;<br><span class="hljs-keyword">var</span> B = &#123;<br>  name: <span class="hljs-string">&#x27;李四&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> proto = &#123;<br>  print: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br>&#125;;<br><br>A.__proto__ = proto;<br>B.__proto__ = proto;<br><br>A.print() <span class="hljs-comment">// 张三</span><br>B.print() <span class="hljs-comment">// 李四</span><br><br>A.print === B.print <span class="hljs-comment">// true</span><br>A.print === proto.print <span class="hljs-comment">// true</span><br>B.print === proto.print <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>A</code>对象和<code>B</code>对象的原型都是<code>proto</code>对象，它们都共享<code>proto</code>对象的<code>print</code>方法。也就是说，<code>A</code>和<code>B</code>的<code>print</code>方法，都是在调用<code>proto</code>对象的<code>print</code>方法  </p>
<h3 id="获取原型对象方法的比较"><a href="#获取原型对象方法的比较" class="headerlink" title="获取原型对象方法的比较"></a>获取原型对象方法的比较</h3><p>如前所述，<code>__proto__</code>属性指向当前对象的原型对象，即构造函数的<code>prototype</code>属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br>obj.__proto__ === <span class="hljs-built_in">Object</span>.prototype<br><span class="hljs-comment">// true</span><br>obj.__proto__ === obj.constructor.prototype<br><span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码首先新建了一个对象<code>obj</code>，它的<code>__proto__</code>属性，指向构造函数（<code>Object</code>或<code>obj.constructor</code>）的<code>prototype</code>属性  </p>
<p>因此，获取实例对象<code>obj</code>的原型对象，有三种方法  </p>
<ul>
<li><code>obj.__proto__</code></li>
<li><code>obj.constructor.prototype</code></li>
<li><code>Object.getPrototypeOf(obj)</code></li>
</ul>
<p>上面三种方法之中，前两种都不是很可靠。<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以不部署。而<code>obj.constructor.prototype</code>在手动改变原型对象时，可能会失效  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> P = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> P();<br><br><span class="hljs-keyword">var</span> C = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>C.prototype = p;<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> C();<br><br>c.constructor.prototype === p <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，构造函数<code>C</code>的原型对象被改成了<code>p</code>，但是实例对象的<code>c.constructor.prototype</code>却没有指向<code>p</code>。所以，在改变原型对象时，一般要同时设置<code>constructor</code>属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">C.prototype = p;<br>C.prototype.constructor = C;<br><br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> C();<br>c.constructor.prototype === p <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>因此，推荐使用第三种<code>Object.getPrototypeOf</code>方法，获取原型对象  </p>
<h3 id="Object-getOwnPropertyNames-1"><a href="#Object-getOwnPropertyNames-1" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.getOwnPropertyNames(<span class="hljs-built_in">Date</span>)<br><span class="hljs-comment">// [&quot;parse&quot;, &quot;arguments&quot;, &quot;UTC&quot;, &quot;caller&quot;, &quot;name&quot;, &quot;prototype&quot;, &quot;now&quot;, &quot;length&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Object.getOwnPropertyNames</code>方法返回<code>Date</code>所有自身的属性名  </p>
<p>对象本身的属性之中，有的是可以遍历的（enumerable），有的是不可以遍历。<code>Object.getOwnPropertyNames</code>方法返回所有键名，不管是否可以遍历。只获取那些可以遍历的属性，使用<code>Object.keys</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.keys(<span class="hljs-built_in">Date</span>) <span class="hljs-comment">// []</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表明，<code>Date</code>对象所有自身的属性，都是不可以遍历的  </p>
<h3 id="Object-prototype-hasOwnProperty-1"><a href="#Object-prototype-hasOwnProperty-1" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h3><p>对象实例的<code>hasOwnProperty</code>方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Date</span>.hasOwnProperty(<span class="hljs-string">&#x27;length&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Date</span>.hasOwnProperty(<span class="hljs-string">&#x27;toString&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表明，<code>Date.length</code>（构造函数<code>Date</code>可以接受多少个参数）是<code>Date</code>自身的属性，<code>Date.toString</code>是继承的属性。</p>
<p>另外，<code>hasOwnProperty</code>方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法  </p>
<h3 id="in-运算符和-for…in-循环"><a href="#in-运算符和-for…in-循环" class="headerlink" title="in 运算符和 for…in 循环"></a>in 运算符和 for…in 循环</h3><p><code>in</code>运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;length&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">Date</span> <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">Date</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p><code>in</code>运算符常用于检查一个属性是否存在  </p>
<p>获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用<code>for...in</code>循环  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123; <span class="hljs-attr">p1</span>: <span class="hljs-number">123</span> &#125;;<br><br><span class="hljs-keyword">var</span> o2 = <span class="hljs-built_in">Object</span>.create(o1, &#123;<br>  p2: &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&quot;abc&quot;</span>, <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span> &#125;<br>&#125;);<br><br><span class="hljs-keyword">for</span> (p <span class="hljs-keyword">in</span> o2) &#123;<br>  <span class="hljs-built_in">console</span>.info(p);<br>&#125;<br><span class="hljs-comment">// p2</span><br><span class="hljs-comment">// p1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>o2</code>的<code>p2</code>属性是自身的，<code>p1</code>属性是继承的。这两个属性都会被<code>for...in</code>循环遍历  </p>
<p>为了在<code>for...in</code>循环中获得对象自身的属性，可以采用<code>hasOwnProperty</code>方法判断一下  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> name <span class="hljs-keyword">in</span> object ) &#123;<br>  <span class="hljs-keyword">if</span> ( object.hasOwnProperty(name) ) &#123;<br>    <span class="hljs-comment">/* loop code */</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>获得对象的所有属性（不管是自身的还是继承的，也不管是否可枚举），可以使用下面的函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritedPropertyNames</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> props = &#123;&#125;;<br>  <span class="hljs-keyword">while</span>(obj) &#123;<br>    <span class="hljs-built_in">Object</span>.getOwnPropertyNames(obj).forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">p</span>) </span>&#123;<br>      props[p] = <span class="hljs-literal">true</span>;<br>    &#125;);<br>    obj = <span class="hljs-built_in">Object</span>.getPrototypeOf(obj);<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.getOwnPropertyNames(props);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码依次获取<code>obj</code>对象的每一级原型对象“自身”的属性，从而获取<code>obj</code>对象的“所有”属性，不管是否可遍历  </p>
<p>下面是一个例子，列出<code>Date</code>对象的所有属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">inheritedPropertyNames(<span class="hljs-built_in">Date</span>)<br><span class="hljs-comment">// [</span><br><span class="hljs-comment">//  &quot;caller&quot;,</span><br><span class="hljs-comment">//  &quot;constructor&quot;,</span><br><span class="hljs-comment">//  &quot;toString&quot;,</span><br><span class="hljs-comment">//  &quot;UTC&quot;,</span><br><span class="hljs-comment">//  ...</span><br><span class="hljs-comment">// ]</span><br></code></pre></div></td></tr></table></figure>
<h3 id="对象的拷贝-1"><a href="#对象的拷贝-1" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h3><p>如果要拷贝一个对象，需要做到下面两件事情  </p>
<ul>
<li>确保拷贝后的对象，与原对象具有同样的原型  </li>
<li>确保拷贝后的对象，与原对象具有同样的实例属性  </li>
</ul>
<p>下面就是根据上面两点，实现的对象拷贝函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyObject</span>(<span class="hljs-params">orig</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> copy = <span class="hljs-built_in">Object</span>.create(<span class="hljs-built_in">Object</span>.getPrototypeOf(orig));<br>  copyOwnPropertiesFrom(copy, orig);<br>  <span class="hljs-keyword">return</span> copy;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyOwnPropertiesFrom</span>(<span class="hljs-params">target, source</span>) </span>&#123;<br>  <span class="hljs-built_in">Object</span><br>    .getOwnPropertyNames(source)<br>    .forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">propKey</span>) </span>&#123;<br>      <span class="hljs-keyword">var</span> desc = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(source, propKey);<br>      <span class="hljs-built_in">Object</span>.defineProperty(target, propKey, desc);<br>    &#125;);<br>  <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>另一种更简单的写法，是利用 ES2017 才引入标准的<code>Object.getOwnPropertyDescriptors</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">copyObject</span>(<span class="hljs-params">orig</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.create(<br>    <span class="hljs-built_in">Object</span>.getPrototypeOf(orig),<br>    <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptors(orig)<br>  );<br>&#125;<br></code></pre></div></td></tr></table></figure>


<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><p>除了正常的运行模式，<code>Javascript</code> 还有第二种运行模式：严格模式（strict mode）。顾名思义，这种模式采用更加严格的 <code>JavaScript</code> 语法  </p>
<p>同样的代码，在正常模式和严格模式中，可能会有不一样的运行结果。一些在正常模式下可以运行的语句，在严格模式下将不能运行  </p>
<h3 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h3><p>早期的 <code>Javacript</code> 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法  </p>
<p>严格模式是从 ES5 进入标准的，主要目的有以下几个  </p>
<ul>
<li>明确禁止一些不合理、不严谨的语法，减少 `Javascripts 语言的一些怪异行为  </li>
<li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全  </li>
<li>提高编译器效率，增加运行速度  </li>
<li>为未来新版本的 <code>JavaScript</code> 语法做好铺垫  </li>
</ul>
<p>总之，严格模式体现了 <code>Javascript</code> 更合理、更安全、更严谨的发展方向  </p>
<h3 id="启用方法"><a href="#启用方法" class="headerlink" title="启用方法"></a>启用方法</h3><p>进入严格模式的标志，是一行字符串<code>use strict</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br></code></pre></div></td></tr></table></figure>
<p>老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式  </p>
<p>严格模式可以用于整个脚本，也可以只用于单个函数  </p>
<p><strong>（1） 整个脚本文件</strong></p>
<p><code>use strict</code>放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，<code>use strict</code>可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)   </p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-meta">  &#x27;use strict&#x27;</span>;</span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是严格模式&#x27;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是正常模式&#x27;</span>);</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，一个网页文件依次有两段 JavaScript 代码。前一个<code>&lt;script&gt;</code>标签是严格模式，后一个不是  </p>
<p>如果<code>use strict</code>写成下面这样，则不起作用，严格模式必须从代码一开始就生效  </p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;这是正常模式&#x27;</span>);</span><br><span class="javascript"><span class="hljs-meta">  &#x27;use strict&#x27;</span>;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（2）单个函数</strong></p>
<p><code>use strict</code>放在函数体的第一行，则整个函数以严格模式运行  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strict</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这是严格模式&#x27;</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">strict2</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这也是严格模式&#x27;</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> f();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notStrict</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;这是正常模式&#x27;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-comment">// some code here</span><br>&#125;)();<br></code></pre></div></td></tr></table></figure>


<h3 id="显式报错"><a href="#显式报错" class="headerlink" title="显式报错"></a>显式报错</h3><p>严格模式使得 <code>Javascript</code> 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错   </p>
<h3 id="只读属性不可写"><a href="#只读属性不可写" class="headerlink" title="只读属性不可写"></a>只读属性不可写</h3><p>严格模式下，设置字符串的<code>length</code>属性，会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-string">&#x27;abc&#x27;</span>.length = <span class="hljs-number">5</span>;<br><span class="hljs-comment">// TypeError: Cannot assign to read only property &#x27;length&#x27; of string &#x27;abc&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码报错，因为<code>length</code>是只读属性，严格模式下不可写。正常模式下，改变<code>length</code>属性是无效的，但不会报错  </p>
<p>严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 对只读属性赋值会报错</span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;a&#x27;</span>, &#123;<br>  value: <span class="hljs-number">37</span>,<br>  writable: <span class="hljs-literal">false</span><br>&#125;);<br>obj.a = <span class="hljs-number">123</span>;<br><span class="hljs-comment">// TypeError: Cannot assign to read only property &#x27;a&#x27; of object #&lt;Object&gt;</span><br><br><span class="hljs-comment">// 删除不可配置的属性会报错</span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">1</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><span class="hljs-keyword">delete</span> obj.p<br><span class="hljs-comment">// TypeError: Cannot delete property &#x27;p&#x27; of #&lt;Object&gt;</span><br></code></pre></div></td></tr></table></figure>


<h4 id="只设置了取值器的属性不可写"><a href="#只设置了取值器的属性不可写" class="headerlink" title="只设置了取值器的属性不可写"></a>只设置了取值器的属性不可写</h4><p>严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title">v</span>() &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; &#125;<br>&#125;;<br>obj.v = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// Uncaught TypeError: Cannot set property v of #&lt;Object&gt; which has only a getter</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj.v</code>只有取值器，没有存值器，对它进行赋值就会报错  </p>
<h4 id="禁止扩展的对象不可扩展"><a href="#禁止扩展的对象不可扩展" class="headerlink" title="禁止扩展的对象不可扩展"></a>禁止扩展的对象不可扩展</h4><p>严格模式下，对禁止扩展的对象添加新属性，会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-built_in">Object</span>.preventExtensions(obj);<br>obj.v = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// Uncaught TypeError: Cannot add property v, object is not extensible</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj</code>对象禁止扩展，添加属性就会报错  </p>
<h4 id="eval、arguments-不可用作标识名"><a href="#eval、arguments-不可用作标识名" class="headerlink" title="eval、arguments 不可用作标识名"></a>eval、arguments 不可用作标识名</h4><p>严格模式下，使用<code>eval</code>或者<code>arguments</code>作为标识名，将会报错。下面的语句都会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">eval</span> = <span class="hljs-number">17</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">arguments</span> = <span class="hljs-number">17</span>;<br><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-keyword">set</span> <span class="hljs-title">p</span>(<span class="hljs-params"><span class="hljs-built_in">arguments</span></span>) &#123; &#125; &#125;;<br><span class="hljs-keyword">try</span> &#123; &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-built_in">arguments</span>) &#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"><span class="hljs-built_in">eval</span></span>) </span>&#123; &#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">arguments</span>(<span class="hljs-params"></span>) </span>&#123; &#125;<br><span class="hljs-keyword">var</span> y = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eval</span>(<span class="hljs-params"></span>) </span>&#123; &#125;;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<span class="hljs-string">&#x27;arguments&#x27;</span>, <span class="hljs-string">&quot;&#x27;use strict&#x27;; return 17;&quot;</span>);<br><span class="hljs-comment">// SyntaxError: Unexpected eval or arguments in strict mode</span><br></code></pre></div></td></tr></table></figure>


<h4 id="函数不能有重名的参数"><a href="#函数不能有重名的参数" class="headerlink" title="函数不能有重名的参数"></a>函数不能有重名的参数</h4><p>正常模式下，如果函数有多个重名的参数，可以用<code>arguments[i]</code>读取。严格模式下，这属于语法错误  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, a, b</span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><span class="hljs-comment">// Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span><br></code></pre></div></td></tr></table></figure>


<h4 id="禁止八进制的前缀0表示法"><a href="#禁止八进制的前缀0表示法" class="headerlink" title="禁止八进制的前缀0表示法"></a>禁止八进制的前缀0表示法</h4><p>正常模式下，整数的第一位如果是<code>0</code>，表示这是八进制数，比如<code>0100</code>等于十进制的64。严格模式禁止这种表示法，整数第一位为<code>0</code>，将报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">0100</span>;<br><span class="hljs-comment">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span><br></code></pre></div></td></tr></table></figure>


<h3 id="增强的安全措施"><a href="#增强的安全措施" class="headerlink" title="增强的安全措施"></a>增强的安全措施</h3><p>严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误  </p>
<h4 id="全局变量显式声明"><a href="#全局变量显式声明" class="headerlink" title="全局变量显式声明"></a>全局变量显式声明</h4><p>正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br>v = <span class="hljs-number">1</span>; <span class="hljs-comment">// 报错，v未声明</span><br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123; <span class="hljs-comment">// 报错，i 未声明</span><br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  x = <span class="hljs-number">123</span>;<br>&#125;<br>f() <span class="hljs-comment">// 报错，未声明就创建一个全局变量</span><br></code></pre></div></td></tr></table></figure>
<p>因此，严格模式下，变量都必须先声明，然后再使用  </p>
<h4 id="禁止-this-关键字指向全局对象"><a href="#禁止-this-关键字指向全局对象" class="headerlink" title="禁止 this 关键字指向全局对象"></a>禁止 this 关键字指向全局对象</h4><p>正常模式下，函数内部的<code>this</code>可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 正常模式</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === <span class="hljs-built_in">window</span>);<br>&#125;<br>f() <span class="hljs-comment">// true</span><br><br><span class="hljs-comment">// 严格模式</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === <span class="hljs-literal">undefined</span>);<br>&#125;<br>f() <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，严格模式的函数体内部<code>this</code>是<code>undefined</code>  </p>
<p>这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加<code>new</code>，这时<code>this</code>不再指向全局对象，而是报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.a = <span class="hljs-number">1</span>;<br>&#125;;<br><br>f();<span class="hljs-comment">// 报错，this 未定义</span><br></code></pre></div></td></tr></table></figure>
<p>严格模式下，函数直接调用时（不使用<code>new</code>调用），函数内部的<code>this</code>表示<code>undefined</code>（未定义），因此可以用<code>call</code>、<code>apply</code>和<code>bind</code>方法，将任意值绑定在<code>this</code>上面。正常模式下，<code>this</code>指向全局对象，如果绑定的值是非对象，将被自动转为对象再绑定上去，而<code>null</code>和<code>undefined</code>这两个无法转成对象的值，将被忽略  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 正常模式</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><br>fun() <span class="hljs-comment">// window</span><br>fun.call(<span class="hljs-number">2</span>) <span class="hljs-comment">// Number &#123;2&#125;</span><br>fun.call(<span class="hljs-literal">true</span>) <span class="hljs-comment">// Boolean &#123;true&#125;</span><br>fun.call(<span class="hljs-literal">null</span>) <span class="hljs-comment">// window</span><br>fun.call(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// window</span><br><br><span class="hljs-comment">// 严格模式</span><br><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><br>fun() <span class="hljs-comment">//undefined</span><br>fun.call(<span class="hljs-number">2</span>) <span class="hljs-comment">// 2</span><br>fun.call(<span class="hljs-literal">true</span>) <span class="hljs-comment">// true</span><br>fun.call(<span class="hljs-literal">null</span>) <span class="hljs-comment">// null</span><br>fun.call(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，可以把任意类型的值，绑定在<code>this</code>上面  </p>
<h4 id="禁止使用-fn-callee、fn-caller"><a href="#禁止使用-fn-callee、fn-caller" class="headerlink" title="禁止使用 fn.callee、fn.caller"></a>禁止使用 fn.callee、fn.caller</h4><p>函数内部不得使用<code>fn.caller</code>、<code>fn.arguments</code>，否则会报错。这意味着不能在函数内部得到调用栈了  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  f1.caller;    <span class="hljs-comment">// 报错</span><br>  f1.arguments; <span class="hljs-comment">// 报错</span><br>&#125;<br><br>f1();<br></code></pre></div></td></tr></table></figure>


<h4 id="禁止使用-arguments-callee、arguments-caller"><a href="#禁止使用-arguments-callee、arguments-caller" class="headerlink" title="禁止使用 arguments.callee、arguments.caller"></a>禁止使用 arguments.callee、arguments.caller</h4><p><code>arguments.callee</code>和<code>arguments.caller</code>是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用<code>arguments.callee</code>、<code>arguments.caller</code>将会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.callee;<br>&#125;;<br><br>f(); <span class="hljs-comment">// 报错</span><br></code></pre></div></td></tr></table></figure>


<h4 id="禁止删除变量"><a href="#禁止删除变量" class="headerlink" title="禁止删除变量"></a>禁止删除变量</h4><p>严格模式下无法删除变量，如果使用<code>delete</code>命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的<code>configurable</code>属性设置为<code>true</code>，才能被<code>delete</code>命令删除  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> x;<br><span class="hljs-keyword">delete</span> x; <span class="hljs-comment">// 语法错误</span><br><br><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>, &#123;<br>  x: &#123;<br>    value: <span class="hljs-number">1</span>,<br>    configurable: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;);<br><span class="hljs-keyword">delete</span> obj.x; <span class="hljs-comment">// 删除成功</span><br></code></pre></div></td></tr></table></figure>
<h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><p><code>Javascript</code> 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的  </p>
<p>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外  </p>
<p>具体来说，涉及以下几个方面  </p>
<h4 id="禁止使用-with-语句"><a href="#禁止使用-with-语句" class="headerlink" title="禁止使用 with 语句"></a>禁止使用 with 语句</h4><p>严格模式下，使用<code>with</code>语句将报错。因为<code>with</code>语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">var</span> v  = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-keyword">with</span> (obj) &#123;<br>  v = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">// Uncaught SyntaxError: Strict mode code may not include a with statement</span><br></code></pre></div></td></tr></table></figure>


<h4 id="创设-eval-作用域"><a href="#创设-eval-作用域" class="headerlink" title="创设 eval 作用域"></a>创设 eval 作用域</h4><p>正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：<code>eval</code>作用域  </p>
<p>正常模式下，<code>eval</code>语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，<code>eval</code>语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，<code>eval</code>所生成的变量只能用于<code>eval</code>内部  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;var x = 5; x&#x27;</span>)) <span class="hljs-comment">// 5</span><br>  <span class="hljs-built_in">console</span>.log(x) <span class="hljs-comment">// 2</span><br>&#125;)()<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，由于<code>eval</code>语句内部是一个独立作用域，所以内部的变量<code>x</code>不会泄露到外部  </p>
<p>注意，如果希望<code>eval</code>语句也使用严格模式，有两种方式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 方式一</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">str</span>)</span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(str);<br>&#125;<br>f1(<span class="hljs-string">&#x27;undeclared_variable = 1&#x27;</span>); <span class="hljs-comment">// 报错</span><br><br><span class="hljs-comment">// 方式二</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params">str</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">eval</span>(str);<br>&#125;<br>f2(<span class="hljs-string">&#x27;&quot;use strict&quot;;undeclared_variable = 1&#x27;</span>)  <span class="hljs-comment">// 报错</span><br></code></pre></div></td></tr></table></figure>
<p>上面两种写法，<code>eval</code>内部使用的都是严格模式  </p>
<h4 id="arguments-不再追踪参数的变化"><a href="#arguments-不再追踪参数的变化" class="headerlink" title="arguments 不再追踪参数的变化"></a>arguments 不再追踪参数的变化</h4><p>变量<code>arguments</code>代表函数的参数。严格模式下，函数内部改变参数与<code>arguments</code>的联系被切断了，两者不再存在联动关系。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a</span>) </span>&#123;<br>  a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> [a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]];<br>&#125;<br>f(<span class="hljs-number">1</span>); <span class="hljs-comment">// 正常模式为[2, 2]</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a</span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> [a, <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]];<br>&#125;<br>f(<span class="hljs-number">1</span>); <span class="hljs-comment">// 严格模式为[2, 1]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，改变函数的参数，不会反应到<code>arguments</code>对象上来。</p>
<h3 id="向下一个版本的-Javascript-过渡"><a href="#向下一个版本的-Javascript-过渡" class="headerlink" title="向下一个版本的 Javascript 过渡"></a>向下一个版本的 Javascript 过渡</h3><p>JavaScript 语言的下一个版本是 ECMAScript 6，为了平稳过渡，严格模式引入了一些 ES6 语法。</p>
<h4 id="非函数代码块不得声明函数"><a href="#非函数代码块不得声明函数" class="headerlink" title="非函数代码块不得声明函数"></a>非函数代码块不得声明函数</h4><p>ES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123; &#125; <span class="hljs-comment">// 语法错误</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123; &#125; <span class="hljs-comment">// 语法错误</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码在<code>if</code>代码块和<code>for</code>代码块中声明了函数，ES5 环境会报错  </p>
<p>注意，如果是 ES6 环境，上面的代码不会报错，因为 ES6 允许在代码块之中声明函数  </p>
<h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><p>为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">package</span>(<span class="hljs-params">protected</span>) </span>&#123; <span class="hljs-comment">// 语法错误</span><br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-keyword">var</span> implements; <span class="hljs-comment">// 语法错误</span><br>&#125;<br></code></pre></div></td></tr></table></figure>


<h1 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h1><h2 id="异步操作概述"><a href="#异步操作概述" class="headerlink" title="异步操作概述"></a>异步操作概述</h2><h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>单线程模型指的是，<code>Javascript</code> 只在一个线程上运行。也就是说，<code>Javascript</code> 同时只能执行一个任务，其他任务都必须在后面排队等待  </p>
<p>注意，<code>Javascript</code> 只在一个线程上运行，不代表 <code>Javascript</code> 引擎只有一个线程。事实上，<code>Javascript</code> 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合  </p>
<p><code>Javascript</code> 之所以采用单线程，而不是多线程，跟历史有关系。<code>Javascript</code> 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 <code>Javascript</code> 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，<code>Javascript</code> 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
<p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 <code>Javascript</code> 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p>
<p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。<code>Javascript</code> 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 <code>Javascript</code> 内部采用的“事件循环”机制（Event Loop）。</p>
<p>单线程模型虽然对 <code>Javascript</code> 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是为什么 Node 可以用很少的资源，应付大流量访问的原因。</p>
<p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 <code>Javascript</code> 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 <code>Javascript</code> 单线程的本质。</p>
<h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h3><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p>
<p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p>
<p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p>
<p>举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p>
<h3 id="任务队列和事件循环"><a href="#任务队列和事件循环" class="headerlink" title="任务队列和事件循环"></a>任务队列和事件循环</h3><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p>
<p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行  </p>
<p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作  </p>
<p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Event_loop">维基百科</a>的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”  </p>
<h3 id="异步操作的模式"><a href="#异步操作的模式" class="headerlink" title="异步操作的模式"></a>异步操作的模式</h3><p>下面总结一下异步操作的几种模式。</p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>回调函数是异步操作最基本的方法。</p>
<p>下面是两个函数<code>f1</code>和<code>f2</code>，编程的意图是<code>f2</code>必须等到<code>f1</code>执行完成，才能执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>f1();<br>f2();<br></code></pre></div></td></tr></table></figure>
<p>上面代码的问题在于，如果<code>f1</code>是异步操作，<code>f2</code>会立即执行，不会等到<code>f1</code>结束再执行。</p>
<p>这时，可以考虑改写<code>f1</code>，把<code>f2</code>写成<code>f1</code>的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  callback();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br>f1(f2);<br></code></pre></div></td></tr></table></figure>
<p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Coupling_(computer_programming)">耦合</a>（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p>
<h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>
<p>还是以<code>f1</code>和<code>f2</code>为例。首先，为<code>f1</code>绑定一个事件（这里采用的 jQuery 的<a target="_blank" rel="noopener" href="http://api.jquery.com/on/">写法</a>）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">f1.on(<span class="hljs-string">&#x27;done&#x27;</span>, f2);<br></code></pre></div></td></tr></table></figure>
<p>上面这行代码的意思是，当<code>f1</code>发生<code>done</code>事件，就执行<code>f2</code>。然后，对<code>f1</code>进行改写：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    f1.trigger(<span class="hljs-string">&#x27;done&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>f1.trigger(&#39;done&#39;)</code>表示，执行完成后，立即触发<code>done</code>事件，从而开始执行<code>f2</code>。</p>
<p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Decoupling">去耦合</a>”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p>
<h4 id="发布-订阅"><a href="#发布-订阅" class="headerlink" title="发布/订阅"></a>发布/订阅</h4><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Publish-subscribe_pattern">发布/订阅模式</a>”（publish-subscribe pattern），又称“<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>”（observer pattern）。</p>
<p>这个模式有多种<a target="_blank" rel="noopener" href="http://msdn.microsoft.com/en-us/magazine/hh201955.aspx">实现</a>，下面采用的是 Ben Alman 的 <a target="_blank" rel="noopener" href="https://gist.github.com/661855">Tiny Pub/Sub</a>，这是 jQuery 的一个插件。</p>
<p>首先，<code>f2</code>向信号中心<code>jQuery</code>订阅<code>done</code>信号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">jQuery.subscribe(<span class="hljs-string">&#x27;done&#x27;</span>, f2);<br></code></pre></div></td></tr></table></figure>
<p>然后，<code>f1</code>进行如下改写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    jQuery.publish(<span class="hljs-string">&#x27;done&#x27;</span>);<br>  &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>jQuery.publish(&#39;done&#39;)</code>的意思是，<code>f1</code>执行完成后，向信号中心<code>jQuery</code>发布<code>done</code>信号，从而引发<code>f2</code>的执行。</p>
<p><code>f2</code>完成执行后，可以取消订阅（unsubscribe）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">jQuery.unsubscribe(<span class="hljs-string">&#x27;done&#x27;</span>, f2);<br></code></pre></div></td></tr></table></figure>
<p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h3 id="异步操作的流程控制"><a href="#异步操作的流程控制" class="headerlink" title="异步操作的流程控制"></a>异步操作的流程控制</h3><p>如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span>(<span class="hljs-params">arg, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;参数为 &#x27;</span> + arg +<span class="hljs-string">&#x27; , 1秒后返回结果&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; callback(arg * <span class="hljs-number">2</span>); &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码的<code>async</code>函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。</p>
<p>如果有六个这样的异步任务，需要全部完成后，才能执行最后的<code>final</code>函数。请问应该如何安排操作流程？</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">final</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成: &#x27;</span>, value);<br>&#125;<br><br><span class="hljs-keyword">async</span>(<span class="hljs-number">1</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">async</span>(<span class="hljs-number">2</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">async</span>(<span class="hljs-number">3</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>      <span class="hljs-keyword">async</span>(<span class="hljs-number">4</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>        <span class="hljs-keyword">async</span>(<span class="hljs-number">5</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>          <span class="hljs-keyword">async</span>(<span class="hljs-number">6</span>, final);<br>        &#125;);<br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;);<br><span class="hljs-comment">// 参数为 1 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 2 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 3 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 4 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 5 , 1秒后返回结果</span><br><span class="hljs-comment">// 参数为 6 , 1秒后返回结果</span><br><span class="hljs-comment">// 完成:  12</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。</p>
<h4 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h4><p>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> items = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> ];<br><span class="hljs-keyword">var</span> results = [];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span>(<span class="hljs-params">arg, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;参数为 &#x27;</span> + arg +<span class="hljs-string">&#x27; , 1秒后返回结果&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; callback(arg * <span class="hljs-number">2</span>); &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">final</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成: &#x27;</span>, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">series</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(item) &#123;<br>    <span class="hljs-keyword">async</span>( item, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>&#123;<br>      results.push(result);<br>      <span class="hljs-keyword">return</span> series(items.shift());<br>    &#125;);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> final(results[results.length - <span class="hljs-number">1</span>]);<br>  &#125;<br>&#125;<br><br>series(items.shift());<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>series</code>就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行<code>final</code>函数。<code>items</code>数组保存每一个异步任务的参数，<code>results</code>数组保存每一个异步任务的运行结果。</p>
<p>注意，上面的写法需要六秒，才能完成整个脚本。</p>
<h4 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h4><p>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行<code>final</code>函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> items = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> ];<br><span class="hljs-keyword">var</span> results = [];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span>(<span class="hljs-params">arg, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;参数为 &#x27;</span> + arg +<span class="hljs-string">&#x27; , 1秒后返回结果&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; callback(arg * <span class="hljs-number">2</span>); &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">final</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成: &#x27;</span>, value);<br>&#125;<br><br>items.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>) </span>&#123;<br>  <span class="hljs-keyword">async</span>(item, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>)</span>&#123;<br>    results.push(result);<br>    <span class="hljs-keyword">if</span>(results.length === items.length) &#123;<br>      final(results[results.length - <span class="hljs-number">1</span>]);<br>    &#125;<br>  &#125;)<br>&#125;);<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>forEach</code>方法会同时发起六个异步任务，等到它们全部完成以后，才会执行<code>final</code>函数。</p>
<p>相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</p>
<h4 id="并行与串行的结合"><a href="#并行与串行的结合" class="headerlink" title="并行与串行的结合"></a>并行与串行的结合</h4><p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行<code>n</code>个异步任务，这样就避免了过分占用系统资源。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> items = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span> ];<br><span class="hljs-keyword">var</span> results = [];<br><span class="hljs-keyword">var</span> running = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> limit = <span class="hljs-number">2</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async</span>(<span class="hljs-params">arg, callback</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;参数为 &#x27;</span> + arg +<span class="hljs-string">&#x27; , 1秒后返回结果&#x27;</span>);<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; callback(arg * <span class="hljs-number">2</span>); &#125;, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">final</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成: &#x27;</span>, value);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">launcher</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">while</span>(running &lt; limit &amp;&amp; items.length &gt; <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">var</span> item = items.shift();<br>    <span class="hljs-keyword">async</span>(item, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>) </span>&#123;<br>      results.push(result);<br>      running--;<br>      <span class="hljs-keyword">if</span>(items.length &gt; <span class="hljs-number">0</span>) &#123;<br>        launcher();<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(running == <span class="hljs-number">0</span>) &#123;<br>        final(results);<br>      &#125;<br>    &#125;);<br>    running++;<br>  &#125;<br>&#125;<br><br>launcher();<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，最多只能同时运行两个异步任务。变量<code>running</code>记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于<code>0</code>，就表示所有任务都执行完了，这时就执行<code>final</code>函数。</p>
<p>这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节<code>limit</code>变量，达到效率和资源的最佳平衡  </p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由<code>setTimeout()</code>和<code>setInterval()</code>这两个函数来完成。它们向任务队列添加定时任务。</p>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h3><p><code>setTimeout</code>函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> timerId = <span class="hljs-built_in">setTimeout</span>(func|code, delay);<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>setTimeout</code>函数接受两个参数，第一个参数<code>func|code</code>是将要推迟执行的函数名或者一段代码，第二个参数<code>delay</code>是推迟执行的毫秒数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&#x27;console.log(2)&#x27;</span>,<span class="hljs-number">1000</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码会先输出1和3，然后等待1000毫秒再输出2。注意，<code>console.log(2)</code>必须以字符串的形式，作为<code>setTimeout</code>的参数。</p>
<p>如果推迟执行的是函数，就直接将函数名，作为<code>setTimeout</code>的参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">1000</span>);<br></code></pre></div></td></tr></table></figure>
<p><code>setTimeout</code>的第二个参数如果省略，则默认为0。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(f)<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>
<p>除了前两个参数，<code>setTimeout</code>还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a,b</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a + b);<br>&#125;, <span class="hljs-number">1000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>setTimeout</code>共有4个参数。最后那两个参数，将在1000毫秒之后回调函数执行时，作为回调函数的参数。</p>
<p>还有一个需要注意的地方，如果回调函数是对象的方法，那么<code>setTimeout</code>使得方法内部的<code>this</code>关键字指向全局环境，而不是定义时所在的那个对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  x: <span class="hljs-number">2</span>,<br>  y: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">setTimeout</span>(obj.y, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码输出的是1，而不是2。因为当<code>obj.y</code>在1000毫秒后运行时，<code>this</code>所指向的已经不是<code>obj</code>了，而是全局环境。</p>
<p>为了防止出现这个问题，一种解决方法是将<code>obj.y</code>放入一个函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  x: <span class="hljs-number">2</span>,<br>  y: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  obj.y();<br>&#125;, <span class="hljs-number">1000</span>);<br><span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>obj.y</code>放在一个匿名函数之中，这使得<code>obj.y</code>在<code>obj</code>的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。</p>
<p>另一种解决方法是，使用<code>bind</code>方法，将<code>obj.y</code>这个方法绑定在<code>obj</code>上面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  x: <span class="hljs-number">2</span>,<br>  y: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.x);<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">setTimeout</span>(obj.y.bind(obj), <span class="hljs-number">1000</span>)<br><span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h3><p><code>setInterval</code>函数的用法与<code>setTimeout</code>完全一致，区别仅仅在于<code>setInterval</code>指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，每隔1000毫秒就输出一个2，会无限运行下去，直到关闭当前窗口。</p>
<p>与<code>setTimeout</code>一样，除了前两个参数，<code>setInterval</code>方法还可以接受更多的参数，它们会传入回调函数。</p>
<p>下面是一个通过<code>setInterval</code>方法实现网页动画的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;someDiv&#x27;</span>);<br><span class="hljs-keyword">var</span> opacity = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> fader = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  opacity -= <span class="hljs-number">0.1</span>;<br>  <span class="hljs-keyword">if</span> (opacity &gt;= <span class="hljs-number">0</span>) &#123;<br>    div.style.opacity = opacity;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">clearInterval</span>(fader);<br>  &#125;<br>&#125;, <span class="hljs-number">100</span>);<br></code></pre></div></td></tr></table></figure>
<p>上面代码每隔100毫秒，设置一次<code>div</code>元素的透明度，直至其完全透明为止。</p>
<p><code>setInterval</code>的一个常见用途是实现轮询。下面是一个轮询 URL 的 Hash 值是否发生变化的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> hash = <span class="hljs-built_in">window</span>.location.hash;<br><span class="hljs-keyword">var</span> hashWatcher = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.location.hash != hash) &#123;<br>    updatePage();<br>  &#125;<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></div></td></tr></table></figure>
<p><code>setInterval</code>指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，<code>setInterval</code>指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。</p>
<p>为了确保两次执行之间有固定的间隔，可以不用<code>setInterval</code>，而是每次执行结束后，使用<code>setTimeout</code>指定下一次执行的具体时间。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  timer = <span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">2000</span>);<br>&#125;, <span class="hljs-number">2000</span>);<br></code></pre></div></td></tr></table></figure>
<p>上面代码可以确保，下一次执行总是在本次执行结束之后的2000毫秒开始。</p>
<h3 id="clearTimeout-，clearInterval"><a href="#clearTimeout-，clearInterval" class="headerlink" title="clearTimeout()，clearInterval()"></a>clearTimeout()，clearInterval()</h3><p><code>setTimeout</code>和<code>setInterval</code>函数，都返回一个整数值，表示计数器编号。将该整数传入<code>clearTimeout</code>和<code>clearInterval</code>函数，就可以取消对应的定时器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> id1 = <span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">1000</span>);<br><span class="hljs-keyword">var</span> id2 = <span class="hljs-built_in">setInterval</span>(f, <span class="hljs-number">1000</span>);<br><br><span class="hljs-built_in">clearTimeout</span>(id1);<br><span class="hljs-built_in">clearInterval</span>(id2);<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，回调函数<code>f</code>不会再执行了，因为两个定时器都被取消了。</p>
<p><code>setTimeout</code>和<code>setInterval</code>返回的整数值是连续的，也就是说，第二个<code>setTimeout</code>方法返回的整数值，将比第一个的整数值大1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 11</span><br><span class="hljs-built_in">setTimeout</span>(f, <span class="hljs-number">1000</span>) <span class="hljs-comment">// 12</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，连续调用三次<code>setTimeout</code>，返回值都比上一次大了1。</p>
<p>利用这一点，可以写一个函数，取消当前所有的<code>setTimeout</code>定时器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 每轮事件循环检查一次</span><br>  <span class="hljs-keyword">var</span> gid = <span class="hljs-built_in">setInterval</span>(clearAllTimeouts, <span class="hljs-number">0</span>);<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clearAllTimeouts</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> id = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">while</span> (id &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">if</span> (id !== gid) &#123;<br>        <span class="hljs-built_in">clearTimeout</span>(id);<br>      &#125;<br>      id--;<br>    &#125;<br>  &#125;<br>&#125;)();<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，先调用<code>setTimeout</code>，得到一个计算器编号，然后把编号比它小的计数器全部取消。</p>
<h3 id="实例：debounce-函数"><a href="#实例：debounce-函数" class="headerlink" title="实例：debounce 函数"></a>实例：debounce 函数</h3><p>有时，我们不希望回调函数被频繁调用。比如，用户填入网页输入框的内容，希望通过 Ajax 方法传回服务器，jQuery 的写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;textarea&#x27;</span>).on(<span class="hljs-string">&#x27;keydown&#x27;</span>, ajaxAction);<br></code></pre></div></td></tr></table></figure>
<p>这样写有一个很大的缺点，就是如果用户连续击键，就会连续触发<code>keydown</code>事件，造成大量的 Ajax 通信。这是不必要的，而且很可能产生性能问题。正确的做法应该是，设置一个门槛值，表示两次 Ajax 通信的最小间隔时间。如果在间隔时间内，发生新的<code>keydown</code>事件，则不触发 Ajax 通信，并且重新开始计时。如果过了指定时间，没有发生新的<code>keydown</code>事件，再将数据发送出去。</p>
<p>这种做法叫做 debounce（防抖动）。假定两次 Ajax 通信的间隔不得小于2500毫秒，上面的代码可以改写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$(<span class="hljs-string">&#x27;textarea&#x27;</span>).on(<span class="hljs-string">&#x27;keydown&#x27;</span>, debounce(ajaxAction, <span class="hljs-number">2500</span>));<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, delay</span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 声明计时器</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">arguments</span>;<br>    <span class="hljs-built_in">clearTimeout</span>(timer);<br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      fn.apply(context, args);<br>    &#125;, delay);<br>  &#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，只要在2500毫秒之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是2500毫秒。</p>
<h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p><code>setTimeout</code>和<code>setInterval</code>的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。</p>
<p>这意味着，<code>setTimeout</code>和<code>setInterval</code>指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，<code>setTimeout</code>和<code>setInterval</code>指定的任务，一定会按照预定时间执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(someTask, <span class="hljs-number">100</span>);<br>veryLongTask();<br></code></pre></div></td></tr></table></figure>
<p>上面代码的<code>setTimeout</code>，指定100毫秒以后运行一个任务。但是，如果后面的<code>veryLongTask</code>函数（同步任务）运行时间非常长，过了100毫秒还无法结束，那么被推迟运行的<code>someTask</code>就只有等着，等到<code>veryLongTask</code>运行结束，才轮到它执行。</p>
<p>再看一个<code>setInterval</code>的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br><br>sleep(<span class="hljs-number">3000</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> start = <span class="hljs-built_in">Date</span>.now();<br>  <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">Date</span>.now() - start) &lt; ms) &#123;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>setInterval</code>要求每隔1000毫秒，就输出一个2。但是，紧接着的<code>sleep</code>语句需要3000毫秒才能完成，那么<code>setInterval</code>就必须推迟到3000毫秒之后才开始生效。注意，生效后<code>setInterval</code>不会产生累积效应，即不会一下子输出三个2，而是只会输出一个2。</p>
<h3 id="setTimeout-f-0"><a href="#setTimeout-f-0" class="headerlink" title="setTimeout(f, 0)"></a>setTimeout(f, 0)</h3><h4 id="含义-1"><a href="#含义-1" class="headerlink" title="含义"></a>含义</h4><p><code>setTimeout</code>的作用是将代码推迟到指定时间执行，如果指定时间为<code>0</code>，即<code>setTimeout(f, 0)</code>，那么会立刻执行吗？</p>
<p>答案是不会。因为上一节说过，必须要等到当前脚本的同步任务，全部处理完以后，才会执行<code>setTimeout</code>指定的回调函数<code>f</code>。也就是说，<code>setTimeout(f, 0)</code>会在下一轮事件循环一开始就执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码先输出<code>2</code>，再输出<code>1</code>。因为<code>2</code>是同步任务，在本轮事件循环执行，而<code>1</code>是下一轮事件循环执行。</p>
<p>总之，<code>setTimeout(f, 0)</code>这种写法的目的是，尽可能早地执行<code>f</code>，但是并不能保证立刻就执行<code>f</code>。</p>
<p>实际上，<code>setTimeout(f, 0)</code>不会真的在0毫秒之后运行，不同的浏览器有不同的实现。以 Edge 浏览器为例，会等到4毫秒之后运行。如果电脑正在使用电池供电，会等到16毫秒之后运行；如果网页不在当前 Tab 页，会推迟到1000毫秒（1秒）之后运行。这样是为了节省系统资源。</p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><code>setTimeout(f, 0)</code>有几个非常重要的用途。它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，想让父元素的事件回调函数先发生，就要用到<code>setTimeout(f, 0)</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// HTML 代码如下</span><br><span class="hljs-comment">// &lt;input type=&quot;button&quot; id=&quot;myButton&quot; value=&quot;click&quot;&gt;</span><br><br><span class="hljs-keyword">var</span> input = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myButton&#x27;</span>);<br><br>input.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;<br>    input.value +=<span class="hljs-string">&#x27; input&#x27;</span>;<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;;<br><br><span class="hljs-built_in">document</span>.body.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">C</span>(<span class="hljs-params"></span>) </span>&#123;<br>  input.value += <span class="hljs-string">&#x27; body&#x27;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>上面代码在点击按钮后，先触发回调函数<code>A</code>，然后触发函数<code>C</code>。函数<code>A</code>中，<code>setTimeout</code>将函数<code>B</code>推迟到下一轮事件循环执行，这样就起到了，先触发父元素的回调函数<code>C</code>的目的了。</p>
<p>另一个应用是，用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，<code>keypress</code>事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// HTML 代码如下</span><br><span class="hljs-comment">// &lt;input type=&quot;text&quot; id=&quot;input-box&quot;&gt;</span><br><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;input-box&#x27;</span>).onkeypress = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.value = <span class="hljs-built_in">this</span>.value.toUpperCase();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码想在用户每次输入文本后，立即将字符转为大写。但是实际上，它只能将本次输入前的字符转为大写，因为浏览器此时还没接收到新的文本，所以<code>this.value</code>取不到最新输入的那个字符。只有用<code>setTimeout</code>改写，上面的代码才能发挥作用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;input-box&#x27;</span>).onkeypress = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    self.value = self.value.toUpperCase();<br>  &#125;, <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码将代码放入<code>setTimeout</code>之中，就能使得它在浏览器接收到文本之后触发。</p>
<p>由于<code>setTimeout(f, 0)</code>实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到<code>setTimeout(f, 0)</code>里面执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// 写法一</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0xA00000</span>; i &lt; <span class="hljs-number">0xFFFFFF</span>; i++) &#123;<br>  div.style.backgroundColor = <span class="hljs-string">&#x27;#&#x27;</span> + i.toString(<span class="hljs-number">16</span>);<br>&#125;<br><br><span class="hljs-comment">// 写法二</span><br><span class="hljs-keyword">var</span> timer;<br><span class="hljs-keyword">var</span> i=<span class="hljs-number">0x100000</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">func</span>(<span class="hljs-params"></span>) </span>&#123;<br>  timer = <span class="hljs-built_in">setTimeout</span>(func, <span class="hljs-number">0</span>);<br>  div.style.backgroundColor = <span class="hljs-string">&#x27;#&#x27;</span> + i.toString(<span class="hljs-number">16</span>);<br>  <span class="hljs-keyword">if</span> (i++ == <span class="hljs-number">0xFFFFFF</span>) <span class="hljs-built_in">clearTimeout</span>(timer);<br>&#125;<br><br>timer = <span class="hljs-built_in">setTimeout</span>(func, <span class="hljs-number">0</span>);<br></code></pre></div></td></tr></table></figure>
<p>上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为 JavaScript 执行速度远高于 DOM，会造成大量 DOM 操作“堆积”，而写法二就不会，这就是<code>setTimeout(f, 0)</code>的好处。</p>
<p>另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成<code>setTimeout(highlightNext, 50)</code>的样子，性能压力就会减轻  </p>
<h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。</p>
<p>注意，本章只是 Promise 对象的简单介绍。为了避免与后续教程的重复，更完整的介绍请看<a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/">《ES6 标准入门》</a>的<a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/promise">《Promise 对象》</a>一章。</p>
<p>首先，Promise 是一个对象，也是一个构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// 异步代码...</span><br>&#125;<br><br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(f1);<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Promise</code>构造函数接受一个回调函数<code>f1</code>作为参数，<code>f1</code>里面是异步操作的代码。然后，返回的<code>p1</code>就是一个 Promise 实例。</p>
<p>Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个<code>then</code>方法，用来指定下一步的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(f1);<br>p1.then(f2);<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>f1</code>的异步操作执行完成，就会执行<code>f2</code>。</p>
<p>传统的写法可能需要把<code>f2</code>作为回调函数传入<code>f1</code>，比如写成<code>f1(f2)</code>，异步操作完成后，在<code>f1</code>内部调用<code>f2</code>。Promise 使得<code>f1</code>和<code>f2</code>变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 传统写法</span><br>step1(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value1</span>) </span>&#123;<br>  step2(value1, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value2</span>) </span>&#123;<br>    step3(value2, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value3</span>) </span>&#123;<br>      step4(value3, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value4</span>) </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>      &#125;);<br>    &#125;);<br>  &#125;);<br>&#125;);<br><br><span class="hljs-comment">// Promise 的写法</span><br>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(step1))<br>  .then(step2)<br>  .then(step3)<br>  .then(step4);<br></code></pre></div></td></tr></table></figure>
<p>从上面代码可以看到，采用 Promises 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的<code>Promise</code>实例的生成格式，做了简化，真正的语法请参照下文。</p>
<p>总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程。</p>
<p>Promise 原本只是社区提出的一个构想，一些函数库率先实现了这个功能。ECMAScript 6 将其写入语言标准，目前 JavaScript 原生支持 Promise 对象。</p>
<h3 id="Promise-对象的状态"><a href="#Promise-对象的状态" class="headerlink" title="Promise 对象的状态"></a>Promise 对象的状态</h3><p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p>
<ul>
<li>异步操作未完成（pending）</li>
<li>异步操作成功（fulfilled）</li>
<li>异步操作失败（rejected）</li>
</ul>
<p>上面三种状态里面，<code>fulfilled</code>和<code>rejected</code>合在一起称为<code>resolved</code>（已定型）。</p>
<p>这三种的状态的变化途径只有两种。</p>
<ul>
<li>从“未完成”到“成功”</li>
<li>从“未完成”到“失败”</li>
</ul>
<p>一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。</p>
<p>因此，Promise 的最终结果只有两种。</p>
<ul>
<li>异步操作成功，Promise 实例传回一个值（value），状态变为<code>fulfilled</code>。</li>
<li>异步操作失败，Promise 实例抛出一个错误（error），状态变为<code>rejected</code>。</li>
</ul>
<h3 id="Promise-构造函数"><a href="#Promise-构造函数" class="headerlink" title="Promise 构造函数"></a>Promise 构造函数</h3><p>JavaScript 提供原生的<code>Promise</code>构造函数，用来生成 Promise 实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;<br>    resolve(value);<br>  &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">/* 异步操作失败 */</span><br>    reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>());<br>  &#125;<br>&#125;);<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</p>
<p><code>resolve</code>函数的作用是，将<code>Promise</code>实例的状态从“未完成”变为“成功”（即从<code>pending</code>变为<code>fulfilled</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。<code>reject</code>函数的作用是，将<code>Promise</code>实例的状态从“未完成”变为“失败”（即从<code>pending</code>变为<code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">timeout</span>(<span class="hljs-params">ms</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, ms, <span class="hljs-string">&#x27;done&#x27;</span>);<br>  &#125;);<br>&#125;<br><br>timeout(<span class="hljs-number">100</span>)<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>timeout(100)</code>返回一个 Promise 实例。100毫秒以后，该实例的状态会变为<code>fulfilled</code>。</p>
<h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p>Promise 实例的<code>then</code>方法，用来添加回调函数。</p>
<p><code>then</code>方法可以接受两个回调函数，第一个是异步操作成功时（变为<code>fulfilled</code>状态）的回调函数，第二个是异步操作失败（变为<code>rejected</code>）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  resolve(<span class="hljs-string">&#x27;成功&#x27;</span>);<br>&#125;);<br>p1.then(<span class="hljs-built_in">console</span>.log, <span class="hljs-built_in">console</span>.error);<br><span class="hljs-comment">// &quot;成功&quot;</span><br><br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;失败&#x27;</span>));<br>&#125;);<br>p2.then(<span class="hljs-built_in">console</span>.log, <span class="hljs-built_in">console</span>.error);<br><span class="hljs-comment">// Error: 失败</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>p1</code>和<code>p2</code>都是Promise 实例，它们的<code>then</code>方法绑定两个回调函数：成功时的回调函数<code>console.log</code>，失败时的回调函数<code>console.error</code>（可以省略）。<code>p1</code>的状态变为成功，<code>p2</code>的状态变为失败，对应的回调函数会收到异步操作传回的值，然后在控制台输出。</p>
<p><code>then</code>方法可以链式使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">p1<br>  .then(step1)<br>  .then(step2)<br>  .then(step3)<br>  .then(<br>    <span class="hljs-built_in">console</span>.log,<br>    <span class="hljs-built_in">console</span>.error<br>  );<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>p1</code>后面有四个<code>then</code>，意味依次有四个回调函数。只要前一步的状态变为<code>fulfilled</code>，就会依次执行紧跟在后面的回调函数。</p>
<p>最后一个<code>then</code>方法，回调函数是<code>console.log</code>和<code>console.error</code>，用法上有一点重要的区别。<code>console.log</code>只显示<code>step3</code>的返回值，而<code>console.error</code>可以显示<code>p1</code>、<code>step1</code>、<code>step2</code>、<code>step3</code>之中任意一个发生的错误。举例来说，如果<code>step1</code>的状态变为<code>rejected</code>，那么<code>step2</code>和<code>step3</code>都不会执行了（因为它们是<code>resolved</code>的回调函数）。Promise 开始寻找，接下来第一个为<code>rejected</code>的回调函数，在上面代码中是<code>console.error</code>。这就是说，Promise 对象的报错具有传递性。</p>
<h3 id="then-用法辨析"><a href="#then-用法辨析" class="headerlink" title="then() 用法辨析"></a>then() 用法辨析</h3><p>Promise 的用法，简单说就是一句话：使用<code>then</code>方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法一</span><br>f1().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> f2();<br>&#125;);<br><br><span class="hljs-comment">// 写法二</span><br>f1().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  f2();<br>&#125;);<br><br><span class="hljs-comment">// 写法三</span><br>f1().then(f2());<br><br><span class="hljs-comment">// 写法四</span><br>f1().then(f2);<br></code></pre></div></td></tr></table></figure>
<p>为了便于讲解，下面这四种写法都再用<code>then</code>方法接一个回调函数<code>f3</code>。写法一的<code>f3</code>回调函数的参数，是<code>f2</code>函数的运行结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">f1().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> f2();<br>&#125;).then(f3);<br></code></pre></div></td></tr></table></figure>
<p>写法二的<code>f3</code>回调函数的参数是<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">f1().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  f2();<br>  <span class="hljs-keyword">return</span>;<br>&#125;).then(f3);<br></code></pre></div></td></tr></table></figure>
<p>写法三的<code>f3</code>回调函数的参数，是<code>f2</code>函数返回的函数的运行结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">f1().then(f2())<br>  .then(f3);<br></code></pre></div></td></tr></table></figure>
<p>写法四与写法一只有一个差别，那就是<code>f2</code>会接收到<code>f1()</code>返回的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">f1().then(f2)<br>  .then(f3);<br></code></pre></div></td></tr></table></figure>
<h3 id="实例：图片加载"><a href="#实例：图片加载" class="headerlink" title="实例：图片加载"></a>实例：图片加载</h3><p>下面是使用 Promise 完成图片的加载。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> preloadImage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">path</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image();<br>    image.onload  = resolve;<br>    image.onerror = reject;<br>    image.src = path;<br>  &#125;);<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>image</code>是一个图片对象的实例。它有两个事件监听属性，<code>onload</code>属性在图片加载成功后调用，<code>onerror</code>属性在加载失败调用。</p>
<p>上面的<code>preloadImage()</code>函数用法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">preloadImage(<span class="hljs-string">&#x27;https://example.com/my.jpg&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123; <span class="hljs-built_in">document</span>.body.append(e.target) &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;加载成功&#x27;</span>) &#125;)<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，图片加载成功以后，<code>onload</code>属性会返回一个事件对象，因此第一个<code>then()</code>方法的回调函数，会接收到这个事件对象。该对象的<code>target</code>属性就是图片加载后生成的 DOM 节点。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。</p>
<p>而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。</p>
<p>Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆<code>then</code>，必须自己在<code>then</code>的回调函数里面理清逻辑。</p>
<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>Promise 的回调函数属于异步任务，会在同步任务之后执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  resolve(<span class="hljs-number">1</span>);<br>&#125;).then(<span class="hljs-built_in">console</span>.log);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码会先输出2，再输出1。因为<code>console.log(2)</code>是同步任务，而<code>then</code>的回调函数属于异步任务，一定晚于同步任务执行。</p>
<p>但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>  resolve(<span class="hljs-number">2</span>);<br>&#125;).then(<span class="hljs-built_in">console</span>.log);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 3</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的输出结果是<code>321</code>。这说明<code>then</code>的回调函数的执行时间，早于<code>setTimeout(fn, 0)</code>。因为<code>then</code>是本轮事件循环执行，<code>setTimeout(fn, 0)</code>在下一轮事件循环开始时执行。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Javascript/">Javascript</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/14a04139/">
                        <span class="hidden-mobile">网络-网关、代理、隧道异同</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        粤ICP备2020127796号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44010502001787"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon"/>
            
            <span>粤公网安备 44010502001787号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?758d4ab1e944598b8ead03bb4eb143a5";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
