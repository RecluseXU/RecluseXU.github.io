

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="自娱自乐">
  <meta name="author" content="EvilRecluse">
  <meta name="keywords" content="">
  <title>Javascript-基础-1 - EvilRecluse</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.4.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.6","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"copy_btn":true,"image_zoom":{"enable":true},"lazyload":{"enable":true,"onlypost":false},"web_analytics":{"enable":true,"baidu":"https://hm.baidu.com/hm.js?758d4ab1e944598b8ead03bb4eb143a5","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Chaotic Record</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/md_editor/">
                <i class="iconfont icon-category-fill"></i>
                MDEditor
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Javascript-基础-1">
              
            </span>

            
              <div class="mt-3">
  
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      48.4k 字
    </span>
  

  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Javascript-基础-1</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2021年1月26日 下午
                
              </p>
            
            <div class="markdown-body">
              <h1 id="Javascript信息"><a href="#Javascript信息" class="headerlink" title="Javascript信息"></a>Javascript信息</h1><blockquote>
<p><code>JavaScript</code> 这个名字的原意是“很像Java的脚本语言”  </p>
</blockquote>
<h2 id="语言信息"><a href="#语言信息" class="headerlink" title="语言信息"></a>语言信息</h2><ul>
<li>轻量级脚本语言<br>它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”  </li>
<li>嵌入式（embedded）语言<br>它本身提供的核心语法不算很多，只能用来做一些数学和逻辑运算。不提供任何与 <code>I/O</code> 相关的 <code>API</code>，都要靠宿主环境（host）提供，所以 <code>JavaScript</code> 只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 <code>API</code><br>最常见的环境就是浏览器，另外还有服务器环境，也就是 Node 项目。</li>
<li>弱类型  </li>
<li>解释型 或 即时编译型  </li>
</ul>
<p><code>JavaScript</code> 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式和声明式（如函数式编程）风格  </p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><h3 id="语法灵活"><a href="#语法灵活" class="headerlink" title="语法灵活"></a>语法灵活</h3><p>既支持类似 <code>C</code> 语言清晰的过程式编程，也支持灵活的函数式编程，可以用来写并发处理（concurrent）<br>这些语法特性已经被证明非常强大，可以用于许多场合，尤其适用异步编程  </p>
<p><code>JavaScript</code> 的所有值都是对象，这为程序员提供了灵活性和便利性。因为你可以很方便地、按照需要随时创造数据结构，不用进行麻烦的预定义  </p>
<h3 id="支持编译运行"><a href="#支持编译运行" class="headerlink" title="支持编译运行"></a>支持编译运行</h3><p>虽然是一种解释型语言，但是在现代浏览器中，<code>JavaScript</code> 都是编译后运行。编译后，程序会被高度优化，运行效率接近二进制程序  </p>
<h3 id="事件驱动和非阻塞式设计"><a href="#事件驱动和非阻塞式设计" class="headerlink" title="事件驱动和非阻塞式设计"></a>事件驱动和非阻塞式设计</h3><p><code>JavaScript</code> 程序可以采用事件驱动（<code>event-driven</code>）和非阻塞式（<code>non-blocking</code>）设计，在服务器端适合高并发环境，普通的硬件就可以承受很大的访问量  </p>
<h2 id="语言历史"><a href="#语言历史" class="headerlink" title="语言历史"></a>语言历史</h2><h3 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h3><p>网景（<code>Netscape</code>）公司开发了 <code>Navigator</code> 浏览器，发现浏览器应该需要脚本语言来实现一些简单的功能<br>此时Sum公司<code>JAVA</code>语言问世，并且相当成功。网景公司决定于Sum公司合作，让浏览器支持<code>JAVA</code><br>网景公司研究了一段时间，发现<code>JAVA</code>太重，不合适，但决定未来浏览器脚本语言语法要接近<code>JAVA</code><br>网景公司雇佣了 <code>Brendan Eich</code> 大佬来开发这种新的语言<br><code>Brendan Eich</code> 大佬以 <code>Scheme</code> 语言为蓝本，花费10天时间，完成了这个语言的第一版  </p>
<ul>
<li>基本语法：借鉴 <code>C</code> 语言和 <code>Java</code> 语言  </li>
<li>数据结构：借鉴 <code>Java</code> 语言，包括将值分成原始值和对象两大类  </li>
<li>函数的用法：借鉴 <code>Scheme</code> 语言和 <code>Awk</code> 语言，将函数当作第一等公民，并引入闭包  </li>
<li>原型继承模型：借鉴 <code>Self</code> 语言（<code>Smalltalk</code> 的一种变种）  </li>
<li>正则表达式：借鉴 <code>Perl</code> 语言  </li>
<li>字符串和数组处理：借鉴 <code>Python</code> 语言  </li>
</ul>
<p>这个脚本语言，最初名字叫做 <code>Mocha</code>，1995年9月改为 <code>LiveScript</code>。12月，网景公司与 Sun公司 达成协议，后者允许将这种语言叫做 <code>JavaScript</code>  </p>
<h3 id="JavaScript-与-ECMAScript"><a href="#JavaScript-与-ECMAScript" class="headerlink" title="JavaScript 与 ECMAScript"></a>JavaScript 与 ECMAScript</h3><p>1996年8月，微软模仿 <code>JavaScript</code> 开发了一种相近的语言，取名为<code>JScript</code>（<code>JavaScript</code> 是 网景公司 的注册商标，微软不能用），内置于 <code>IE</code>3.0。网景公司面临丧失浏览器脚本语言的主导权的局面  </p>
<p>1996年11月，网景公司决定将 <code>JavaScript</code> 提交给国际标准化组织 <code>ECMA</code>（European Computer Manufacturers Association），希望 <code>JavaScript</code> 能够成为国际标准，以此抵抗微软。ECMA 的39号技术委员会（Technical Committee 39）负责制定和审核这个标准，成员由业内的大公司派出的工程师组成  </p>
<p>1997年7月，ECMA组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 <code>ECMAScript</code>。这个版本就是 <code>ECMAScript</code> 1.0 版  </p>
<p>之所以不叫 <code>JavaScript</code>，<br>一方面是由于商标的关系，<code>Java</code> 是 <code>Sun</code> 公司的商标，根据授权协议，只有 网景公司可以合法地使用 <code>JavaScript</code> 这个名字， <code>JavaScript</code> 已经被 网景公司注册为商标<br>另一方面也是想体现这门语言的制定者是 <code>ECMA</code>，不是 网景公司，这样有利于保证这门语言的开放性和中立性。因此，<code>ECMAScript</code> 和 <code>JavaScript</code> 的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的  </p>
<h3 id="更新迭代"><a href="#更新迭代" class="headerlink" title="更新迭代"></a>更新迭代</h3><p>1997年7月，<code>ECMAScript</code> 1.0发布  </p>
<p>1998年6月，<code>ECMAScript</code> 2.0版发布  </p>
<p>1999年12月，<code>ECMAScript</code> 3.0版发布，成为 <code>JavaScript</code> 的通行标准，得到了广泛支持  </p>
<p>2007年10月，<code>ECMAScript</code> 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 <code>JavaScript</code> 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案  </p>
<p>2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，<code>ECMA</code> 开会决定，中止 <code>ECMAScript</code> 4.0 的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为 <code>ECMAScript</code> 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 <code>Harmony</code>（和谐）。会后不久，<code>ECMAScript</code> 3.1 就改名为 <code>ECMAScript</code> 5。</p>
<p>2009年12月，<code>ECMAScript</code> 5.0版 正式发布。<code>Harmony</code> 项目则一分为二，一些较为可行的设想定名为 <code>JavaScript.next</code> 继续开发，后来演变成 <code>ECMAScript</code> 6；一些不是很成熟的设想，则被视为 <code>JavaScript.next.next</code>，在更远的将来再考虑推出。TC39 的总体考虑是，<code>ECMAScript</code> 5 与 <code>ECMAScript</code> 3 基本保持兼容，较大的语法修正和新功能加入，将由 <code>JavaScript.next</code> 完成。当时，<code>JavaScript.next</code> 指的是<code>ECMAScript</code> 6。第六版发布以后，将指 <code>ECMAScript</code> 7。TC39 预计，<code>ECMAScript</code> 5 会在2013年的年中成为 <code>JavaScript</code> 开发的主流标准，并在此后五年中一直保持这个位置。</p>
<p>2011年6月，<code>ECMAScript</code> 5.1版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持 ECMAScript 5.1版的全部功能。</p>
<p>2013年3月，<code>ECMAScript</code> 6 草案冻结，不再添加新功能。新的功能设想将被放到 <code>ECMAScript</code> 7  </p>
<p>2013年12月，<code>ECMAScript</code> 6 草案发布  </p>
<p>2015年6月，<code>ECMAScript</code> 6 正式发布，并且更名为 <code>ECMAScript</code>2015。这是因为 TC39 委员会计划，以后每年发布一个 <code>ECMAScript</code> 的版本，下一个版本在2016年发布，称为 <code>ECMAScript</code> 2016，2017年发布 <code>ECMAScript</code> 2017，以此类推  </p>
<h2 id="常见应用"><a href="#常见应用" class="headerlink" title="常见应用"></a>常见应用</h2><ul>
<li>前端 <code>React</code>, <code>Vue</code>, <code>Angular</code>  </li>
<li>后端 <code>Node.js</code>  </li>
<li>桌面端 <code>Electron</code>  </li>
<li>物联网 <code>Arduino</code>  </li>
<li>数据库 <code>MongoDB</code>  </li>
<li>移动端 <code>React Native</code></li>
</ul>
<h1 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h1><h2 id="语句-与-表达式"><a href="#语句-与-表达式" class="headerlink" title="语句 与 表达式"></a>语句 与 表达式</h2><p><code>JavaScript</code> 程序的执行单位为<strong>行（<code>line</code>）</strong>，也就是一行一行地执行。一般情况下，每一行就是一个语句  </p>
<p><strong>语句（<code>statement</code>）</strong>是为了完成某种任务而进行的操作，一般情况下不需要返回值<br><strong>表达式（<code>expression</code>）</strong>，指一个为了得到返回值的计算式  </p>
<p>比如下面的代码  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">3</span>;<br></code></pre></div></td></tr></table></figure>
<p>这是 一<strong>行</strong> 赋值 <strong>语句</strong>，这条语句先用<code>var</code>命令，声明了变量a 然后将 <code>表达式</code> <code>1 + 3</code> 的运算结果赋值给变量<code>a</code>  </p>
<p>凡是 <code>JavaScript</code> 语言中预期为值的地方，都可以使用<strong>表达式</strong><br>比如，赋值<strong>语句</strong>的等号右边，预期是一个值，因此可以放置各种<strong>表达式</strong>  </p>
<p><strong>语句</strong>以分号结尾，一个分号就表示一个<strong>语句</strong>结束。多个语句可以写在一行内  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span> + <span class="hljs-number">3</span> ; <span class="hljs-keyword">var</span> b = <span class="hljs-string">&#x27;abc&#x27;</span>;<br></code></pre></div></td></tr></table></figure>
<p>分号前面可以没有任何内容，<code>JavaScript</code> 引擎将其视为 空<strong>语句</strong>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">;;;<br></code></pre></div></td></tr></table></figure>
<p><strong>表达式</strong> 不需要分号 <strong>结尾</strong>。一旦在表达式后面添加分号，则 <code>JavaScript</code> 引擎就将表达式视为 <strong>语句</strong>，这样会产生一些没有任何意义的 <strong>语句</strong>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">1</span> + <span class="hljs-number">3</span>;<br><span class="hljs-string">&#x27;abc&#x27;</span>;<br></code></pre></div></td></tr></table></figure>
<p>上面两行语句只是单纯地产生一个值，并没有任何实际的意义  </p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>变量</strong> 是对 “值” 的具名引用<br><strong>变量</strong>就是为“值”起名，然后引用这个名字，就等同于引用这个值。<strong>变量</strong>的名字就是<strong>变量名</strong>  </p>
<h3 id="声明与赋值"><a href="#声明与赋值" class="headerlink" title="声明与赋值"></a>声明与赋值</h3><blockquote>
<p><strong>注意，JavaScript 的变量名区分大小写，A和a是两个不同的变量</strong>  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure>
<p>上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，称为将数值1“赋值”给变量a<br>以后，引用变量名a就会得到数值1。最前面的<code>var</code>，是变量声明命令。它表示通知解释引擎，要创建一个变量a  </p>
<p>变量的 声明 和 赋值，是分开的两个步骤，上面的代码将它们合在了一起，实际的步骤是下面这样  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<br>a = <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure>
<p>可以在同一条 <code>var</code> 命令中声明多个变量  </p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javasript">var a, b;<br></code></pre></div></td></tr></table></figure>
<hr>
<p><strong>只声明不赋值的变量</strong><br>如果 只是声明变量 而 没有赋值，则该变量的值是<code>undefined</code><br><code>undefined</code>是一个特殊的值，表示“无定义”  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<br>a <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意：无定义与空是完全不同的</strong>  </p>
</blockquote>
<hr>
<p><strong>不使用命令的变量声明与赋值</strong><br>如果变量赋值的时候，忘了写<code>var</code>命令，这条语句也是有效的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">a = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 词句与var a = 1;几乎完全相同 </span><br></code></pre></div></td></tr></table></figure>
<p>但不写<code>var</code>的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用 <code>var</code> 命令声明变量  </p>
<hr>
<p><strong>动态语言特性</strong><br><code>JavaScript</code> 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>a = <span class="hljs-string">&#x27;hello&#x27;</span>;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，变量a起先被赋值为一个数值，后来又被重新赋值为一个字符串  </p>
<hr>
<p><strong>重复声明</strong><br>如果使用<code>var</code>重新声明一个已经存在的变量，是无效的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> x;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，变量x声明了两次，但第二次声明是无效的<br>但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 此时x被赋值为2，并不会无效</span><br></code></pre></div></td></tr></table></figure>
<p>这是由于声明和赋值是两个操作，声明无效了不会导致赋值无效<br>上面的代码相当于  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> x;  <span class="hljs-comment">// 无效</span><br>x = <span class="hljs-number">2</span>;  <span class="hljs-comment">// 有效</span><br></code></pre></div></td></tr></table></figure>

<h3 id="变量提升-Hoisting"><a href="#变量提升-Hoisting" class="headerlink" title="变量提升 Hoisting"></a>变量提升 Hoisting</h3><p><code>JavaScript</code> 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行<br>这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做 <strong>变量提升（hoisting）</strong>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure>
<p>上面代码首先使用<code>console.log</code>方法，在控制台（console）显示变量a的值。这时变量a还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<br><span class="hljs-built_in">console</span>.log(a);<br>a = <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure>
<p>最后的结果是显示<code>undefined</code>，表示变量<code>a</code>已声明，但还未赋值。</p>
<h2 id="标识符-Identifier"><a href="#标识符-Identifier" class="headerlink" title="标识符 Identifier"></a>标识符 Identifier</h2><p><strong>标识符（identifier）</strong>指的是用来识别各种值的合法名称<br><code>JavaScript</code> 语言的标识符对大小写敏感，所以<code>a</code>和<code>A</code>是两个不同的标识符  </p>
<p>标识符有一套命名规则，不符合规则的就是非法标识符。<code>JavaScript</code>引擎遇到非法标识符会报错  </p>
<p>标识符命名规则:  </p>
<ul>
<li>第一个字符，可以是任意 <code>Unicode</code> 字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）  </li>
<li>第二个字符及后面的字符，除了 <code>Unicode</code> 字母、美元符号和下划线，还可以用数字0-9  </li>
</ul>
<p>由于<code>Unicode</code>字符里存在中文字符，所以中文变量也是合法的  </p>
<p>和其它语言类似，<code>JavaScript</code> 有一些保留字，不能用作标识符<br><code>arguments</code>、<code>break</code>、<code>case</code>、<code>catch</code>、<code>class</code>、<code>const</code>、<code>continue</code>、<code>debugger</code>、<code>default</code>、<code>delete</code>、<code>do</code>、<code>else</code>、<code>enum</code>、<code>eval</code>、<code>export</code>、<code>extends</code>、<code>false</code>、<code>finally</code>、<code>for</code>、<code>function</code>、<code>if</code>、<code>implements</code>、<code>import</code>、<code>in</code>、<code>instanceof</code>、<code>interface</code>、<code>let</code>、<code>new</code>、<code>null</code>、<code>package</code>、<code>private</code>、<code>protected</code>、<code>public</code>、<code>return</code>、<code>static</code>、<code>super</code>、<code>switch</code>、<code>this</code>、<code>throw</code>、<code>true</code>、<code>try</code>、<code>typeof</code>、<code>var</code>、<code>void</code>、<code>while</code>、<code>with</code>、<code>yield</code>  </p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>源码中被 <code>JavaScript</code> 引擎忽略的部分就叫做注释，它的作用是对代码进行解释<br><code>JavaScript</code> 提供两种注释的写法<br>单行注释，用<code>//</code>起头；多行注释，放在<code>/*和*/</code>之间  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 单行注释</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> 多行</span><br><span class="hljs-comment"> 注释</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>

<hr>
<p><strong>不推荐使用的 HTML注释</strong><br>由于历史上 <code>JavaScript</code> 可以兼容 <code>HTML</code> 代码的注释，所以<code>&lt;!--</code>和<code>--&gt;</code>也被视为合法的单行注释  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">x = <span class="hljs-number">1</span>; &lt;!-- 我是注释 <br>--&gt;<br></code></pre></div></td></tr></table></figure>
<p>需要注意的是，<code>--&gt;</code>只有在行首，才会被当成单行注释，否则会当作正常的运算  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countdown</span>(<span class="hljs-params">n</span>) </span>&#123;<br>  <span class="hljs-keyword">while</span> (n --&gt; <span class="hljs-number">0</span>) <span class="hljs-built_in">console</span>.log(n);<br>&#125;<br>countdown(<span class="hljs-number">3</span>)<br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>n --&gt; 0</code>实际上会当作<code>n--</code> <code>&gt; 0</code>，因此输出2、1、0  </p>
<h2 id="区块-Block"><a href="#区块-Block" class="headerlink" title="区块 Block"></a>区块 Block</h2><p><code>JavaScript</code> 使用大括号，将多个相关的语句组合在一起，称为<strong>“区块”（block）</strong>  </p>
<p>对于<code>var</code>命令来说，<code>JavaScript</code> 的区块不构成单独的<strong>作用域（scope）</strong>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>&#125;<br>a <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码在区块内部，使用<code>var</code>命令声明并赋值了变量a，然后在区块外部，变量a依然有效，区块对于<code>var</code>命令不构成单独的作用域，与不使用区块的情况没有任何区别<br>在 <code>JavaScript</code> 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如<code>for</code>、<code>if</code>、<code>while</code>、<code>function</code>等  </p>
<h2 id="条件判断结构"><a href="#条件判断结构" class="headerlink" title="条件判断结构"></a>条件判断结构</h2><p><code>JavaScript</code> 提供<code>if</code>结构和<code>switch</code>结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句  </p>
<h3 id="if-结构"><a href="#if-结构" class="headerlink" title="if 结构"></a>if 结构</h3><p><code>if</code>结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句 </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (布尔值) 语句;<br></code></pre></div></td></tr></table></figure>
<p>“布尔值”往往由一个条件表达式产生的，必须放在圆括号中，表示对表达式求值<br>如果表达式的求值结果为<code>true</code>，就执行紧跟在后面的语句；如果结果为<code>false</code>，则跳过紧跟在后面的语句  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (m === <span class="hljs-number">3</span>) m = m + <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，只有在m等于3时，才会将其值加上1。</p>
<p>这种写法要求条件表达式后面只能有一个语句。如果想执行多个语句，必须在<code>if</code>的条件判断之后，加上大括号，表示代码块（多个语句合并成一个语句）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (m === <span class="hljs-number">3</span>) &#123;<br>  m += <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<blockquote>
<p>建议总是在if语句中使用大括号，因为这样方便插入语句  </p>
</blockquote>
<h3 id="if…else-结构"><a href="#if…else-结构" class="headerlink" title="if…else 结构"></a>if…else 结构</h3><p><code>if</code>代码块后面，还可以跟一个<code>else</code>代码块，表示不满足条件时，所要执行的代码  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (m === <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-comment">// 满足条件时，执行的语句</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-comment">// 不满足条件时，执行的语句</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码判断变量m是否等于3，如果等于就执行<code>if</code>代码块，否则执行<code>else</code>代码块  </p>
<p>对同一个变量进行多次判断时，多个<code>if...else</code>语句可以连写在一起。</p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-keyword">if</span> (m === <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-regexp">//</span> ...<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m === <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-regexp">//</span> ...<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (m === <span class="hljs-number">2</span>) &#123;<br>  <span class="hljs-regexp">//</span> ...<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-regexp">//</span> ...<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>else</code>代码块总是与离自己最近的那个if语句配对  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> n = <span class="hljs-number">2</span>;<br><br><span class="hljs-keyword">if</span> (m !== <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;world&#x27;</span>);<br></code></pre></div></td></tr></table></figure>
<p>上面代码不会有任何输出，<code>else</code>代码块不会得到执行，因为它跟着的是最近的那个<code>if</code>语句，相当于下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (m !== <span class="hljs-number">1</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;world&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="switch-结构"><a href="#switch-结构" class="headerlink" title="switch 结构"></a>switch 结构</h3><p>多个<code>if...else</code>连在一起使用的时候，可以转为使用更方便的<code>switch</code>结构  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (fruit) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;banana&quot;</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;apple&quot;</span>:<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码根据变量<code>fruit</code>的值，选择执行相应的<code>case</code><br>如果所有<code>case</code>都不符合，则执行最后的<code>default</code>部分<br>需要注意的是，每个<code>case</code>代码块内部的<code>break</code>语句不能少，否则会接下去执行下一个<code>case</code>代码块，而不是跳出<code>switch</code>结构  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">switch</span> (x) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x 等于1&#x27;</span>);<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x 等于2&#x27;</span>);<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x 等于其他值&#x27;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>case</code>代码块之中没有<code>break</code>语句，导致不会跳出<code>switch</code>结构，而会一直执行下去  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (x) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x 等于1&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x 等于2&#x27;</span>);<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x 等于其他值&#x27;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>switch语句部分和case语句部分，都可以使用表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">switch</span> (<span class="hljs-number">1</span> + <span class="hljs-number">3</span>) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span> + <span class="hljs-number">2</span>:<br>    f();<br>    <span class="hljs-keyword">break</span>;<br>  <span class="hljs-keyword">default</span>:<br>    neverHappens();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码的<code>default</code>部分，是永远不会执行到的。</p>
<h2 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符 ?:"></a>三元运算符 ?:</h2><p><code>JavaScript</code> 还有一个三元运算符（即该运算符需要三个运算子）<code>?:，</code>也可以用于逻辑判断  </p>
<p><code>(条件) ? 表达式1 : 表达式2</code><br>上面代码中，如果“条件”为<code>true</code>，则返回“表达式1”的值，否则返回“表达式2”的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> even = (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，如果n可以被2整除，则<code>even</code>等于<code>true</code>，否则等于<code>false</code>  它等同于下面的形式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> even;<br><span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) &#123;<br>  even = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  even = <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这个三元运算符可以被视为<code>if...else...</code>的简写形式，因此可以用于多种场合  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myVar;<br><span class="hljs-built_in">console</span>.log(<br>  myVar ?<br>  <span class="hljs-string">&#x27;myVar has a value&#x27;</span> :<br>  <span class="hljs-string">&#x27;myVar does not have a value&#x27;</span><br>)<br><span class="hljs-comment">// myVar does not have a value</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码利用三元运算符，输出相应的提示  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> msg = <span class="hljs-string">&#x27;数字&#x27;</span> + n + <span class="hljs-string">&#x27;是&#x27;</span> + (n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;偶数&#x27;</span> : <span class="hljs-string">&#x27;奇数&#x27;</span>);<br></code></pre></div></td></tr></table></figure>
<p>上面代码利用三元运算符，在字符串之中插入不同的值  </p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>循环语句用于重复执行某个操作，它有多种形式  </p>
<h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p><code>While</code>语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块  </p>
<figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-keyword">while</span> (条件)语句;<br></code></pre></div></td></tr></table></figure>
<figure class="highlight gauss"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gauss"><span class="hljs-keyword">while</span> (条件) &#123;<br>  语句;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>while</code>语句的循环条件是一个表达式，必须放在圆括号中<br>代码块部分，如果只有一条语句，可以省略大括号，否则就必须加上大括号  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i 当前为：&#x27;</span> + i);<br>  i = i + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面的代码将循环100次，直到i等于100为止。</p>
<p>下面的例子是一个无限循环，因为循环条件总是为真。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello, world&#x27;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p><code>for</code>语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (初始化表达式; 条件; 递增表达式) 语句<br></code></pre></div></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (初始化表达式; 条件; 递增表达式) &#123;<br>  语句<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>for</code>语句后面的括号里面，有三个表达式  </p>
<p><strong>初始化表达式（initialize）</strong>：确定循环变量的初始值，只在循环开始时执行一次<br><strong>条件表达式（test）</strong>：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环<br><strong>递增表达式（increment）</strong>：每轮循环的最后一个操作，通常用来递增循环变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; x; i++) &#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，初始化表达式是var i = 0，即初始化一个变量i；<br>测试表达式是i &lt; x，即只要i小于x，就会执行循环；<br>递增表达式是i++，即每次循环结束后，i增大1  </p>
<hr>
<p><strong>忽略成分</strong><br>for语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> ( ; ; )&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello World&#x27;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码省略了for语句表达式的三个部分，结果就导致了一个无限循环  </p>
<h3 id="do…while-循环"><a href="#do…while-循环" class="headerlink" title="do…while 循环"></a>do…while 循环</h3><p><code>do...while</code>循环与<code>while</code>循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">do</span><br>  语句<br><span class="hljs-keyword">while</span> (条件);<br></code></pre></div></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">do</span> &#123;<br>  语句<br>&#125; <span class="hljs-keyword">while</span> (条件);<br></code></pre></div></td></tr></table></figure>
<p>不管条件是否为真，<code>do...while</code>循环至少运行一次，这是这种结构最大的特点  </p>
<blockquote>
<p>注意不要省略 <code>while</code>语句后面的分号  </p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">do</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>  i++;<br>&#125; <span class="hljs-keyword">while</span>(i &lt; x);<br></code></pre></div></td></tr></table></figure>

<h3 id="break-语句和-continue-语句"><a href="#break-语句和-continue-语句" class="headerlink" title="break 语句和 continue 语句"></a>break 语句和 continue 语句</h3><p>break语句和continue语句都具有跳转作用，可以让代码不按既有的顺序执行<br>break语句用于跳出代码块或循环  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span>(i &lt; <span class="hljs-number">100</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i 当前为：&#x27;</span> + i);<br>  i++;<br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">10</span>) <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码只会执行10次循环，一旦i等于10，就会跳出循环。</p>
<p>continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">while</span> (i &lt; <span class="hljs-number">100</span>)&#123;<br>  i++;<br>  <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i 当前为：&#x27;</span> + i);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码只有在i为奇数时，才会输出i的值。如果i为偶数，则直接进入下一轮循环  </p>
<p>如果存在多重循环，不带参数的<code>break</code>语句和<code>continue</code>语句都只针对最内层循环  </p>
<h2 id="标签-Label"><a href="#标签-Label" class="headerlink" title="标签 Label"></a>标签 Label</h2><p>(不建议使用)<br><code>JavaScript</code> 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">label:<br>  语句<br></code></pre></div></td></tr></table></figure>
<p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句  </p>
<p>标签通常与break语句和continue语句配合使用，跳出特定的循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">top:<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++)&#123;<br>      <span class="hljs-keyword">if</span> (i === <span class="hljs-number">1</span> &amp;&amp; j === <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span> top;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;i=&#x27;</span> + i + <span class="hljs-string">&#x27;, j=&#x27;</span> + j);<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// i=0, j=0</span><br><span class="hljs-comment">// i=0, j=1</span><br><span class="hljs-comment">// i=0, j=2</span><br><span class="hljs-comment">// i=1, j=0</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码为一个双重循环区块，<code>break</code>命令后面加上了<code>top</code>标签（注意，top不用加引号），满足条件时，直接跳出双层循环<br>如果break语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环  </p>
<p>标签也可以用于跳出代码块  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">foo: &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">break</span> foo;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;本行不会输出&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码执行到break foo，就会跳出区块。</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="类型测定"><a href="#类型测定" class="headerlink" title="类型测定"></a>类型测定</h2><p><code>JavaScript</code> 有三种方法，可以确定一个值到底是什么类型  </p>
<ul>
<li><code>typeof</code> 运算符  </li>
<li><code>instanceof</code> 运算符  </li>
<li><code>Object.prototype.toString</code> 方法  </li>
</ul>
<p><code>instanceof</code>运算符 和 <code>Object.prototype.toString</code>方法，将在后文介绍。这里介绍 <code>typeof</code>运算符  </p>
<p><code>typeof</code>运算符可以返回一个值的数据类型  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-number">123</span>  <span class="hljs-comment">// &quot;number&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-string">&#x27;123&#x27;</span>  <span class="hljs-comment">// &quot;string&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">false</span>  <span class="hljs-comment">// &quot;boolean&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">typeof</span> f  <span class="hljs-comment">// &quot;function&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>  <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> &#123;&#125; <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> [] <span class="hljs-comment">// &quot;object&quot;</span><br><span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span> <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></div></td></tr></table></figure>
<blockquote>
<p><strong>注意：typeof null 返回的是 “object”</strong>  </p>
</blockquote>
<h2 id="null-和-undefined"><a href="#null-和-undefined" class="headerlink" title="null 和 undefined"></a>null 和 undefined</h2><p><code>null</code>与<code>undefined</code>都可以表示“没有”，含义非常相似<br>将一个变量赋值为<code>undefined</code>或<code>null</code>，语法效果几乎没区别  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-literal">undefined</span>;<br><span class="hljs-keyword">var</span> a = <span class="hljs-literal">null</span>;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，变量a分别被赋值为<code>undefined</code>和<code>null</code>，这两种写法的效果几乎等价  </p>
<p>在<code>if</code>语句中，它们都会被自动转为<code>false</code>，相等运算符（==）甚至直接报告两者相等  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!<span class="hljs-literal">undefined</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;undefined is false&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (!<span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;null is false&#x27;</span>);<br>&#125;<br><br><span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>  <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>从上面代码可见，两者的行为是何等相似！<br>谷歌公司开发的 <code>JavaScript</code> 语言的替代品 <code>Dart</code> 语言，就明确规定只有<code>null</code>，没有<code>undefined</code>  </p>
<p>既然含义与用法都差不多，为什么要同时设置两个这样的值，这不是无端增加复杂度，令初学者困扰吗？这与历史原因有关  </p>
<blockquote>
<p><strong>历史原因</strong><br>1995年 <code>JavaScript</code> 诞生时，最初像 <code>Java</code> 一样，只设置了<code>null</code>表示”无”。根据 <code>C</code> 语言的传统，<code>null</code>可以自动转为0<br>但是，<code>JavaScript</code> 的设计者 Brendan Eich，觉得这样做还不够<br>首先，第一版的 <code>JavaScript</code> 里面，<code>null</code>就像在 <code>Java</code> 里一样，被当成一个对象，Brendan Eich 觉得表示“无”的值最好不是对象<br>其次，那时的 <code>JavaScript</code> 不包括错误处理机制，Brendan Eich 觉得，如果<code>null</code>自动转为0，很不容易发现错误<br>因此，他又设计了一个 <code>undefined</code>。区别是这样的：<br><code>null</code>是一个表示“空”的对象，转为数值时为0；<br><code>undefined</code>是一个表示”此处无定义”的原始值，转为数值时为NaN  </p>
</blockquote>
<p>对于<code>null</code>和<code>undefined</code>，大致可以像下面这样理解  </p>
<p><code>null</code>表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入<code>null</code>，表示该参数为空  </p>
<p><code>undefined</code>表示“未定义”，下面是返回<code>undefined</code>的典型场景  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 变量声明了，但没有赋值</span><br><span class="hljs-keyword">var</span> i;<br>i <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x;<br>&#125;<br>f() <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// 对象没有赋值的属性</span><br><span class="hljs-keyword">var</span>  o = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>o.p <span class="hljs-comment">// undefined</span><br><br><span class="hljs-comment">// 函数没有返回值时，默认返回 undefined</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>f() <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>

<h2 id="Boolean-布尔值"><a href="#Boolean-布尔值" class="headerlink" title="Boolean 布尔值"></a>Boolean 布尔值</h2><p>布尔值代表“真”和“假”两个状态<br>“真”用关键字<code>true</code>表示，“假”用关键字<code>false</code>表示。布尔值只有这两个值<br>进行逻辑运算会得到布尔值  </p>
<ul>
<li>前置逻辑运算符： <code>!(Not)</code>  </li>
<li>相等运算符：<code>===</code>，<code>!==</code>，<code>==</code>，<code>!=</code>  </li>
<li>比较运算符：<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code><br>如果 <code>JavaScript</code> 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值  </li>
</ul>
<p><strong>转换规则</strong><br>转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code><br><code>undefined</code>、<code>null</code>、<code>false</code>、<code>0</code>、<code>NaN</code>、<code>&quot;&quot;</code>(空字符串）、<code>&#39;&#39;</code>(空字符串）、<code>[]</code>(空数组)、<code>&#123;&#125;</code>(空对象)  </p>
<p>布尔值往往用于程序流程的控制  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;&#x27;</span>) &#123;  <span class="hljs-comment">// 没有任何输出</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，if命令后面的判断条件，预期应该是一个布尔值，所以 JavaScript 自动将空字符串，转为布尔值false，导致程序不会进入代码块，所以没有任何输出  </p>
<h2 id="Number-数值"><a href="#Number-数值" class="headerlink" title="Number 数值"></a>Number 数值</h2><h3 id="只有浮点数"><a href="#只有浮点数" class="headerlink" title="只有浮点数"></a>只有浮点数</h3><p><code>JavaScript</code> 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，1与1.0是相同的，是同一个数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">1</span> === <span class="hljs-number">1.0</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 <code>JavaScript</code> 会自动把64位浮点数，转成32位整数，然后再进行运算  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> === <span class="hljs-number">0.3</span><br><span class="hljs-comment">// false</span><br><br><span class="hljs-number">0.3</span> / <span class="hljs-number">0.</span><br><span class="hljs-comment">// 2.9999999999999996</span><br><br>(<span class="hljs-number">0.3</span> - <span class="hljs-number">0.2</span>) === (<span class="hljs-number">0.2</span> - <span class="hljs-number">0.1</span>)<br><span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>

<h3 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h3><p><code>JavaScript</code> 浮点数的64个二进制位，从最左边开始，是这样组成的。</p>
<ul>
<li>第1位：符号位，0表示正数，1表示负数  </li>
<li>第2位到第12位（共11位）：指数部分  </li>
<li>第13位到第64位（共52位）：小数部分（即有效数字）<br>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度  </li>
</ul>
<p>精度最多只能到53个二进制位，这意味着，绝对值小于2的53次方的整数，即 -2^53 到 2^53，都可以精确表示  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>)<br><span class="hljs-comment">// 9007199254740992</span><br><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) + <span class="hljs-number">1</span><br><span class="hljs-comment">// 9007199254740992</span><br><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) + <span class="hljs-number">2</span><br><span class="hljs-comment">// 9007199254740994</span><br><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) + <span class="hljs-number">3</span><br><span class="hljs-comment">// 9007199254740996</span><br><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">53</span>) + <span class="hljs-number">4</span><br><span class="hljs-comment">// 9007199254740996</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，大于2的53次方以后，整数运算的结果开始出现错误。所以，大于2的53次方的数值，都无法保持精度。由于2的53次方是一个16位的十进制数值，所以简单的法则就是，JavaScript 对15位的十进制数都可以精确处理  </p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>64位浮点数的指数部分的长度是11个二进制位，意味着指数部分的最大值是2047（2的11次方减1）。也就是说，64位浮点数的指数部分的值最大为2047，分出一半表示负数，则 <code>JavaScript</code> 能够表示的数值范围为2^1024到2^-1023（开区间），超出这个范围的数无法表示  </p>
<p>如果一个数大于等于2的1024次方，那么就会发生“正向溢出”，即 JavaScript 无法表示这么大的数，这时就会返回<code>Infinity</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">1024</span>)  <span class="hljs-comment">// Infinity</span><br></code></pre></div></td></tr></table></figure>
<p>如果一个数小于等于2的-1075次方（指数部分最小值-1023，再加上小数部分的52位），那么就会发生为“负向溢出”，即 <code>JavaScript</code> 无法表示这么小的数，这时会直接返回0  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, -<span class="hljs-number">1075</span>)  <span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure>
<p><code>JavaScript</code> 提供<code>Number</code>对象的<code>MAX_VALUE</code>和<code>MIN_VALUE</code>属性，返回可以表示的具体的最大值和最小值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>.MAX_VALUE  <span class="hljs-comment">// 1.7976931348623157e+308</span><br><span class="hljs-built_in">Number</span>.MIN_VALUE  <span class="hljs-comment">// 5e-324</span><br></code></pre></div></td></tr></table></figure>

<h3 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h3><p><code>JavaScript</code> 的数值有多种表示方法，可以用字面形式直接表示，比如35（十进制）和0xFF（十六进制）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">123e3</span> <span class="hljs-comment">// 123000</span><br><span class="hljs-number">123e-3</span> <span class="hljs-comment">// 0.123</span><br>-<span class="hljs-number">3.1E+12</span><br><span class="hljs-number">.1e-23</span><br></code></pre></div></td></tr></table></figure>
<p>科学计数法允许字母e或E的后面，跟着一个整数，表示这个数值的指数部分  </p>
<p>以下两种情况，<code>JavaScript</code> 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示  </p>
<ol>
<li>小数点前的数字多于21位  <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">1234567890123456789012</span><br><span class="hljs-comment">// 1.2345678901234568e+21</span><br><br><span class="hljs-number">123456789012345678901</span><br><span class="hljs-comment">// 123456789012345680000</span><br></code></pre></div></td></tr></table></figure></li>
<li>小数点后的零多于5个  <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 小数点后紧跟5个以上的零，</span><br><span class="hljs-comment">// 就自动转为科学计数法</span><br><span class="hljs-number">0.0000003</span> <span class="hljs-comment">// 3e-7</span><br><br><span class="hljs-comment">// 否则，就保持原来的字面形式</span><br><span class="hljs-number">0.000003</span> <span class="hljs-comment">// 0.000003</span><br></code></pre></div></td></tr></table></figure>

</li>
</ol>
<h3 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h3><p>使用字面量（<code>Literal</code>）直接表示一个数值时，<code>JavaScript</code> 对整数提供四种进制的表示方法：  </p>
<ul>
<li>十进制：没有前导0的数值  </li>
<li>八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值  </li>
<li>十六进制：有前缀0x或0X的数值  </li>
<li>二进制：有前缀0b或0B的数值  </li>
</ul>
<p>默认情况下，<code>JavaScript</code> 内部会自动将八进制、十六进制、二进制转为十进制  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">0xff</span> <span class="hljs-comment">// 255</span><br><span class="hljs-number">0o377</span> <span class="hljs-comment">// 255</span><br><span class="hljs-number">0b11</span> <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">0xzz <span class="hljs-comment">// 报错</span><br>0o88 <span class="hljs-comment">// 报错</span><br>0b22 <span class="hljs-comment">// 报错</span><br></code></pre></div></td></tr></table></figure>
<p>通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字8和9，则该数值被视为十进制  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">0888</span> <span class="hljs-comment">// 888</span><br><span class="hljs-number">0777</span> <span class="hljs-comment">// 511</span><br></code></pre></div></td></tr></table></figure>
<p>前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法  </p>
<h3 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h3><h4 id="正零和负零"><a href="#正零和负零" class="headerlink" title="正零和负零"></a>正零和负零</h4><p><code>JavaScript</code> 内部实际上存在2个0：一个是+0，一个是-0<br>区别就是64位浮点数表示法的符号位不同。它们是等价的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">-<span class="hljs-number">0</span> === +<span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">0</span> === -<span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">0</span> === +<span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>几乎所有场合，正零和负零都会被当作正常的0  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">+<span class="hljs-number">0</span> <span class="hljs-comment">// 0</span><br>-<span class="hljs-number">0</span> <span class="hljs-comment">// 0</span><br>(-<span class="hljs-number">0</span>).toString() <span class="hljs-comment">// &#x27;0&#x27;</span><br>(+<span class="hljs-number">0</span>).toString() <span class="hljs-comment">// &#x27;0&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>唯一有区别的场合是，+0或-0当作分母，返回的值是不相等的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-number">1</span> / +<span class="hljs-number">0</span>) === (<span class="hljs-number">1</span> / -<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面的代码之所以出现这样结果，是因为除以正零得到<code>+Infinity</code>，除以负零得到<code>-Infinity</code>，这两者是不相等的  </p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p><code>NaN</code>是 <code>JavaScript</code> 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">5</span> - <span class="hljs-string">&#x27;x&#x27;</span> <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码运行时，会自动将字符串x转为数值，但是由于x不是数值，所以最后得到结果为<code>NaN</code>，表示它是“非数字”  </p>
<p>另外，一些数学函数的运算结果会出现NaN  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.acos(<span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Math</span>.log(-<span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Math</span>.sqrt(-<span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure>
<p>0除以0也会得到<code>NaN</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">0</span> / <span class="hljs-number">0</span> <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure>
<p>需要注意的是，<code>NaN</code>不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于<code>Number</code>，使用<code>typeof</code>运算符可以看得很清楚  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span> <span class="hljs-comment">// &#x27;number&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p><code>NaN</code>不等于任何值，包括它本身  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>数组的<code>indexOf</code>方法内部使用的是严格相等运算符，所以该方法对<code>NaN</code>不成立  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-literal">NaN</span>].indexOf(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// -1</span><br></code></pre></div></td></tr></table></figure>
<p><code>NaN</code>在布尔运算时被当作<code>false</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p><code>NaN</code>与任何数（包括它自己）的运算，得到的都是<code>NaN</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-literal">NaN</span> + <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">NaN</span> - <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">NaN</span> * <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">NaN</span> / <span class="hljs-number">32</span> <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure>

<h4 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h4><p><code>Infinity</code>表示“无穷”，用来表示两种场景  </p>
<ul>
<li>一个正的数值太大，或一个负的数值太小，无法表示  </li>
<li>另一种是非0数值除以0，得到Infinity  <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 场景一</span><br><span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">1024</span>)<br><span class="hljs-comment">// Infinity</span><br><br><span class="hljs-comment">// 场景二</span><br><span class="hljs-number">0</span> / <span class="hljs-number">0</span> <span class="hljs-comment">// NaN</span><br><span class="hljs-number">1</span> / <span class="hljs-number">0</span> <span class="hljs-comment">// Infinity</span><br></code></pre></div></td></tr></table></figure>
上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回<code>Infinity</code>。第二个场景是0除以0会得到NaN，而非0数值除以0，会返回<code>Infinity</code>  </li>
</ul>
<p><code>Infinity</code>有正负之分，<code>Infinity</code>表示正的无穷，<code>-Infinity</code>表示负的无穷  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-literal">Infinity</span> === -<span class="hljs-literal">Infinity</span> <span class="hljs-comment">// false</span><br><br><span class="hljs-number">1</span> / -<span class="hljs-number">0</span> <span class="hljs-comment">// -Infinity</span><br>-<span class="hljs-number">1</span> / -<span class="hljs-number">0</span> <span class="hljs-comment">// Infinity</span><br></code></pre></div></td></tr></table></figure>
<p>由于数值正向溢出（overflow）、负向溢出（underflow）和被0除，<code>JavaScript</code> 都不报错，所以单纯的数学运算几乎没有可能抛出错误  </p>
<p><code>Infinity</code>大于一切数值（除了<code>NaN</code>），<code>-Infinity</code>小于一切数值（除了<code>NaN</code>）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-literal">Infinity</span> &gt; <span class="hljs-number">1000</span> <span class="hljs-comment">// true</span><br>-<span class="hljs-literal">Infinity</span> &lt; -<span class="hljs-number">1000</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p><code>Infinity</code>与<code>NaN</code>比较，总是返回<code>false</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-literal">Infinity</span> &gt; <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br>-<span class="hljs-literal">Infinity</span> &gt; <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><br><span class="hljs-literal">Infinity</span> &lt; <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br>-<span class="hljs-literal">Infinity</span> &lt; <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>

<p><code>Infinity</code>的四则运算，符合无穷的数学计算规则  </p>
<figure class="highlight plain"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascirpt">&#x2F;&#x2F; 0乘以&#96;Infinity&#96;，返回NaN；0除以&#96;Infinity&#96;，返回0；Infinity除以0，返回Infinity  <br>5 * Infinity &#x2F;&#x2F; Infinity<br>5 - Infinity &#x2F;&#x2F; -Infinity<br>Infinity &#x2F; 5 &#x2F;&#x2F; Infinity<br>5 &#x2F; Infinity &#x2F;&#x2F; 0<br><br>&#x2F;&#x2F; Infinity加上或乘以Infinity，返回的还是Infinity<br>0 * Infinity &#x2F;&#x2F; NaN<br>0 &#x2F; Infinity &#x2F;&#x2F; 0<br>Infinity &#x2F; 0 &#x2F;&#x2F; Infinity<br><br>&#x2F;&#x2F; Infinity减去或除以Infinity，得到NaN  <br>Infinity + Infinity &#x2F;&#x2F; Infinity<br>Infinity * Infinity &#x2F;&#x2F; Infinity<br><br>&#x2F;&#x2F; Infinity与null计算时，null会转成0，等同于与0的计算<br>Infinity - Infinity &#x2F;&#x2F; NaN<br>Infinity &#x2F; Infinity &#x2F;&#x2F; NaN<br><br>&#x2F;&#x2F; Infinity与undefined计算，返回的都是NaN<br>null * Infinity &#x2F;&#x2F; NaN<br>null &#x2F; Infinity &#x2F;&#x2F; 0<br>Infinity &#x2F; null &#x2F;&#x2F; Infinity<br><br>undefined + Infinity &#x2F;&#x2F; NaN<br>undefined - Infinity &#x2F;&#x2F; NaN<br>undefined * Infinity &#x2F;&#x2F; NaN<br>undefined &#x2F; Infinity &#x2F;&#x2F; NaN<br>Infinity &#x2F; undefined &#x2F;&#x2F; NaN<br></code></pre></div></td></tr></table></figure>

<h3 id="常用全局方法"><a href="#常用全局方法" class="headerlink" title="常用全局方法"></a>常用全局方法</h3><h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h4><p>用于将字符串转为整数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;123&#x27;</span>) <span class="hljs-comment">// 123</span><br></code></pre></div></td></tr></table></figure>
<p>如果字符串头部有空格，空格会被自动去除  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;   81&#x27;</span>) <span class="hljs-comment">// 81</span><br></code></pre></div></td></tr></table></figure>
<p>如果<code>parseInt</code>的参数不是字符串，则会先转为字符串再转换  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1.23</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1.23&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>字符串转为整数的时候，是一个个字符依次转换<br>如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;8a&#x27;</span>) <span class="hljs-comment">// 8</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;12**&#x27;</span>) <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;12.34&#x27;</span>) <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;15e2&#x27;</span>) <span class="hljs-comment">// 15</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;15px&#x27;</span>) <span class="hljs-comment">// 15</span><br></code></pre></div></td></tr></table></figure>
<p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回NaN。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;.3&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;+&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;+1&#x27;</span>) <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>如果字符串以<code>0x</code>或<code>0X</code>开头，<code>parseInt</code>会将其按照十六进制数解析<br>如果字符串以<code>0</code>开头，将其按照10进制解析  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;0x10&#x27;</span>) <span class="hljs-comment">// 16</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;011&#x27;</span>) <span class="hljs-comment">// 11</span><br></code></pre></div></td></tr></table></figure>
<p>对于那些会自动转为科学计数法的数字，<code>parseInt</code>会将科学计数法的表示方法视为字符串，因此导致一些奇怪的结果  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1000000000000000000000.5</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1e+21&#x27;</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0.0000008</span>) <span class="hljs-comment">// 8</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;8e-7&#x27;</span>) <span class="hljs-comment">// 8</span><br></code></pre></div></td></tr></table></figure>
<p><code>parseInt</code>方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数<br>默认情况下，<code>parseInt</code>的第二个参数为10，即默认是十进制转十进制  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 8</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// 216</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>, <span class="hljs-number">8</span>) <span class="hljs-comment">// 512</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1000&#x27;</span>) <span class="hljs-comment">// 默认10进制，1000</span><br></code></pre></div></td></tr></table></figure>
<p>如果第二个参数不是数值，会被自动转为一个整数<br>这个整数只有在2到36之间，才能得到有意义的结果，超出这个范围，则返回<code>NaN</code><br>如果第二个参数是<code>0</code>、<code>undefined</code>和<code>null</code>，则直接忽略  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">37</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-literal">null</span>) <span class="hljs-comment">// 10</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;10&#x27;</span>, <span class="hljs-literal">undefined</span>) <span class="hljs-comment">// 10</span><br></code></pre></div></td></tr></table></figure>
<p>如果字符串包含对于指定进制无意义的字符，则从最高位开始，只返回可以转换的数值<br>如果最高位无法转换，则直接返回<code>NaN</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1546&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;546&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure>
<p>对于二进制来说，1是有意义的字符，而5、4、6都是无意义的字符，所以第一行返回1，第二行返回<code>NaN</code>  </p>
<p>前面说过，如果parseInt的第一个参数不是字符串，会被先转为字符串。这会导致一些令人意外的结果  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0x11</span>, <span class="hljs-number">36</span>) <span class="hljs-comment">// 43</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">0x11</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">String</span>(<span class="hljs-number">0x11</span>), <span class="hljs-number">36</span>)<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">String</span>(<span class="hljs-number">0x11</span>), <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;17&#x27;</span>, <span class="hljs-number">36</span>)<br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;17&#x27;</span>, <span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，十六进制的0x11会被先转为十进制的17，再转为字符串。然后，再用36进制或二进制解读字符串17，最后返回结果43和1  </p>
<p>这种处理方式，对于八进制的前缀0，尤其需要注意。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">011</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">String</span>(<span class="hljs-number">011</span>), <span class="hljs-number">2</span>)<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-built_in">String</span>(<span class="hljs-number">9</span>), <span class="hljs-number">2</span>)<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，第一行的011会被先转为字符串9，因为9不是二进制的有效字符，所以返回<code>NaN</code>。如果直接计算<code>parseInt(&#39;011&#39;, 2)</code>，011则是会被当作二进制处理，返回3  </p>
<p><code>JavaScript</code> 不再允许将带有前缀0的数字视为八进制数，而是要求忽略这个0。但是，为了保证兼容性，大部分浏览器并没有部署这一条规定  </p>
<h4 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h4><p><code>parseFloat</code>方法用于将一个字符串转为浮点数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;3.14&#x27;</span>) <span class="hljs-comment">// 3.14</span><br></code></pre></div></td></tr></table></figure>
<p>如果字符串符合科学计数法，则会进行相应的转换  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;314e-2&#x27;</span>) <span class="hljs-comment">// 3.14</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;0.0314E+2&#x27;</span>) <span class="hljs-comment">// 3.14</span><br></code></pre></div></td></tr></table></figure>
<p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;3.14more non-digit characters&#x27;</span>) <span class="hljs-comment">// 3.14</span><br></code></pre></div></td></tr></table></figure>
<p><code>parseFloat</code>方法会自动过滤字符串前导的空格。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;\t\v\r12.34\n &#x27;</span>) <span class="hljs-comment">// 12.34</span><br></code></pre></div></td></tr></table></figure>
<p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>([]) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;FF2&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，尤其值得注意，<code>parseFloat</code>会将空字符串转为<code>NaN</code>  </p>
<p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-literal">true</span>)  <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&#x27;123.45#&#x27;</span>) <span class="hljs-comment">// 123.45</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;123.45#&#x27;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure>

<h4 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h4><p><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>但是，<code>isNaN</code>只对数值有效，如果传入其他值，会被先转成数值<br>比如，传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回<code>true</code>，这一点要特别引起注意。也就是说，<code>isNaN</code>为<code>true</code>的值，有可能不是<code>NaN</code>，而是一个字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 相当于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>)) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>出于同样的原因，对于对象和数组，<code>isNaN</code>也返回<code>true</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>(&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">Number</span>(&#123;&#125;)) <span class="hljs-comment">// true</span><br><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-string">&#x27;xzy&#x27;</span>]) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">isNaN</span>(<span class="hljs-built_in">Number</span>([<span class="hljs-string">&#x27;xzy&#x27;</span>])) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>但是，对于空数组和只有一个数值成员的数组，<code>isNaN</code>返回<code>false</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">isNaN</span>([]) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-number">123</span>]) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isNaN</span>([<span class="hljs-string">&#x27;123&#x27;</span>]) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值  </p>
<p>因此，使用isNaN之前，最好判断一下数据类型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myIsNaN</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-built_in">isNaN</span>(value);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>判断NaN更可靠的方法是，利用NaN为唯一不等于自身的值的这个特点，进行判断。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myIsNaN</span>(<span class="hljs-params">value</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> value !== value;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="isFinite"><a href="#isFinite" class="headerlink" title="isFinite()"></a>isFinite()</h4><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">Infinity</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(-<span class="hljs-literal">Infinity</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">isFinite</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">isFinite</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>  </p>
<h2 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String 字符串"></a>String 字符串</h2><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-string">&quot;abc&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;key = &quot;value&quot;&#x27;</span><br><span class="hljs-string">&quot;It&#x27;s a long journey&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;Did she say \&#x27;Hello\&#x27;?&#x27;</span>  <span class="hljs-comment">// &quot;Did she say &#x27;Hello&#x27;?&quot;</span><br><span class="hljs-string">&quot;Did she say \&quot;Hello\&quot;?&quot;</span>  <span class="hljs-comment">// &quot;Did she say &quot;Hello&quot;?&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>由于 HTML 语言的属性值使用双引号，所以很多项目约定 <code>JavaScript</code> 语言的字符串只使用单引号，默认应该遵守这个约定  </p>
<p>字符串默认只能写在一行内，分成多行将会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a</span><br><span class="hljs-string">b</span><br><span class="hljs-string">c&#x27;</span><br><span class="hljs-comment">// SyntaxError: Unexpected token ILLEGAL</span><br></code></pre></div></td></tr></table></figure>
<p>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> longString = <span class="hljs-string">&#x27;Long \</span><br><span class="hljs-string">long \</span><br><span class="hljs-string">long \</span><br><span class="hljs-string">string&#x27;</span>;<br><br>longString<br><span class="hljs-comment">// &quot;Long long long string&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错  </p>
<p>连接运算符（+）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> longString = <span class="hljs-string">&#x27;Long &#x27;</span><br>  + <span class="hljs-string">&#x27;long &#x27;</span><br>  + <span class="hljs-string">&#x27;long &#x27;</span><br>  + <span class="hljs-string">&#x27;string&#x27;</span>;<br></code></pre></div></td></tr></table></figure>
<p>如果想输出多行字符串，有一种利用多行注释的变通方法  </p>
<figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> &#123; /*</span><br><span class="hljs-built_in">line</span> <span class="hljs-number">1</span><br><span class="hljs-built_in">line</span> <span class="hljs-number">2</span><br><span class="hljs-built_in">line</span> <span class="hljs-number">3</span><br>*/&#125;).toString().<span class="hljs-keyword">split</span>(<span class="hljs-string">&#x27;\n&#x27;</span>).slice(<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>).<span class="hljs-keyword">join</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>// <span class="hljs-comment">&quot;line 1</span><br>// <span class="hljs-built_in">line</span> <span class="hljs-number">2</span><br>// <span class="hljs-built_in">line</span> <span class="hljs-number">3</span><span class="hljs-comment">&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面的例子中，输出的字符串就是多行  </p>
<h3 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h3><p>反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符  </p>
<p>需要用反斜杠转义的特殊字符，主要有下面这些  </p>
<ul>
<li>\0 ：null（\u0000）  </li>
<li>\b ：后退键（\u0008）  </li>
<li>\f ：换页符（\u000C）  </li>
<li>\n ：换行符（\u000A）  </li>
<li>\r ：回车键（\u000D）  </li>
<li>\t ：制表符（\u0009）  </li>
<li>\v ：垂直制表符（\u000B）  </li>
<li>&#39; ：单引号（\u0027）  </li>
<li>&quot; ：双引号（\u0022）  </li>
<li>\ ：反斜杠（\u005C）  </li>
</ul>
<p>反斜杠还有三种特殊用法。</p>
<ol>
<li><p>\HHH<br>反斜杠后面紧跟三个八进制数（000到377），代表一个字符<br>HHH对应该字符的 <code>Unicode</code> 码点，比如\251表示版权符号<br>显然，这种方法只能输出256种字符  </p>
</li>
<li><p>\xHH<br>\x后面紧跟两个十六进制数（00到FF），代表一个字符<br>HH对应该字符的 Unicode 码点，比如\xA9表示版权符号<br>这种方法也只能输出256种字符  </p>
</li>
<li><p>\uXXXX<br>\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符<br>XXXX对应该字符的 <code>Unicode</code> 码点，比如\u00A9表示版权符号  </p>
</li>
</ol>
<p>下面是这三种字符特殊写法的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;\251&#x27;</span> <span class="hljs-comment">// &quot;©&quot;</span><br><span class="hljs-string">&#x27;\xA9&#x27;</span> <span class="hljs-comment">// &quot;©&quot;</span><br><span class="hljs-string">&#x27;\u00A9&#x27;</span> <span class="hljs-comment">// &quot;©&quot;</span><br><br><span class="hljs-string">&#x27;\172&#x27;</span> === <span class="hljs-string">&#x27;z&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;\x7A&#x27;</span> === <span class="hljs-string">&#x27;z&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;\u007A&#x27;</span> === <span class="hljs-string">&#x27;z&#x27;</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;\a&#x27;</span><br><span class="hljs-comment">// &quot;a&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，a是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略  </p>
<h3 id="字符串与数组"><a href="#字符串与数组" class="headerlink" title="字符串与数组"></a>字符串与数组</h3><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>s[<span class="hljs-number">0</span>] <span class="hljs-comment">// &quot;h&quot;</span><br>s[<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;e&quot;</span><br>s[<span class="hljs-number">4</span>] <span class="hljs-comment">// &quot;o&quot;</span><br><br><span class="hljs-comment">// 直接对字符串使用方括号运算符</span><br><span class="hljs-string">&#x27;hello&#x27;</span>[<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;e&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回<code>undefined</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;abc&#x27;</span>[<span class="hljs-number">3</span>] <span class="hljs-comment">// undefined</span><br><span class="hljs-string">&#x27;abc&#x27;</span>[-<span class="hljs-number">1</span>] <span class="hljs-comment">// undefined</span><br><span class="hljs-string">&#x27;abc&#x27;</span>[<span class="hljs-string">&#x27;x&#x27;</span>] <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><br><span class="hljs-keyword">delete</span> s[<span class="hljs-number">0</span>];<br>s <span class="hljs-comment">// &quot;hello&quot;</span><br><br>s[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>s <span class="hljs-comment">// &quot;hello&quot;</span><br><br>s[<span class="hljs-number">5</span>] = <span class="hljs-string">&#x27;!&#x27;</span>;<br>s <span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></div></td></tr></table></figure>

<h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><p><code>length</code>属性返回字符串的长度，该属性也是无法改变的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;hello&#x27;</span>;<br>s.length <span class="hljs-comment">// 5</span><br><br>s.length = <span class="hljs-number">3</span>;<br>s.length <span class="hljs-comment">// 5</span><br><br>s.length = <span class="hljs-number">7</span>;<br>s.length <span class="hljs-comment">// 5</span><br></code></pre></div></td></tr></table></figure>

<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p><code>JavaScript</code> 使用 <code>Unicode</code> 字符集<br><code>JavaScript</code> 引擎内部，所有字符都用 <code>Unicode</code> 表示  </p>
<p><code>JavaScript</code> 不仅以 <code>Unicode</code> 储存字符，还允许直接在程序中使用 <code>Unicode</code> 码点表示字符，即将字符写成 \uxxxx 的形式，其中xxxx代表该字符的 <code>Unicode</code> 码点  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> s = <span class="hljs-string">&#x27;\u00A9&#x27;</span>;<br>s <span class="hljs-comment">// &quot;©&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>解析代码的时候，<code>JavaScript</code> 会自动识别一个字符是字面形式表示，还是 <code>Unicode</code> 形式表示<br>输出给用户的时候，所有字符都会转成字面形式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f\u006F\u006F = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>foo <span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>每个字符在 <code>JavaScript</code> 内部都是以16位（即2个字节）的 <code>UTF-16</code> 格式储存<br><code>JavaScript</code> 的单位字符长度固定为16位长度，即2个字节<br>但是，<code>UTF-16</code> 有两种长度：对于码点在 U+0000 到 U+FFFF 之间的字符，长度为16位（即2个字节）；对于码点在U+10000到U+10FFFF之间的字符，长度为32位（即4个字节），而且前两个字节在 0xD800 到 0xDBFF 之间，后两个字节在 0xDC00 到 0xDFFF 之间<br>举例来说，码点 U+1D306 对应的字符为 𝌆，它写成 <code>UTF-16</code> 就是 0xD834 0xDF06  </p>
<p><code>JavaScript</code> 对 <code>UTF-16</code> 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符<br>这是因为 <code>JavaScript</code> 第一版发布的时候，<code>Unicode</code> 的码点只编到 U+FFFF，因此两字节足够表示了。后来，<code>Unicode</code> 纳入的字符越来越多，出现了四字节的编码。但是，<code>JavaScript</code> 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符𝌆，浏览器会正确识别这是一个字符，但是 <code>JavaScript</code> 无法识别，会认为这是两个字符  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;𝌆&#x27;</span>.length <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>JavaScript</code> 认为𝌆的长度为2，而不是1  </p>
<p>对于码点在 U+10000 到 U+10FFFF 之间的字符，<code>JavaScript</code> 总是认为它们是两个字符（length属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，<code>JavaScript</code> 返回的字符串长度可能是不正确的  </p>
<h3 id="Base64-转码"><a href="#Base64-转码" class="headerlink" title="Base64 转码"></a>Base64 转码</h3><p>有时，文本里面包含一些不可打印的符号，比如 <code>ASCII</code> 码0到31的符号都无法打印出来，这时可以使用 <code>Base64</code> 编码，将它们转成可以打印的字符<br>另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 <code>Base64</code> 编码  </p>
<p>所谓 <code>Base64</code> 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符<br>使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理  </p>
<p><code>JavaScript</code> 原生提供两个 <code>Base64</code> 相关的方法  </p>
<ul>
<li>btoa()：任意值转为 Base64 编码  </li>
<li>atob()：Base64 编码转为原来的值  </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> string = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br>btoa(string) <span class="hljs-comment">// &quot;SGVsbG8gV29ybGQh&quot;</span><br>atob(<span class="hljs-string">&#x27;SGVsbG8gV29ybGQh&#x27;</span>) <span class="hljs-comment">// &quot;Hello World!&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>注意，这两个方法不适合非 <code>ASCII</code> 码的字符，会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">btoa(<span class="hljs-string">&#x27;你好&#x27;</span>) <span class="hljs-comment">// 报错</span><br></code></pre></div></td></tr></table></figure>
<p>要将非 <code>ASCII</code> 码字符转为 <code>Base64</code> 编码，必须中间插入一个转码环节，再使用这两个方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b64Encode</span>(<span class="hljs-params">str</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> btoa(<span class="hljs-built_in">encodeURIComponent</span>(str));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b64Decode</span>(<span class="hljs-params">str</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">decodeURIComponent</span>(atob(str));<br>&#125;<br><br>b64Encode(<span class="hljs-string">&#x27;你好&#x27;</span>) <span class="hljs-comment">// &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;</span><br>b64Decode(<span class="hljs-string">&#x27;JUU0JUJEJUEwJUU1JUE1JUJE&#x27;</span>) <span class="hljs-comment">// &quot;你好&quot;</span><br></code></pre></div></td></tr></table></figure>

<h2 id="Object-对象"><a href="#Object-对象" class="headerlink" title="Object 对象"></a>Object 对象</h2><h3 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h3><p>对象（object）是 <code>JavaScript</code> 语言的核心概念，也是最重要的数据类型  </p>
<p>什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  foo: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>  bar: <span class="hljs-string">&#x27;World&#x27;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，大括号就定义了一个对象，它被赋值给变量<code>obj</code>，所以变量<code>obj</code>就指向一个对象<br>该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是<code>foo: &#39;Hello&#39;</code>，其中<code>foo</code>是“键名”（成员的名称），字符串<code>Hello</code>是“键值”（成员的值）<br>键名与键值之间用冒号分隔。第二个键值对是<code>bar: &#39;World&#39;</code>，<code>bar</code>是键名，<code>World</code>是键值。两个键值对之间用逗号分隔  </p>
<h3 id="键名"><a href="#键名" class="headerlink" title="键名"></a>键名</h3><p>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-string">&#x27;foo&#x27;</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>  <span class="hljs-string">&#x27;bar&#x27;</span>: <span class="hljs-string">&#x27;World&#x27;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>如果键名是数值，会被自动转为字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>  <span class="hljs-number">3.2</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>  <span class="hljs-number">1e2</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-number">1e-2</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-number">.234</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-number">0xFF</span>: <span class="hljs-literal">true</span><br>&#125;;<br><br>obj<br><span class="hljs-comment">// Object &#123;</span><br><span class="hljs-comment">//   1: &quot;a&quot;,</span><br><span class="hljs-comment">//   3.2: &quot;b&quot;,</span><br><span class="hljs-comment">//   100: true,</span><br><span class="hljs-comment">//   0.01: true,</span><br><span class="hljs-comment">//   0.234: true,</span><br><span class="hljs-comment">//   255: true</span><br><span class="hljs-comment">// &#125;</span><br><br>obj[<span class="hljs-string">&#x27;100&#x27;</span>] <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的所有键名虽然看上去像数值，实际上都被自动转成了字符串。</p>
<p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  1p: <span class="hljs-string">&#x27;Hello World&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 不报错</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-string">&#x27;1p&#x27;</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span>,<br>  <span class="hljs-string">&#x27;h w&#x27;</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span>,<br>  <span class="hljs-string">&#x27;p+q&#x27;</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span><br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型<br>如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * x;<br>  &#125;<br>&#125;;<br><br>obj.p(<span class="hljs-number">1</span>) <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>如果属性的值还是一个对象，就形成了链式引用  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123;&#125;;<br><span class="hljs-keyword">var</span> o2 = &#123; <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;hello&#x27;</span> &#125;;<br><br>o1.foo = o2;<br>o1.foo.bar <span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>o1</code>的属性<code>foo</code>指向对象<code>o2</code>，就可以链式引用<code>o2</code>的属性。</p>
<p>对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加   </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-number">123</span>,<br>  m: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; ... &#125;,<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>属性可以动态创建，不必在对象声明时就指定  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.foo = <span class="hljs-number">123</span>;<br>obj.foo <span class="hljs-comment">// 123</span><br></code></pre></div></td></tr></table></figure>

<h3 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h3><p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址<br>修改其中一个变量，会影响到其他所有变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123;&#125;;<br><span class="hljs-keyword">var</span> o2 = o1;<br><br>o1.a = <span class="hljs-number">1</span>;<br>o2.a <span class="hljs-comment">// 1</span><br><br>o2.b = <span class="hljs-number">2</span>;<br>o1.b <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性  </p>
<p>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o1 = &#123;&#125;;<br><span class="hljs-keyword">var</span> o2 = o1;<br><br>o1 = <span class="hljs-number">1</span>;<br>o2 <span class="hljs-comment">// &#123;&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，然后<code>o1</code>的值变为1，这时不会对<code>o2</code>产生影响，<code>o2</code>还是指向原来的那个对象  </p>
<p>但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> y = x;<br><br>x = <span class="hljs-number">2</span>;<br>y <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面的代码中，当<code>x</code>的值发生变化后，<code>y</code>的值并不变，这就表示<code>y</code>和<code>x</code>并不是指向同一个内存地址  </p>
<h3 id="表达式还是语句？"><a href="#表达式还是语句？" class="headerlink" title="表达式还是语句？"></a>表达式还是语句？</h3><p>对象采用大括号表示，这导致了一个问题：如果行首是一个大括号，它到底是表达式还是语句？</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span> &#125;<br></code></pre></div></td></tr></table></figure>
<p><code>JavaScript</code> 引擎读到上面这行代码，会发现可能有两种含义<br>第一种可能是，这是一个表达式，表示一个包含<code>foo</code>属性的对象；<br>第二种可能是，这是一个语句，表示一个代码区块，里面有一个标签<code>foo</code>，指向表达式<code>123</code>  </p>
<p>为了避免这种歧义，<code>JavaScript</code> 引擎的做法是，如果遇到这种情况，无法确定是对象还是代码块，一律解释为代码块  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>) &#125; <span class="hljs-comment">// 123</span><br></code></pre></div></td></tr></table></figure>
<p>上面的语句是一个代码块，而且只有解释为代码块，才能执行  </p>
<p>如果要解释为对象，最好在大括号前加上圆括号。因为圆括号的里面，只能是表达式，所以确保大括号只能解释为对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">123</span> &#125;) <span class="hljs-comment">// 正确</span><br>(&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123</span>) &#125;) <span class="hljs-comment">// 报错</span><br></code></pre></div></td></tr></table></figure>
<p>这种差异在<code>eval</code>语句（作用是对字符串求值）中反映得最明显  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;&#123;foo: 123&#125;&#x27;</span>) <span class="hljs-comment">// 123</span><br><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;(&#123;foo: 123&#125;)&#x27;</span>) <span class="hljs-comment">// &#123;foo: 123&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，如果没有圆括号，<code>eval</code>将其理解为一个代码块；加上圆括号以后，就理解成一个对象  </p>
<h3 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h3><h4 id="属性的读取"><a href="#属性的读取" class="headerlink" title="属性的读取"></a>属性的读取</h4><p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  p: <span class="hljs-string">&#x27;Hello World&#x27;</span><br>&#125;;<br><br>obj.p <span class="hljs-comment">// &quot;Hello World&quot;</span><br>obj[<span class="hljs-string">&#x27;p&#x27;</span>] <span class="hljs-comment">// &quot;Hello World&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码分别采用点运算符和方括号运算符，读取属性<code>p</code>。</p>
<p>请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-string">&#x27;bar&#x27;</span>;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  foo: <span class="hljs-number">1</span>,<br>  bar: <span class="hljs-number">2</span><br>&#125;;<br><br>obj.foo  <span class="hljs-comment">// 1</span><br>obj[foo]  <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，引用对象<code>obj</code>的<code>foo</code>属性时，如果使用点运算符，<code>foo</code>就是字符串；<br>如果使用方括号运算符，但是不使用引号，那么<code>foo</code>就是一个变量，指向字符串<code>bar</code>  </p>
<p>方括号运算符内部还可以使用表达式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">obj[<span class="hljs-string">&#x27;hello&#x27;</span> + <span class="hljs-string">&#x27; world&#x27;</span>]<br>obj[<span class="hljs-number">3</span> + <span class="hljs-number">3</span>]<br></code></pre></div></td></tr></table></figure>
<p>数字键可以不加引号，因为会自动转成字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-number">0.7</span>: <span class="hljs-string">&#x27;Hello World&#x27;</span><br>&#125;;<br><br>obj[<span class="hljs-string">&#x27;0.7&#x27;</span>] <span class="hljs-comment">// &quot;Hello World&quot;</span><br>obj[<span class="hljs-number">0.7</span>] <span class="hljs-comment">// &quot;Hello World&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>的数字键<code>0.7</code>，加不加引号都可以，因为会被自动转为字符串<br>注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-number">123</span>: <span class="hljs-string">&#x27;hello world&#x27;</span><br>&#125;;<br><br>obj<span class="hljs-number">.123</span> <span class="hljs-comment">// 报错</span><br>obj[<span class="hljs-number">123</span>] <span class="hljs-comment">// &quot;hello world&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的第一个表达式，对数值键名<code>123</code>使用点运算符，结果报错<br>第二个表达式使用方括号运算符，结果就是正确的  </p>
<h3 id="属性的赋值"><a href="#属性的赋值" class="headerlink" title="属性的赋值"></a>属性的赋值</h3><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br>obj.foo = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br>obj[<span class="hljs-string">&#x27;bar&#x27;</span>] = <span class="hljs-string">&#x27;World&#x27;</span>;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，分别使用点运算符和方括号运算符，对属性赋值  </p>
<p><code>JavaScript</code> 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-comment">// 等价于</span><br><br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.p = <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure>
<h3 id="属性的查看"><a href="#属性的查看" class="headerlink" title="属性的查看"></a>属性的查看</h3><p>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  key1: <span class="hljs-number">1</span>,<br>  key2: <span class="hljs-number">2</span><br>&#125;;<br><br><span class="hljs-built_in">Object</span>.keys(obj);<br><span class="hljs-comment">// [&#x27;key1&#x27;, &#x27;key2&#x27;]</span><br></code></pre></div></td></tr></table></figure>
<h3 id="属性的删除：delete-命令"><a href="#属性的删除：delete-命令" class="headerlink" title="属性的删除：delete 命令"></a>属性的删除：delete 命令</h3><p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-built_in">Object</span>.keys(obj) <span class="hljs-comment">// [&quot;p&quot;]</span><br><br><span class="hljs-keyword">delete</span> obj.p <span class="hljs-comment">// true</span><br>obj.p <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">Object</span>.keys(obj) <span class="hljs-comment">// []</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>delete</code>命令删除对象<code>obj</code>的<code>p</code>属性。删除后，再读取<code>p</code>属性就会返回<code>undefined</code>，而且<code>Object.keys</code>方法的返回值也不再包括该属性  </p>
<p>注意，删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-keyword">delete</span> obj.p <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>并没有<code>p</code>属性，但是<code>delete</code>命令照样返回<code>true</code><br>因此，不能根据<code>delete</code>命令的结果，认定某个属性是存在的  </p>
<p>只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.defineProperty(&#123;&#125;, <span class="hljs-string">&#x27;p&#x27;</span>, &#123;<br>  value: <span class="hljs-number">123</span>,<br>  configurable: <span class="hljs-literal">false</span><br>&#125;);<br><br>obj.p <span class="hljs-comment">// 123</span><br><span class="hljs-keyword">delete</span> obj.p <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码之中，对象<code>obj</code>的<code>p</code>属性是不能删除的，所以<code>delete</code>命令返回<code>false</code>  </p>
<p>另外，需要注意的是，<code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-keyword">delete</span> obj.toString <span class="hljs-comment">// true</span><br>obj.toString <span class="hljs-comment">// function toString() &#123; [native code] &#125;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在<br>这个例子还说明，即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值  </p>
<h3 id="属性是否存在：in-运算符"><a href="#属性是否存在：in-运算符" class="headerlink" title="属性是否存在：in 运算符"></a>属性是否存在：in 运算符</h3><p><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code><br>它的左边是一个字符串，表示属性名，右边是一个对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-string">&#x27;p&#x27;</span> <span class="hljs-keyword">in</span> obj <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> obj <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p><code>in</code>运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象<code>obj</code>本身并没有<code>toString</code>属性，但是<code>in</code>运算符会返回<code>true</code>，因为这个属性是继承的  </p>
<p>这时，可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;toString&#x27;</span> <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-built_in">console</span>.log(obj.hasOwnProperty(<span class="hljs-string">&#x27;toString&#x27;</span>)) <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="属性的遍历：for…in-循环"><a href="#属性的遍历：for…in-循环" class="headerlink" title="属性的遍历：for…in 循环"></a>属性的遍历：for…in 循环</h3><p><code>for...in</code>循环用来遍历一个对象的全部属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;键名：&#x27;</span>, i);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;键值：&#x27;</span>, obj[i]);<br>&#125;<br><span class="hljs-comment">// 键名： a</span><br><span class="hljs-comment">// 键值： 1</span><br><span class="hljs-comment">// 键名： b</span><br><span class="hljs-comment">// 键值： 2</span><br><span class="hljs-comment">// 键名： c</span><br><span class="hljs-comment">// 键值： 3</span><br></code></pre></div></td></tr></table></figure>
<p><code>for...in</code>循环有两个使用注意点。</p>
<ul>
<li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</li>
<li>它不仅遍历对象自身的属性，还遍历继承的属性。</li>
</ul>
<p>举例来说，对象都继承了<code>toString</code>属性，但是<code>for...in</code>循环不会遍历到这个属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><br><span class="hljs-comment">// toString 属性是存在的</span><br>obj.toString <span class="hljs-comment">// toString() &#123; [native code] &#125;</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> p <span class="hljs-keyword">in</span> obj) &#123;<br>  <span class="hljs-built_in">console</span>.log(p);<br>&#125; <span class="hljs-comment">// 没有任何输出</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>继承了<code>toString</code>属性，该属性不会被<code>for...in</code>循环遍历到，因为它默认是“不可遍历”的  </p>
<p>如果继承的属性是可遍历的，那么就会被<code>for...in</code>循环遍历到<br>但是，一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;老张&#x27;</span> &#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> person) &#123;<br>  <span class="hljs-keyword">if</span> (person.hasOwnProperty(key)) &#123;<br>    <span class="hljs-built_in">console</span>.log(key);<br>  &#125;<br>&#125;<br><span class="hljs-comment">// name</span><br></code></pre></div></td></tr></table></figure>
<h3 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h3><p>不建议使用  </p>
<p><code>with</code>语句的格式如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">with</span> (对象) &#123;<br>  语句;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 例一</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  p1: <span class="hljs-number">1</span>,<br>  p2: <span class="hljs-number">2</span>,<br>&#125;;<br><span class="hljs-keyword">with</span> (obj) &#123;<br>  p1 = <span class="hljs-number">4</span>;<br>  p2 = <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-comment">// 等同于</span><br>obj.p1 = <span class="hljs-number">4</span>;<br>obj.p2 = <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">// 例二</span><br><span class="hljs-keyword">with</span> (<span class="hljs-built_in">document</span>.links[<span class="hljs-number">0</span>])&#123;<br>  <span class="hljs-built_in">console</span>.log(href);<br>  <span class="hljs-built_in">console</span>.log(title);<br>  <span class="hljs-built_in">console</span>.log(style);<br>&#125;<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.links[<span class="hljs-number">0</span>].href);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.links[<span class="hljs-number">0</span>].title);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">document</span>.links[<span class="hljs-number">0</span>].style);<br></code></pre></div></td></tr></table></figure>
<p>注意，如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-keyword">with</span> (obj) &#123;<br>  p1 = <span class="hljs-number">4</span>;<br>  p2 = <span class="hljs-number">5</span>;<br>&#125;<br><br>obj.p1 <span class="hljs-comment">// undefined</span><br>p1 <span class="hljs-comment">// 4</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>并没有<code>p1</code>属性，对<code>p1</code>赋值等于创造了一个全局变量<code>p1</code><br>正确的写法应该是，先定义对象<code>obj</code>的属性<code>p1</code>，然后在<code>with</code>区块内操作它  </p>
<p>这是因为<code>with</code>区块没有改变作用域，它的内部依然是当前作用域<br>这造成了<code>with</code>语句的一个很大的弊病，就是绑定对象不明确  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">with</span> (obj) &#123;<br>  <span class="hljs-built_in">console</span>.log(x);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>单纯从上面的代码块，根本无法判断<code>x</code>到底是全局变量，还是对象<code>obj</code>的一个属性<br>这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度<br>因此，建议不要使用<code>with</code>语句，可以考虑用一个临时变量代替<code>with</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">with</span>(<span class="hljs-params">obj1.obj2.obj3</span>)</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(p1 + p2);<br>&#125;<br><br><span class="hljs-comment">// 可以写成</span><br><span class="hljs-keyword">var</span> temp = obj1.obj2.obj3;<br><span class="hljs-built_in">console</span>.log(temp.p1 + temp.p2);<br></code></pre></div></td></tr></table></figure>

<h2 id="Function-函数"><a href="#Function-函数" class="headerlink" title="Function 函数"></a>Function 函数</h2><p>函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值  </p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><h4 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h4><p><strong>（1）function 命令</strong>  </p>
<p><code>function</code>命令声明的代码区块，就是一个函数<br><code>function</code>命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(s);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面的代码命名了一个<code>print</code>函数，以后使用<code>print()</code>这种形式，就可以调用相应的代码。这叫做函数的声明（Function Declaration）  </p>
<p><strong>（2）函数表达式</strong>  </p>
<p>除了用<code>function</code>命令声明函数，还可以采用变量赋值的写法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">s</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(s);<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>这种写法将一个匿名函数赋值给变量<br>这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式  </p>
<p>采用函数表达式声明函数时，<code>function</code>命令后面不带有函数名<br>如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> print = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">x</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> x);<br>&#125;;<br><br>x<br><span class="hljs-comment">// ReferenceError: x is not defined</span><br><br>print()<br><span class="hljs-comment">// function</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码在函数表达式中，加入了函数名<code>x</code>。这个<code>x</code>只在函数体内部可用，指代函数表达式本身，其他地方都不可用<br>这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br></code></pre></div></td></tr></table></figure>
<p>需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束<br>而函数的声明在结尾的大括号后面不用加分号<br>总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的  </p>
<p><strong>（3）Function 构造函数</strong>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> add = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<br>  <span class="hljs-string">&#x27;x&#x27;</span>,<br>  <span class="hljs-string">&#x27;y&#x27;</span>,<br>  <span class="hljs-string">&#x27;return x + y&#x27;</span><br>);<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Function</code>构造函数接受三个参数，除了最后一个参数是<code>add</code>函数的“函数体”，其他参数都是<code>add</code>函数的参数  </p>
<p>你可以传递任意数量的参数给<code>Function</code>构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> foo = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(<br>  <span class="hljs-string">&#x27;return &quot;hello world&quot;;&#x27;</span><br>);<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>Function</code>构造函数可以不使用<code>new</code>命令，返回结果完全一样  </p>
<p>总的来说，这种声明函数的方式非常不直观，几乎无人使用  </p>
<h3 id="函数的重复声明"><a href="#函数的重复声明" class="headerlink" title="函数的重复声明"></a>函数的重复声明</h3><p>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>&#125;<br>f() <span class="hljs-comment">// 2</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br>&#125;<br>f() <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，后一次的函数声明覆盖了前面一次<br>而且，由于函数名的提升，前一次声明在任何时候都是无效的，这一点要特别注意  </p>
<h3 id="圆括号运算符，return-语句和递归"><a href="#圆括号运算符，return-语句和递归" class="headerlink" title="圆括号运算符，return 语句和递归"></a>圆括号运算符，return 语句和递归</h3><p>调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数  </p>
<p>函数体内部的<code>return</code>语句，表示返回。JavaScript 引擎遇到<code>return</code>语句，就直接返回<code>return</code>后面的那个表达式的值，后面即使还有语句，也不会得到执行<br>也就是说，<code>return</code>语句所带的那个表达式，就是函数的返回值。<code>return</code>语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回<code>undefined</code>  </p>
<p>函数可以调用自身，这就是递归（recursion）<br>下面就是通过递归，计算斐波那契数列的代码  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fib</span>(<span class="hljs-params">num</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">if</span> (num === <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> fib(num - <span class="hljs-number">2</span>) + fib(num - <span class="hljs-number">1</span>);<br>&#125;<br><br>fib(<span class="hljs-number">6</span>) <span class="hljs-comment">// 8</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>fib</code>函数内部又调用了<code>fib</code>，计算得到斐波那契数列的第6个元素是8  </p>
<h3 id="第一等公民"><a href="#第一等公民" class="headerlink" title="第一等公民"></a>第一等公民</h3><p><code>JavaScript</code> 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同<br>凡是可以使用值的地方，就能使用函数<br>比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回<br>函数只是一个可以执行的值，此外并无特殊之处  </p>
<p>由于函数与其他数据类型地位平等，所以在 <code>JavaScript</code> 语言中又称函数为第一等公民  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><br><span class="hljs-comment">// 将函数赋值给一个变量</span><br><span class="hljs-keyword">var</span> operator = add;<br><br><span class="hljs-comment">// 将函数作为参数和返回值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params">op</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> op;<br>&#125;<br>a(add)(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<h3 id="函数名的提升"><a href="#函数名的提升" class="headerlink" title="函数名的提升"></a>函数名的提升</h3><p><code>JavaScript</code> 引擎将函数名视同变量名，所以采用<code>function</code>命令声明函数时，整个函数会像变量声明一样，被提升到代码头部  </p>
<p>所以，下面的代码不会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">f();<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></div></td></tr></table></figure>
<p>表面上，上面代码好像在声明之前就调用了函数<code>f</code><br>但是实际上，由于“变量提升”，函数<code>f</code>被提升到了代码头部，也就是在调用之前已经声明了  但是，如果采用赋值语句定义函数，JavaScript 就会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">f();<br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;&#125;;<br><span class="hljs-comment">// TypeError: undefined is not a function</span><br></code></pre></div></td></tr></table></figure>
<p>上面的代码等同于下面的形式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f;<br>f();<br>f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br></code></pre></div></td></tr></table></figure>
<p>上面代码第二行，调用<code>f</code>的时候，<code>f</code>只是被声明了，还没有被赋值，等于<code>undefined</code>，所以会报错  </p>
<p>注意，如果像下面例子那样，采用<code>function</code>命令和<code>var</code>赋值语句声明同一个函数，由于存在函数提升，最后会采用<code>var</code>赋值语句的定义  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);<br>&#125;<br><br>f() <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面例子中，表面上后面声明的函数<code>f</code>，应该覆盖前面的<code>var</code>赋值语句，但是由于存在函数提升，实际上正好反过来  </p>
<h3 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h3><h4 id="name-属性"><a href="#name-属性" class="headerlink" title="name 属性"></a>name 属性</h4><p>函数的<code>name</code>属性返回函数的名字  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>f1.name <span class="hljs-comment">// &quot;f1&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果是通过变量赋值定义的函数，那么<code>name</code>属性返回变量名  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br>f2.name <span class="hljs-comment">// &quot;f2&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此<br>如果变量的值是一个具名函数，那么<code>name</code>属性返回<code>function</code>关键字之后的那个函数名  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f3 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myName</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br>f3.name <span class="hljs-comment">// &#x27;myName&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>f3.name</code>返回函数表达式的名字。注意，真正的函数名还是<code>f3</code>，而<code>myName</code>这个名字只在函数体内部可用  </p>
<p><code>name</code>属性的一个用处，就是获取参数函数的名字  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> myFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">f</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(f.name);<br>&#125;<br><br>test(myFunc) <span class="hljs-comment">// myFunc</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>test</code>内部通过<code>name</code>属性，就可以知道传入的参数是什么函数  </p>
<h4 id="length-属性-1"><a href="#length-属性-1" class="headerlink" title="length 属性"></a>length 属性</h4><p>函数的<code>length</code>属性返回函数预期传入的参数个数，即函数定义之中的参数个数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, b</span>) </span>&#123;&#125;<br>f.length <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码定义了空函数<code>f</code>，它的<code>length</code>属性就是定义时的参数个数<br>不管调用时输入了多少个参数，<code>length</code>属性始终等于2  </p>
<p><code>length</code>属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）  </p>
<h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><p>函数的<code>toString()</code>方法返回一个字符串，内容是函数的源码  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  a();<br>  b();<br>  c();<br>&#125;<br><br>f.toString()<br><span class="hljs-comment">// function f() &#123;</span><br><span class="hljs-comment">//  a();</span><br><span class="hljs-comment">//  b();</span><br><span class="hljs-comment">//  c();</span><br><span class="hljs-comment">// &#125;</span><br></code></pre></div></td></tr></table></figure>
<p>上面示例中，函数<code>f</code>的<code>toString()</code>方法返回了<code>f</code>的源码，包含换行符在内  </p>
<p>对于那些原生的函数，<code>toString()</code>方法返回<code>function ()&#123;[native code]&#125;</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Math</span>.sqrt.toString()<br><span class="hljs-comment">// &quot;function sqrt() &#123; [native code] &#125;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Math.sqrt()</code>是 JavaScript 引擎提供的原生函数，<code>toString()</code>方法就返回原生代码的提示  </p>
<p>函数内部的注释也可以返回  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">/*</span><br><span class="hljs-comment">  这是一个</span><br><span class="hljs-comment">  多行注释</span><br><span class="hljs-comment">*/</span>&#125;<br><br>f.toString()<br><span class="hljs-comment">// &quot;function f()&#123;/*</span><br><span class="hljs-comment">//   这是一个</span><br><span class="hljs-comment">//   多行注释</span><br><span class="hljs-comment">// */&#125;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>利用这一点，可以变相实现多行字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> multiline = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> arr = fn.toString().split(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>  <span class="hljs-keyword">return</span> arr.slice(<span class="hljs-number">1</span>, arr.length - <span class="hljs-number">1</span>).join(<span class="hljs-string">&#x27;\n&#x27;</span>);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">/*</span><br><span class="hljs-comment">  这是一个</span><br><span class="hljs-comment">  多行注释</span><br><span class="hljs-comment">*/</span>&#125;<br><br>multiline(f);<br><span class="hljs-comment">// &quot; 这是一个</span><br><span class="hljs-comment">//   多行注释&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面示例中，函数<code>f</code>内部有一个多行注释，<code>toString()</code>方法拿到<code>f</code>的源码后，去掉首尾两行，就得到了一个多行字符串  </p>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>作用域（scope）指的是变量存在的范围。在 ES5 的规范中，<code>JavaScript</code> 只有两种作用域：<br>一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取<br>另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本教程不涉及  </p>
<p>对于顶层函数来说，函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> v = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(v);<br>&#125;<br><br>f()<br><span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面的代码表明，函数<code>f</code>内部可以读取全局变量<code>v</code>  </p>
<p>在函数内部定义的变量，外部无法读取，称为“局部变量”（local variable）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> v = <span class="hljs-number">1</span>;<br>&#125;<br><br>v <span class="hljs-comment">// ReferenceError: v is not defined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，变量<code>v</code>在函数内部定义，所以是一个局部变量，函数之外就无法读取  </p>
<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> v = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">var</span> v = <span class="hljs-number">2</span>;<br>  <span class="hljs-built_in">console</span>.log(v);<br>&#125;<br><br>f() <span class="hljs-comment">// 2</span><br>v <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，变量<code>v</code>同时在函数的外部和内部有定义<br>结果，在函数内部定义，局部变量<code>v</code>覆盖了全局变量<code>v</code>  </p>
<p>注意，对于<code>var</code>命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(x);  <span class="hljs-comment">// 5</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，变量<code>x</code>在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取  </p>
<h4 id="函数内部的变量提升"><a href="#函数内部的变量提升" class="headerlink" title="函数内部的变量提升"></a>函数内部的变量提升</h4><p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象<br><code>var</code>命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">100</span>) &#123;<br>    <span class="hljs-keyword">var</span> tmp = x - <span class="hljs-number">100</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> tmp;<br>  <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">100</span>) &#123;<br>    tmp = x - <span class="hljs-number">100</span>;<br>  &#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="函数本身的作用域"><a href="#函数本身的作用域" class="headerlink" title="函数本身的作用域"></a>函数本身的作用域</h4><p>函数本身也是一个值，也有自己的作用域<br>它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> x = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>  x();<br>&#125;<br><br>f() <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>x</code>是在函数<code>f</code>的外部声明的，所以它的作用域绑定外层，内部变量<code>a</code>不会到函数<code>f</code>体内取值，所以输出<code>1</code>，而不是<code>2</code>  </p>
<p>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域  </p>
<p>很容易犯错的一点是，如果函数<code>A</code>调用函数<code>B</code>，却没考虑到函数<code>B</code>不会引用函数<code>A</code>的内部变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">y</span>(<span class="hljs-params">f</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>  f();<br>&#125;<br><br>y(x)<br><span class="hljs-comment">// ReferenceError: a is not defined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码将函数<code>x</code>作为参数，传入函数<code>y</code><br>但是，函数<code>x</code>是在函数<code>y</code>体外声明的，作用域绑定外层，因此找不到函数<code>y</code>的内部变量<code>a</code>，导致报错。</p>
<p>同样的，函数体内部声明的函数，作用域绑定函数体内部。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(x);<br>  &#125;<br>  <span class="hljs-keyword">return</span> bar;<br>&#125;<br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">var</span> f = foo();<br>f() <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>foo</code>内部声明了一个函数<code>bar</code>，<code>bar</code>的作用域绑定<code>foo</code><br>当我们在<code>foo</code>外部取出<code>bar</code>执行时，变量<code>x</code>指向的是<code>foo</code>内部的<code>x</code>，而不是<code>foo</code>外部的<code>x</code><br>正是这种机制，构成了下文要讲解的“闭包”现象  </p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br>square(<span class="hljs-number">2</span>) <span class="hljs-comment">// 4</span><br>square(<span class="hljs-number">3</span>) <span class="hljs-comment">// 9</span><br></code></pre></div></td></tr></table></figure>
<p>上式的<code>x</code>就是<code>square</code>函数的参数<br>每次运行的时候，需要提供这个值，否则得不到结果  </p>
<h4 id="参数的省略"><a href="#参数的省略" class="headerlink" title="参数的省略"></a>参数的省略</h4><p>函数参数不是必需的，JavaScript 允许省略参数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><br>f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 1</span><br>f(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br>f() <span class="hljs-comment">// undefined</span><br><br>f.length <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的函数<code>f</code>定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），<code>JavaScript</code> 都不会报错<br>省略的参数的值就变为<code>undefined</code><br>需要注意的是，函数的<code>length</code>属性与实际传入的参数个数无关，只反映函数预期传入的参数个数  </p>
<p>但是，没有办法只省略靠前的参数，而保留靠后的参数<br>如果一定要省略靠前的参数，只有显式传入<code>undefined</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a;<br>&#125;<br><br>f( , <span class="hljs-number">1</span>) <span class="hljs-comment">// SyntaxError: Unexpected token ,(…)</span><br>f(<span class="hljs-literal">undefined</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，如果省略第一个参数，就会报错  </p>
<h4 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h4><p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）<br>这意味着，在函数体内修改参数值，不会影响到函数外部  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p = <span class="hljs-number">2</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">p</span>) </span>&#123;<br>  p = <span class="hljs-number">3</span>;<br>&#125;<br>f(p);<br><br>p <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，变量<code>p</code>是一个原始类型的值，传入函数<code>f</code>的方式是传值传递<br>因此，在函数内部，<code>p</code>的值是原始值的拷贝，无论怎么修改，都不会影响到原始值  </p>
<p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）<br>也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">o</span>) </span>&#123;<br>  o.p = <span class="hljs-number">2</span>;<br>&#125;<br>f(obj);<br><br>obj.p <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，传入函数<code>f</code>的是参数对象<code>obj</code>的地址<br>因此，在函数内部修改<code>obj</code>的属性<code>p</code>，会影响到原始值  </p>
<p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">o</span>) </span>&#123;<br>  o = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br>&#125;<br>f(obj);<br><br>obj <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，在函数<code>f()</code>内部，参数对象<code>obj</code>被整个替换成另一个值<br>这时不会影响到原始值。这是因为，形式参数（<code>o</code>）的值实际是参数<code>obj</code>的地址，重新对<code>o</code>赋值导致<code>o</code>指向另一个地址，保存在原地址上的值当然不受影响  </p>
<h4 id="同名参数"><a href="#同名参数" class="headerlink" title="同名参数"></a>同名参数</h4><p>如果有同名的参数，则取最后出现的那个值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, a</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br><br>f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>f()</code>有两个参数，且参数名都是<code>a</code><br>取值的时候，以后面的<code>a</code>为准，即使后面的<code>a</code>没有值或被省略，也是以其为准  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, a</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a);<br>&#125;<br><br>f(<span class="hljs-number">1</span>) <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>调用函数<code>f()</code>的时候，没有提供第二个参数，<code>a</code>的取值就变成了<code>undefined</code><br>这时，如果要获得第一个<code>a</code>的值，可以使用<code>arguments</code>对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, a</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]);<br>&#125;<br><br>f(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<h4 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h4><p><strong>（1）定义</strong></p>
<p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是<code>arguments</code>对象的由来  </p>
<p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推<br>这个对象只有在函数体内部，才可以使用  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">one</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]);<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>]);<br>&#125;<br><br>f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>正常模式下，<code>arguments</code>对象可以在运行时修改  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;<br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br>f(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 5</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>f()</code>调用时传入的参数，在函数内部被修改成<code>3</code>和<code>2</code>  </p>
<p>严格模式下，<code>arguments</code>对象与函数参数不具有联动关系<br>也就是说，修改<code>arguments</code>对象不会影响到实际的函数参数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>; <span class="hljs-comment">// 开启严格模式</span><br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;<br>  <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br>f(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数体内是严格模式，这时修改<code>arguments</code>对象，不会影响到真实参数<code>a</code>和<code>b</code>  </p>
<p>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span>.length;<br>&#125;<br><br>f(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 3</span><br>f(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br>f() <span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（2）与数组的关系</strong></p>
<p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用  </p>
<p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);<br><br><span class="hljs-comment">// 或者</span><br><span class="hljs-keyword">var</span> args = [];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) &#123;<br>  args.push(<span class="hljs-built_in">arguments</span>[i]);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><strong>（3）callee 属性</strong></p>
<p><code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>.callee === f);<br>&#125;<br><br>f() <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>可以通过<code>arguments.callee</code>，达到调用函数自身的目的<br>这个属性在严格模式里面是禁用的，因此不建议使用  </p>
<h3 id="函数的其他知识点"><a href="#函数的其他知识点" class="headerlink" title="函数的其他知识点"></a>函数的其他知识点</h3><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>闭包（closure）是 <code>JavaScript</code> 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现  </p>
<p>理解闭包，首先必须理解变量作用域<br>前面提到，<code>JavaScript</code> 有两种作用域：全局作用域和函数作用域<br>函数内部可以直接读取全局变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(n);<br>&#125;<br>f1() <span class="hljs-comment">// 999</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>f1</code>可以读取全局变量<code>n</code>  </p>
<p>但是，正常情况下，函数外部无法读取函数内部声明的变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(n)<br><span class="hljs-comment">// Uncaught ReferenceError: n is not defined(</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>f1</code>内部声明的变量<code>n</code>，函数外是无法读取的  </p>
<p>如果出于种种原因，需要得到函数内的局部变量<br>正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>　　<span class="hljs-built_in">console</span>.log(n); <span class="hljs-comment">// 999</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。但是反过来就不行，<code>f2</code>内部的局部变量，对<code>f1</code>就是不可见的<br>这就是 <code>JavaScript</code> 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量<br>所以，父对象的所有变量，对子对象都是可见的，反之则不成立  </p>
<p>既然<code>f2</code>可以读取<code>f1</code>的局部变量，那么只要把<code>f2</code>作为返回值，我们不就可以在<code>f1</code>外部读取它的内部变量了吗！</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> n = <span class="hljs-number">999</span>;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(n);<br>  &#125;<br>  <span class="hljs-keyword">return</span> f2;<br>&#125;<br><br><span class="hljs-keyword">var</span> result = f1();<br>result(); <span class="hljs-comment">// 999</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>f1</code>的返回值就是函数<code>f2</code>，由于<code>f2</code>可以读取<code>f1</code>的内部变量，所以就可以在外部获得<code>f1</code>的内部变量了  </p>
<p>闭包就是函数<code>f2</code>，即能够读取其他函数内部变量的函数<br>由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”<br>闭包最大的特点，就是它可以“记住”诞生的环境，比如<code>f2</code>记住了它诞生的环境<code>f1</code>，所以从<code>f2</code>可以得到<code>f1</code>的内部变量<br>在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁  </p>
<p>闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在<br>请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createIncrementor</span>(<span class="hljs-params">start</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> start++;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> inc = createIncrementor(<span class="hljs-number">5</span>);<br><br>inc() <span class="hljs-comment">// 5</span><br>inc() <span class="hljs-comment">// 6</span><br>inc() <span class="hljs-comment">// 7</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>start</code>是函数<code>createIncrementor</code>的内部变量<br>通过闭包，<code>start</code>的状态被保留了，每一次调用都是在上一次调用的基础上进行计算<br>从中可以看到，闭包<code>inc</code>使得函数<code>createIncrementor</code>的内部环境，一直存在<br>所以，闭包可以看作是函数内部作用域的一个接口  </p>
<p>为什么闭包能够返回外层函数的内部变量？<br>原因是闭包（上例的<code>inc</code>）用到了外层变量（<code>start</code>），导致外层函数（<code>createIncrementor</code>）不能从内存释放<br>只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取  </p>
<p>闭包的另一个用处，是封装对象的私有属性和私有方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> _age;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setAge</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    _age = n;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getAge</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> _age;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> &#123;<br>    name: name,<br>    getAge: getAge,<br>    setAge: setAge<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> p1 = Person(<span class="hljs-string">&#x27;张三&#x27;</span>);<br>p1.setAge(<span class="hljs-number">25</span>);<br>p1.getAge() <span class="hljs-comment">// 25</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>Person</code>的内部变量<code>_age</code>，通过闭包<code>getAge</code>和<code>setAge</code>，变成了返回对象<code>p1</code>的私有变量。</p>
<p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大<br>因此不能滥用闭包，否则会造成网页的性能问题  </p>
<h4 id="立即调用的函数表达式-IIFE"><a href="#立即调用的函数表达式-IIFE" class="headerlink" title="立即调用的函数表达式 IIFE"></a>立即调用的函数表达式 IIFE</h4><p>根据 JavaScript 的语法，圆括号<code>()</code>跟在函数名之后，表示调用该函数<br>比如，<code>print()</code>就表示调用<code>print</code>函数  </p>
<p>有时，我们需要在定义函数之后，立即调用该函数<br>这时，你不能在函数的定义之后加上圆括号，这会产生语法错误  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br><span class="hljs-comment">// SyntaxError: Unexpected token (</span><br></code></pre></div></td></tr></table></figure>
<p>产生这个错误的原因是，<code>function</code>这个关键字即可以当作语句，也可以当作表达式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 语句</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><br><span class="hljs-comment">// 表达式</span><br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></div></td></tr></table></figure>
<p>当作表达式时，函数可以定义后直接加圆括号调用  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;();<br>f <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面的代码中，函数定义后直接加圆括号调用，没有报错<br>原因就是<code>function</code>作为表达式，引擎就把函数定义当作一个值。这种情况下，就不会报错  </p>
<p>为了避免解析的歧义，JavaScript 规定，如果<code>function</code>关键字出现在行首，一律解释成语句<br>因此，引擎看到行首是<code>function</code>关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了  </p>
<p>函数定义后立即调用的解决方法，就是不要让<code>function</code>出现在行首，让引擎将其理解成一个表达式<br>最简单的处理，就是将其放在一个圆括号里面  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;());<br><span class="hljs-comment">// 或者</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;)();<br></code></pre></div></td></tr></table></figure>
<p>上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表达式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 <code>IIFE</code>  </p>
<p>注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 <code>IIFE</code>，可能就会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;())<br>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;())<br></code></pre></div></td></tr></table></figure>
<p>上面代码的两行之间没有分号，<code>JavaScript</code> 会将它们连在一起解释，将第二行解释为第一行的参数  </p>
<p>推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> i = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>; &#125;();<br><span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br><span class="hljs-number">0</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br></code></pre></div></td></tr></table></figure>
<p>甚至像下面这样写，也是可以的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">!<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br>~<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br>-<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br>+<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">/* code */</span> &#125;();<br></code></pre></div></td></tr></table></figure>
<p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”<br>它的目的有两个：<br>一是不必为函数命名，避免了污染全局变量<br>二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法一</span><br><span class="hljs-keyword">var</span> tmp = newData;<br>processData(tmp);<br>storeData(tmp);<br><br><span class="hljs-comment">// 写法二</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> tmp = newData;<br>  processData(tmp);<br>  storeData(tmp);<br>&#125;());<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，写法二比写法一更好，因为完全避免了污染全局变量  </p>
<h3 id="eval-命令"><a href="#eval-命令" class="headerlink" title="eval 命令"></a>eval 命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;var a = 1;&#x27;</span>);<br>a <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码将字符串当作语句运行，生成了变量<code>a</code>  </p>
<p>如果参数字符串无法当作语句运行，那么就会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;3x&#x27;</span>) <span class="hljs-comment">// Uncaught SyntaxError: Invalid or unexpected token</span><br></code></pre></div></td></tr></table></figure>
<p>放在<code>eval</code>中的字符串，应该有独自存在的意义，不能用来与<code>eval</code>以外的命令配合使用<br>举例来说，下面的代码将会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;return;&#x27;</span>); <span class="hljs-comment">// Uncaught SyntaxError: Illegal return statement</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码会报错，因为<code>return</code>不能单独使用，必须在函数中使用  </p>
<p>如果<code>eval</code>的参数不是字符串，那么会原样返回  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// 123</span><br></code></pre></div></td></tr></table></figure>
<p><code>eval</code>没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;a = 2&#x27;</span>);<br><br>a <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>eval</code>命令修改了外部变量<code>a</code>的值<br>由于这个原因，<code>eval</code>有安全风险  </p>
<p>为了防止这种风险，<code>JavaScript</code> 规定，如果使用严格模式，<code>eval</code>内部声明的变量，不会影响到外部作用域  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;var foo = 123&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.log(foo);  <span class="hljs-comment">// ReferenceError: foo is not defined</span><br>&#125;)()<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数<code>f</code>内部是严格模式，这时<code>eval</code>内部声明的<code>foo</code>变量，就不会影响到外部  </p>
<p>不过，即使在严格模式下，<code>eval</code>依然可以读写当前作用域的变量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span>;<br>  <span class="hljs-keyword">var</span> foo = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;foo = 2&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.log(foo);  <span class="hljs-comment">// 2</span><br>&#125;)()<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，严格模式下，<code>eval</code>内部还是改写了外部变量，可见安全风险依然存在  </p>
<p>总之，<code>eval</code>的本质是在当前作用域之中，注入代码<br>由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用<br>通常情况下，<code>eval</code>最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的<code>JSON.parse</code>方法  </p>
<h4 id="eval-的别名调用"><a href="#eval-的别名调用" class="headerlink" title="eval 的别名调用"></a>eval 的别名调用</h4><p>前面说过<code>eval</code>不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是<code>eval</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> m = <span class="hljs-built_in">eval</span>;<br>m(<span class="hljs-string">&#x27;var x = 1&#x27;</span>);<br>x <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，变量<code>m</code>是<code>eval</code>的别名<br>静态代码分析阶段，引擎分辨不出<code>m(&#39;var x = 1&#39;)</code>执行的是<code>eval</code>命令  </p>
<p>为了保证<code>eval</code>的别名不影响代码优化，<code>JavaScript</code> 的标准规定，凡是使用别名执行<code>eval</code>，<code>eval</code>内部一律是全局作用域  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;<br>  <span class="hljs-keyword">var</span> e = <span class="hljs-built_in">eval</span>;<br>  e(<span class="hljs-string">&#x27;console.log(a)&#x27;</span>);<br>&#125;<br><br>f() <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>eval</code>是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的<code>a</code>为全局变量<br>这样的话，引擎就能确认<code>e()</code>不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉  </p>
<p><code>eval</code>的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨<code>eval()</code>这一种形式是直接调用  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">eval</span>.call(<span class="hljs-literal">null</span>, <span class="hljs-string">&#x27;...&#x27;</span>)<br><span class="hljs-built_in">window</span>.eval(<span class="hljs-string">&#x27;...&#x27;</span>)<br>(<span class="hljs-number">1</span>, <span class="hljs-built_in">eval</span>)(<span class="hljs-string">&#x27;...&#x27;</span>)<br>(<span class="hljs-built_in">eval</span>, <span class="hljs-built_in">eval</span>)(<span class="hljs-string">&#x27;...&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<p>上面这些形式都是<code>eval</code>的别名调用，作用域都是全局作用域  </p>
<h2 id="Array-数组"><a href="#Array-数组" class="headerlink" title="Array 数组"></a>Array 数组</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>数组（array）是按次序排列的一组值<br>每个值的位置都有编号（从0开始），整个数组用方括号表示  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br></code></pre></div></td></tr></table></figure>
<p>上面代码中的<code>a</code>、<code>b</code>、<code>c</code>就构成一个数组，两端的方括号是数组的标志。<code>a</code>是0号位置，<code>b</code>是1号位置，<code>c</code>是2号位置  </p>
<p>除了在定义时赋值，数组也可以先定义后赋值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<br><br>arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;b&#x27;</span>;<br>arr[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;c&#x27;</span>;<br></code></pre></div></td></tr></table></figure>
<p>任何类型的数据，都可以放入数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<br>  &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;,<br>  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],<br>  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;<br>];<br><br>arr[<span class="hljs-number">0</span>] <span class="hljs-comment">// Object &#123;a: 1&#125;</span><br>arr[<span class="hljs-number">1</span>] <span class="hljs-comment">// [1, 2, 3]</span><br>arr[<span class="hljs-number">2</span>] <span class="hljs-comment">// function ()&#123;return true;&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>上面数组<code>arr</code>的3个成员依次是对象、数组、函数  </p>
<p>如果数组的元素还是数组，就形成了多维数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]];<br>a[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] <span class="hljs-comment">// 2</span><br>a[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] <span class="hljs-comment">// 4</span><br></code></pre></div></td></tr></table></figure>
<h3 id="数组的本质"><a href="#数组的本质" class="headerlink" title="数组的本质"></a>数组的本质</h3><p>本质上，数组属于一种特殊的对象。<code>typeof</code>运算符会返回数组的类型是<code>object</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">typeof</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-comment">// &quot;object&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表明，<code>typeof</code>运算符认为数组的类型就是对象  </p>
<p>数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br><span class="hljs-built_in">Object</span>.keys(arr)<br><span class="hljs-comment">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Object.keys</code>方法返回数组的所有键名<br>可以看到数组的键名就是整数0、1、2  </p>
<p>由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名<br><code>JavaScript</code> 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串<br>之所以可以用数值读取，是因为非字符串的键名会被转为字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>];<br><br>arr[<span class="hljs-string">&#x27;0&#x27;</span>] <span class="hljs-comment">// &#x27;a&#x27;</span><br>arr[<span class="hljs-number">0</span>] <span class="hljs-comment">// &#x27;a&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串  </p>
<p>注意，这点在赋值时也成立。一个值总是先转成字符串，再作为键名进行赋值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [];<br><br>a[<span class="hljs-number">1.00</span>] = <span class="hljs-number">6</span>;<br>a[<span class="hljs-number">1</span>] <span class="hljs-comment">// 6</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，由于<code>1.00</code>转成字符串是<code>1</code>，所以通过数字键<code>1</code>可以读取值  </p>
<p>上一章说过，对象有两种读取成员的方法：点结构（<code>object.key</code>）和方括号结构（<code>object[key]</code>）。但是，对于数值的键名，不能使用点结构  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr<span class="hljs-number">.0</span> <span class="hljs-comment">// SyntaxError</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>arr.0</code>的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号<code>arr[0]</code>表示（方括号是运算符，可以接受数值）  </p>
<h3 id="length-属性-2"><a href="#length-属性-2" class="headerlink" title="length 属性"></a>length 属性</h3><p>数组的<code>length</code>属性，返回数组的成员数量  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>].length <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>JavaScript 使用一个32位整数，保存数组的元素个数<br>这意味着，数组成员最多只有 4294967295 个（2<sup>32</sup> - 1）个，也就是说<code>length</code>属性的最大值就是 4294967295  </p>
<p>只要是数组，就一定有<code>length</code>属性<br>该属性是一个动态的值，等于键名中的最大整数加上<code>1</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>];<br>arr.length <span class="hljs-comment">// 2</span><br><br>arr[<span class="hljs-number">2</span>] = <span class="hljs-string">&#x27;c&#x27;</span>;<br>arr.length <span class="hljs-comment">// 3</span><br><br>arr[<span class="hljs-number">9</span>] = <span class="hljs-string">&#x27;d&#x27;</span>;<br>arr.length <span class="hljs-comment">// 10</span><br><br>arr[<span class="hljs-number">1000</span>] = <span class="hljs-string">&#x27;e&#x27;</span>;<br>arr.length <span class="hljs-comment">// 1001</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，数组的数字键不需要连续，<code>length</code>属性的值总是比最大的那个整数键大<code>1</code><br>另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员  </p>
<p><code>length</code>属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到<code>length</code>设置的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> ];<br>arr.length <span class="hljs-comment">// 3</span><br><br>arr.length = <span class="hljs-number">2</span>;<br>arr <span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，当数组的<code>length</code>属性设为2（即最大的整数键只能是1）那么整数键2（值为<code>c</code>）就已经不在数组中了，被自动删除了  </p>
<p>清空数组的一个有效方法，就是将<code>length</code>属性设为0  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> ];<br><br>arr.length = <span class="hljs-number">0</span>;<br>arr <span class="hljs-comment">// []</span><br></code></pre></div></td></tr></table></figure>
<p>如果人为设置<code>length</code>大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-string">&#x27;a&#x27;</span>];<br><br>a.length = <span class="hljs-number">3</span>;<br>a[<span class="hljs-number">1</span>] <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，当<code>length</code>属性设为大于数组个数时，读取新增的位置都会返回<code>undefined</code>  </p>
<p>如果人为设置<code>length</code>为不合法的值，<code>JavaScript</code> 会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 设置负值</span><br>[].length = -<span class="hljs-number">1</span><br><span class="hljs-comment">// RangeError: Invalid array length</span><br><br><span class="hljs-comment">// 数组元素个数大于等于2的32次方</span><br>[].length = <span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>)<br><span class="hljs-comment">// RangeError: Invalid array length</span><br><br><span class="hljs-comment">// 设置字符串</span><br>[].length = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-comment">// RangeError: Invalid array length</span><br></code></pre></div></td></tr></table></figure>
<p>值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响<code>length</code>属性的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [];<br><br>a[<span class="hljs-string">&#x27;p&#x27;</span>] = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>a.length <span class="hljs-comment">// 0</span><br><br>a[<span class="hljs-number">2.1</span>] = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>a.length <span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码将数组的键分别设为字符串和小数，结果都不影响<code>length</code>属性<br>因为，<code>length</code>属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以<code>length</code>属性保持为<code>0</code>  </p>
<p>如果数组的键名是添加超出范围的数值，该键名会自动转为字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<br>arr[-<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br>arr[<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>)] = <span class="hljs-string">&#x27;b&#x27;</span>;<br><br>arr.length <span class="hljs-comment">// 0</span><br>arr[-<span class="hljs-number">1</span>] <span class="hljs-comment">// &quot;a&quot;</span><br>arr[<span class="hljs-number">4294967296</span>] <span class="hljs-comment">// &quot;b&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，我们为数组<code>arr</code>添加了两个不合法的数字键，结果<code>length</code>属性没有发生变化<br>这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串  </p>
<h3 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h3><p>检查某个键名是否存在的运算符<code>in</code>，适用于对象，也适用于数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [ <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> ];<br><span class="hljs-number">2</span> <span class="hljs-keyword">in</span> arr  <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-keyword">in</span> arr <span class="hljs-comment">// true</span><br><span class="hljs-number">4</span> <span class="hljs-keyword">in</span> arr <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表明，数组存在键名为<code>2</code>的键。由于键名都是字符串，所以数值<code>2</code>会自动转成字符串  </p>
<p>注意，如果数组的某个位置是空位，<code>in</code>运算符返回<code>false</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<br>arr[<span class="hljs-number">100</span>] = <span class="hljs-string">&#x27;a&#x27;</span>;<br><br><span class="hljs-number">100</span> <span class="hljs-keyword">in</span> arr <span class="hljs-comment">// true</span><br><span class="hljs-number">1</span> <span class="hljs-keyword">in</span> arr <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，数组<code>arr</code>只有一个成员<code>arr[100]</code>，其他位置的键名都会返回<code>false</code>  </p>
<h3 id="for…in-循环和数组的遍历"><a href="#for…in-循环和数组的遍历" class="headerlink" title="for…in 循环和数组的遍历"></a>for…in 循环和数组的遍历</h3><p><code>for...in</code>循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> a) &#123;<br>  <span class="hljs-built_in">console</span>.log(a[i]);<br>&#125;<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>但是，<code>for...in</code>不仅会遍历数组所有的数字键，还会遍历非数字键  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>a.foo = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> a) &#123;<br>  <span class="hljs-built_in">console</span>.log(key);<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// foo</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码在遍历数组时，也遍历到了非整数键<code>foo</code>。所以，不推荐使用<code>for...in</code>遍历数组  </p>
<p>数组的遍历可以考虑使用<code>for</code>循环或<code>while</code>循环  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// for循环</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; a.length; i++) &#123;<br>  <span class="hljs-built_in">console</span>.log(a[i]);<br>&#125;<br><br><span class="hljs-comment">// while循环</span><br><span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (i &lt; a.length) &#123;<br>  <span class="hljs-built_in">console</span>.log(a[i]);<br>  i++;<br>&#125;<br><br><span class="hljs-keyword">var</span> l = a.length;<br><span class="hljs-keyword">while</span> (l--) &#123;<br>  <span class="hljs-built_in">console</span>.log(a[l]);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>];<br>colors.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">color</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(color);<br>&#125;);<br><span class="hljs-comment">// red</span><br><span class="hljs-comment">// green</span><br><span class="hljs-comment">// blue</span><br></code></pre></div></td></tr></table></figure>
<h3 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h3><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, , <span class="hljs-number">1</span>];<br>a.length <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表明，数组的空位不影响<code>length</code>属性  </p>
<p>需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>,];<br><br>a.length <span class="hljs-comment">// 3</span><br>a <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，数组最后一个成员后面有一个逗号，这不影响<code>length</code>属性的值，与没有这个逗号时效果一样  </p>
<p>数组的空位是可以读取的，返回<code>undefined</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [, , ,];<br>a[<span class="hljs-number">1</span>] <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">delete</span> a[<span class="hljs-number">1</span>];<br><br>a[<span class="hljs-number">1</span>] <span class="hljs-comment">// undefined</span><br>a.length <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码用<code>delete</code>命令删除了数组的第二个元素，这个位置就形成了空位，但是对<code>length</code>属性没有影响<br>也就是说，<code>length</code>属性不过滤空位<br>所以，使用<code>length</code>属性进行数组遍历，一定要非常小心  </p>
<p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的<br>如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [, , ,];<br><br>a.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, i</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&#x27;. &#x27;</span> + x);<br>&#125;)<br><span class="hljs-comment">// 不产生任何输出</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> a) &#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br><span class="hljs-comment">// 不产生任何输出</span><br><br><span class="hljs-built_in">Object</span>.keys(a)<br><span class="hljs-comment">// []</span><br></code></pre></div></td></tr></table></figure>
<p>如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = [<span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>];<br><br>a.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, i</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&#x27;. &#x27;</span> + x);<br>&#125;);<br><span class="hljs-comment">// 0. undefined</span><br><span class="hljs-comment">// 1. undefined</span><br><span class="hljs-comment">// 2. undefined</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> a) &#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>&#125;<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><br><span class="hljs-built_in">Object</span>.keys(a)<br><span class="hljs-comment">// [&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;]</span><br></code></pre></div></td></tr></table></figure>
<p>这就是说，空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是<code>undefined</code>，所以遍历不会跳过  </p>
<h3 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h3><p>如果一个对象的所有键名都是正整数或零，并且有<code>length</code>属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-number">0</span>: <span class="hljs-string">&#x27;a&#x27;</span>,<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;b&#x27;</span>,<br>  <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;c&#x27;</span>,<br>  length: <span class="hljs-number">3</span><br>&#125;;<br><br>obj[<span class="hljs-number">0</span>] <span class="hljs-comment">// &#x27;a&#x27;</span><br>obj[<span class="hljs-number">1</span>] <span class="hljs-comment">// &#x27;b&#x27;</span><br>obj.length <span class="hljs-comment">// 3</span><br>obj.push(<span class="hljs-string">&#x27;d&#x27;</span>) <span class="hljs-comment">// TypeError: obj.push is not a function</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象<code>obj</code>就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法<br>对象<code>obj</code>没有数组的<code>push</code>方法，使用该方法就会报错  </p>
<p>“类似数组的对象”的根本特征，就是具有<code>length</code>属性<br>只要有<code>length</code>属性，就可以认为这个对象类似于数组<br>但是有一个问题，这种<code>length</code>属性不是动态值，不会随着成员的变化而变化  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  length: <span class="hljs-number">0</span><br>&#125;;<br>obj[<span class="hljs-number">3</span>] = <span class="hljs-string">&#x27;d&#x27;</span>;<br>obj.length <span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码为对象<code>obj</code>添加了一个数字键，但是<code>length</code>属性没变。这就说明了<code>obj</code>不是数组  </p>
<p>典型的“类似数组的对象”是函数的<code>arguments</code>对象，以及大多数 DOM 元素集，还有字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// arguments对象</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">args</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">arguments</span> &#125;<br><span class="hljs-keyword">var</span> arrayLike = args(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>);<br><br>arrayLike[<span class="hljs-number">0</span>] <span class="hljs-comment">// &#x27;a&#x27;</span><br>arrayLike.length <span class="hljs-comment">// 2</span><br>arrayLike <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// DOM元素集</span><br><span class="hljs-keyword">var</span> elts = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;h3&#x27;</span>);<br>elts.length <span class="hljs-comment">// 3</span><br>elts <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 字符串</span><br><span class="hljs-string">&#x27;abc&#x27;</span>[<span class="hljs-number">1</span>] <span class="hljs-comment">// &#x27;b&#x27;</span><br><span class="hljs-string">&#x27;abc&#x27;</span>.length <span class="hljs-comment">// 3</span><br><span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码包含三个例子，它们都不是数组（<code>instanceof</code>运算符返回<code>false</code>），但是看上去都非常像数组  </p>
<p>数组的<code>slice</code>方法可以将“类似数组的对象”变成真正的数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Array</span>.prototype.slice.call(arrayLike);<br></code></pre></div></td></tr></table></figure>
<p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过<code>call()</code>把数组的方法放到对象上面  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">value, index</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(index + <span class="hljs-string">&#x27; : &#x27;</span> + value);<br>&#125;<br><br><span class="hljs-built_in">Array</span>.prototype.forEach.call(arrayLike, print);<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用  </p>
<p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// forEach 方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logArgs</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">Array</span>.prototype.forEach.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">elem, i</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&#x27;. &#x27;</span> + elem);<br>  &#125;);<br>&#125;<br><br><span class="hljs-comment">// 等同于 for 循环</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">logArgs</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) &#123;<br>    <span class="hljs-built_in">console</span>.log(i + <span class="hljs-string">&#x27;. &#x27;</span> + <span class="hljs-built_in">arguments</span>[i]);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Array</span>.prototype.forEach.call(<span class="hljs-string">&#x27;abc&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chr</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(chr);<br>&#125;);<br><span class="hljs-comment">// a</span><br><span class="hljs-comment">// b</span><br><span class="hljs-comment">// c</span><br></code></pre></div></td></tr></table></figure>
<p>注意，这种方法比直接使用数组原生的<code>forEach</code>要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-string">&#x27;abc&#x27;</span>);<br>arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chr</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(chr);<br>&#125;);<br><span class="hljs-comment">// a</span><br><span class="hljs-comment">// b</span><br><span class="hljs-comment">// c</span><br></code></pre></div></td></tr></table></figure>


<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p><code>JavaScript</code> 共提供10个算术运算符，用来完成基本的算术运算  </p>
<p>加法运算符：<code>x + y</code><br>减法运算符： <code>x - y</code><br>乘法运算符： <code>x * y</code><br>除法运算符：<code>x / y</code><br>指数运算符：<code>x ** y</code><br>余数运算符：<code>x % y</code><br>自增运算符：<code>++x</code> 或者 <code>x++</code><br>自减运算符：<code>--x</code> 或者 <code>x--</code><br>数值运算符： <code>+x</code><br>负数值运算符：<code>-x</code><br>减法、乘法、除法运算法比较单纯，就是执行相应的数学运算，重点是加法运算符  </p>
<h3 id="加法运算符"><a href="#加法运算符" class="headerlink" title="加法运算符"></a>加法运算符</h3><h4 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h4><p>加法运算符（+）是最常见的运算符，用来求两个数值的和  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">1</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>JavaScript 允许非数值的相加  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-literal">true</span> + <span class="hljs-literal">true</span> <span class="hljs-comment">// 2</span><br><span class="hljs-number">1</span> + <span class="hljs-literal">true</span> <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，第一行是两个布尔值相加，第二行是数值与布尔值相加<br>这两种情况，布尔值都会自动转成数值，然后再相加  </p>
<p>比较特殊的是，如果是两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a&#x27;</span> + <span class="hljs-string">&#x27;bc&#x27;</span> <span class="hljs-comment">// &quot;abc&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>如果一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">1</span> + <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-comment">// &quot;1a&quot;</span><br><span class="hljs-literal">false</span> + <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-comment">// &quot;falsea&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>加法运算符是在运行时决定，到底是执行相加，还是执行连接<br>也就是说，运算子的不同，导致了不同的语法行为，这种现象称为“重载”（overload）<br>由于加法运算符存在重载，可能执行两种运算，使用的时候必须很小心  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;3&#x27;</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> <span class="hljs-comment">// &quot;345&quot;</span><br><span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-comment">// &quot;75&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，由于从左到右的运算次序，字符串的位置不同会导致不同的结果  </p>
<p>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载<br>它们的规则是：所有运算子一律转为数值，再进行相应的数学运算  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">1</span> - <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// -1</span><br><span class="hljs-number">1</span> * <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 2</span><br><span class="hljs-number">1</span> / <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 0.5</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，减法、除法和乘法运算符，都是将字符串自动转为数值，然后再运算  </p>
<h4 id="对象的相加"><a href="#对象的相加" class="headerlink" title="对象的相加"></a>对象的相加</h4><p>如果运算子是对象，必须先转成原始类型的值，然后再相加  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br>obj + <span class="hljs-number">2</span> <span class="hljs-comment">// &quot;[object Object]2&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象obj转成原始类型的值是<code>[object Object]</code>，再加2就得到了上面的结果  </p>
<p>对象转成原始类型的值，规则如下。</p>
<p>首先，自动调用对象的valueOf方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br>obj.valueOf() <span class="hljs-comment">// &#123; p: 1 &#125;</span><br></code></pre></div></td></tr></table></figure>
<p>一般来说，对象的<code>valueOf</code>方法总是返回对象自身，这时再自动调用对象的<code>toString</code>方法，将其转为字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">p</span>: <span class="hljs-number">1</span> &#125;;<br>obj.valueOf().toString() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>对象的<code>toString</code>方法默认返回<code>[object Object]</code>，所以就得到了最前面那个例子的结果  </p>
<p>知道了这个规则以后，就可以自己定义<code>valueOf</code>方法或<code>toString</code>方法，得到想要的结果  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>&#125;;<br><br>obj + <span class="hljs-number">2</span> <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，我们定义 obj对象的<code>valueOf</code>方法返回1，于是 obj + 2 就得到了3<br>这个例子中，由于<code>valueOf</code>方法直接返回一个原始类型的值，所以不再调用<code>toString</code>方法  </p>
<p>下面是自定义<code>toString</code>方法的例子  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span>;<br>  &#125;<br>&#125;;<br><br>obj + <span class="hljs-number">2</span> <span class="hljs-comment">// &quot;hello2&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象obj的<code>toString</code>方法返回字符串hello<br>前面说过，只要有一个运算子是字符串，加法运算符就变成连接运算符，返回连接后的字符串  </p>
<p>这里有一个特例，如果运算子是一个 <code>Date</code>对象的实例，那么会优先执行<code>toString</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>obj.valueOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> &#125;;<br>obj.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello&#x27;</span> &#125;;<br><br>obj + <span class="hljs-number">2</span> <span class="hljs-comment">// &quot;hello2&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，对象obj是一个<code>Date</code>对象的实例，并且自定义了<code>valueOf</code>方法和<code>toString</code>方法，结果<code>toString</code>方法优先执行  </p>
<h3 id="余数运算符"><a href="#余数运算符" class="headerlink" title="余数运算符"></a>余数运算符</h3><p>余数运算符（<code>%</code>）返回前一个运算子被后一个运算子除，所得的余数  </p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">12 </span>% <span class="hljs-number">5</span> // <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure>
<p>需要注意的是，运算结果的正负号由第一个运算子的正负号决定  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">-<span class="hljs-number">1</span> % <span class="hljs-number">2</span> <span class="hljs-regexp">//</span> -<span class="hljs-number">1</span><br><span class="hljs-number">1</span> % -<span class="hljs-number">2</span> <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>
<p>所以，为了得到负数的正确余数值，可以先使用绝对值函数  </p>
<figure class="highlight reasonml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs reasonml"><span class="hljs-comment">// 错误的写法</span><br><span class="hljs-keyword">function</span> is<span class="hljs-constructor">Odd(<span class="hljs-params">n</span>)</span> &#123;<br>  return n % <span class="hljs-number">2</span><span class="hljs-operator"> === </span><span class="hljs-number">1</span>;<br>&#125;<br>is<span class="hljs-constructor">Odd(-5)</span> <span class="hljs-comment">// false</span><br>is<span class="hljs-constructor">Odd(-4)</span> <span class="hljs-comment">// false</span><br><br><span class="hljs-comment">// 正确的写法</span><br><span class="hljs-keyword">function</span> is<span class="hljs-constructor">Odd(<span class="hljs-params">n</span>)</span> &#123;<br>  return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>abs(n % <span class="hljs-number">2</span>)<span class="hljs-operator"> === </span><span class="hljs-number">1</span>;<br>&#125;<br>is<span class="hljs-constructor">Odd(-5)</span> <span class="hljs-comment">// true</span><br>is<span class="hljs-constructor">Odd(-4)</span> <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>余数运算符还可以用于浮点数的运算。但是，由于浮点数不是精确的值，无法得到完全准确的结果  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-number">6.5</span> % <span class="hljs-number">2.1</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">0.19999999999999973</span><br></code></pre></div></td></tr></table></figure>


<h3 id="自增和自减运算符"><a href="#自增和自减运算符" class="headerlink" title="自增和自减运算符"></a>自增和自减运算符</h3><p>自增和自减运算符，是一元运算符，只需要一个运算子  </p>
<p>它们的作用是将运算子首先转为数值，然后加上1或者减去1  </p>
<p>它们会修改原始变量  </p>
<figure class="highlight gml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gml"><span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span> = <span class="hljs-number">1</span>;<br>++<span class="hljs-symbol">x</span> <span class="hljs-comment">// 2</span><br><span class="hljs-symbol">x</span> <span class="hljs-comment">// 2</span><br><br>--<span class="hljs-symbol">x</span> <span class="hljs-comment">// 1</span><br><span class="hljs-symbol">x</span> <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的变量<code>x</code>自增后，返回<code>2</code>，再进行自减，返回<code>1</code>  </p>
<p>这两种情况都会使得，原始变量<code>x</code>的值发生改变  </p>
<p>运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）  </p>
<p>自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值  </p>
<p>自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值  </p>
<figure class="highlight gml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gml"><span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span> = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> <span class="hljs-symbol">y</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-symbol">x</span>++ <span class="hljs-comment">// 1</span><br>++<span class="hljs-symbol">y</span> <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>x</code>是先返回当前值，然后自增，所以得到<code>1</code>；<code>y</code>是先自增，然后返回新的值，所以得到<code>2</code>  </p>
<h3 id="数值运算符，负数值运算符"><a href="#数值运算符，负数值运算符" class="headerlink" title="数值运算符，负数值运算符"></a>数值运算符，负数值运算符</h3><p>数值运算符（<code>+</code>）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）  </p>
<p>数值运算符的作用在于可以将任何值转为数值（与<code>Number</code>函数的作用相同）  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">+true <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br>+[] <span class="hljs-regexp">//</span> <span class="hljs-number">0</span><br>+&#123;&#125; <span class="hljs-regexp">//</span> NaN<br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，非数值经过数值运算符以后，都变成了数值（最后一行<code>NaN</code>也是数值）  </p>
<p>负数值运算符（<code>-</code>），也同样具有将一个值转为数值的功能，只不过得到的值正负相反  </p>
<p>连用两个负数值运算符，等同于数值运算符  </p>
<figure class="highlight gml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gml"><span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span> = <span class="hljs-number">1</span>;<br>-<span class="hljs-symbol">x</span> <span class="hljs-comment">// -1</span><br>-(-<span class="hljs-symbol">x</span>) <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码最后一行的圆括号不可少，否则会变成自减运算符  </p>
<p>数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值  </p>
<h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h3><p>指数运算符（<code>**</code>）完成指数运算，前一个运算子是底数，后一个运算子是指数  </p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>** <span class="hljs-number">4</span> // <span class="hljs-number">16</span><br></code></pre></div></td></tr></table></figure>
<p>注意，指数运算符是右结合，而不是左结合。即多个指数运算符连用时，先进行最右边的计算  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 相当于 <span class="hljs-number">2</span> ** (<span class="hljs-number">3</span> ** <span class="hljs-number">2</span>)<br><span class="hljs-number">2</span> ** <span class="hljs-number">3</span> ** <span class="hljs-number">2</span><br><span class="hljs-regexp">//</span> <span class="hljs-number">512</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，由于指数运算符是右结合，所以先计算第二个指数运算符，而不是第一个  </p>
<h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>赋值运算符（Assignment Operators）用于给变量赋值  </p>
<p>最常见的赋值运算符，当然就是等号（<code>=</code>）  </p>
<figure class="highlight gml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gml"><span class="hljs-comment">// 将 1 赋值给变量 x</span><br><span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span> = <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// 将变量 y 的值赋值给变量 x</span><br><span class="hljs-keyword">var</span> <span class="hljs-symbol">x</span> = <span class="hljs-symbol">y</span>;<br></code></pre></div></td></tr></table></figure>
<p>赋值运算符还可以与其他运算符结合，形成变体  </p>
<p>下面是与算术运算符的结合  </p>
<figure class="highlight gml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gml"><span class="hljs-comment">// 等同于 x = x + y</span><br><span class="hljs-symbol">x</span> += <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x - y</span><br><span class="hljs-symbol">x</span> -= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x * y</span><br><span class="hljs-symbol">x</span> *= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x / y</span><br><span class="hljs-symbol">x</span> /= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x % y</span><br><span class="hljs-symbol">x</span> %= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x ** y</span><br><span class="hljs-symbol">x</span> **= <span class="hljs-symbol">y</span><br></code></pre></div></td></tr></table></figure>
<p>下面是与位运算符的结合（关于位运算符，请见后文的介绍）  </p>
<figure class="highlight gml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gml"><span class="hljs-comment">// 等同于 x = x &gt;&gt; y</span><br><span class="hljs-symbol">x</span> &gt;&gt;= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x &lt;&lt; y</span><br><span class="hljs-symbol">x</span> &lt;&lt;= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x &gt;&gt;&gt; y</span><br><span class="hljs-symbol">x</span> &gt;&gt;&gt;= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x &amp; y</span><br><span class="hljs-symbol">x</span> &amp;= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x | y</span><br><span class="hljs-symbol">x</span> |= <span class="hljs-symbol">y</span><br><br><span class="hljs-comment">// 等同于 x = x ^ y</span><br><span class="hljs-symbol">x</span> ^= <span class="hljs-symbol">y</span><br></code></pre></div></td></tr></table></figure>
<p>这些复合的赋值运算符，都是先进行指定运算，然后将得到值返回给左边的变量  </p>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>比较运算符用于比较两个值的大小，然后返回一个布尔值，表示是否满足指定的条件  </p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>&gt; <span class="hljs-number">1</span> // true<br></code></pre></div></td></tr></table></figure>
<p>上面代码比较<code>2</code>是否大于<code>1</code>，返回<code>true</code>  </p>
<blockquote>
<p>注意，比较运算符可以比较各种类型的值，不仅仅是数值  </p>
</blockquote>
<p>JavaScript 一共提供了8个比较运算符  </p>
<ul>
<li><code>&gt;</code> 大于运算符  </li>
<li><code>&lt;</code> 小于运算符  </li>
<li><code>&lt;=</code> 小于或等于运算符  </li>
<li><code>&gt;=</code> 大于或等于运算符  </li>
<li><code>==</code> 相等运算符  </li>
<li><code>===</code> 严格相等运算符  </li>
<li><code>!=</code> 不相等运算符  </li>
<li><code>!==</code> 严格不相等运算符  </li>
</ul>
<p>这八个比较运算符分成两类：相等比较和非相等比较  </p>
<p>两者的规则是不一样的，对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小。</p>
<h3 id="非相等运算符：字符串的比较"><a href="#非相等运算符：字符串的比较" class="headerlink" title="非相等运算符：字符串的比较"></a>非相等运算符：字符串的比较</h3><p>字符串按照字典顺序进行比较  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-string">&#x27;cat&#x27;</span> &gt; <span class="hljs-string">&#x27;dog&#x27;</span> <span class="hljs-regexp">//</span> false<br><span class="hljs-string">&#x27;cat&#x27;</span> &gt; <span class="hljs-string">&#x27;catalog&#x27;</span> <span class="hljs-regexp">//</span> false<br></code></pre></div></td></tr></table></figure>
<p><code>JavaScript</code> 引擎内部首先比较首字符的 <code>Unicode</code> 码点  </p>
<p>如果相等，再比较第二个字符的 <code>Unicode</code> 码点，以此类推  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-string">&#x27;cat&#x27;</span> &gt; <span class="hljs-string">&#x27;Cat&#x27;</span> <span class="hljs-regexp">//</span> true<span class="hljs-string">&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，小写的<code>c</code>的<code>Unicode</code> 码点（<code>99</code>）大于大写的<code>C</code>的 <code>Unicode</code> 码点（<code>67</code>），所以返回<code>true</code>。</p>
<p>由于所有字符都有 <code>Unicode</code> 码点，因此汉字也可以比较  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-string">&#x27;大&#x27;</span> &gt; <span class="hljs-string">&#x27;小&#x27;</span> <span class="hljs-regexp">//</span> false<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，“大”的 <code>Unicode</code> 码点是22823，“小”是<code>23567</code>，因此返回<code>false</code>  </p>
<h3 id="非相等运算符：非字符串的比较"><a href="#非相等运算符：非字符串的比较" class="headerlink" title="非相等运算符：非字符串的比较"></a>非相等运算符：非字符串的比较</h3><p>如果两个运算子之中，至少有一个不是字符串，需要分成以下两种情况  </p>
<p><strong>（1）原始类型值</strong></p>
<p>如果两个运算子都是原始类型的值，则是先转成数值再比较  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-number">5</span> &gt; <span class="hljs-string">&#x27;4&#x27;</span> <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">5</span> &gt; Number(<span class="hljs-string">&#x27;4&#x27;</span>)<br><span class="hljs-regexp">//</span> 即 <span class="hljs-number">5</span> &gt; <span class="hljs-number">4</span><br><br>true &gt; false <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 Number(true) &gt; Number(false)<br><span class="hljs-regexp">//</span> 即 <span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span><br><br><span class="hljs-number">2</span> &gt; true <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">2</span> &gt; Number(true)<br><span class="hljs-regexp">//</span> 即 <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，字符串和布尔值都会先转成数值，再进行比较  </p>
<p>这里需要注意与<code>NaN</code>的比较。任何值（包括<code>NaN</code>本身）与<code>NaN</code>使用非相等运算符进行比较，返回的都是<code>false</code>  </p>
<figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade"><span class="hljs-number">1</span> &gt; <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-number">1</span> &lt;= <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-string">&#x27;1&#x27;</span> &gt; <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-string">&#x27;1&#x27;</span> &lt;= <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">NaN</span> &gt; <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">NaN</span> &lt;= <span class="hljs-literal">NaN</span> <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（2）对象</strong></p>
<p>如果运算子是对象，会转为原始类型的值，再进行比较  </p>
<p>对象转换成原始类型的值，算法是先调用<code>valueOf</code>方法  </p>
<p>如果返回的还是对象，再接着调用<code>toString</code>方法  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var x = [<span class="hljs-number">2</span>];<br>x &gt; <span class="hljs-string">&#x27;11&#x27;</span> <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 [<span class="hljs-number">2</span>].valueOf().toString() &gt; <span class="hljs-string">&#x27;11&#x27;</span><br><span class="hljs-regexp">//</span> 即 <span class="hljs-string">&#x27;2&#x27;</span> &gt; <span class="hljs-string">&#x27;11&#x27;</span><br><br>x.valueOf = <span class="hljs-keyword">function</span> () &#123; return <span class="hljs-string">&#x27;1&#x27;</span> &#125;;<br>x &gt; <span class="hljs-string">&#x27;11&#x27;</span> <span class="hljs-regexp">//</span> false<br><span class="hljs-regexp">//</span> 等同于 [<span class="hljs-number">2</span>].valueOf() &gt; <span class="hljs-string">&#x27;11&#x27;</span><br><span class="hljs-regexp">//</span> 即 <span class="hljs-string">&#x27;1&#x27;</span> &gt; <span class="hljs-string">&#x27;11&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>两个对象之间的比较也是如此  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">[<span class="hljs-number">2</span>] &gt; [<span class="hljs-number">1</span>] <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 [<span class="hljs-number">2</span>].valueOf().toString() &gt; [<span class="hljs-number">1</span>].valueOf().toString()<br><span class="hljs-regexp">//</span> 即 <span class="hljs-string">&#x27;2&#x27;</span> &gt; <span class="hljs-string">&#x27;1&#x27;</span><br><br>[<span class="hljs-number">2</span>] &gt; [<span class="hljs-number">11</span>] <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 [<span class="hljs-number">2</span>].valueOf().toString() &gt; [<span class="hljs-number">11</span>].valueOf().toString()<br><span class="hljs-regexp">//</span> 即 <span class="hljs-string">&#x27;2&#x27;</span> &gt; <span class="hljs-string">&#x27;11&#x27;</span><br><br>&#123; x: <span class="hljs-number">2</span> &#125; &gt;= &#123; x: <span class="hljs-number">1</span> &#125; <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 &#123; x: <span class="hljs-number">2</span> &#125;.valueOf().toString() &gt;= &#123; x: <span class="hljs-number">1</span> &#125;.valueOf().toString()<br><span class="hljs-regexp">//</span> 即 <span class="hljs-string">&#x27;[object Object]&#x27;</span> &gt;= <span class="hljs-string">&#x27;[object Object]&#x27;</span><br></code></pre></div></td></tr></table></figure>


<h3 id="严格相等运算符"><a href="#严格相等运算符" class="headerlink" title="严格相等运算符"></a>严格相等运算符</h3><p>JavaScript 提供两种相等运算符：<code>==</code>和<code>===</code>。</p>
<p>简单说，它们的区别是相等运算符（<code>==</code>）比较两个值是否相等，严格相等运算符（<code>===</code>）比较它们是否为“同一个值”    </p>
<p>如果两个值不是同一类型，严格相等运算符（<code>===</code>）直接返回<code>false</code>，而相等运算符（<code>==</code>）会将它们转换成同一个类型，再用严格相等运算符进行比较  </p>
<p><strong>（1）不同类型的值</strong>  </p>
<p>如果两个值的类型不同，直接返回<code>false</code>  </p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">1</span> === <span class="hljs-string">&quot;1&quot;</span> // <span class="hljs-literal">false</span><br><span class="hljs-attr">true</span> === <span class="hljs-string">&quot;true&quot;</span> // <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码比较数值的<code>1</code>与字符串的“1”、布尔值的<code>true</code>与字符串<code>&quot;true&quot;</code>，因为类型不同，结果都是<code>false</code>  </p>
<p><strong>（2）同一类的原始类型值</strong>  </p>
<p>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回<code>true</code>，值不同就返回<code>false</code>  </p>
<figure class="highlight basic"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>=== <span class="hljs-number">0</span>x1 // true<br></code></pre></div></td></tr></table></figure>
<p>上面代码比较十进制的<code>1</code>与十六进制的<code>1</code>，因为类型和值都相同，返回<code>true</code>  </p>
<p>需要注意的是，<code>NaN</code>与任何值都不相等（包括自身）  </p>
<p>另外，正<code>0</code>等于负<code>0</code>  </p>
<figure class="highlight arcade"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs arcade"><span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span>  <span class="hljs-comment">// false</span><br>+<span class="hljs-number">0</span> === <span class="hljs-number">-0</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（3）复合类型值</strong>  </p>
<p>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址  </p>
<figure class="highlight actionscript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs actionscript">&#123;&#125; === &#123;&#125; <span class="hljs-comment">// false</span><br>[] === [] <span class="hljs-comment">// false</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;&#125; === <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;&#125;) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码分别比较两个空对象、两个空数组、两个空函数，结果都是不相等  </p>
<p>原因是对于复合类型的值，严格相等运算比较的是，它们是否引用同一个内存地址，而运算符两边的空对象、空数组、空函数的值，都存放在不同的内存地址，结果当然是<code>false</code>  </p>
<p>如果两个变量引用同一个对象，则它们相等  </p>
<figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">var</span> <span class="hljs-built_in">v1</span> = &#123;&#125;<span class="hljs-comment">;</span><br><span class="hljs-symbol">var</span> <span class="hljs-built_in">v2</span> = <span class="hljs-built_in">v1</span><span class="hljs-comment">;</span><br><span class="hljs-symbol">v1</span> === <span class="hljs-built_in">v2</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">var obj1 = &#123;&#125;;<br>var obj2 = &#123;&#125;;<br><br>obj1 &gt; obj2 <span class="hljs-regexp">//</span> false<br>obj1 &lt; obj2 <span class="hljs-regexp">//</span> false<br>obj1 === obj2 <span class="hljs-regexp">//</span> false<br></code></pre></div></td></tr></table></figure>
<p>上面的三个比较，前两个比较的是值，最后一个比较的是地址，所以都返回<code>false</code>  </p>
<p><strong>（4）undefined 和 null</strong></p>
<p><code>undefined</code>和<code>null</code>与自身严格相等  </p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">undefined</span> <span class="hljs-string">===</span> <span class="hljs-string">undefined</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br><span class="hljs-literal">null</span> <span class="hljs-string">===</span> <span class="hljs-literal">null</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure>
<p>由于变量声明后默认值是<code>undefined</code>，因此两个只声明未赋值的变量是相等的  </p>
<figure class="highlight armasm"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs armasm"><span class="hljs-symbol">var</span> <span class="hljs-built_in">v1</span><span class="hljs-comment">;</span><br><span class="hljs-symbol">var</span> <span class="hljs-built_in">v2</span><span class="hljs-comment">;</span><br><span class="hljs-symbol">v1</span> === <span class="hljs-built_in">v2</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>


<h3 id="严格不相等运算符"><a href="#严格不相等运算符" class="headerlink" title="严格不相等运算符"></a>严格不相等运算符</h3><p>严格相等运算符有一个对应的“严格不相等运算符”（<code>!==</code>），它的算法就是先求严格相等运算符的结果，然后返回相反值  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-number">1</span> !== <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于<br>!(<span class="hljs-number">1</span> === <span class="hljs-string">&#x27;1&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，感叹号<code>!</code>是求出后面表达式的相反值  </p>
<h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符"></a>相等运算符</h3><p>相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样   </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-number">1</span> == <span class="hljs-number">1.0</span><br><span class="hljs-regexp">//</span> 等同于<br><span class="hljs-number">1</span> === <span class="hljs-number">1.0</span><br></code></pre></div></td></tr></table></figure>
<p>比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较  </p>
<p>下面分成几种情况，讨论不同类型的值互相比较的规则  </p>
<p><strong>（1）原始类型值</strong></p>
<p>原始类型的值会转换成数值再进行比较  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-number">1</span> == true <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">1</span> === Number(true)<br><br><span class="hljs-number">0</span> == false <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">0</span> === Number(false)<br><br><span class="hljs-number">2</span> == true <span class="hljs-regexp">//</span> false<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">2</span> === Number(true)<br><br><span class="hljs-number">2</span> == false <span class="hljs-regexp">//</span> false<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">2</span> === Number(false)<br><br><span class="hljs-string">&#x27;true&#x27;</span> == true <span class="hljs-regexp">//</span> false<br><span class="hljs-regexp">//</span> 等同于 Number(<span class="hljs-string">&#x27;true&#x27;</span>) === Number(true)<br><span class="hljs-regexp">//</span> 等同于 NaN === <span class="hljs-number">1</span><br><br><span class="hljs-string">&#x27;&#x27;</span> == <span class="hljs-number">0</span> <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 Number(<span class="hljs-string">&#x27;&#x27;</span>) === <span class="hljs-number">0</span><br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">0</span> === <span class="hljs-number">0</span><br><br><span class="hljs-string">&#x27;&#x27;</span> == false  <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 Number(<span class="hljs-string">&#x27;&#x27;</span>) === Number(false)<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">0</span> === <span class="hljs-number">0</span><br><br><span class="hljs-string">&#x27;1&#x27;</span> == true  <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 等同于 Number(<span class="hljs-string">&#x27;1&#x27;</span>) === Number(true)<br><span class="hljs-regexp">//</span> 等同于 <span class="hljs-number">1</span> === <span class="hljs-number">1</span><br><br><span class="hljs-string">&#x27;\n  123  \t&#x27;</span> == <span class="hljs-number">123</span> <span class="hljs-regexp">//</span> true<br><span class="hljs-regexp">//</span> 因为字符串转为数字时，省略前置和后置的空格<br></code></pre></div></td></tr></table></figure>
<p>上面代码将字符串和布尔值都转为数值，然后再进行比较  </p>
<p><strong>（2）对象与原始类型值比较</strong></p>
<p>对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较  </p>
<p>具体来说，先调用对象的<code>valueOf()</code>方法，如果得到原始类型的值，就按照上一小节的规则，互相比较；如果得到的还是对象，则再调用<code>toString()</code>方法，得到字符串形式，再进行比较  </p>
<p>下面是数组与原始类型值比较的例子  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 数组与数值的比较<br>[<span class="hljs-number">1</span>] == <span class="hljs-number">1</span> <span class="hljs-regexp">//</span> true<br><br><span class="hljs-regexp">//</span> 数组与字符串的比较<br>[<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-regexp">//</span> true<br>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;1,2&#x27;</span> <span class="hljs-regexp">//</span> true<br><br><span class="hljs-regexp">//</span> 对象与布尔值的比较<br>[<span class="hljs-number">1</span>] == true <span class="hljs-regexp">//</span> true<br>[<span class="hljs-number">2</span>] == true <span class="hljs-regexp">//</span> false<br></code></pre></div></td></tr></table></figure>
<p>上面例子中，<code>Javascript</code> 引擎会先对数组<code>[1]</code>调用数组的<code>valueOf()</code>方法，由于返回的还是一个数组，所以会接着调用数组的<code>toString()</code>方法，得到字符串形式，再按照上一小节的规则进行比较  </p>
<p>下面是一个更直接的例子  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行 valueOf()&#x27;</span>);<br>    <span class="hljs-keyword">return</span> obj;<br>  &#125;,<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;执行 toString()&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;foo&#x27;</span>;<br>  &#125;<br>&#125;;<br><br>obj == <span class="hljs-string">&#x27;foo&#x27;</span><br><span class="hljs-comment">// 执行 valueOf()</span><br><span class="hljs-comment">// 执行 toString()</span><br><span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面例子中，<code>obj</code>是一个自定义了<code>valueOf()</code>和<code>toString()</code>方法的对象。这个对象与字符串<code>&#39;foo&#39;</code>进行比较时，会依次调用<code>valueOf()</code>和<code>toString()</code>方法，最后返回<code>&#39;foo&#39;</code>，所以比较结果是<code>true</code>。</p>
<p><strong>（3）undefined 和 null</strong></p>
<p><code>undefined</code>和<code>null</code>只有与自身比较，或者互相比较时，才会返回<code>true</code>；与其他类型的值比较时，结果都为<code>false</code>  </p>
<figure class="highlight yaml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">undefined</span> <span class="hljs-string">==</span> <span class="hljs-string">undefined</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br><span class="hljs-literal">null</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br><span class="hljs-string">undefined</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span><br><br><span class="hljs-literal">false</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span><br><span class="hljs-literal">false</span> <span class="hljs-string">==</span> <span class="hljs-string">undefined</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span><br><br><span class="hljs-number">0</span> <span class="hljs-string">==</span> <span class="hljs-literal">null</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span><br><span class="hljs-number">0</span> <span class="hljs-string">==</span> <span class="hljs-string">undefined</span> <span class="hljs-string">//</span> <span class="hljs-literal">false</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（4）相等运算符的缺点</strong></p>
<p>相等运算符隐藏的类型转换，会带来一些违反直觉的结果  </p>
<figure class="highlight ini"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">0</span> == <span class="hljs-string">&#x27;&#x27;</span>             // <span class="hljs-literal">true</span><br><span class="hljs-attr">0</span> == <span class="hljs-string">&#x27;0&#x27;</span>            // <span class="hljs-literal">true</span><br><br><span class="hljs-attr">2</span> == <span class="hljs-literal">true</span>           // <span class="hljs-literal">false</span><br><span class="hljs-attr">2</span> == <span class="hljs-literal">false</span>          // <span class="hljs-literal">false</span><br><br><span class="hljs-attr">false</span> == <span class="hljs-string">&#x27;false&#x27;</span>    // <span class="hljs-literal">false</span><br><span class="hljs-attr">false</span> == <span class="hljs-string">&#x27;0&#x27;</span>        // <span class="hljs-literal">true</span><br><br><span class="hljs-attr">false</span> == undefined  // <span class="hljs-literal">false</span><br><span class="hljs-attr">false</span> == null       // <span class="hljs-literal">false</span><br><span class="hljs-attr">null</span> == undefined   // <span class="hljs-literal">true</span><br><br><span class="hljs-attr">&#x27; \t\r\n &#x27;</span> == <span class="hljs-number">0</span>     // <span class="hljs-literal">true</span><br></code></pre></div></td></tr></table></figure>
<p>上面这些表达式都不同于直觉，很容易出错  </p>
<p>因此建议不要使用相等运算符（<code>==</code>），最好只使用严格相等运算符（<code>===</code>）。</p>
<h3 id="不相等运算符"><a href="#不相等运算符" class="headerlink" title="不相等运算符"></a>不相等运算符</h3><p>相等运算符有一个对应的“不相等运算符”（<code>!=</code>），它的算法就是先求相等运算符的结果，然后返回相反值  </p>
<figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk"><span class="hljs-number">1</span> != <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-regexp">//</span> false<br><br><span class="hljs-regexp">//</span> 等同于<br>!(<span class="hljs-number">1</span> == <span class="hljs-string">&#x27;1&#x27;</span>)<br></code></pre></div></td></tr></table></figure>


<h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>布尔运算符用于将表达式转为布尔值，一共包含四个运算符  </p>
<ul>
<li>取反运算符：<code>!</code></li>
<li>且运算符：<code>&amp;&amp;</code></li>
<li>或运算符：<code>||</code></li>
<li>三元运算符：<code>?:</code></li>
</ul>
<h3 id="取反运算符"><a href="#取反运算符" class="headerlink" title="取反运算符 !"></a>取反运算符 !</h3><p>取反运算符是一个感叹号，用于将布尔值变为相反值，即<code>true</code>变成<code>false</code>，<code>false</code>变成<code>true</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">!<span class="hljs-literal">true</span> <span class="hljs-comment">// false</span><br>!<span class="hljs-literal">false</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为<code>true</code>，其他值都为<code>false</code>  </p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li>空字符串（<code>&#39;&#39;</code>）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">!<span class="hljs-literal">undefined</span> <span class="hljs-comment">// true</span><br>!<span class="hljs-literal">null</span> <span class="hljs-comment">// true</span><br>!<span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br>!<span class="hljs-literal">NaN</span> <span class="hljs-comment">// true</span><br>!<span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// true</span><br><br>!<span class="hljs-number">54</span> <span class="hljs-comment">// false</span><br>!<span class="hljs-string">&#x27;hello&#x27;</span> <span class="hljs-comment">// false</span><br>![] <span class="hljs-comment">// false</span><br>!&#123;&#125; <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，不管什么类型的值，经过取反运算后，都变成了布尔值  </p>
<p>如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与<code>Boolean</code>函数的作用相同  </p>
<p>这是一种常用的类型转换的写法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">!!x<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">Boolean</span>(x)<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，不管<code>x</code>是什么类型的值，经过两次取反运算后，变成了与<code>Boolean</code>函数结果相同的布尔值  </p>
<p>所以，两次取反就是将一个值转为布尔值的简便写法  </p>
<h3 id="且运算符-amp-amp"><a href="#且运算符-amp-amp" class="headerlink" title="且运算符 &amp;&amp;"></a>且运算符 &amp;&amp;</h3><p>且运算符（<code>&amp;&amp;</code>）往往用于多个表达式的求值  </p>
<p>运算规则：  </p>
<p>如果第一个运算子的布尔值为<code>true</code>，则返回第二个运算子的值（注意是值，不是布尔值）  </p>
<p>如果第一个运算子的布尔值为<code>false</code>，则直接返回第一个运算子的值，且不再对第二个运算子求值    </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;t&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// &quot;&quot;</span><br><span class="hljs-string">&#x27;t&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;f&#x27;</span> <span class="hljs-comment">// &quot;f&quot;</span><br><span class="hljs-string">&#x27;t&#x27;</span> &amp;&amp; (<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br><span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;f&#x27;</span> <span class="hljs-comment">// &quot;&quot;</span><br><span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// &quot;&quot;</span><br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>(<span class="hljs-number">1</span> - <span class="hljs-number">1</span>) &amp;&amp; ( x += <span class="hljs-number">1</span>) <span class="hljs-comment">// 0</span><br>x <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的最后一个例子，由于且运算符的第一个运算子的布尔值为<code>false</code>，则直接返回它的值<code>0</code>，而不再对第二个运算子求值，所以变量<code>x</code>的值没变    </p>
<p>这种跳过第二个运算子的机制，被称为“短路”    </p>
<p>有些程序员喜欢用它取代<code>if</code>结构，比如下面是一段<code>if</code>结构的代码，就可以用且运算符改写  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (i) &#123;<br>  doSomething();<br>&#125;<br><br><span class="hljs-comment">// 等价于</span><br><br>i &amp;&amp; doSomething();<br></code></pre></div></td></tr></table></figure>
<p>上面代码的两种写法是等价的，但是后一种不容易看出目的，也不容易除错，建议谨慎使用  </p>
<p>且运算符可以多个连用，这时返回第一个布尔值为<code>false</code>的表达式的值。如果所有表达式的布尔值都为<code>true</code>，则返回最后一个表达式的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-string">&#x27;foo&#x27;</span> &amp;&amp; <span class="hljs-string">&#x27;&#x27;</span> &amp;&amp; <span class="hljs-number">4</span> &amp;&amp; <span class="hljs-string">&#x27;foo&#x27;</span> &amp;&amp; <span class="hljs-literal">true</span><br><span class="hljs-comment">// &#x27;&#x27;</span><br><br><span class="hljs-number">1</span> &amp;&amp; <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-number">3</span><br><span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，例一里面，第一个布尔值为<code>false</code>的表达式为第三个表达式，所以得到一个空字符串  </p>
<p>例二里面，所有表达式的布尔值都是<code>true</code>，所以返回最后一个表达式的值<code>3</code>   </p>
<h3 id="或运算符"><a href="#或运算符" class="headerlink" title="或运算符 ||"></a>或运算符 ||</h3><p>或运算符（<code>||</code>）也用于多个表达式的求值  </p>
<p>它的运算规则是：如果第一个运算子的布尔值为<code>true</code>，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为<code>false</code>，则返回第二个运算子的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;t&#x27;</span> || <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// &quot;t&quot;</span><br><span class="hljs-string">&#x27;t&#x27;</span> || <span class="hljs-string">&#x27;f&#x27;</span> <span class="hljs-comment">// &quot;t&quot;</span><br><span class="hljs-string">&#x27;&#x27;</span> || <span class="hljs-string">&#x27;f&#x27;</span> <span class="hljs-comment">// &quot;f&quot;</span><br><span class="hljs-string">&#x27;&#x27;</span> || <span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-comment">// &quot;&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>短路规则对这个运算符也适用  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-literal">true</span> || (x = <span class="hljs-number">2</span>) <span class="hljs-comment">// true</span><br>x <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，或运算符的第一个运算子为<code>true</code>，所以直接返回<code>true</code>，不再运行第二个运算子  </p>
<p>所以，<code>x</code>的值没有改变。这种只通过第一个表达式的值，控制是否运行第二个表达式的机制，就称为“短路”（short-cut）  </p>
<p>或运算符可以多个连用，这时返回第一个布尔值为<code>true</code>的表达式的值  </p>
<p>如果所有表达式都为<code>false</code>，则返回最后一个表达式的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-literal">false</span> || <span class="hljs-number">0</span> || <span class="hljs-string">&#x27;&#x27;</span> || <span class="hljs-number">4</span> || <span class="hljs-string">&#x27;foo&#x27;</span> || <span class="hljs-literal">true</span><br><span class="hljs-comment">// 4</span><br><br><span class="hljs-literal">false</span> || <span class="hljs-number">0</span> || <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-comment">// &#x27;&#x27;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，例一里面，第一个布尔值为<code>true</code>的表达式是第四个表达式，所以得到数值4  </p>
<p>例二里面，所有表达式的布尔值都为<code>false</code>，所以返回最后一个表达式的值  </p>
<p>或运算符常用于为一个变量设置默认值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">saveText</span>(<span class="hljs-params">text</span>) </span>&#123;<br>  text = text || <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 或者写成</span><br>saveText(<span class="hljs-built_in">this</span>.text || <span class="hljs-string">&#x27;&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，如果函数调用时，没有提供参数，则该参数默认设置为空字符串  </p>
<h3 id="三元条件运算符"><a href="#三元条件运算符" class="headerlink" title="三元条件运算符 ?:"></a>三元条件运算符 ?:</h3><p>三元条件运算符由问号<code>?</code>和冒号<code>:</code>组成，分隔三个表达式  </p>
<p>它是 <code>JavaScript</code> 语言唯一一个需要三个运算子的运算符  </p>
<p>如果第一个表达式的布尔值为<code>true</code>，则返回第二个表达式的值，否则返回第三个表达式的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;t&#x27;</span> ? <span class="hljs-string">&#x27;hello&#x27;</span> : <span class="hljs-string">&#x27;world&#x27;</span> <span class="hljs-comment">// &quot;hello&quot;</span><br><span class="hljs-number">0</span> ? <span class="hljs-string">&#x27;hello&#x27;</span> : <span class="hljs-string">&#x27;world&#x27;</span> <span class="hljs-comment">// &quot;world&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的<code>t</code>和<code>0</code>的布尔值分别为<code>true</code>和<code>false</code>，所以分别返回第二个和第三个表达式的值  </p>
<p>通常来说，三元条件表达式与<code>if...else</code>语句具有同样表达效果，前者可以表达的，后者也能表达  </p>
<p>但是两者具有一个重大差别，<code>if...else</code>是语句，没有返回值；三元条件表达式是表达式，具有返回值  </p>
<p>所以，在需要返回值的场合，只能使用三元条件表达式，而不能使用<code>if..else</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> ? <span class="hljs-string">&#x27;T&#x27;</span> : <span class="hljs-string">&#x27;F&#x27;</span>);<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>console.log</code>方法的参数必须是一个表达式，这时就只能使用三元条件表达式  </p>
<p>如果要用<code>if...else</code>语句，就必须改变整个代码写法了  </p>
<h2 id="二进制位运算符"><a href="#二进制位运算符" class="headerlink" title="二进制位运算符"></a>二进制位运算符</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>二进制位运算符用于直接对二进制位进行计算，一共有7个。</p>
<ul>
<li><strong>二进制或运算符</strong>（or）：符号为<code>|</code>，表示若两个二进制位都为<code>0</code>，则结果为<code>0</code>，否则为<code>1</code>。</li>
<li><strong>二进制与运算符</strong>（and）：符号为<code>&amp;</code>，表示若两个二进制位都为1，则结果为1，否则为0。</li>
<li><strong>二进制否运算符</strong>（not）：符号为<code>~</code>，表示对一个二进制位取反。</li>
<li><strong>异或运算符</strong>（xor）：符号为<code>^</code>，表示若两个二进制位不相同，则结果为1，否则为0。</li>
<li><strong>左移运算符</strong>（left shift）：符号为<code>&lt;&lt;</code>，详见下文解释。</li>
<li><strong>右移运算符</strong>（right shift）：符号为<code>&gt;&gt;</code>，详见下文解释。</li>
<li><strong>头部补零的右移运算符</strong>（zero filled right shift）：符号为<code>&gt;&gt;&gt;</code>，详见下文解释。</li>
</ul>
<p>这些位运算符直接处理每一个比特位（bit），所以是非常底层的运算，好处是速度极快，缺点是很不直观，许多场合不能使用它们，否则会使代码难以理解和查错。</p>
<p>有一点需要特别注意，位运算符只对整数起作用，如果一个运算子不是整数，会自动转为整数后再执行。另外，虽然在 JavaScript 内部，数值都是以64位浮点数的形式储存，但是做位运算的时候，是以32位带符号的整数进行运算的，并且返回值也是一个32位带符号的整数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">i = i | <span class="hljs-number">0</span>;<br></code></pre></div></td></tr></table></figure>
<p>上面这行代码的意思，就是将<code>i</code>（不管是整数或小数）转为32位整数。</p>
<p>利用这个特性，可以写出一个函数，将任意数值转为32位整数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">toInt32</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> x | <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面这个函数将任意值与<code>0</code>进行一次或运算，这个位运算会自动将一个值转为32位整数。下面是这个函数的用法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">toInt32(<span class="hljs-number">1.001</span>) <span class="hljs-comment">// 1</span><br>toInt32(<span class="hljs-number">1.999</span>) <span class="hljs-comment">// 1</span><br>toInt32(<span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br>toInt32(-<span class="hljs-number">1</span>) <span class="hljs-comment">// -1</span><br>toInt32(<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>) + <span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span><br>toInt32(<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">32</span>) - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>toInt32</code>可以将小数转为整数。对于一般的整数，返回值不会有任何变化。对于大于或等于2的32次方的整数，大于32位的数位都会被舍去。</p>
<h3 id="二进制或运算符"><a href="#二进制或运算符" class="headerlink" title="二进制或运算符"></a>二进制或运算符</h3><p>二进制或运算符（<code>|</code>）逐位比较两个运算子，两个二进制位之中只要有一个为<code>1</code>，就返回<code>1</code>，否则返回<code>0</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">0</span> | <span class="hljs-number">3</span> <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>0</code>和<code>3</code>的二进制形式分别是<code>00</code>和<code>11</code>，所以进行二进制或运算会得到<code>11</code>（即<code>3</code>）  </p>
<p>位运算只对整数有效，遇到小数时，会将小数部分舍去，只保留整数部分  </p>
<p>所以，将一个小数与<code>0</code>进行二进制或运算，等同于对该数去除小数部分，即取整数位  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">2.9</span> | <span class="hljs-number">0</span> <span class="hljs-comment">// 2</span><br>-<span class="hljs-number">2.9</span> | <span class="hljs-number">0</span> <span class="hljs-comment">// -2</span><br></code></pre></div></td></tr></table></figure>
<p>需要注意的是，这种取整方法不适用超过32位整数最大值<code>2147483647</code>的数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">2147483649.4</span> | <span class="hljs-number">0</span>;<br><span class="hljs-comment">// -2147483647</span><br></code></pre></div></td></tr></table></figure>


<h3 id="二进制与运算符"><a href="#二进制与运算符" class="headerlink" title="二进制与运算符"></a>二进制与运算符</h3><p>二进制与运算符（<code>&amp;</code>）的规则是逐位比较两个运算子，两个二进制位之中只要有一个位为<code>0</code>，就返回<code>0</code>，否则返回<code>1</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">0</span> &amp; <span class="hljs-number">3</span> <span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，0（二进制<code>00</code>）和3（二进制<code>11</code>）进行二进制与运算会得到<code>00</code>（即<code>0</code>）。</p>
<h3 id="二进制否运算符"><a href="#二进制否运算符" class="headerlink" title="二进制否运算符"></a>二进制否运算符</h3><p>二进制否运算符（<code>~</code>）将每个二进制位都变为相反值（<code>0</code>变为<code>1</code>，<code>1</code>变为<code>0</code>）  </p>
<p>它的返回结果有时比较难理解，因为涉及到计算机内部的数值表示机制  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">~ <span class="hljs-number">3</span> <span class="hljs-comment">// -4</span><br></code></pre></div></td></tr></table></figure>
<p>上面表达式对<code>3</code>进行二进制否运算，得到<code>-4</code>。之所以会有这样的结果，是因为位运算时，JavaScript 内部将所有的运算子都转为32位的二进制整数再进行运算。</p>
<p><code>3</code>的32位整数形式是<code>00000000000000000000000000000011</code>，二进制否运算以后得到<code>11111111111111111111111111111100</code>  </p>
<p>由于第一位（符号位）是1，所以这个数是一个负数  </p>
<p><code>JavaScript</code> 内部采用补码形式表示负数，即需要将这个数减去1，再取一次反，然后加上负号，才能得到这个负数对应的10进制值  </p>
<p>这个数减去1等于<code>11111111111111111111111111111011</code>，再取一次反得到<code>00000000000000000000000000000100</code>，再加上负号就是<code>-4</code>  </p>
<p>考虑到这样的过程比较麻烦，可以简单记忆成，一个数与自身的取反值相加，等于-1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">~ -<span class="hljs-number">3</span> <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面表达式可以这样算，<code>-3</code>的取反值等于<code>-1</code>减去<code>-3</code>，结果为<code>2</code>  </p>
<p>对一个整数连续两次二进制否运算，得到它自身  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">~~<span class="hljs-number">3</span> <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>所有的位运算都只对整数有效  </p>
<p>二进制否运算遇到小数时，也会将小数部分舍去，只保留整数部分  </p>
<p>所以，对一个小数连续进行两次二进制否运算，能达到取整效果  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">~~<span class="hljs-number">2.9</span> <span class="hljs-comment">// 2</span><br>~~<span class="hljs-number">47.11</span> <span class="hljs-comment">// 47</span><br>~~<span class="hljs-number">1.9999</span> <span class="hljs-comment">// 1</span><br>~~<span class="hljs-number">3</span> <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>使用二进制否运算取整，是所有取整方法中最快的一种  </p>
<p>对字符串进行二进制否运算，<code>Javascript</code> 引擎会先调用<code>Number</code>函数，将字符串转为数值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 相当于~Number(&#x27;011&#x27;)</span><br>~<span class="hljs-string">&#x27;011&#x27;</span>  <span class="hljs-comment">// -12</span><br><br><span class="hljs-comment">// 相当于~Number(&#x27;42 cats&#x27;)</span><br>~<span class="hljs-string">&#x27;42 cats&#x27;</span> <span class="hljs-comment">// -1</span><br><br><span class="hljs-comment">// 相当于~Number(&#x27;0xcafebabe&#x27;)</span><br>~<span class="hljs-string">&#x27;0xcafebabe&#x27;</span> <span class="hljs-comment">// 889275713</span><br><br><span class="hljs-comment">// 相当于~Number(&#x27;deadbeef&#x27;)</span><br>~<span class="hljs-string">&#x27;deadbeef&#x27;</span> <span class="hljs-comment">// -1</span><br></code></pre></div></td></tr></table></figure>
<p>对于其他类型的值，二进制否运算也是先用<code>Number</code>转为数值，然后再进行处理  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 相当于 ~Number([])</span><br>~[] <span class="hljs-comment">// -1</span><br><br><span class="hljs-comment">// 相当于 ~Number(NaN)</span><br>~<span class="hljs-literal">NaN</span> <span class="hljs-comment">// -1</span><br><br><span class="hljs-comment">// 相当于 ~Number(null)</span><br>~<span class="hljs-literal">null</span> <span class="hljs-comment">// -1</span><br></code></pre></div></td></tr></table></figure>


<h3 id="异或运算符"><a href="#异或运算符" class="headerlink" title="异或运算符"></a>异或运算符</h3><p>异或运算（<code>^</code>）在两个二进制位不同时返回<code>1</code>，相同时返回<code>0</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">0</span> ^ <span class="hljs-number">3</span> <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>上面表达式中，<code>0</code>（二进制<code>00</code>）与<code>3</code>（二进制<code>11</code>）进行异或运算，它们每一个二进制位都不同，所以得到<code>11</code>（即<code>3</code>）  </p>
<p>“异或运算”有一个特殊运用，连续对两个数<code>a</code>和<code>b</code>进行三次异或运算，<code>a^=b; b^=a; a^=b;</code>，可以<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/XOR_swap_algorithm">互换</a>它们的值  </p>
<p>这意味着，使用“异或运算”可以在不引入临时变量的前提下，互换两个变量的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">var</span> b = <span class="hljs-number">99</span>;<br><br>a ^= b, b ^= a, a ^= b;<br><br>a <span class="hljs-comment">// 99</span><br>b <span class="hljs-comment">// 10</span><br></code></pre></div></td></tr></table></figure>
<p>这是互换两个变量的值的最快方法  </p>
<p>异或运算也可以用来取整  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">12.9</span> ^ <span class="hljs-number">0</span> <span class="hljs-comment">// 12</span><br></code></pre></div></td></tr></table></figure>


<h3 id="左移运算符"><a href="#左移运算符" class="headerlink" title="左移运算符"></a>左移运算符</h3><p>左移运算符（<code>&lt;&lt;</code>）表示将一个数的二进制值向左移动指定的位数，尾部补<code>0</code>，即乘以<code>2</code>的指定次方  </p>
<p>向左移动的时候，最高位的符号位是一起移动的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 4 的二进制形式为100，</span><br><span class="hljs-comment">// 左移一位为1000（即十进制的8）</span><br><span class="hljs-comment">// 相当于乘以2的1次方</span><br><span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">1</span><br><span class="hljs-comment">// 8</span><br><br>-<span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">1</span><br><span class="hljs-comment">// -8</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>-4</code>左移一位得到<code>-8</code>，是因为<code>-4</code>的二进制形式是<code>11111111111111111111111111111100</code>，左移一位后得到<code>11111111111111111111111111111000</code>，该数转为十进制（减去1后取反，再加上负号）即为<code>-8</code>  </p>
<p>如果左移0位，就相当于将该数值转为32位整数，等同于取整，对于正数和负数都有效  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">13.5</span> &lt;&lt; <span class="hljs-number">0</span><br><span class="hljs-comment">// 13</span><br><br>-<span class="hljs-number">13.5</span> &lt;&lt; <span class="hljs-number">0</span><br><span class="hljs-comment">// -13</span><br></code></pre></div></td></tr></table></figure>
<p>左移运算符用于二进制数值非常方便  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> color = &#123;<span class="hljs-attr">r</span>: <span class="hljs-number">186</span>, <span class="hljs-attr">g</span>: <span class="hljs-number">218</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">85</span>&#125;;<br><br><span class="hljs-comment">// RGB to HEX</span><br><span class="hljs-comment">// (1 &lt;&lt; 24)的作用为保证结果是6位数</span><br><span class="hljs-keyword">var</span> rgb2hex = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">r, g, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;#&#x27;</span> + ((<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">24</span>) + (r &lt;&lt; <span class="hljs-number">16</span>) + (g &lt;&lt; <span class="hljs-number">8</span>) + b)<br>    .toString(<span class="hljs-number">16</span>) <span class="hljs-comment">// 先转成十六进制，然后返回字符串</span><br>    .substr(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 去除字符串的最高位，返回后面六个字符串</span><br>&#125;<br><br>rgb2hex(color.r, color.g, color.b)<br><span class="hljs-comment">// &quot;#bada55&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码使用左移运算符，将颜色的 RGB 值转为 HEX 值  </p>
<h3 id="右移运算符"><a href="#右移运算符" class="headerlink" title="右移运算符"></a>右移运算符</h3><p>右移运算符（<code>&gt;&gt;</code>）表示将一个数的二进制值向右移动指定的位数  </p>
<p>如果是正数，头部全部补<code>0</code>；如果是负数，头部全部补<code>1</code>  </p>
<p>右移运算符基本上相当于除以<code>2</code>的指定次方（最高位即符号位参与移动）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// 因为4的二进制形式为 00000000000000000000000000000100，</span><br><span class="hljs-comment">// 右移一位得到 00000000000000000000000000000010，</span><br><span class="hljs-comment">// 即为十进制的2</span><br><span class="hljs-comment">*/</span><br><br>-<span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">1</span><br><span class="hljs-comment">// -2</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// 因为-4的二进制形式为 11111111111111111111111111111100，</span><br><span class="hljs-comment">// 右移一位，头部补1，得到 11111111111111111111111111111110,</span><br><span class="hljs-comment">// 即为十进制的-2</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>
<p>右移运算可以模拟 2 的整除运算  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">5</span> &gt;&gt; <span class="hljs-number">1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 相当于 5 / 2 = 2</span><br><br><span class="hljs-number">21</span> &gt;&gt; <span class="hljs-number">2</span><br><span class="hljs-comment">// 5</span><br><span class="hljs-comment">// 相当于 21 / 4 = 5</span><br><br><span class="hljs-number">21</span> &gt;&gt; <span class="hljs-number">3</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 相当于 21 / 8 = 2</span><br><br><span class="hljs-number">21</span> &gt;&gt; <span class="hljs-number">4</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 相当于 21 / 16 = 1</span><br></code></pre></div></td></tr></table></figure>


<h3 id="头部补零的右移运算符"><a href="#头部补零的右移运算符" class="headerlink" title="头部补零的右移运算符"></a>头部补零的右移运算符</h3><p>头部补零的右移运算符（<code>&gt;&gt;&gt;</code>）与右移运算符（<code>&gt;&gt;</code>）只有一个差别，就是一个数的二进制形式向右移动时，头部一律补零，而不考虑符号位  </p>
<p>所以，该运算总是得到正值  </p>
<p>对于正数，该运算的结果与右移运算符（<code>&gt;&gt;</code>）完全一致，区别主要在于负数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">4</span> &gt;&gt;&gt; <span class="hljs-number">1</span><br><span class="hljs-comment">// 2</span><br><br>-<span class="hljs-number">4</span> &gt;&gt;&gt; <span class="hljs-number">1</span><br><span class="hljs-comment">// 2147483646</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// 因为-4的二进制形式为11111111111111111111111111111100，</span><br><span class="hljs-comment">// 带符号位的右移一位，得到01111111111111111111111111111110，</span><br><span class="hljs-comment">// 即为十进制的2147483646。</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>
<p>这个运算实际上将一个值转为32位无符号整数  </p>
<p>查看一个负整数在计算机内部的储存形式，最快的方法就是使用这个运算符  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">-<span class="hljs-number">1</span> &gt;&gt;&gt; <span class="hljs-number">0</span> <span class="hljs-comment">// 4294967295</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，<code>-1</code>作为32位整数时，内部的储存形式使用无符号整数格式解读，值为 4294967295（即<code>(2^32)-1</code>，等于<code>11111111111111111111111111111111</code>）。</p>
<h3 id="开关作用"><a href="#开关作用" class="headerlink" title="开关作用"></a>开关作用</h3><p>位运算符可以用作设置对象属性的开关。</p>
<p>假定某个对象有四个开关，每个开关都是一个变量。那么，可以设置一个四位的二进制数，它的每个位对应一个开关  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> FLAG_A = <span class="hljs-number">1</span>; <span class="hljs-comment">// 0001</span><br><span class="hljs-keyword">var</span> FLAG_B = <span class="hljs-number">2</span>; <span class="hljs-comment">// 0010</span><br><span class="hljs-keyword">var</span> FLAG_C = <span class="hljs-number">4</span>; <span class="hljs-comment">// 0100</span><br><span class="hljs-keyword">var</span> FLAG_D = <span class="hljs-number">8</span>; <span class="hljs-comment">// 1000</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码设置 A、B、C、D 四个开关，每个开关分别占有一个二进制位  </p>
<p>然后，就可以用二进制与运算，检查当前设置是否打开了指定开关  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> flags = <span class="hljs-number">5</span>; <span class="hljs-comment">// 二进制的0101</span><br><br><span class="hljs-keyword">if</span> (flags &amp; FLAG_C) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-comment">// 0101 &amp; 0100 =&gt; 0100 =&gt; true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码检验是否打开了开关<code>C</code>。如果打开，会返回<code>true</code>，否则返回<code>false</code>  </p>
<p>现在假设需要打开<code>A</code>、<code>B</code>、<code>D</code>三个开关，我们可以构造一个掩码变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> mask = FLAG_A | FLAG_B | FLAG_D;<br><span class="hljs-comment">// 0001 | 0010 | 1000 =&gt; 1011</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码对<code>A</code>、<code>B</code>、<code>D</code>三个变量进行二进制或运算，得到掩码值为二进制的<code>1011</code>  </p>
<p>有了掩码，二进制或运算可以确保打开指定的开关  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">flags = flags | mask;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，计算后得到的<code>flags</code>变量，代表三个开关的二进制位都打开了  </p>
<p>二进制与运算可以将当前设置中凡是与开关设置不一样的项，全部关闭  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">flags = flags &amp; mask;<br></code></pre></div></td></tr></table></figure>
<p>异或运算可以切换（toggle）当前设置，即第一次执行可以得到当前设置的相反值，再执行一次又得到原来的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">flags = flags ^ mask;<br></code></pre></div></td></tr></table></figure>
<p>二进制否运算可以翻转当前设置，即原设置为<code>0</code>，运算后变为<code>1</code>；原设置为<code>1</code>，运算后变为<code>0</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">flags = ~flags;<br></code></pre></div></td></tr></table></figure>




<h2 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h2><p><code>void</code>运算符的作用是执行一个表达式，然后不返回任何值，或者说返回<code>undefined</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">void</span> <span class="hljs-number">0</span> <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">void</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure>
<p>上面是<code>void</code>运算符的两种写法，都正确。建议采用后一种形式，即总是使用圆括号  </p>
<p>因为<code>void</code>运算符的优先性很高，如果不使用括号，容易造成错误的结果  </p>
<p>比如，<code>void 4 + 7</code>实际上等同于<code>(void 4) + 7</code>。</p>
<p>下面是<code>void</code>运算符的一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">void</span> (x = <span class="hljs-number">5</span>) <span class="hljs-comment">//undefined</span><br>x <span class="hljs-comment">// 5</span><br></code></pre></div></td></tr></table></figure>
<p>这个运算符的主要用途是浏览器的书签工具（Bookmarklet），以及在超级链接中插入代码防止网页跳转  </p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello World&#x27;</span>);</span><br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://example.com&quot;</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;f(); return false;&quot;</span>&gt;</span>点击<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，点击链接后，会先执行<code>onclick</code>的代码，由于<code>onclick</code>返回<code>false</code>，所以浏览器不会跳转到 example.com  </p>
<p><code>void</code>运算符可以取代上面的写法  </p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript: void(f())&quot;</span>&gt;</span>文字<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure>
<p>下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转  </p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;javascript: void(document.form.submit())&quot;</span>&gt;</span><br>  提交<br><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure>


<h2 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h2><p>逗号运算符用于对两个表达式求值，并返回后一个表达式的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-comment">// &quot;b&quot;</span><br><br><span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> y = (x++, <span class="hljs-number">10</span>);<br>x <span class="hljs-comment">// 1</span><br>y <span class="hljs-comment">// 10</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，逗号运算符返回后一个表达式的值。</p>
<p>逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> value = (<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hi!&#x27;</span>), <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// Hi!</span><br><br>value <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，先执行逗号之前的操作，然后返回逗号后面的值  </p>
<h2 id="运算顺序"><a href="#运算顺序" class="headerlink" title="运算顺序"></a>运算顺序</h2><h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p><code>Javascript</code> 各种运算符的优先级别（Operator Precedence）是不一样的。优先级高的运算符先执行，优先级低的运算符后执行  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">4</span> + <span class="hljs-number">5</span> * <span class="hljs-number">6</span> <span class="hljs-comment">// 34</span><br></code></pre></div></td></tr></table></figure>
<p>上面的代码中，乘法运算符<code>*</code>的优先性高于加法运算符<code>+</code>，所以先执行乘法，再执行加法，相当于下面这样  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">4</span> + (<span class="hljs-number">5</span> * <span class="hljs-number">6</span>) <span class="hljs-comment">// 34</span><br></code></pre></div></td></tr></table></figure>
<p>如果多个运算符混写在一起，常常会导致令人困惑的代码  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> arr = [];<br><br><span class="hljs-keyword">var</span> y = arr.length &lt;= <span class="hljs-number">0</span> || arr[<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span> ? x : arr[<span class="hljs-number">0</span>];<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，变量<code>y</code>的值就很难看出来，因为这个表达式涉及5个运算符，到底谁的优先级最高，实在不容易记住  </p>
<p>根据语言规格，这五个运算符的优先级从高到低依次为：  </p>
<p>小于等于（<code>&lt;=</code>)、严格相等（<code>===</code>）、或（<code>||</code>）、三元（<code>?:</code>）、等号（<code>=</code>）  </p>
<p>因此上面的表达式，实际的运算顺序如下  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> y = ((arr.length &lt;= <span class="hljs-number">0</span>) || (arr[<span class="hljs-number">0</span>] === <span class="hljs-literal">undefined</span>)) ? x : arr[<span class="hljs-number">0</span>];<br></code></pre></div></td></tr></table></figure>
<p>记住所有运算符的优先级，是非常难的，也是没有必要的  </p>
<h3 id="圆括号的作用"><a href="#圆括号的作用" class="headerlink" title="圆括号的作用"></a>圆括号的作用</h3><p>圆括号（<code>()</code>）可以用来提高运算的优先级，因为它的优先级是最高的，即圆括号中的表达式会第一个运算  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-number">4</span> + <span class="hljs-number">5</span>) * <span class="hljs-number">6</span> <span class="hljs-comment">// 54</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，由于使用了圆括号，加法会先于乘法执行  </p>
<p>运算符的优先级别十分繁杂，且都是硬性规定，因此建议总是使用圆括号，保证运算顺序清晰可读，这对代码的维护和除错至关重要  </p>
<p>顺便说一下，圆括号不是运算符，而是一种语法结构。它一共有两种用法：</p>
<ul>
<li>把表达式放在圆括号之中，提升运算的优先级  </li>
<li>跟在函数的后面，作用是调用函数  </li>
</ul>
<p>注意，因为圆括号不是运算符，所以不具有求值作用，只改变运算的优先级  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;<br>(x) = <span class="hljs-number">2</span>;<br></code></pre></div></td></tr></table></figure>
<p>上面代码的第二行，如果圆括号具有求值作用，那么就会变成<code>1 = 2</code>，这是会报错了  </p>
<p>但是，上面的代码可以运行，这验证了圆括号只改变优先级，不会求值  </p>
<p>这也意味着，如果整个表达式都放在圆括号之中，那么不会有任何效果  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(expression)<br><span class="hljs-comment">// 等同于</span><br>expression<br></code></pre></div></td></tr></table></figure>
<p>函数放在圆括号中，会返回函数本身。如果圆括号紧跟在函数的后面，就表示调用函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br>(f) <span class="hljs-comment">// function f()&#123;return 1;&#125;</span><br>f() <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，函数放在圆括号之中会返回函数本身，圆括号跟在函数后面则是调用函数  </p>
<p>圆括号之中，只能放置表达式，如果将语句放在圆括号之中，就会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">(<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>)<br><span class="hljs-comment">// SyntaxError: Unexpected token var</span><br></code></pre></div></td></tr></table></figure>


<h3 id="左结合与右结合"><a href="#左结合与右结合" class="headerlink" title="左结合与右结合"></a>左结合与右结合</h3><p>对于优先级别相同的运算符，同时出现的时候，就会有计算顺序的问题  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">a OP b OP c<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>OP</code>表示运算符。它可以有两种解释方式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 方式一</span><br>(a OP b) OP c<br><br><span class="hljs-comment">// 方式二</span><br>a OP (b OP c)<br></code></pre></div></td></tr></table></figure>
<p>上面的两种方式，得到的计算结果往往是不一样的  </p>
<p>方式一是将左侧两个运算数结合在一起，采用这种解释方式的运算符，称为“左结合”（left-to-right associativity）运算符  </p>
<p>方式二是将右侧两个运算数结合在一起，这样的运算符称为“右结合”运算符（right-to-left associativity）  </p>
<p>JavaScript 语言的大多数运算符是“左结合”，请看下面加法运算符的例子   </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">x + y + z<br><br><span class="hljs-comment">// 引擎解释如下</span><br>(x + y) + z<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>x</code>与<code>y</code>结合在一起，它们的预算结果再与<code>z</code>进行运算  </p>
<p>少数运算符是“右结合”，其中最主要的是赋值运算符（<code>=</code>）和三元条件运算符（<code>?:</code>）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">w = x = y = z;<br>q = a ? b : c ? d : e ? f : g;<br></code></pre></div></td></tr></table></figure>
<p>上面代码的解释方式如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">w = (x = (y = z));<br>q = a ? b : (c ? d : (e ? f : g));<br></code></pre></div></td></tr></table></figure>
<p>上面的两行代码，都是右侧的运算数结合在一起。</p>
<p>另外，指数运算符（<code>**</code>）也是右结合。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">2</span> ** <span class="hljs-number">3</span> ** <span class="hljs-number">2</span><br><span class="hljs-comment">// 相当于 2 ** (3 ** 2)</span><br><span class="hljs-comment">// 512</span><br></code></pre></div></td></tr></table></figure>






<h1 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h1><p><code>Javascript</code> 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> x = y ? <span class="hljs-number">1</span> : <span class="hljs-string">&#x27;a&#x27;</span>;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，变量<code>x</code>到底是数值还是字符串，取决于另一个变量<code>y</code>的值  </p>
<p><code>y</code>为<code>true</code>时，<code>x</code>是一个数值；<code>y</code>为<code>false</code>时，<code>x</code>是一个字符串  </p>
<p>这意味着，<code>x</code>的类型没法在编译阶段就知道，必须等到运行时才能知道  </p>
<p>虽然变量的数据类型是不确定的，但是各种运算符对数据类型是有要求的  </p>
<p>如果运算符发现，运算子的类型与预期不符，就会自动转换类型  </p>
<p>比如，减法运算符预期左右两侧的运算子应该是数值，如果不是，就会自动将它们转为数值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;4&#x27;</span> - <span class="hljs-string">&#x27;3&#x27;</span> <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，虽然是两个字符串相减，但是依然会得到结果数值<code>1</code>，原因就在于<code> Javascript</code> 将运算子自动转为了数值  </p>
<p>本章讲解数据类型自动转换的规则。在此之前，先讲解如何手动强制转换数据类型  </p>
<h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><p>强制转换主要指使用<code>Number()</code>、<code>String()</code>和<code>Boolean()</code>三个函数，手动将各种类型的值，分别转换成数字、字符串或者布尔值  </p>
<h3 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h3><p>使用<code>Number</code>函数，可以将任意类型的值转化成数值  </p>
<p>下面分成两种情况讨论，一种是参数是原始类型的值，另一种是参数是对象  </p>
<p><strong>（1）原始类型值</strong></p>
<p>原始类型值的转换规则如下  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 数值：转换后还是原来的值</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-number">324</span>) <span class="hljs-comment">// 324</span><br><br><span class="hljs-comment">// 字符串：如果可以被解析为数值，则转换为相应的数值</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;324&#x27;</span>) <span class="hljs-comment">// 324</span><br><br><span class="hljs-comment">// 字符串：如果不可以被解析为数值，返回 NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;324abc&#x27;</span>) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// 空字符串转为0</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// 布尔值：true 转成 1，false 转成 0</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// undefined：转成 NaN</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// null：转成0</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure>
<p><code>Number</code>函数将字符串转为数值，要比<code>parseInt</code>函数严格很多  </p>
<p>基本上，只要有一个字符无法转成数值，整个字符串就会被转为<code>NaN</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;42 cats&#x27;</span>) <span class="hljs-comment">// 42</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;42 cats&#x27;</span>) <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>parseInt</code>逐个解析字符，而<code>Number</code>函数整体转换字符串的类型  </p>
<p>另外，<code>parseInt</code>和<code>Number</code>函数都会自动过滤一个字符串前导和后缀的空格  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;\t\v\r12.34\n&#x27;</span>) <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">Number</span>(<span class="hljs-string">&#x27;\t\v\r12.34\n&#x27;</span>) <span class="hljs-comment">// 12.34</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（2）对象</strong></p>
<p>简单的规则是，<code>Number</code>方法的参数是对象时，将返回<code>NaN</code>，除非是包含单个数值的数组  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">Number</span>([<span class="hljs-number">5</span>]) <span class="hljs-comment">// 5</span><br></code></pre></div></td></tr></table></figure>
<p>之所以会这样，是因为<code>Number</code>背后的转换规则比较复杂  </p>
<ol>
<li><p>调用对象自身的<code>valueOf</code>方法。如果返回原始类型的值，则直接对该值使用<code>Number</code>函数，不再进行后续步骤  </p>
</li>
<li><p>如果<code>valueOf</code>方法返回的还是对象，则改为调用对象自身的<code>toString</code>方法。如果<code>toString</code>方法返回原始类型的值，则对该值使用<code>Number</code>函数，不再进行后续步骤  </p>
</li>
<li><p>如果<code>toString</code>方法返回的是对象，就报错  </p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-built_in">Number</span>(obj) <span class="hljs-comment">// NaN</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj.valueOf() === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>  <span class="hljs-built_in">Number</span>(obj.toString());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-built_in">Number</span>(obj.valueOf());<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>Number</code>函数将<code>obj</code>对象转为数值。背后发生了一连串的操作，首先调用<code>obj.valueOf</code>方法, 结果返回对象本身；于是，继续调用<code>obj.toString</code>方法，这时返回字符串<code>[object Object]</code>，对这个字符串使用<code>Number</code>函数，得到<code>NaN</code>  </p>
<p>默认情况下，对象的<code>valueOf</code>方法返回对象本身，所以一般总是会调用<code>toString</code>方法，而<code>toString</code>方法返回对象的类型字符串（比如<code>[object Object]</code>）。所以，会有下面的结果  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>(&#123;&#125;) <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure>
<p>如果<code>toString</code>方法返回的不是原始类型的值，结果就会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;,<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">Number</span>(obj)<br><span class="hljs-comment">// TypeError: Cannot convert object to primitive value</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的<code>valueOf</code>和<code>toString</code>方法，返回的都是对象，所以转成数值时会报错  </p>
<p>从上例还可以看到，<code>valueOf</code>和<code>toString</code>方法，都是可以自定义的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Number</span>(&#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// 2</span><br><br><span class="hljs-built_in">Number</span>(&#123;<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// 3</span><br><br><span class="hljs-built_in">Number</span>(&#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;,<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码对三个对象使用<code>Number</code>函数。第一个对象返回<code>valueOf</code>方法的值，第二个对象返回<code>toString</code>方法的值，第三个对象表示<code>valueOf</code>方法先于<code>toString</code>方法执行  </p>
<h3 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h3><p><code>String</code>函数可以将任意类型的值转化成字符串，转换规则如下  </p>
<p><strong>（1）原始类型值</strong></p>
<ul>
<li><strong>数值</strong>：转为相应的字符串  </li>
<li><strong>字符串</strong>：转换后还是原来的值  </li>
<li><strong>布尔值</strong>：<code>true</code>转为字符串<code>&quot;true&quot;</code>，<code>false</code>转为字符串<code>&quot;false&quot;</code>  </li>
<li><strong>undefined</strong>：转为字符串<code>&quot;undefined&quot;</code>  </li>
<li><strong>null</strong>：转为字符串<code>&quot;null&quot;</code>   </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>(<span class="hljs-number">123</span>) <span class="hljs-comment">// &quot;123&quot;</span><br><span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>) <span class="hljs-comment">// &quot;abc&quot;</span><br><span class="hljs-built_in">String</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// &quot;true&quot;</span><br><span class="hljs-built_in">String</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// &quot;undefined&quot;</span><br><span class="hljs-built_in">String</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// &quot;null&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（2）对象</strong></p>
<p><code>String</code>方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-built_in">String</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]) <span class="hljs-comment">// &quot;1,2,3&quot;</span><br></code></pre></div></td></tr></table></figure>
<p><code>String</code>方法背后的转换规则，与<code>Number</code>方法基本相同，只是互换了<code>valueOf</code>方法和<code>toString</code>方法的执行顺序  </p>
<ol>
<li><p>先调用对象自身的<code>toString</code>方法。如果返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤。</p>
</li>
<li><p>如果<code>toString</code>方法返回的是对象，再调用原对象的<code>valueOf</code>方法。如果<code>valueOf</code>方法返回原始类型的值，则对该值使用<code>String</code>函数，不再进行以下步骤  </p>
</li>
<li><p>如果<code>valueOf</code>方法返回的是对象，就报错  </p>
</li>
</ol>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;)<br><span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">String</span>(&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>&#125;.toString())<br><span class="hljs-comment">// &quot;[object Object]&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码先调用对象的<code>toString</code>方法，发现返回的是字符串<code>[object Object]</code>，就不再调用<code>valueOf</code>方法了  </p>
<p>如果<code>toString</code>法和<code>valueOf</code>方法，返回的都是对象，就会报错  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;,<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;;<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">String</span>(obj)<br><span class="hljs-comment">// TypeError: Cannot convert object to primitive value</span><br></code></pre></div></td></tr></table></figure>
<p>下面是通过自定义<code>toString</code>方法，改变返回值的例子  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">String</span>(&#123;<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// &quot;3&quot;</span><br><br><span class="hljs-built_in">String</span>(&#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// &quot;[object Object]&quot;</span><br><br><span class="hljs-built_in">String</span>(&#123;<br>  valueOf: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;,<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// &quot;3&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码对三个对象使用<code>String</code>函数。第一个对象返回<code>toString</code>方法的值（数值3），第二个对象返回的还是<code>toString</code>方法的值（<code>[object Object]</code>），第三个对象表示<code>toString</code>方法先于<code>valueOf</code>方法执行  </p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h3><p><code>Boolean()</code>函数可以将任意类型的值转为布尔值  </p>
<p>它的转换规则相对简单：除了以下五个值的转换结果为<code>false</code>，其他的值全部为<code>true</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>0</code>（包含<code>-0</code>和<code>+0</code>）</li>
<li><code>NaN</code></li>
<li><code>&#39;&#39;</code>（空字符串）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">undefined</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">null</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">NaN</span>) <span class="hljs-comment">// false</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>当然，<code>true</code>和<code>false</code>这两个布尔值不会发生变化  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">true</span>) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>) <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>注意，所有对象（包括空对象）的转换结果都是<code>true</code>，甚至连<code>false</code>对应的布尔对象<code>new Boolean(false)</code>也是<code>true</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">Boolean</span>(&#123;&#125;) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>([]) <span class="hljs-comment">// true</span><br><span class="hljs-built_in">Boolean</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-literal">false</span>)) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>所有对象的布尔值都是<code>true</code>，这是因为 <code>Javascript</code> 语言设计的时候，出于性能的考虑，如果对象需要计算才能得到布尔值，对于<code>obj1 &amp;&amp; obj2</code>这样的场景，可能会需要较多的计算  </p>
<p>为了保证性能，就统一规定，对象的布尔值为<code>true</code>  </p>
<h2 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h2><p>下面介绍自动转换，它是以强制转换为基础的  </p>
<p>遇到以下三种情况时，JavaScript 会自动转换数据类型，即转换是自动完成的，用户不可见  </p>
<ol>
<li>不同类型的数据互相运算  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">123</span> + <span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-comment">// &quot;123abc&quot;</span><br></code></pre></div></td></tr></table></figure>
<ol start="2">
<li>对非布尔值类型的数据求布尔值  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;abc&#x27;</span>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>&#125;  <span class="hljs-comment">// &quot;hello&quot;</span><br></code></pre></div></td></tr></table></figure>
<ol start="3">
<li>对非数值类型的值使用一元运算符（即<code>+</code>和<code>-</code>）  </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">+ &#123;<span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125; <span class="hljs-comment">// NaN</span><br>- [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure>
<p>自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数  </p>
<p>比如，某个位置预期为字符串，就调用<code>String()</code>函数进行转换。如果该位置既可以是字符串，也可能是数值，那么默认转为数值  </p>
<p>由于自动转换具有不确定性，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用<code>Boolean()</code>、<code>Number()</code>和<code>String()</code>函数进行显式转换。</p>
<h3 id="自动转换为布尔值"><a href="#自动转换为布尔值" class="headerlink" title="自动转换为布尔值"></a>自动转换为布尔值</h3><p><code>Javascript</code> 遇到预期为布尔值的地方（比如<code>if</code>语句的条件部分），就会将非布尔值的参数自动转换为布尔值。系统内部会自动调用<code>Boolean()</code>函数  </p>
<p>因此除了以下五个值，其他都是自动转为<code>true</code>  </p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>+0</code>或<code>-0</code></li>
<li><code>NaN</code></li>
<li><code>&#39;&#39;</code>（空字符串）</li>
</ul>
<p>下面这个例子中，条件部分的每个值都相当于<code>false</code>，使用否定运算符后，就变成了<code>true</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> ( !<span class="hljs-literal">undefined</span><br>  &amp;&amp; !<span class="hljs-literal">null</span><br>  &amp;&amp; !<span class="hljs-number">0</span><br>  &amp;&amp; !<span class="hljs-literal">NaN</span><br>  &amp;&amp; !<span class="hljs-string">&#x27;&#x27;</span><br>) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;true&#x27;</span>);<br>&#125; <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>下面两种写法，有时也用于将一个表达式转为布尔值。它们内部调用的也是<code>Boolean()</code>函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 写法一</span><br>expression ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// 写法二</span><br>!! expression<br></code></pre></div></td></tr></table></figure>


<h3 id="自动转换为字符串"><a href="#自动转换为字符串" class="headerlink" title="自动转换为字符串"></a>自动转换为字符串</h3><p><code>Javascript</code> 遇到预期为字符串的地方，就会将非字符串的值自动转为字符串  </p>
<p>具体规则是，先将复合类型的值转为原始类型的值，再将原始类型的值转为字符串  </p>
<p>字符串的自动转换，主要发生在字符串的加法运算时。当一个值为字符串，另一个值为非字符串，则后者转为字符串  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// &#x27;51&#x27;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">true</span> <span class="hljs-comment">// &quot;5true&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">false</span> <span class="hljs-comment">// &quot;5false&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + &#123;&#125; <span class="hljs-comment">// &quot;5[object Object]&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + [] <span class="hljs-comment">// &quot;5&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;&#125; <span class="hljs-comment">// &quot;5function ()&#123;&#125;&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">undefined</span> <span class="hljs-comment">// &quot;5undefined&quot;</span><br><span class="hljs-string">&#x27;5&#x27;</span> + <span class="hljs-literal">null</span> <span class="hljs-comment">// &quot;5null&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>这种自动转换很容易出错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123;<br>  width: <span class="hljs-string">&#x27;100&#x27;</span><br>&#125;;<br><br>obj.width + <span class="hljs-number">20</span> <span class="hljs-comment">// &quot;10020&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，开发者可能期望返回<code>120</code>，但是由于自动转换，实际上返回了一个字符<code>10020</code>  </p>
<h3 id="自动转换为数值"><a href="#自动转换为数值" class="headerlink" title="自动转换为数值"></a>自动转换为数值</h3><p><code>Javascript</code> 遇到预期为数值的地方，就会将参数值自动转换为数值  </p>
<p>系统内部会自动调用<code>Number()</code>函数。  </p>
<p>除了加法运算符（<code>+</code>）有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;5&#x27;</span> - <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 3</span><br><span class="hljs-string">&#x27;5&#x27;</span> * <span class="hljs-string">&#x27;2&#x27;</span> <span class="hljs-comment">// 10</span><br><span class="hljs-literal">true</span> - <span class="hljs-number">1</span>  <span class="hljs-comment">// 0</span><br><span class="hljs-literal">false</span> - <span class="hljs-number">1</span> <span class="hljs-comment">// -1</span><br><span class="hljs-string">&#x27;1&#x27;</span> - <span class="hljs-number">1</span>   <span class="hljs-comment">// 0</span><br><span class="hljs-string">&#x27;5&#x27;</span> * []    <span class="hljs-comment">// 0</span><br><span class="hljs-literal">false</span> / <span class="hljs-string">&#x27;5&#x27;</span> <span class="hljs-comment">// 0</span><br><span class="hljs-string">&#x27;abc&#x27;</span> - <span class="hljs-number">1</span>   <span class="hljs-comment">// NaN</span><br><span class="hljs-literal">null</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// 1</span><br><span class="hljs-literal">undefined</span> + <span class="hljs-number">1</span> <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，运算符两侧的运算子，都被转成了数值  </p>
<blockquote>
<p>注意：<code>null</code>转为数值时为<code>0</code>，而<code>undefined</code>转为数值时为<code>NaN</code>  </p>
</blockquote>
<p>一元运算符也会把运算子转成数值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">+<span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-comment">// NaN</span><br>-<span class="hljs-string">&#x27;abc&#x27;</span> <span class="hljs-comment">// NaN</span><br>+<span class="hljs-literal">true</span> <span class="hljs-comment">// 1</span><br>-<span class="hljs-literal">false</span> <span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure>



<h1 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h1><h2 id="Error-实例对象"><a href="#Error-实例对象" class="headerlink" title="Error 实例对象"></a>Error 实例对象</h2><p>JavaScript 解析或运行时，一旦发生错误，引擎就会抛出一个错误对象  </p>
<p><code>Javascript</code> 原生提供<code>Error</code>构造函数，所有抛出的错误都是这个构造函数的实例  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> err = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>);<br>err.message <span class="hljs-comment">// &quot;出错了&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，我们调用<code>Error</code>构造函数，生成一个实例对象<code>err</code>    </p>
<p><code>Error</code>构造函数接受一个参数，表示错误提示，可以从实例的<code>message</code>属性读到这个参数  </p>
<p>抛出<code>Error</code>实例对象以后，整个程序就中断在发生错误的地方，不再往下执行  </p>
<p><code>Javascript</code> 语言标准只提到，<code>Error</code>实例对象必须有<code>message</code>属性，表示出错时的提示信息，没有提到其他属性  </p>
<p>大多数 <code>Javascript</code> 引擎，对<code>Error</code>实例还提供<code>name</code>和<code>stack</code>属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有  </p>
<ul>
<li><strong>message</strong>：错误提示信息</li>
<li><strong>name</strong>：错误名称（非标准属性）</li>
<li><strong>stack</strong>：错误的堆栈（非标准属性）</li>
</ul>
<p>使用<code>name</code>和<code>message</code>这两个属性，可以对发生什么错误有一个大概的了解  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (error.name) &#123;<br>  <span class="hljs-built_in">console</span>.log(error.name + <span class="hljs-string">&#x27;: &#x27;</span> + error.message);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p><code>stack</code>属性用来查看错误发生时的堆栈。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throwit</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">catchit</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    throwit();<br>  &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>    <span class="hljs-built_in">console</span>.log(e.stack); <span class="hljs-comment">// print stack trace</span><br>  &#125;<br>&#125;<br><br>catchit()<br><span class="hljs-comment">// Error</span><br><span class="hljs-comment">//    at throwit (~/examples/throwcatch.js:9:11)</span><br><span class="hljs-comment">//    at catchit (~/examples/throwcatch.js:3:9)</span><br><span class="hljs-comment">//    at repl:1:5</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，错误堆栈的最内层是<code>throwit</code>函数，然后是<code>catchit</code>函数，最后是函数的运行环境  </p>
<h2 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h2><p><code>Error</code>实例对象是最一般的错误类型，在它的基础上，<code>Javascript</code> 还定义了其他6种错误对象  </p>
<p>也就是说，存在<code>Error</code>的6个派生对象  </p>
<h3 id="SyntaxError-对象"><a href="#SyntaxError-对象" class="headerlink" title="SyntaxError 对象"></a>SyntaxError 对象</h3><p><code>SyntaxError</code>对象是解析代码时发生的语法错误  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 变量名错误</span><br><span class="hljs-keyword">var</span> 1a;<br><span class="hljs-comment">// Uncaught SyntaxError: Invalid or unexpected token</span><br><br><span class="hljs-comment">// 缺少括号</span><br><span class="hljs-built_in">console</span>.log <span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-comment">// Uncaught SyntaxError: Unexpected string</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的错误，都是在语法解析阶段就可以发现，所以会抛出<code>SyntaxError</code>。第一个错误提示是“token 非法”，第二个错误提示是“字符串不符合要求”  </p>
<h3 id="ReferenceError-对象"><a href="#ReferenceError-对象" class="headerlink" title="ReferenceError 对象"></a>ReferenceError 对象</h3><p><code>ReferenceError</code>对象是引用一个不存在的变量时发生的错误    </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用一个不存在的变量</span><br>unknownVariable<br><span class="hljs-comment">// Uncaught ReferenceError: unknownVariable is not defined</span><br></code></pre></div></td></tr></table></figure>
<p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果赋值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 等号左侧不是变量</span><br><span class="hljs-built_in">console</span>.log() = <span class="hljs-number">1</span><br><span class="hljs-comment">// Uncaught ReferenceError: Invalid left-hand side in assignment</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码对函数<code>console.log</code>的运行结果赋值，结果引发了<code>ReferenceError</code>错误  </p>
<h3 id="RangeError-对象"><a href="#RangeError-对象" class="headerlink" title="RangeError 对象"></a>RangeError 对象</h3><p><code>RangeError</code>对象是一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是<code>Number</code>对象的方法参数超出范围，以及函数堆栈超过最大值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 数组长度不得为负数</span><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(-<span class="hljs-number">1</span>)<br><span class="hljs-comment">// Uncaught RangeError: Invalid array length</span><br></code></pre></div></td></tr></table></figure>


<h3 id="TypeError-对象"><a href="#TypeError-对象" class="headerlink" title="TypeError 对象"></a>TypeError 对象</h3><p><code>TypeError</code>对象是变量或参数不是预期类型时发生的错误  </p>
<p>比如，对字符串、布尔值、数值等原始类型的值使用<code>new</code>命令，就会抛出这种错误，因为<code>new</code>命令的参数应该是一个构造函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-number">123</span><br><span class="hljs-comment">// Uncaught TypeError: number is not a func</span><br><br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>obj.unknownMethod()<br><span class="hljs-comment">// Uncaught TypeError: obj.unknownMethod is not a function</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码的第二种情况，调用对象不存在的方法，也会抛出<code>TypeError</code>错误，因为<code>obj.unknownMethod</code>的值是<code>undefined</code>，而不是一个函数  </p>
<h3 id="URIError-对象"><a href="#URIError-对象" class="headerlink" title="URIError 对象"></a>URIError 对象</h3><p><code>URIError</code>对象是 URI 相关函数的参数不正确时抛出的错误，主要涉及<code>encodeURI()</code>、<code>decodeURI()</code>、<code>encodeURIComponent()</code>、<code>decodeURIComponent()</code>、<code>escape()</code>和<code>unescape()</code>这六个函数  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">decodeURI</span>(<span class="hljs-string">&#x27;%2&#x27;</span>)<br><span class="hljs-comment">// URIError: URI malformed</span><br></code></pre></div></td></tr></table></figure>


<h3 id="EvalError-对象"><a href="#EvalError-对象" class="headerlink" title="EvalError 对象"></a>EvalError 对象</h3><p><code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误。该错误类型已经不再使用了，只是为了保证与以前代码兼容，才继续保留  </p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上这6种派生错误，连同原始的<code>Error</code>对象，都是构造函数。开发者可以使用它们，手动生成错误对象的实例。这些构造函数都接受一个参数，代表错误提示信息（message）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> err1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了！&#x27;</span>);<br><span class="hljs-keyword">var</span> err2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RangeError</span>(<span class="hljs-string">&#x27;出错了，变量超出有效范围！&#x27;</span>);<br><span class="hljs-keyword">var</span> err3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;出错了，变量类型无效！&#x27;</span>);<br><br>err1.message <span class="hljs-comment">// &quot;出错了！&quot;</span><br>err2.message <span class="hljs-comment">// &quot;出错了，变量超出有效范围！&quot;</span><br>err3.message <span class="hljs-comment">// &quot;出错了，变量类型无效！&quot;</span><br></code></pre></div></td></tr></table></figure>


<h2 id="自定义错误"><a href="#自定义错误" class="headerlink" title="自定义错误"></a>自定义错误</h2><p>除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserError</span>(<span class="hljs-params">message</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.message = message || <span class="hljs-string">&#x27;默认信息&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;UserError&#x27;</span>;<br>&#125;<br><br>UserError.prototype = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>();<br>UserError.prototype.constructor = UserError;<br></code></pre></div></td></tr></table></figure>
<p>上面代码自定义一个错误对象<code>UserError</code>，让它继承<code>Error</code>对象。然后，就可以生成这种自定义类型的错误了  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> UserError(<span class="hljs-string">&#x27;这是自定义的错误！&#x27;</span>);<br></code></pre></div></td></tr></table></figure>


<h2 id="throw-语句"><a href="#throw-语句" class="headerlink" title="throw 语句"></a>throw 语句</h2><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (x &lt;= <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;x 必须为正数&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// Uncaught ReferenceError: x is not defined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，如果变量<code>x</code>小于等于<code>0</code>，就手动抛出一个错误，告诉用户<code>x</code>的值不正确，整个程序就会在这里中断执行。可以看到，<code>throw</code>抛出的错误就是它的参数，这里是一个<code>Error</code>实例  </p>
<p><code>throw</code>也可以抛出自定义错误  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">UserError</span>(<span class="hljs-params">message</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.message = message || <span class="hljs-string">&#x27;默认信息&#x27;</span>;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;UserError&#x27;</span>;<br>&#125;<br><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UserError(<span class="hljs-string">&#x27;出错了！&#x27;</span>);<br><span class="hljs-comment">// Uncaught UserError &#123;message: &quot;出错了！&quot;, name: &quot;UserError&quot;&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>throw</code>抛出的是一个<code>UserError</code>实例  </p>
<p>实际上，<code>throw</code>可以抛出任何类型的值。也就是说，它的参数可以是任何值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 抛出一个字符串</span><br><span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;Error！&#x27;</span>;<br><span class="hljs-comment">// Uncaught Error！</span><br><br><span class="hljs-comment">// 抛出一个数值</span><br><span class="hljs-keyword">throw</span> <span class="hljs-number">42</span>;<br><span class="hljs-comment">// Uncaught 42</span><br><br><span class="hljs-comment">// 抛出一个布尔值</span><br><span class="hljs-keyword">throw</span> <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// Uncaught true</span><br><br><span class="hljs-comment">// 抛出一个对象</span><br><span class="hljs-keyword">throw</span> &#123;<br>  toString: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Error!&#x27;</span>;<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// Uncaught &#123;toString: ƒ&#125;</span><br></code></pre></div></td></tr></table></figure>
<p>对于 <code>Javascript</code> 引擎来说，遇到<code>throw</code>语句，程序就中止了。引擎会接收到<code>throw</code>抛出的信息，可能是一个错误实例，也可能是其他类型的值  </p>
<h2 id="try…catch-结构"><a href="#try…catch-结构" class="headerlink" title="try…catch 结构"></a>try…catch 结构</h2><p>一旦发生错误，程序就中止执行了  </p>
<p><code>Javascript</code> 提供了<code>try...catch</code>结构，允许对错误进行处理，选择是否往下执行   </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了!&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-built_in">console</span>.log(e.name + <span class="hljs-string">&quot;: &quot;</span> + e.message);<br>  <span class="hljs-built_in">console</span>.log(e.stack);<br>&#125;<br><span class="hljs-comment">// Error: 出错了!</span><br><span class="hljs-comment">//   at &lt;anonymous&gt;:3:9</span><br><span class="hljs-comment">//   ...</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>try</code>代码块抛出错误（上例用的是<code>throw</code>语句），<code>Javascript</code> 引擎就立即把代码的执行，转到<code>catch</code>代码块，或者说错误被<code>catch</code>代码块捕获了。<code>catch</code>接受一个参数，表示<code>try</code>代码块抛出的值  </p>
<p>如果你不确定某些代码是否会报错，就可以把它们放在<code>try...catch</code>代码块之中，便于进一步对错误进行处理  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  f();<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>  <span class="hljs-comment">// 处理错误</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，如果函数<code>f</code>执行报错，就会进行<code>catch</code>代码块，接着对错误进行处理  </p>
<p><code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;出错了&quot;</span>;<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">111</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">222</span>);<br><span class="hljs-comment">// 111</span><br><span class="hljs-comment">// 222</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>try</code>代码块抛出的错误，被<code>catch</code>代码块捕获后，程序会继续向下执行  </p>
<p><code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> n = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">throw</span> n;<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-keyword">if</span> (e &lt;= <span class="hljs-number">50</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">throw</span> e;<br>  &#125;<br>&#125;<br><span class="hljs-comment">// Uncaught 100</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>catch</code>代码之中又抛出了一个错误  </p>
<p>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  foo.bar();<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>  <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">EvalError</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(e.name + <span class="hljs-string">&quot;: &quot;</span> + e.message);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RangeError</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(e.name + <span class="hljs-string">&quot;: &quot;</span> + e.message);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>catch</code>捕获错误之后，会判断错误类型（<code>EvalError</code>还是<code>RangeError</code>），进行不同的处理  </p>
<h2 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h2><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleansUp</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;出错了……&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;此行不会执行&#x27;</span>);<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;完成清理工作&#x27;</span>);<br>  &#125;<br>&#125;<br><br>cleansUp()<br><span class="hljs-comment">// 完成清理工作</span><br><span class="hljs-comment">// Uncaught Error: 出错了……</span><br><span class="hljs-comment">//    at cleansUp (&lt;anonymous&gt;:3:11)</span><br><span class="hljs-comment">//    at &lt;anonymous&gt;:10:1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，由于没有<code>catch</code>语句块，一旦发生错误，代码就会中断执行。中断执行之前，会先执行<code>finally</code>代码块，然后再向用户提示报错信息  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">idle</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(x);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;result&#x27;</span>;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;FINALLY&#x27;</span>);<br>  &#125;<br>&#125;<br><br>idle(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-comment">// hello</span><br><span class="hljs-comment">// FINALLY</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>try</code>代码块没有发生错误，而且里面还包括<code>return</code>语句，但是<code>finally</code>代码块依然会执行。而且，这个函数的返回值还是<code>result</code>  </p>
<p>下面的例子说明，<code>return</code>语句的执行是排在<code>finally</code>代码之前，只是等<code>finally</code>代码执行完毕后才返回  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">countUp</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> count;<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    count++;<br>  &#125;<br>&#125;<br><br>countUp()<br><span class="hljs-comment">// 0</span><br>count<br><span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码说明，<code>return</code>语句里面的<code>count</code>的值，是在<code>finally</code>代码块运行之前就获取了  </p>
<p>下面是<code>finally</code>代码块用法的典型场景  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">openFile();<br><br><span class="hljs-keyword">try</span> &#123;<br>  writeFile(Data);<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>  handleError(e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>  closeFile();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码首先打开一个文件，然后在<code>try</code>代码块中写入文件，如果没有发生错误，则运行<code>finally</code>代码块关闭文件；一旦发生错误，则先使用<code>catch</code>代码块处理错误，再使用<code>finally</code>代码块关闭文件  </p>
<p>下面的例子充分反映了<code>try...catch...finally</code>这三者之间的执行顺序  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;bug&#x27;</span>;<br>  &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 这句原本会延迟到 finally 代码块结束再执行</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>); <span class="hljs-comment">// 不会运行</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 这句会覆盖掉前面那句 return</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">4</span>); <span class="hljs-comment">// 不会运行</span><br>  &#125;<br><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">5</span>); <span class="hljs-comment">// 不会运行</span><br>&#125;<br><br><span class="hljs-keyword">var</span> result = f();<br><span class="hljs-comment">// 0</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 3</span><br><br>result<br><span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>catch</code>代码块结束执行之前，会先执行<code>finally</code>代码块  </p>
<p><code>catch</code>代码块之中，触发转入<code>finally</code>代码块的标志，不仅有<code>return</code>语句，还有<code>throw</code>语句  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&#x27;出错了！&#x27;</span>;<br>  &#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;捕捉到内部错误&#x27;</span>);<br>    <span class="hljs-keyword">throw</span> e; <span class="hljs-comment">// 这句原本会等到finally结束再执行</span><br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 直接返回</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>  f();<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>  <span class="hljs-comment">// 此处不会执行</span><br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;caught outer &quot;bogus&quot;&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">//  捕捉到内部错误</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，进入<code>catch</code>代码块之后，一遇到<code>throw</code>语句，就会去执行<code>finally</code>代码块，其中有<code>return false</code>语句，因此就直接返回了，不再会回去执行<code>catch</code>代码块剩下的部分了  </p>
<p><code>try</code>代码块内部，还可以再使用<code>try</code>代码块  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    consle.log(<span class="hljs-string">&#x27;Hello world!&#x27;</span>); <span class="hljs-comment">// 报错</span><br>  &#125;<br>  <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Finally&#x27;</span>);<br>  &#125;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Will I run?&#x27;</span>);<br>&#125; <span class="hljs-keyword">catch</span>(error) &#123;<br>  <span class="hljs-built_in">console</span>.error(error.message);<br>&#125;<br><span class="hljs-comment">// Finally</span><br><span class="hljs-comment">// consle is not defined</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>try</code>里面还有一个<code>try</code>。内层的<code>try</code>报错（<code>console</code>拼错了），这时会执行内层的<code>finally</code>代码块，然后抛出错误，被外层的<code>catch</code>捕获  </p>
<h1 id="编程风格"><a href="#编程风格" class="headerlink" title="编程风格"></a>编程风格</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>“编程风格”（programming style）指的是编写代码的样式规则。不同的程序员，往往有不同的编程风格  </p>
<p>有人说，编译器的规范叫做“语法规则”（grammar），这是程序员必须遵守的；而编译器忽略的部分，就叫“编程风格”（programming style），这是程序员可以自由选择的。这种说法不完全正确，程序员固然可以自由选择编程风格，但是好的编程风格有助于写出质量更高、错误更少、更易于维护的程序  </p>
<p>所以，编程风格的选择不应该基于个人爱好、熟悉程度、打字量等因素，而要考虑如何尽量使代码清晰易读、减少出错。你选择的，不是你喜欢的风格，而是一种能够清晰表达你的意图的风格。这一点，对于 <code>Javascript</code> 这种语法自由度很高的语言尤其重要  </p>
<p>必须牢记的一点是，如果你选定了一种“编程风格”，就应该坚持遵守，切忌多种风格混用。如果你加入他人的项目，就应该遵守现有的风格  </p>
<h2 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h2><p>行首的空格和 Tab 键，都可以产生代码缩进效果（indent）  </p>
<p>Tab 键可以节省击键次数，但不同的文本编辑器对 Tab 的显示不尽相同，有的显示四个空格，有的显示两个空格，所以有人觉得，空格键可以使得显示效果更统一    </p>
<p>无论你选择哪一种方法，都是可以接受的，要做的就是始终坚持这一种选择。不要一会使用 Tab 键，一会使用空格键  </p>
<h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>如果循环和判断的代码体只有一行，<code>Javascript</code> 允许该区块（block）省略大括号  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (a)<br>  b();<br>  c();<br></code></pre></div></td></tr></table></figure>
<p>上面代码的原意可能是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (a) &#123;<br>  b();<br>  c();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>但是，实际效果却是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (a) &#123;<br>  b();<br>&#125;<br>  c();<br></code></pre></div></td></tr></table></figure>
<p>因此，建议总是使用大括号表示区块  </p>
<p>另外，区块起首的大括号的位置，有许多不同的写法。最流行的有两种，一种是起首的大括号另起一行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">block<br>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>另一种是起首的大括号跟在关键字的后面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">block &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>一般来说，这两种写法都可以接受。但是，<code>Javascript</code> 要使用后一种，因为 <code>Javascript</code> 会自动添加句末的分号，导致一些难以察觉的错误  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span><br>&#123;<br>  key: value<br>&#125;;<br><br><span class="hljs-comment">// 相当于</span><br><span class="hljs-keyword">return</span>;<br>&#123;<br>  key: value<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>上面的代码的原意，是要返回一个对象，但实际上返回的是<code>undefined</code>，因为 JavaScript 自动在<code>return</code>语句后面添加了分号。为了避免这一类错误，需要写成下面这样  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> &#123;<br>  key : value<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>因此，表示区块起首的大括号，不要另起一行  </p>
<h2 id="圆括号"><a href="#圆括号" class="headerlink" title="圆括号"></a>圆括号</h2><p>圆括号（parentheses）在<code> Javascript</code> 中有两种作用，一种表示函数的调用，另一种表示表达式的组合（grouping）  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 圆括号表示函数的调用</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;abc&#x27;</span>);<br><br><span class="hljs-comment">// 圆括号表示表达式的组合</span><br>(<span class="hljs-number">1</span> + <span class="hljs-number">2</span>) * <span class="hljs-number">3</span><br></code></pre></div></td></tr></table></figure>
<p>建议可以用空格，区分这两种不同的括号  </p>
<blockquote>
<ol>
<li><p>表示函数调用时，函数名与左括号之间没有空格。</p>
</li>
<li><p>表示函数定义时，函数名与左括号之间没有空格。</p>
</li>
<li><p>其他情况时，前面位置的语法元素与左括号之间，都有一个空格。</p>
</li>
</ol>
</blockquote>
<p>按照上面的规则，下面的写法都是不规范的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">foo (bar)<br><span class="hljs-keyword">return</span>(a+b);<br><span class="hljs-keyword">if</span>(a === <span class="hljs-number">0</span>) &#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">b</span>) </span>&#123;...&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">x</span>) </span>&#123;...&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码的最后一行是一个匿名函数，<code>function</code>是语法关键字，不是函数名，所以与左括号之间应该要有一个空格  </p>
<h2 id="行尾的分号"><a href="#行尾的分号" class="headerlink" title="行尾的分号"></a>行尾的分号</h2><p>分号表示一条语句的结束。<code>Javascript</code> 允许省略行尾的分号  </p>
<p>事实上，确实有一些开发者行尾从来不写分号。但是，由于下面要讨论的原因，建议还是不要省略这个分号  </p>
<h3 id="不使用分号的情况"><a href="#不使用分号的情况" class="headerlink" title="不使用分号的情况"></a>不使用分号的情况</h3><p>首先，以下三种情况，语法规定本来就不需要在结尾添加分号  </p>
<p><strong>（1）for 和 while 循环</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> ( ; ; ) &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br></code></pre></div></td></tr></table></figure>
<p>注意，<code>do...while</code>循环是有分号的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">do</span> &#123;<br>  a--;<br>&#125; <span class="hljs-keyword">while</span>(a &gt; <span class="hljs-number">0</span>); <span class="hljs-comment">// 分号不能省略</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（2）分支语句：if，switch，try</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br><br><span class="hljs-keyword">switch</span> () &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br><br><span class="hljs-keyword">try</span> &#123;<br>&#125; <span class="hljs-keyword">catch</span> &#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br></code></pre></div></td></tr></table></figure>
<p><strong>（3）函数的声明语句</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125; <span class="hljs-comment">// 没有分号</span><br></code></pre></div></td></tr></table></figure>
<p>注意，函数表达式仍然要使用分号  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<p>以上三种情况，如果使用了分号，并不会出错。因为，解释引擎会把这个分号解释为空语句  </p>
<h3 id="分号的自动添加"><a href="#分号的自动添加" class="headerlink" title="分号的自动添加"></a>分号的自动添加</h3><p>除了上一节的三种情况，所有语句都应该使用分号  </p>
<p>但是，如果没有使用分号，大多数情况下，Javascript 会自动添加  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure>
<p>这种语法特性被称为“分号的自动添加”（Automatic Semicolon Insertion，简称 ASI）  </p>
<p>因此，有人提倡省略句尾的分号。麻烦的是，如果下一行的开始可以与本行的结尾连在一起解释，<code>Javascript</code> 就不会自动添加分号  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 等同于 var a = 3</span><br><span class="hljs-keyword">var</span><br>a<br>=<br><span class="hljs-number">3</span><br><br><span class="hljs-comment">// 等同于 &#x27;abc&#x27;.length</span><br><span class="hljs-string">&#x27;abc&#x27;</span><br>.length<br><br><span class="hljs-comment">// 等同于 return a + b;</span><br><span class="hljs-keyword">return</span> a +<br>b;<br><br><span class="hljs-comment">// 等同于 obj.foo(arg1, arg2);</span><br>obj.foo(arg1,<br>arg2);<br><br><span class="hljs-comment">// 等同于 3 * 2 + 10 * (27 / 6)</span><br><span class="hljs-number">3</span> * <span class="hljs-number">2</span><br>+<br><span class="hljs-number">10</span> * (<span class="hljs-number">27</span> / <span class="hljs-number">6</span>)<br></code></pre></div></td></tr></table></figure>
<p>上面代码都会多行放在一起解释，不会每一行自动添加分号。这些例子还是比较容易看出来的，但是下面这个例子就不那么容易看出来了  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">x = y<br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)();<br><br><span class="hljs-comment">// 等同于</span><br>x = y(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;...&#125;)();<br></code></pre></div></td></tr></table></figure>
<p>下面是更多不会自动添加分号的例子  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-comment">// 引擎解释为 c(d+e)</span><br><span class="hljs-keyword">var</span> a = b + c<br>(d+e).toString();<br><br><span class="hljs-comment">// 引擎解释为 a = b/hi/g.exec(c).map(d)</span><br><span class="hljs-comment">// 正则表达式的斜杠，会当作除法运算符</span><br>a = b<br>/hi/g.exec(c).map(d);<br><br><span class="hljs-comment">// 解释为&#x27;b&#x27;[&#x27;red&#x27;, &#x27;green&#x27;]，</span><br><span class="hljs-comment">// 即把字符串当作一个数组，按索引取值</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;b&#x27;</span><br>[<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(c);<br>&#125;)<br><br><span class="hljs-comment">// 解释为 function (x) &#123; return x &#125;(a++)</span><br><span class="hljs-comment">// 即调用匿名函数，结果f等于0</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123; <span class="hljs-keyword">return</span> x &#125;<br>(a++)<br></code></pre></div></td></tr></table></figure>
<p>只有下一行的开始与本行的结尾，无法放在一起解释，<code>Javascript</code> 引擎才会自动添加分号  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>) a = <span class="hljs-number">0</span><br><span class="hljs-built_in">console</span>.log(a)<br><br><span class="hljs-comment">// 等同于下面的代码，</span><br><span class="hljs-comment">// 因为 0console 没有意义</span><br><span class="hljs-keyword">if</span> (a &lt; <span class="hljs-number">0</span>) a = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">console</span>.log(a)<br></code></pre></div></td></tr></table></figure>
<p>另外，如果一行的起首是“自增”（<code>++</code>）或“自减”（<code>--</code>）运算符，则它们的前面会自动添加分号  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">a = b = c = <span class="hljs-number">1</span><br><br>a<br>++<br>b<br>--<br>c<br><br><span class="hljs-built_in">console</span>.log(a, b, c)<br><span class="hljs-comment">// 1 2 0</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码之所以会得到<code>1 2 0</code>的结果，原因是自增和自减运算符前，自动加上了分号。上面的代码实际上等同于下面的形式  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">a = b = c = <span class="hljs-number">1</span>;<br>a;<br>++b;<br>--c;<br></code></pre></div></td></tr></table></figure>
<p>如果<code>continue</code>、<code>break</code>、<code>return</code>和<code>throw</code>这四个语句后面，直接跟换行符，则会自动添加分号  </p>
<p>这意味着，如果<code>return</code>语句返回的是一个对象的字面量，起首的大括号一定要写在同一行，否则得不到预期结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span><br>&#123; <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;Jane&#x27;</span> &#125;;<br><br><span class="hljs-comment">// 解释成</span><br><span class="hljs-keyword">return</span>;<br>&#123; <span class="hljs-attr">first</span>: <span class="hljs-string">&#x27;Jane&#x27;</span> &#125;;<br></code></pre></div></td></tr></table></figure>
<p>由于解释引擎自动添加分号的行为难以预测，因此编写代码的时候不应该省略行尾的分号  </p>
<p>不应该省略结尾的分号，还有一个原因。有些 <code>Javascript</code> 代码压缩器（uglifier）不会自动添加分号，因此遇到没有分号的结尾，就会让代码保持原状，而不是压缩成一行，使得压缩无法得到最优的结果  </p>
<p>另外，不写结尾的分号，可能会导致脚本合并出错。所以，有的代码库在第一行语句开始前，会加上一个分号  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">;<span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-comment">// ...</span><br></code></pre></div></td></tr></table></figure>
<p>上面这种写法就可以避免与其他脚本合并时，排在前面的脚本最后一行语句没有分号，导致运行出错的问题。</p>
<h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><p>JavaScript 最大的语法缺点，可能就是全局变量对于任何一个代码块，都是可读可写。这对代码的模块化和重复使用，非常不利  </p>
<p>因此，建议避免使用全局变量。如果不得不使用，可以考虑用大写字母表示变量名，这样更容易看出这是全局变量，比如<code>UPPER_CASE</code>  </p>
<h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p><code>Javascript</code> 会自动将变量声明“提升”（hoist）到代码块（block）的头部  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (!x) &#123;<br>  <span class="hljs-keyword">var</span> x = &#123;&#125;;<br>&#125;<br><br><span class="hljs-comment">// 等同于</span><br><span class="hljs-keyword">var</span> x;<br><span class="hljs-keyword">if</span> (!x) &#123;<br>  x = &#123;&#125;;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>这意味着，变量<code>x</code>是<code>if</code>代码块之前就存在了。为了避免可能出现的问题，最好把变量声明都放在代码块的头部  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-comment">// 写成</span><br><span class="hljs-keyword">var</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面这样的写法，就容易看出存在一个全局的循环变量<code>i</code>  </p>
<p>另外，所有函数都应该在使用之前定义。函数内部的变量声明，都应该放在函数的头部  </p>
<h2 id="with-语句-1"><a href="#with-语句-1" class="headerlink" title="with 语句"></a>with 语句</h2><p><code>with</code>可以减少代码的书写，但是会造成混淆  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">with</span> (o) &#123;<br>　foo = bar;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面的代码，可以有四种运行结果：</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">o.foo = bar;<br>o.foo = o.bar;<br>foo = bar;<br>foo = o.bar;<br></code></pre></div></td></tr></table></figure>
<p>这四种结果都可能发生，取决于不同的变量是否有定义。因此，不要使用<code>with</code>语句  </p>
<h2 id="相等和严格相等"><a href="#相等和严格相等" class="headerlink" title="相等和严格相等"></a>相等和严格相等</h2><p>JavaScript 有两个表示相等的运算符：“相等”（<code>==</code>）和“严格相等”（<code>===</code>）  </p>
<p>相等运算符会自动转换变量类型，造成很多意想不到的情况  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">0</span> == <span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">// true</span><br><span class="hljs-number">1</span> == <span class="hljs-literal">true</span> <span class="hljs-comment">// true</span><br><span class="hljs-number">2</span> == <span class="hljs-literal">true</span> <span class="hljs-comment">// false</span><br><span class="hljs-number">0</span> == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-literal">false</span> == <span class="hljs-string">&#x27;false&#x27;</span> <span class="hljs-comment">// false</span><br><span class="hljs-literal">false</span> == <span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-comment">// true</span><br><span class="hljs-string">&#x27; \t\r\n &#x27;</span> == <span class="hljs-number">0</span> <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>
<p>因此，建议不要使用相等运算符（<code>==</code>），只使用严格相等运算符（<code>===</code>）  </p>
<h2 id="语句的合并"><a href="#语句的合并" class="headerlink" title="语句的合并"></a>语句的合并</h2><p>有些程序员追求简洁，喜欢合并不同目的的语句。比如，原来的语句是  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">a = b;<br><span class="hljs-keyword">if</span> (a) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>他喜欢写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> (a = b) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>虽然语句少了一行，但是可读性大打折扣，而且会造成误读，让别人误解这行代码的意思是下面这样  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">if</span> （a === b）&#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>建议不要将不同目的的语句，合并成一行  </p>
<h2 id="自增和自减运算符-1"><a href="#自增和自减运算符-1" class="headerlink" title="自增和自减运算符"></a>自增和自减运算符</h2><p>自增（<code>++</code>）和自减（<code>--</code>）运算符，放在变量的前面或后面，返回的值不一样，很容易发生错误。事实上，所有的<code>++</code>运算符都可以用<code>+= 1</code>代替  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">++x<br><span class="hljs-comment">// 等同于</span><br>x += <span class="hljs-number">1</span>;<br></code></pre></div></td></tr></table></figure>
<p>改用<code>+= 1</code>，代码变得更清晰了  </p>
<p>建议自增（<code>++</code>）和自减（<code>--</code>）运算符尽量使用<code>+=</code>和<code>-=</code>代替  </p>
<h2 id="switch…case-结构"><a href="#switch…case-结构" class="headerlink" title="switch…case 结构"></a>switch…case 结构</h2><p><code>switch...case</code>结构要求，在每一个<code>case</code>的最后一行必须是<code>break</code>语句，否则会接着运行下一个<code>case</code>。这样不仅容易忘记，还会造成代码的冗长  </p>
<p>而且，<code>switch...case</code>不使用大括号，不利于代码形式的统一  </p>
<p>此外，这种结构类似于<code>goto</code>语句，容易造成程序流程的混乱，使得代码结构混乱不堪，不符合面向对象编程的原则  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAction</span>(<span class="hljs-params">action</span>) </span>&#123;<br>  <span class="hljs-keyword">switch</span> (action) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;hack&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hack&#x27;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;slash&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;slash&#x27;</span>;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;run&#x27;</span>:<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;run&#x27;</span>;<br>    <span class="hljs-keyword">default</span>:<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Invalid action.&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面的代码建议改写成对象结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doAction</span>(<span class="hljs-params">action</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> actions = &#123;<br>    <span class="hljs-string">&#x27;hack&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hack&#x27;</span>;<br>    &#125;,<br>    <span class="hljs-string">&#x27;slash&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;slash&#x27;</span>;<br>    &#125;,<br>    <span class="hljs-string">&#x27;run&#x27;</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;run&#x27;</span>;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> actions[action] !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Invalid action.&#x27;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> actions[action]();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>因此，建议<code>switch...case</code>结构可以用对象结构代替  </p>
<h1 id="console-对象与控制台"><a href="#console-对象与控制台" class="headerlink" title="console 对象与控制台"></a>console 对象与控制台</h1><h2 id="console-对象"><a href="#console-对象" class="headerlink" title="console 对象"></a>console 对象</h2><p><code>console</code>对象是 <code>Javascript</code> 的原生对象，它有点像 Unix 系统的标准输出<code>stdout</code>和标准错误<code>stderr</code>，可以输出各种信息到控制台，并且还提供了很多有用的辅助方法  </p>
<p><code>console</code>的常见用途有两个  </p>
<ul>
<li>调试程序，显示网页代码运行时的错误信息  </li>
<li>提供了一个命令行接口，用来与网页代码互动  </li>
</ul>
<h2 id="console-对象的静态方法"><a href="#console-对象的静态方法" class="headerlink" title="console 对象的静态方法"></a>console 对象的静态方法</h2><p><code>console</code>对象提供的各种静态方法，用来与控制台窗口互动  </p>
<h3 id="console-log-，console-info-，console-debug"><a href="#console-log-，console-info-，console-debug" class="headerlink" title="console.log()，console.info()，console.debug()"></a>console.log()，console.info()，console.debug()</h3><p><code>console.log</code>方法用于在控制台输出信息。它可以接受一个或多个参数，将它们连接起来输出  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello World&#x27;</span>)<br><span class="hljs-comment">// Hello World</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>)<br><span class="hljs-comment">// a b c</span><br></code></pre></div></td></tr></table></figure>
<p><code>console.log</code>方法会自动在每次输出的结尾，添加换行符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>
<p>如果第一个参数是格式字符串（使用了格式占位符），<code>console.log</code>方法将依次用后面的参数替换占位符，然后再进行输出  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27; %s + %s = %s&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">//  1 + 1 = 2</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，<code>console.log</code>方法的第一个参数有三个占位符（<code>%s</code>），第二、三、四个参数会在显示时，依次替换掉这个三个占位符  </p>
<p><code>console.log</code>方法支持以下占位符，不同类型的数据必须使用对应的占位符  </p>
<ul>
<li><code>%s</code> 字符串   </li>
<li><code>%d</code> 整数  </li>
<li><code>%i</code> 整数  </li>
<li><code>%f</code> 浮点数  </li>
<li><code>%o</code> 对象的链接  </li>
<li><code>%c</code> CSS 格式字符串  </li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> number = <span class="hljs-number">11</span> * <span class="hljs-number">9</span>;<br><span class="hljs-keyword">var</span> color = <span class="hljs-string">&#x27;red&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;%d %s balloons&#x27;</span>, number, color);<br><span class="hljs-comment">// 99 red balloons</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码中，第二个参数是数值，对应的占位符是<code>%d</code>，第三个参数是字符串，对应的占位符是<code>%s</code>  </p>
<p>使用<code>%c</code>占位符时，对应的参数必须是 CSS 代码，用来对输出内容进行 CSS 渲染  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<br>  <span class="hljs-string">&#x27;%cThis text is styled!&#x27;</span>,<br>  <span class="hljs-string">&#x27;color: red; background: yellow; font-size: 24px;&#x27;</span><br>)<br></code></pre></div></td></tr></table></figure>
<p>上面代码运行后，输出的内容将显示为黄底红字  </p>
<p><code>console.log</code>方法的两种参数格式，可以结合在一起使用  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27; %s + %s &#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;= 2&#x27;</span>)<br><span class="hljs-comment">// 1 + 1  = 2</span><br></code></pre></div></td></tr></table></figure>
<p>如果参数是一个对象，<code>console.log</code>会显示该对象的值  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(&#123;<span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125;)<br><span class="hljs-comment">// Object &#123;foo: &quot;bar&quot;&#125;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Date</span>)<br><span class="hljs-comment">// function Date() &#123; [native code] &#125;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码输出<code>Date</code>对象的值，结果为一个构造函数  </p>
<p><code>console.info</code>是<code>console.log</code>方法的别名，用法完全一样。只不过<code>console.info</code>方法会在输出信息的前面，加上一个蓝色图标  </p>
<p><code>console.debug</code>方法与<code>console.log</code>方法类似，会在控制台输出调试信息。但是，默认情况下，<code>console.debug</code>输出的信息不会显示，只有在打开显示级别在<code>verbose</code>的情况下，才会显示  </p>
<p><code>console</code>对象的所有方法，都可以被覆盖。因此，可以按照自己的需要，定义<code>console.log</code>方法  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;log&#x27;</span>, <span class="hljs-string">&#x27;info&#x27;</span>, <span class="hljs-string">&#x27;warn&#x27;</span>, <span class="hljs-string">&#x27;error&#x27;</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">method</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>[method] = <span class="hljs-built_in">console</span>[method].bind(<br>    <span class="hljs-built_in">console</span>,<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().toISOString()<br>  );<br>&#125;);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;出错了！&quot;</span>);<br><span class="hljs-comment">// 2014-05-18T09:00.000Z 出错了！</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码表示，使用自定义的<code>console.log</code>方法，可以在显示结果添加当前时间  </p>
<h3 id="console-warn-，console-error"><a href="#console-warn-，console-error" class="headerlink" title="console.warn()，console.error()"></a>console.warn()，console.error()</h3><p><code>warn</code>方法和<code>error</code>方法也是在控制台输出信息，它们与<code>log</code>方法的不同之处在于，<code>warn</code>方法输出信息时，在最前面加一个黄色三角，表示警告；<code>error</code>方法输出信息时，在最前面加一个红色的叉，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;Error: %s (%i)&#x27;</span>, <span class="hljs-string">&#x27;Server is not responding&#x27;</span>, <span class="hljs-number">500</span>)<br><span class="hljs-comment">// Error: Server is not responding (500)</span><br><span class="hljs-built_in">console</span>.warn(<span class="hljs-string">&#x27;Warning! Too few nodes (%d)&#x27;</span>, <span class="hljs-built_in">document</span>.childNodes.length)<br><span class="hljs-comment">// Warning! Too few nodes (1)</span><br></code></pre></div></td></tr></table></figure>
<p>可以这样理解，<code>log</code>方法是写入标准输出（<code>stdout</code>），<code>warn</code>方法和<code>error</code>方法是写入标准错误（<code>stderr</code>）  </p>
<h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h3><p>对于某些复合类型的数据，<code>console.table</code>方法可以将其转为表格显示  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> languages = [<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;JavaScript&quot;</span>, <span class="hljs-attr">fileExtension</span>: <span class="hljs-string">&quot;.js&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;TypeScript&quot;</span>, <span class="hljs-attr">fileExtension</span>: <span class="hljs-string">&quot;.ts&quot;</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;CoffeeScript&quot;</span>, <span class="hljs-attr">fileExtension</span>: <span class="hljs-string">&quot;.coffee&quot;</span> &#125;<br>];<br><br><span class="hljs-built_in">console</span>.table(languages);<br></code></pre></div></td></tr></table></figure>
<p>上面代码的<code>language</code>变量，转为表格显示如下  </p>
<table>
<thead>
<tr>
<th>(index)</th>
<th>name</th>
<th>fileExtension</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>“JavaScript”</td>
<td>“.js”</td>
</tr>
<tr>
<td>1</td>
<td>“TypeScript”</td>
<td>“.ts”</td>
</tr>
<tr>
<td>2</td>
<td>“CoffeeScript”</td>
<td>“.coffee”</td>
</tr>
</tbody></table>
<p>下面是显示表格内容的例子  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> languages = &#123;<br>  csharp: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;C#&quot;</span>, <span class="hljs-attr">paradigm</span>: <span class="hljs-string">&quot;object-oriented&quot;</span> &#125;,<br>  fsharp: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;F#&quot;</span>, <span class="hljs-attr">paradigm</span>: <span class="hljs-string">&quot;functional&quot;</span> &#125;<br>&#125;;<br><br><span class="hljs-built_in">console</span>.table(languages);<br></code></pre></div></td></tr></table></figure>
<p>上面代码的<code>language</code>，转为表格显示如下  </p>
<table>
<thead>
<tr>
<th>(index)</th>
<th>name</th>
<th>paradigm</th>
</tr>
</thead>
<tbody><tr>
<td>csharp</td>
<td>“C#”</td>
<td>“object-oriented”</td>
</tr>
<tr>
<td>fsharp</td>
<td>“F#”</td>
<td>“functional”</td>
</tr>
</tbody></table>
<h3 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h3><p><code>count</code>方法用于计数，输出它被调用了多少次  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.count();<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hi &#x27;</span> + user;<br>&#125;<br><br>greet(<span class="hljs-string">&#x27;bob&#x27;</span>)<br><span class="hljs-comment">//  : 1</span><br><span class="hljs-comment">// &quot;hi bob&quot;</span><br><br>greet(<span class="hljs-string">&#x27;alice&#x27;</span>)<br><span class="hljs-comment">//  : 2</span><br><span class="hljs-comment">// &quot;hi alice&quot;</span><br><br>greet(<span class="hljs-string">&#x27;bob&#x27;</span>)<br><span class="hljs-comment">//  : 3</span><br><span class="hljs-comment">// &quot;hi bob&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码每次调用<code>greet</code>函数，内部的<code>console.count</code>方法就输出执行次数  </p>
<p>该方法可以接受一个字符串作为参数，作为标签，对执行次数进行分类  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">greet</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.count(user);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hi &quot;</span> + user;<br>&#125;<br><br>greet(<span class="hljs-string">&#x27;bob&#x27;</span>)<br><span class="hljs-comment">// bob: 1</span><br><span class="hljs-comment">// &quot;hi bob&quot;</span><br><br>greet(<span class="hljs-string">&#x27;alice&#x27;</span>)<br><span class="hljs-comment">// alice: 1</span><br><span class="hljs-comment">// &quot;hi alice&quot;</span><br><br>greet(<span class="hljs-string">&#x27;bob&#x27;</span>)<br><span class="hljs-comment">// bob: 2</span><br><span class="hljs-comment">// &quot;hi bob&quot;</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码根据参数的不同，显示<code>bob</code>执行了两次，<code>alice</code>执行了一次  </p>
<h3 id="console-dir-，console-dirxml"><a href="#console-dir-，console-dirxml" class="headerlink" title="console.dir()，console.dirxml()"></a>console.dir()，console.dirxml()</h3><p><code>dir</code>方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(&#123;<span class="hljs-attr">f1</span>: <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-attr">f2</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125;)<br><span class="hljs-comment">// Object &#123;f1: &quot;foo&quot;, f2: &quot;bar&quot;&#125;</span><br><br><span class="hljs-built_in">console</span>.dir(&#123;<span class="hljs-attr">f1</span>: <span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-attr">f2</span>: <span class="hljs-string">&#x27;bar&#x27;</span>&#125;)<br><span class="hljs-comment">// Object</span><br><span class="hljs-comment">//   f1: &quot;foo&quot;</span><br><span class="hljs-comment">//   f2: &quot;bar&quot;</span><br><span class="hljs-comment">//   __proto__: Object</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码显示<code>dir</code>方法的输出结果，比<code>log</code>方法更易读，信息也更丰富   </p>
<p>该方法对于输出 DOM 对象非常有用，因为会显示 DOM 对象的所有属性  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.dir(<span class="hljs-built_in">document</span>.body)<br></code></pre></div></td></tr></table></figure>
<p>Node 环境之中，还可以指定以代码高亮的形式输出  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.dir(obj, &#123;<span class="hljs-attr">colors</span>: <span class="hljs-literal">true</span>&#125;)<br></code></pre></div></td></tr></table></figure>
<p><code>dirxml</code>方法主要用于以目录树的形式，显示 DOM 节点  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.dirxml(<span class="hljs-built_in">document</span>.body)<br></code></pre></div></td></tr></table></figure>
<p>如果参数不是 DOM 节点，而是普通的 JavaScript 对象，<code>console.dirxml</code>等同于<code>console.dir</code>  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.dirxml([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-built_in">console</span>.dir([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br></code></pre></div></td></tr></table></figure>


<h3 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert()"></a>console.assert()</h3><p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确  </p>
<p>它接受两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为<code>false</code>，才会提示有错误，在控制台输出第二个参数，否则不会有任何结果  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.assert(<span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;判断条件不成立&#x27;</span>)<br><span class="hljs-comment">// Assertion failed: 判断条件不成立</span><br><br><span class="hljs-comment">// 相当于</span><br><span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-literal">false</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;判断条件不成立&#x27;</span>);<br>  &#125;<br>&#125; <span class="hljs-keyword">catch</span>(e) &#123;<br>  <span class="hljs-built_in">console</span>.error(e);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>下面是一个例子，判断子节点的个数是否大于等于500  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.assert(list.childNodes.length &lt; <span class="hljs-number">500</span>, <span class="hljs-string">&#x27;节点个数大于等于500&#x27;</span>)<br></code></pre></div></td></tr></table></figure>
<p>上面代码中，如果符合条件的节点小于500个，不会有任何输出；只有大于等于500时，才会在控制台提示错误，并且显示指定文本  </p>
<h3 id="console-time-，console-timeEnd"><a href="#console-time-，console-timeEnd" class="headerlink" title="console.time()，console.timeEnd()"></a>console.time()，console.timeEnd()</h3><p>这两个方法用于计时，可以算出一个操作所花费的准确时间  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.time(<span class="hljs-string">&#x27;Array initialize&#x27;</span>);<br><br><span class="hljs-keyword">var</span> array= <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1000000</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = array.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>  array[i] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>&#125;;<br><br><span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&#x27;Array initialize&#x27;</span>);<br><span class="hljs-comment">// Array initialize: 1914.481ms</span><br></code></pre></div></td></tr></table></figure>
<p><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”  </p>
<h3 id="console-group-，console-groupEnd-，console-groupCollapsed"><a href="#console-group-，console-groupEnd-，console-groupCollapsed" class="headerlink" title="console.group()，console.groupEnd()，console.groupCollapsed()"></a>console.group()，console.groupEnd()，console.groupCollapsed()</h3><p><code>console.group</code>和<code>console.groupEnd</code>这两个方法用于将显示的信息分组  </p>
<p>它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.group(<span class="hljs-string">&#x27;一级分组&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;一级分组的内容&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.group(<span class="hljs-string">&#x27;二级分组&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;二级分组的内容&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.groupEnd(); <span class="hljs-comment">// 二级分组结束</span><br><span class="hljs-built_in">console</span>.groupEnd(); <span class="hljs-comment">// 一级分组结束</span><br></code></pre></div></td></tr></table></figure>
<p>上面代码会将“二级分组”显示在“一级分组”内部，并且“一级分组”和“二级分组”前面都有一个折叠符号，可以用来折叠本级的内容  </p>
<p><code>console.groupCollapsed</code>方法与<code>console.group</code>方法很类似，唯一的区别是该组的内容，在第一次显示时是收起的（collapsed），而不是展开的  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.groupCollapsed(<span class="hljs-string">&#x27;Fetching Data&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Request Sent&#x27;</span>);<br><span class="hljs-built_in">console</span>.error(<span class="hljs-string">&#x27;Error: Server not responding (500)&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.groupEnd();<br></code></pre></div></td></tr></table></figure>
<p>上面代码只显示一行”Fetching Data“，点击后才会展开，显示其中包含的两行  </p>
<h3 id="console-trace-，console-clear"><a href="#console-trace-，console-clear" class="headerlink" title="console.trace()，console.clear()"></a>console.trace()，console.clear()</h3><p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.trace()<br><span class="hljs-comment">// console.trace()</span><br><span class="hljs-comment">//   (anonymous function)</span><br><span class="hljs-comment">//   InjectedScript._evaluateOn</span><br><span class="hljs-comment">//   InjectedScript._evaluateAndWrap</span><br><span class="hljs-comment">//   InjectedScript.evaluate</span><br></code></pre></div></td></tr></table></figure>
<p><code>console.clear</code>方法用于清除当前控制台的所有输出，将光标回置到第一行。如果用户选中了控制台的“Preserve log”选项，<code>console.clear</code>方法将不起作用  </p>
<h2 id="控制台命令行-API"><a href="#控制台命令行-API" class="headerlink" title="控制台命令行 API"></a>控制台命令行 API</h2><p>浏览器控制台中，除了使用<code>console</code>对象，还可以使用一些控制台自带的命令行方法  </p>
<p>（1）<code>$_</code></p>
<p><code>$_</code>属性返回上一个表达式的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-number">2</span> + <span class="hljs-number">2</span><br><span class="hljs-comment">// 4</span><br>$_<br><span class="hljs-comment">// 4</span><br></code></pre></div></td></tr></table></figure>


<p>（2）<code>$0</code> - <code>$4</code></p>
<p>控制台保存了最近5个在 Elements 面板选中的 DOM 元素，<code>$0</code>代表倒数第一个（最近一个），<code>$1</code>代表倒数第二个，以此类推直到<code>$4</code>。</p>
<p>（3）<code>$(selector)</code></p>
<p><code>$(selector)</code>返回第一个匹配的元素，等同于<code>document.querySelector()</code>。注意，如果页面脚本对<code>$</code>有定义，则会覆盖原始的定义。比如，页面里面有 jQuery，控制台执行<code>$(selector)</code>就会采用 jQuery 的实现，返回一个数组。</p>
<p>（4）<code>$$(selector)</code></p>
<p><code>$$(selector)</code>返回选中的 DOM 对象，等同于<code>document.querySelectorAll</code>。</p>
<p>（5）<code>$x(path)</code></p>
<p><code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">$x(<span class="hljs-string">&quot;//p[a]&quot;</span>)<br></code></pre></div></td></tr></table></figure>
<p>上面代码返回所有包含<code>a</code>元素的<code>p</code>元素。</p>
<p>（6）<code>inspect(object)</code></p>
<p><code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节。DOM 元素在<code>Elements</code>面板中显示，比如<code>inspect(document)</code>会在 Elements 面板显示<code>document</code>元素。JavaScript 对象在控制台面板<code>Profiles</code>面板中显示，比如<code>inspect(window)</code>。</p>
<p>（7）<code>getEventListeners(object)</code></p>
<p><code>getEventListeners(object)</code>方法返回一个对象，该对象的成员为<code>object</code>登记了回调函数的各种事件（比如<code>click</code>或<code>keydown</code>），每个事件对应一个数组，数组的成员为该事件的回调函数。</p>
<p>（8）<code>keys(object)</code>，<code>values(object)</code></p>
<p><code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。</p>
<p><code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> o = &#123;<span class="hljs-string">&#x27;p1&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;p2&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>&#125;;<br><br>keys(o)<br><span class="hljs-comment">// [&quot;p1&quot;, &quot;p2&quot;]</span><br>values(o)<br><span class="hljs-comment">// [&quot;a&quot;, &quot;b&quot;]</span><br></code></pre></div></td></tr></table></figure>


<p>（9）<code>monitorEvents(object[, events]) ，unmonitorEvents(object[, events])</code></p>
<p><code>monitorEvents(object[, events])</code>方法监听特定对象上发生的特定事件。事件发生时，会返回一个<code>Event</code>对象，包含该事件的相关信息。<code>unmonitorEvents</code>方法用于停止监听。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">monitorEvents(<span class="hljs-built_in">window</span>, <span class="hljs-string">&quot;resize&quot;</span>);<br>monitorEvents(<span class="hljs-built_in">window</span>, [<span class="hljs-string">&quot;resize&quot;</span>, <span class="hljs-string">&quot;scroll&quot;</span>])<br></code></pre></div></td></tr></table></figure>
<p>上面代码分别表示单个事件和多个事件的监听方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">monitorEvents($<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;mouse&#x27;</span>);<br>unmonitorEvents($<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;mousemove&#x27;</span>);<br></code></pre></div></td></tr></table></figure>
<p>上面代码表示如何停止监听。</p>
<p><code>monitorEvents</code>允许监听同一大类的事件。所有事件可以分成四个大类。</p>
<ul>
<li>mouse：”mousedown”, “mouseup”, “click”, “dblclick”, “mousemove”, “mouseover”, “mouseout”, “mousewheel”</li>
<li>key：”keydown”, “keyup”, “keypress”, “textInput”</li>
<li>touch：”touchstart”, “touchmove”, “touchend”, “touchcancel”</li>
<li>control：”resize”, “scroll”, “zoom”, “focus”, “blur”, “select”, “change”, “submit”, “reset”</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">monitorEvents($(<span class="hljs-string">&quot;#msg&quot;</span>), <span class="hljs-string">&quot;key&quot;</span>);<br></code></pre></div></td></tr></table></figure>
<p>上面代码表示监听所有<code>key</code>大类的事件。</p>
<p>（10）其他方法</p>
<p>命令行 API 还提供以下方法。</p>
<ul>
<li><code>clear()</code>：清除控制台的历史。</li>
<li><code>copy(object)</code>：复制特定 DOM 元素到剪贴板。</li>
<li><code>dir(object)</code>：显示特定对象的所有属性，是<code>console.dir</code>方法的别名。</li>
<li><code>dirxml(object)</code>：显示特定对象的 XML 形式，是<code>console.dirxml</code>方法的别名。</li>
</ul>
<h2 id="debugger-语句"><a href="#debugger-语句" class="headerlink" title="debugger 语句"></a>debugger 语句</h2><p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，<code>Javascript</code> 引擎自动跳过这一句  </p>
<p>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++)&#123;<br>  <span class="hljs-built_in">console</span>.log(i);<br>  <span class="hljs-keyword">if</span> (i === <span class="hljs-number">2</span>) <span class="hljs-keyword">debugger</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<p>上面代码打印出0，1，2以后，就会暂停，自动打开源码界面，等待进一步处理  </p>
<h1 id="Javascript进阶"><a href="#Javascript进阶" class="headerlink" title="Javascript进阶"></a>Javascript进阶</h1><h2 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环  Event Loop"></a>事件循环  Event Loop</h2><h3 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h3><ul>
<li>进程是cpu资源分配的最小单位（系统会给它分配内存）</li>
<li>不同的进程之间是可以同学的，如管道、FIFO(命名管道)、消息队列 </li>
<li>一个进程里有单个或多个线程</li>
<li>浏览器是多进程的，因为系统给它的进程分配了资源（cpu、内存）（打开Chrome会有一个主进程，每打开一个Tab页就有一个独立的进程）  </li>
</ul>
<h3 id="浏览器的渲染进程是多线程的"><a href="#浏览器的渲染进程是多线程的" class="headerlink" title="浏览器的渲染进程是多线程的"></a>浏览器的渲染进程是多线程的</h3><ul>
<li>GUI渲染线程  </li>
<li>JS引擎线程  </li>
<li>事件触发线程  </li>
<li>定时触发器线程  </li>
<li>异步HTTP请求线程  </li>
</ul>
<h3 id="事件循环机制"><a href="#事件循环机制" class="headerlink" title="事件循环机制"></a>事件循环机制</h3><p>实际上是描述了一些函数处理顺序和过程<br>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/bv1kf4y1U7Ln">https://www.bilibili.com/video/bv1kf4y1U7Ln</a>  </p>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h4 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h4><p>现在有1个类A,我想要创建一个类B,这个类是以A为原型的,并且能进行扩展。我们称B的原型为A  </p>
<h4 id="原型关系"><a href="#原型关系" class="headerlink" title="原型关系"></a>原型关系</h4><p><img src="/Javascript-%E5%9F%BA%E7%A1%80-1/20200807110353813.png" srcset="/img/loading.gif">  </p>
<figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>A.prototype.name = <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> A();<br><span class="hljs-built_in">console</span>.log(a.name)<br></code></pre></div></td></tr></table></figure>
<ul>
<li><p>.prototype<br>返回原型对象的引用  </p>
</li>
<li><p>__proto__  (实际上是[[prototype]]，不过浏览器里一般都简写)<br>这个属性保存着原型对象的属性  </p>
<blockquote>
<p>Object是所有对象的“老祖宗”，所有的__proto__最终都会指向Object，Object本身并没有__proto__属性  </p>
</blockquote>
  <figure class="highlight javascript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs javascript">a.__proto__ = A.prototype;<br></code></pre></div></td></tr></table></figure></li>
<li><p>constructor<br>A原型的属性，指向A  </p>
</li>
</ul>
<p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV117411v76o">https://www.bilibili.com/video/BV117411v76o</a>  </p>
<h4 id="原型链-1"><a href="#原型链-1" class="headerlink" title="原型链"></a>原型链</h4><p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1N7411k7D2">https://www.bilibili.com/video/BV1N7411k7D2</a></p>
<h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV15J411G7FG?from=search&amp;seid=7940074723107809573">https://www.bilibili.com/video/BV15J411G7FG?from=search&amp;seid=7940074723107809573</a></p>
<h3 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h3><p>客户端与不同源服务端的通信  </p>
<ul>
<li>CORS<br>跨域资源共享，解决跨域请求的成熟方案  </li>
<li>JSONP<br>基于<code>&lt;script&gt;</code>标签，具有可跨域特性<br>只能用于GET请求</li>
<li>iframe<br>通过<code>&lt;iframe&gt;</code>标签在同一个页面暂时不同源的页面<br>通过<code>PostMessage</code>进行页面间的通信  </li>
<li>反向代理<br>通过反向代理让客户端与服务端保持同步，较为安全  </li>
</ul>
<h3 id="Webpack-打包"><a href="#Webpack-打包" class="headerlink" title="Webpack 打包"></a>Webpack 打包</h3><p>目的：将不同类型的源文件编译打包成静态文件</p>
<ul>
<li>前端技术纷繁复杂，缺乏统一管理</li>
<li>大型项目需要模块化  </li>
<li>对于JSX,TS之类的新技术，需要编译以后才能使用<br>编译器，插件，优化</li>
</ul>
<hr>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/667a20d008cf">https://www.jianshu.com/p/667a20d008cf</a></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Javascript/">Javascript</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/post/86bce51a/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Fiddler-抓包</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/post/da48434/">
                        <span class="hidden-mobile">Javascript-Hook-基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        粤ICP备2020127796号
      </a>
    </span>
    
      
        <span>
          <a
            href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=44010502001787"
            rel="nofollow noopener"
            class="beian-police"
            target="_blank"
          >
            
              <span style="visibility: hidden; width: 0">|</span>
              <img src="/img/police_beian.png" srcset="/img/loading.gif" alt="police-icon"/>
            
            <span>粤公网安备 44010502001787号</span>
          </a>
        </span>
      
    
  </div>


  
</footer>

<!-- SCRIPTS -->

  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":200})
    NProgress.start()
    document.addEventListener('DOMContentLoaded', function() {
      window.NProgress && window.NProgress.inc();
    })
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.0/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      var inputArea = document.querySelector("#local-search-input");
      inputArea.onclick = function () {
        searchFunc(path, 'local-search-input', 'local-search-result');
        this.onclick = null
      }
    })()
  </script>












  
    <!-- Baidu Analytics -->
    <script defer>
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?https://hm.baidu.com/hm.js?758d4ab1e944598b8ead03bb4eb143a5";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>



</body>
</html>
